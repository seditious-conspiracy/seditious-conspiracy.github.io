new EventSource('/esbuild').addEventListener('change', () => location.reload());
"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x3) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x3, {
    get: (a2, b) => (typeof require !== "undefined" ? require : a2)[b]
  }) : x3)(function(x3) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x3 + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod3) => function __require2() {
    return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
    mod3
  ));
  var __toCommonJS = (mod3) => __copyProps(__defProp({}, "__esModule", { value: true }), mod3);

  // node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "node_modules/eventemitter3/index.js"(exports, module) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__) prefix = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
        else emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events();
        else delete emitter._events[evt];
      }
      function EventEmitter3() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter3.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0) return names;
        for (name in events = this._events) {
          if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter3.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers) return [];
        if (handlers.fn) return [handlers.fn];
        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
          ee[i] = handlers[i].fn;
        }
        return ee;
      };
      EventEmitter3.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
      };
      EventEmitter3.prototype.emit = function emit2(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j;
          for (i = 0; i < length; i++) {
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter3.prototype.on = function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
      };
      EventEmitter3.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
      };
      EventEmitter3.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
              events.push(listeners[i]);
            }
          }
          if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
          else clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt]) clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
      EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
      EventEmitter3.prefixed = prefix;
      EventEmitter3.EventEmitter = EventEmitter3;
      if ("undefined" !== typeof module) {
        module.exports = EventEmitter3;
      }
    }
  });

  // node_modules/gl-matrix/cjs/common.js
  var require_common = __commonJS({
    "node_modules/gl-matrix/cjs/common.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.RANDOM = exports.EPSILON = exports.ARRAY_TYPE = exports.ANGLE_ORDER = void 0;
      exports.equals = equals;
      exports.round = round3;
      exports.setMatrixArrayType = setMatrixArrayType;
      exports.toDegree = toDegree;
      exports.toRadian = toRadian;
      var EPSILON3 = exports.EPSILON = 1e-6;
      var ARRAY_TYPE = exports.ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
      var RANDOM = exports.RANDOM = Math.random;
      var ANGLE_ORDER = exports.ANGLE_ORDER = "zyx";
      function round3(a2) {
        if (a2 >= 0) return Math.round(a2);
        return a2 % 0.5 === 0 ? Math.floor(a2) : Math.round(a2);
      }
      function setMatrixArrayType(type) {
        exports.ARRAY_TYPE = ARRAY_TYPE = type;
      }
      var degree3 = Math.PI / 180;
      var radian = 180 / Math.PI;
      function toRadian(a2) {
        return a2 * degree3;
      }
      function toDegree(a2) {
        return a2 * radian;
      }
      function equals(a2, b) {
        var tolerance2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : EPSILON3;
        return Math.abs(a2 - b) <= tolerance2 * Math.max(1, Math.abs(a2), Math.abs(b));
      }
    }
  });

  // node_modules/gl-matrix/cjs/mat2.js
  var require_mat2 = __commonJS({
    "node_modules/gl-matrix/cjs/mat2.js"(exports) {
      "use strict";
      function _typeof2(o) {
        "@babel/helpers - typeof";
        return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof2(o);
      }
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.LDU = LDU;
      exports.add = add5;
      exports.adjoint = adjoint;
      exports.clone = clone8;
      exports.copy = copy;
      exports.create = create2;
      exports.determinant = determinant2;
      exports.equals = equals;
      exports.exactEquals = exactEquals;
      exports.frob = frob;
      exports.fromRotation = fromRotation;
      exports.fromScaling = fromScaling;
      exports.fromValues = fromValues;
      exports.identity = identity3;
      exports.invert = invert;
      exports.mul = void 0;
      exports.multiply = multiply2;
      exports.multiplyScalar = multiplyScalar;
      exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
      exports.rotate = rotate3;
      exports.scale = scale4;
      exports.set = set6;
      exports.str = str;
      exports.sub = void 0;
      exports.subtract = subtract2;
      exports.transpose = transpose2;
      var glMatrix = _interopRequireWildcard(require_common());
      function _interopRequireWildcard(e, t) {
        if ("function" == typeof WeakMap) var r = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
        return (_interopRequireWildcard = function _interopRequireWildcard2(e3, t2) {
          if (!t2 && e3 && e3.__esModule) return e3;
          var o, i, f = { __proto__: null, "default": e3 };
          if (null === e3 || "object" != _typeof2(e3) && "function" != typeof e3) return f;
          if (o = t2 ? n : r) {
            if (o.has(e3)) return o.get(e3);
            o.set(e3, f);
          }
          for (var _t in e3) "default" !== _t && {}.hasOwnProperty.call(e3, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e3, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e3[_t]);
          return f;
        })(e, t);
      }
      function create2() {
        var out = new glMatrix.ARRAY_TYPE(4);
        if (glMatrix.ARRAY_TYPE != Float32Array) {
          out[1] = 0;
          out[2] = 0;
        }
        out[0] = 1;
        out[3] = 1;
        return out;
      }
      function clone8(a2) {
        var out = new glMatrix.ARRAY_TYPE(4);
        out[0] = a2[0];
        out[1] = a2[1];
        out[2] = a2[2];
        out[3] = a2[3];
        return out;
      }
      function copy(out, a2) {
        out[0] = a2[0];
        out[1] = a2[1];
        out[2] = a2[2];
        out[3] = a2[3];
        return out;
      }
      function identity3(out) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      }
      function fromValues(m00, m01, m10, m11) {
        var out = new glMatrix.ARRAY_TYPE(4);
        out[0] = m00;
        out[1] = m01;
        out[2] = m10;
        out[3] = m11;
        return out;
      }
      function set6(out, m00, m01, m10, m11) {
        out[0] = m00;
        out[1] = m01;
        out[2] = m10;
        out[3] = m11;
        return out;
      }
      function transpose2(out, a2) {
        if (out === a2) {
          var a1 = a2[1];
          out[1] = a2[2];
          out[2] = a1;
        } else {
          out[0] = a2[0];
          out[1] = a2[2];
          out[2] = a2[1];
          out[3] = a2[3];
        }
        return out;
      }
      function invert(out, a2) {
        var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
        var det = a0 * a3 - a22 * a1;
        if (!det) {
          return null;
        }
        det = 1 / det;
        out[0] = a3 * det;
        out[1] = -a1 * det;
        out[2] = -a22 * det;
        out[3] = a0 * det;
        return out;
      }
      function adjoint(out, a2) {
        var a0 = a2[0];
        out[0] = a2[3];
        out[1] = -a2[1];
        out[2] = -a2[2];
        out[3] = a0;
        return out;
      }
      function determinant2(a2) {
        return a2[0] * a2[3] - a2[2] * a2[1];
      }
      function multiply2(out, a2, b) {
        var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
        var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
        out[0] = a0 * b0 + a22 * b1;
        out[1] = a1 * b0 + a3 * b1;
        out[2] = a0 * b2 + a22 * b3;
        out[3] = a1 * b2 + a3 * b3;
        return out;
      }
      function rotate3(out, a2, rad2) {
        var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
        var s = Math.sin(rad2);
        var c2 = Math.cos(rad2);
        out[0] = a0 * c2 + a22 * s;
        out[1] = a1 * c2 + a3 * s;
        out[2] = a0 * -s + a22 * c2;
        out[3] = a1 * -s + a3 * c2;
        return out;
      }
      function scale4(out, a2, v) {
        var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
        var v0 = v[0], v1 = v[1];
        out[0] = a0 * v0;
        out[1] = a1 * v0;
        out[2] = a22 * v1;
        out[3] = a3 * v1;
        return out;
      }
      function fromRotation(out, rad2) {
        var s = Math.sin(rad2);
        var c2 = Math.cos(rad2);
        out[0] = c2;
        out[1] = s;
        out[2] = -s;
        out[3] = c2;
        return out;
      }
      function fromScaling(out, v) {
        out[0] = v[0];
        out[1] = 0;
        out[2] = 0;
        out[3] = v[1];
        return out;
      }
      function str(a2) {
        return "mat2(" + a2[0] + ", " + a2[1] + ", " + a2[2] + ", " + a2[3] + ")";
      }
      function frob(a2) {
        return Math.sqrt(a2[0] * a2[0] + a2[1] * a2[1] + a2[2] * a2[2] + a2[3] * a2[3]);
      }
      function LDU(L, D, U, a2) {
        L[2] = a2[2] / a2[0];
        U[0] = a2[0];
        U[1] = a2[1];
        U[3] = a2[3] - L[2] * U[1];
        return [L, D, U];
      }
      function add5(out, a2, b) {
        out[0] = a2[0] + b[0];
        out[1] = a2[1] + b[1];
        out[2] = a2[2] + b[2];
        out[3] = a2[3] + b[3];
        return out;
      }
      function subtract2(out, a2, b) {
        out[0] = a2[0] - b[0];
        out[1] = a2[1] - b[1];
        out[2] = a2[2] - b[2];
        out[3] = a2[3] - b[3];
        return out;
      }
      function exactEquals(a2, b) {
        return a2[0] === b[0] && a2[1] === b[1] && a2[2] === b[2] && a2[3] === b[3];
      }
      function equals(a2, b) {
        var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
        var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
        return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= glMatrix.EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
      }
      function multiplyScalar(out, a2, b) {
        out[0] = a2[0] * b;
        out[1] = a2[1] * b;
        out[2] = a2[2] * b;
        out[3] = a2[3] * b;
        return out;
      }
      function multiplyScalarAndAdd(out, a2, b, scale5) {
        out[0] = a2[0] + b[0] * scale5;
        out[1] = a2[1] + b[1] * scale5;
        out[2] = a2[2] + b[2] * scale5;
        out[3] = a2[3] + b[3] * scale5;
        return out;
      }
      var mul = exports.mul = multiply2;
      var sub2 = exports.sub = subtract2;
    }
  });

  // node_modules/gl-matrix/cjs/mat2d.js
  var require_mat2d = __commonJS({
    "node_modules/gl-matrix/cjs/mat2d.js"(exports) {
      "use strict";
      function _typeof2(o) {
        "@babel/helpers - typeof";
        return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof2(o);
      }
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.add = add5;
      exports.clone = clone8;
      exports.copy = copy;
      exports.create = create2;
      exports.determinant = determinant2;
      exports.equals = equals;
      exports.exactEquals = exactEquals;
      exports.frob = frob;
      exports.fromRotation = fromRotation;
      exports.fromScaling = fromScaling;
      exports.fromTranslation = fromTranslation;
      exports.fromValues = fromValues;
      exports.identity = identity3;
      exports.invert = invert;
      exports.mul = void 0;
      exports.multiply = multiply2;
      exports.multiplyScalar = multiplyScalar;
      exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
      exports.rotate = rotate3;
      exports.scale = scale4;
      exports.set = set6;
      exports.str = str;
      exports.sub = void 0;
      exports.subtract = subtract2;
      exports.translate = translate3;
      var glMatrix = _interopRequireWildcard(require_common());
      function _interopRequireWildcard(e, t) {
        if ("function" == typeof WeakMap) var r = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
        return (_interopRequireWildcard = function _interopRequireWildcard2(e3, t2) {
          if (!t2 && e3 && e3.__esModule) return e3;
          var o, i, f = { __proto__: null, "default": e3 };
          if (null === e3 || "object" != _typeof2(e3) && "function" != typeof e3) return f;
          if (o = t2 ? n : r) {
            if (o.has(e3)) return o.get(e3);
            o.set(e3, f);
          }
          for (var _t in e3) "default" !== _t && {}.hasOwnProperty.call(e3, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e3, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e3[_t]);
          return f;
        })(e, t);
      }
      function create2() {
        var out = new glMatrix.ARRAY_TYPE(6);
        if (glMatrix.ARRAY_TYPE != Float32Array) {
          out[1] = 0;
          out[2] = 0;
          out[4] = 0;
          out[5] = 0;
        }
        out[0] = 1;
        out[3] = 1;
        return out;
      }
      function clone8(a2) {
        var out = new glMatrix.ARRAY_TYPE(6);
        out[0] = a2[0];
        out[1] = a2[1];
        out[2] = a2[2];
        out[3] = a2[3];
        out[4] = a2[4];
        out[5] = a2[5];
        return out;
      }
      function copy(out, a2) {
        out[0] = a2[0];
        out[1] = a2[1];
        out[2] = a2[2];
        out[3] = a2[3];
        out[4] = a2[4];
        out[5] = a2[5];
        return out;
      }
      function identity3(out) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        out[4] = 0;
        out[5] = 0;
        return out;
      }
      function fromValues(a2, b, c2, d2, tx, ty) {
        var out = new glMatrix.ARRAY_TYPE(6);
        out[0] = a2;
        out[1] = b;
        out[2] = c2;
        out[3] = d2;
        out[4] = tx;
        out[5] = ty;
        return out;
      }
      function set6(out, a2, b, c2, d2, tx, ty) {
        out[0] = a2;
        out[1] = b;
        out[2] = c2;
        out[3] = d2;
        out[4] = tx;
        out[5] = ty;
        return out;
      }
      function invert(out, a2) {
        var aa = a2[0], ab = a2[1], ac = a2[2], ad = a2[3];
        var atx = a2[4], aty = a2[5];
        var det = aa * ad - ab * ac;
        if (!det) {
          return null;
        }
        det = 1 / det;
        out[0] = ad * det;
        out[1] = -ab * det;
        out[2] = -ac * det;
        out[3] = aa * det;
        out[4] = (ac * aty - ad * atx) * det;
        out[5] = (ab * atx - aa * aty) * det;
        return out;
      }
      function determinant2(a2) {
        return a2[0] * a2[3] - a2[1] * a2[2];
      }
      function multiply2(out, a2, b) {
        var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3], a4 = a2[4], a5 = a2[5];
        var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
        out[0] = a0 * b0 + a22 * b1;
        out[1] = a1 * b0 + a3 * b1;
        out[2] = a0 * b2 + a22 * b3;
        out[3] = a1 * b2 + a3 * b3;
        out[4] = a0 * b4 + a22 * b5 + a4;
        out[5] = a1 * b4 + a3 * b5 + a5;
        return out;
      }
      function rotate3(out, a2, rad2) {
        var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3], a4 = a2[4], a5 = a2[5];
        var s = Math.sin(rad2);
        var c2 = Math.cos(rad2);
        out[0] = a0 * c2 + a22 * s;
        out[1] = a1 * c2 + a3 * s;
        out[2] = a0 * -s + a22 * c2;
        out[3] = a1 * -s + a3 * c2;
        out[4] = a4;
        out[5] = a5;
        return out;
      }
      function scale4(out, a2, v) {
        var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3], a4 = a2[4], a5 = a2[5];
        var v0 = v[0], v1 = v[1];
        out[0] = a0 * v0;
        out[1] = a1 * v0;
        out[2] = a22 * v1;
        out[3] = a3 * v1;
        out[4] = a4;
        out[5] = a5;
        return out;
      }
      function translate3(out, a2, v) {
        var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3], a4 = a2[4], a5 = a2[5];
        var v0 = v[0], v1 = v[1];
        out[0] = a0;
        out[1] = a1;
        out[2] = a22;
        out[3] = a3;
        out[4] = a0 * v0 + a22 * v1 + a4;
        out[5] = a1 * v0 + a3 * v1 + a5;
        return out;
      }
      function fromRotation(out, rad2) {
        var s = Math.sin(rad2), c2 = Math.cos(rad2);
        out[0] = c2;
        out[1] = s;
        out[2] = -s;
        out[3] = c2;
        out[4] = 0;
        out[5] = 0;
        return out;
      }
      function fromScaling(out, v) {
        out[0] = v[0];
        out[1] = 0;
        out[2] = 0;
        out[3] = v[1];
        out[4] = 0;
        out[5] = 0;
        return out;
      }
      function fromTranslation(out, v) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        out[4] = v[0];
        out[5] = v[1];
        return out;
      }
      function str(a2) {
        return "mat2d(" + a2[0] + ", " + a2[1] + ", " + a2[2] + ", " + a2[3] + ", " + a2[4] + ", " + a2[5] + ")";
      }
      function frob(a2) {
        return Math.sqrt(a2[0] * a2[0] + a2[1] * a2[1] + a2[2] * a2[2] + a2[3] * a2[3] + a2[4] * a2[4] + a2[5] * a2[5] + 1);
      }
      function add5(out, a2, b) {
        out[0] = a2[0] + b[0];
        out[1] = a2[1] + b[1];
        out[2] = a2[2] + b[2];
        out[3] = a2[3] + b[3];
        out[4] = a2[4] + b[4];
        out[5] = a2[5] + b[5];
        return out;
      }
      function subtract2(out, a2, b) {
        out[0] = a2[0] - b[0];
        out[1] = a2[1] - b[1];
        out[2] = a2[2] - b[2];
        out[3] = a2[3] - b[3];
        out[4] = a2[4] - b[4];
        out[5] = a2[5] - b[5];
        return out;
      }
      function multiplyScalar(out, a2, b) {
        out[0] = a2[0] * b;
        out[1] = a2[1] * b;
        out[2] = a2[2] * b;
        out[3] = a2[3] * b;
        out[4] = a2[4] * b;
        out[5] = a2[5] * b;
        return out;
      }
      function multiplyScalarAndAdd(out, a2, b, scale5) {
        out[0] = a2[0] + b[0] * scale5;
        out[1] = a2[1] + b[1] * scale5;
        out[2] = a2[2] + b[2] * scale5;
        out[3] = a2[3] + b[3] * scale5;
        out[4] = a2[4] + b[4] * scale5;
        out[5] = a2[5] + b[5] * scale5;
        return out;
      }
      function exactEquals(a2, b) {
        return a2[0] === b[0] && a2[1] === b[1] && a2[2] === b[2] && a2[3] === b[3] && a2[4] === b[4] && a2[5] === b[5];
      }
      function equals(a2, b) {
        var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3], a4 = a2[4], a5 = a2[5];
        var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
        return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= glMatrix.EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5));
      }
      var mul = exports.mul = multiply2;
      var sub2 = exports.sub = subtract2;
    }
  });

  // node_modules/gl-matrix/cjs/mat3.js
  var require_mat3 = __commonJS({
    "node_modules/gl-matrix/cjs/mat3.js"(exports) {
      "use strict";
      function _typeof2(o) {
        "@babel/helpers - typeof";
        return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof2(o);
      }
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.add = add5;
      exports.adjoint = adjoint;
      exports.clone = clone8;
      exports.copy = copy;
      exports.create = create2;
      exports.determinant = determinant2;
      exports.equals = equals;
      exports.exactEquals = exactEquals;
      exports.frob = frob;
      exports.fromMat2d = fromMat2d;
      exports.fromMat4 = fromMat4;
      exports.fromQuat = fromQuat;
      exports.fromRotation = fromRotation;
      exports.fromScaling = fromScaling;
      exports.fromTranslation = fromTranslation;
      exports.fromValues = fromValues;
      exports.identity = identity3;
      exports.invert = invert;
      exports.mul = void 0;
      exports.multiply = multiply2;
      exports.multiplyScalar = multiplyScalar;
      exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
      exports.normalFromMat4 = normalFromMat4;
      exports.projection = projection;
      exports.rotate = rotate3;
      exports.scale = scale4;
      exports.set = set6;
      exports.str = str;
      exports.sub = void 0;
      exports.subtract = subtract2;
      exports.translate = translate3;
      exports.transpose = transpose2;
      var glMatrix = _interopRequireWildcard(require_common());
      function _interopRequireWildcard(e, t) {
        if ("function" == typeof WeakMap) var r = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
        return (_interopRequireWildcard = function _interopRequireWildcard2(e3, t2) {
          if (!t2 && e3 && e3.__esModule) return e3;
          var o, i, f = { __proto__: null, "default": e3 };
          if (null === e3 || "object" != _typeof2(e3) && "function" != typeof e3) return f;
          if (o = t2 ? n : r) {
            if (o.has(e3)) return o.get(e3);
            o.set(e3, f);
          }
          for (var _t in e3) "default" !== _t && {}.hasOwnProperty.call(e3, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e3, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e3[_t]);
          return f;
        })(e, t);
      }
      function create2() {
        var out = new glMatrix.ARRAY_TYPE(9);
        if (glMatrix.ARRAY_TYPE != Float32Array) {
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          out[5] = 0;
          out[6] = 0;
          out[7] = 0;
        }
        out[0] = 1;
        out[4] = 1;
        out[8] = 1;
        return out;
      }
      function fromMat4(out, a2) {
        out[0] = a2[0];
        out[1] = a2[1];
        out[2] = a2[2];
        out[3] = a2[4];
        out[4] = a2[5];
        out[5] = a2[6];
        out[6] = a2[8];
        out[7] = a2[9];
        out[8] = a2[10];
        return out;
      }
      function clone8(a2) {
        var out = new glMatrix.ARRAY_TYPE(9);
        out[0] = a2[0];
        out[1] = a2[1];
        out[2] = a2[2];
        out[3] = a2[3];
        out[4] = a2[4];
        out[5] = a2[5];
        out[6] = a2[6];
        out[7] = a2[7];
        out[8] = a2[8];
        return out;
      }
      function copy(out, a2) {
        out[0] = a2[0];
        out[1] = a2[1];
        out[2] = a2[2];
        out[3] = a2[3];
        out[4] = a2[4];
        out[5] = a2[5];
        out[6] = a2[6];
        out[7] = a2[7];
        out[8] = a2[8];
        return out;
      }
      function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
        var out = new glMatrix.ARRAY_TYPE(9);
        out[0] = m00;
        out[1] = m01;
        out[2] = m02;
        out[3] = m10;
        out[4] = m11;
        out[5] = m12;
        out[6] = m20;
        out[7] = m21;
        out[8] = m22;
        return out;
      }
      function set6(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
        out[0] = m00;
        out[1] = m01;
        out[2] = m02;
        out[3] = m10;
        out[4] = m11;
        out[5] = m12;
        out[6] = m20;
        out[7] = m21;
        out[8] = m22;
        return out;
      }
      function identity3(out) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 1;
        out[5] = 0;
        out[6] = 0;
        out[7] = 0;
        out[8] = 1;
        return out;
      }
      function transpose2(out, a2) {
        if (out === a2) {
          var a01 = a2[1], a02 = a2[2], a12 = a2[5];
          out[1] = a2[3];
          out[2] = a2[6];
          out[3] = a01;
          out[5] = a2[7];
          out[6] = a02;
          out[7] = a12;
        } else {
          out[0] = a2[0];
          out[1] = a2[3];
          out[2] = a2[6];
          out[3] = a2[1];
          out[4] = a2[4];
          out[5] = a2[7];
          out[6] = a2[2];
          out[7] = a2[5];
          out[8] = a2[8];
        }
        return out;
      }
      function invert(out, a2) {
        var a00 = a2[0], a01 = a2[1], a02 = a2[2];
        var a10 = a2[3], a11 = a2[4], a12 = a2[5];
        var a20 = a2[6], a21 = a2[7], a22 = a2[8];
        var b01 = a22 * a11 - a12 * a21;
        var b11 = -a22 * a10 + a12 * a20;
        var b21 = a21 * a10 - a11 * a20;
        var det = a00 * b01 + a01 * b11 + a02 * b21;
        if (!det) {
          return null;
        }
        det = 1 / det;
        out[0] = b01 * det;
        out[1] = (-a22 * a01 + a02 * a21) * det;
        out[2] = (a12 * a01 - a02 * a11) * det;
        out[3] = b11 * det;
        out[4] = (a22 * a00 - a02 * a20) * det;
        out[5] = (-a12 * a00 + a02 * a10) * det;
        out[6] = b21 * det;
        out[7] = (-a21 * a00 + a01 * a20) * det;
        out[8] = (a11 * a00 - a01 * a10) * det;
        return out;
      }
      function adjoint(out, a2) {
        var a00 = a2[0], a01 = a2[1], a02 = a2[2];
        var a10 = a2[3], a11 = a2[4], a12 = a2[5];
        var a20 = a2[6], a21 = a2[7], a22 = a2[8];
        out[0] = a11 * a22 - a12 * a21;
        out[1] = a02 * a21 - a01 * a22;
        out[2] = a01 * a12 - a02 * a11;
        out[3] = a12 * a20 - a10 * a22;
        out[4] = a00 * a22 - a02 * a20;
        out[5] = a02 * a10 - a00 * a12;
        out[6] = a10 * a21 - a11 * a20;
        out[7] = a01 * a20 - a00 * a21;
        out[8] = a00 * a11 - a01 * a10;
        return out;
      }
      function determinant2(a2) {
        var a00 = a2[0], a01 = a2[1], a02 = a2[2];
        var a10 = a2[3], a11 = a2[4], a12 = a2[5];
        var a20 = a2[6], a21 = a2[7], a22 = a2[8];
        return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
      }
      function multiply2(out, a2, b) {
        var a00 = a2[0], a01 = a2[1], a02 = a2[2];
        var a10 = a2[3], a11 = a2[4], a12 = a2[5];
        var a20 = a2[6], a21 = a2[7], a22 = a2[8];
        var b00 = b[0], b01 = b[1], b02 = b[2];
        var b10 = b[3], b11 = b[4], b12 = b[5];
        var b20 = b[6], b21 = b[7], b22 = b[8];
        out[0] = b00 * a00 + b01 * a10 + b02 * a20;
        out[1] = b00 * a01 + b01 * a11 + b02 * a21;
        out[2] = b00 * a02 + b01 * a12 + b02 * a22;
        out[3] = b10 * a00 + b11 * a10 + b12 * a20;
        out[4] = b10 * a01 + b11 * a11 + b12 * a21;
        out[5] = b10 * a02 + b11 * a12 + b12 * a22;
        out[6] = b20 * a00 + b21 * a10 + b22 * a20;
        out[7] = b20 * a01 + b21 * a11 + b22 * a21;
        out[8] = b20 * a02 + b21 * a12 + b22 * a22;
        return out;
      }
      function translate3(out, a2, v) {
        var a00 = a2[0], a01 = a2[1], a02 = a2[2], a10 = a2[3], a11 = a2[4], a12 = a2[5], a20 = a2[6], a21 = a2[7], a22 = a2[8], x3 = v[0], y3 = v[1];
        out[0] = a00;
        out[1] = a01;
        out[2] = a02;
        out[3] = a10;
        out[4] = a11;
        out[5] = a12;
        out[6] = x3 * a00 + y3 * a10 + a20;
        out[7] = x3 * a01 + y3 * a11 + a21;
        out[8] = x3 * a02 + y3 * a12 + a22;
        return out;
      }
      function rotate3(out, a2, rad2) {
        var a00 = a2[0], a01 = a2[1], a02 = a2[2], a10 = a2[3], a11 = a2[4], a12 = a2[5], a20 = a2[6], a21 = a2[7], a22 = a2[8], s = Math.sin(rad2), c2 = Math.cos(rad2);
        out[0] = c2 * a00 + s * a10;
        out[1] = c2 * a01 + s * a11;
        out[2] = c2 * a02 + s * a12;
        out[3] = c2 * a10 - s * a00;
        out[4] = c2 * a11 - s * a01;
        out[5] = c2 * a12 - s * a02;
        out[6] = a20;
        out[7] = a21;
        out[8] = a22;
        return out;
      }
      function scale4(out, a2, v) {
        var x3 = v[0], y3 = v[1];
        out[0] = x3 * a2[0];
        out[1] = x3 * a2[1];
        out[2] = x3 * a2[2];
        out[3] = y3 * a2[3];
        out[4] = y3 * a2[4];
        out[5] = y3 * a2[5];
        out[6] = a2[6];
        out[7] = a2[7];
        out[8] = a2[8];
        return out;
      }
      function fromTranslation(out, v) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 1;
        out[5] = 0;
        out[6] = v[0];
        out[7] = v[1];
        out[8] = 1;
        return out;
      }
      function fromRotation(out, rad2) {
        var s = Math.sin(rad2), c2 = Math.cos(rad2);
        out[0] = c2;
        out[1] = s;
        out[2] = 0;
        out[3] = -s;
        out[4] = c2;
        out[5] = 0;
        out[6] = 0;
        out[7] = 0;
        out[8] = 1;
        return out;
      }
      function fromScaling(out, v) {
        out[0] = v[0];
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = v[1];
        out[5] = 0;
        out[6] = 0;
        out[7] = 0;
        out[8] = 1;
        return out;
      }
      function fromMat2d(out, a2) {
        out[0] = a2[0];
        out[1] = a2[1];
        out[2] = 0;
        out[3] = a2[2];
        out[4] = a2[3];
        out[5] = 0;
        out[6] = a2[4];
        out[7] = a2[5];
        out[8] = 1;
        return out;
      }
      function fromQuat(out, q) {
        var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
        var x22 = x3 + x3;
        var y22 = y3 + y3;
        var z2 = z + z;
        var xx = x3 * x22;
        var yx = y3 * x22;
        var yy = y3 * y22;
        var zx = z * x22;
        var zy = z * y22;
        var zz = z * z2;
        var wx = w * x22;
        var wy = w * y22;
        var wz = w * z2;
        out[0] = 1 - yy - zz;
        out[3] = yx - wz;
        out[6] = zx + wy;
        out[1] = yx + wz;
        out[4] = 1 - xx - zz;
        out[7] = zy - wx;
        out[2] = zx - wy;
        out[5] = zy + wx;
        out[8] = 1 - xx - yy;
        return out;
      }
      function normalFromMat4(out, a2) {
        var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
        var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
        var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
        var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
        var b00 = a00 * a11 - a01 * a10;
        var b01 = a00 * a12 - a02 * a10;
        var b02 = a00 * a13 - a03 * a10;
        var b03 = a01 * a12 - a02 * a11;
        var b04 = a01 * a13 - a03 * a11;
        var b05 = a02 * a13 - a03 * a12;
        var b06 = a20 * a31 - a21 * a30;
        var b07 = a20 * a32 - a22 * a30;
        var b08 = a20 * a33 - a23 * a30;
        var b09 = a21 * a32 - a22 * a31;
        var b10 = a21 * a33 - a23 * a31;
        var b11 = a22 * a33 - a23 * a32;
        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        if (!det) {
          return null;
        }
        det = 1 / det;
        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
        out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
        out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
        out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
        out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
        out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
        out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
        out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
        out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
        return out;
      }
      function projection(out, width2, height) {
        out[0] = 2 / width2;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = -2 / height;
        out[5] = 0;
        out[6] = -1;
        out[7] = 1;
        out[8] = 1;
        return out;
      }
      function str(a2) {
        return "mat3(" + a2[0] + ", " + a2[1] + ", " + a2[2] + ", " + a2[3] + ", " + a2[4] + ", " + a2[5] + ", " + a2[6] + ", " + a2[7] + ", " + a2[8] + ")";
      }
      function frob(a2) {
        return Math.sqrt(a2[0] * a2[0] + a2[1] * a2[1] + a2[2] * a2[2] + a2[3] * a2[3] + a2[4] * a2[4] + a2[5] * a2[5] + a2[6] * a2[6] + a2[7] * a2[7] + a2[8] * a2[8]);
      }
      function add5(out, a2, b) {
        out[0] = a2[0] + b[0];
        out[1] = a2[1] + b[1];
        out[2] = a2[2] + b[2];
        out[3] = a2[3] + b[3];
        out[4] = a2[4] + b[4];
        out[5] = a2[5] + b[5];
        out[6] = a2[6] + b[6];
        out[7] = a2[7] + b[7];
        out[8] = a2[8] + b[8];
        return out;
      }
      function subtract2(out, a2, b) {
        out[0] = a2[0] - b[0];
        out[1] = a2[1] - b[1];
        out[2] = a2[2] - b[2];
        out[3] = a2[3] - b[3];
        out[4] = a2[4] - b[4];
        out[5] = a2[5] - b[5];
        out[6] = a2[6] - b[6];
        out[7] = a2[7] - b[7];
        out[8] = a2[8] - b[8];
        return out;
      }
      function multiplyScalar(out, a2, b) {
        out[0] = a2[0] * b;
        out[1] = a2[1] * b;
        out[2] = a2[2] * b;
        out[3] = a2[3] * b;
        out[4] = a2[4] * b;
        out[5] = a2[5] * b;
        out[6] = a2[6] * b;
        out[7] = a2[7] * b;
        out[8] = a2[8] * b;
        return out;
      }
      function multiplyScalarAndAdd(out, a2, b, scale5) {
        out[0] = a2[0] + b[0] * scale5;
        out[1] = a2[1] + b[1] * scale5;
        out[2] = a2[2] + b[2] * scale5;
        out[3] = a2[3] + b[3] * scale5;
        out[4] = a2[4] + b[4] * scale5;
        out[5] = a2[5] + b[5] * scale5;
        out[6] = a2[6] + b[6] * scale5;
        out[7] = a2[7] + b[7] * scale5;
        out[8] = a2[8] + b[8] * scale5;
        return out;
      }
      function exactEquals(a2, b) {
        return a2[0] === b[0] && a2[1] === b[1] && a2[2] === b[2] && a2[3] === b[3] && a2[4] === b[4] && a2[5] === b[5] && a2[6] === b[6] && a2[7] === b[7] && a2[8] === b[8];
      }
      function equals(a2, b) {
        var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3], a4 = a2[4], a5 = a2[5], a6 = a2[6], a7 = a2[7], a8 = a2[8];
        var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
        return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= glMatrix.EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
      }
      var mul = exports.mul = multiply2;
      var sub2 = exports.sub = subtract2;
    }
  });

  // node_modules/gl-matrix/cjs/mat4.js
  var require_mat4 = __commonJS({
    "node_modules/gl-matrix/cjs/mat4.js"(exports) {
      "use strict";
      function _typeof2(o) {
        "@babel/helpers - typeof";
        return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof2(o);
      }
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.add = add5;
      exports.adjoint = adjoint;
      exports.clone = clone8;
      exports.copy = copy;
      exports.create = create2;
      exports.decompose = decompose2;
      exports.determinant = determinant2;
      exports.equals = equals;
      exports.exactEquals = exactEquals;
      exports.frob = frob;
      exports.fromQuat = fromQuat;
      exports.fromQuat2 = fromQuat2;
      exports.fromRotation = fromRotation;
      exports.fromRotationTranslation = fromRotationTranslation;
      exports.fromRotationTranslationScale = fromRotationTranslationScale2;
      exports.fromRotationTranslationScaleOrigin = fromRotationTranslationScaleOrigin;
      exports.fromScaling = fromScaling;
      exports.fromTranslation = fromTranslation;
      exports.fromValues = fromValues;
      exports.fromXRotation = fromXRotation;
      exports.fromYRotation = fromYRotation;
      exports.fromZRotation = fromZRotation;
      exports.frustum = frustum;
      exports.getRotation = getRotation;
      exports.getScaling = getScaling;
      exports.getTranslation = getTranslation;
      exports.identity = identity3;
      exports.invert = invert;
      exports.lookAt = lookAt;
      exports.mul = void 0;
      exports.multiply = multiply2;
      exports.multiplyScalar = multiplyScalar;
      exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
      exports.ortho = void 0;
      exports.orthoNO = orthoNO;
      exports.orthoZO = orthoZO;
      exports.perspective = void 0;
      exports.perspectiveFromFieldOfView = perspectiveFromFieldOfView;
      exports.perspectiveNO = perspectiveNO;
      exports.perspectiveZO = perspectiveZO;
      exports.rotate = rotate3;
      exports.rotateX = rotateX2;
      exports.rotateY = rotateY2;
      exports.rotateZ = rotateZ2;
      exports.scale = scale4;
      exports.set = set6;
      exports.str = str;
      exports.sub = void 0;
      exports.subtract = subtract2;
      exports.targetTo = targetTo;
      exports.translate = translate3;
      exports.transpose = transpose2;
      var glMatrix = _interopRequireWildcard(require_common());
      function _interopRequireWildcard(e, t) {
        if ("function" == typeof WeakMap) var r = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
        return (_interopRequireWildcard = function _interopRequireWildcard2(e3, t2) {
          if (!t2 && e3 && e3.__esModule) return e3;
          var o, i, f = { __proto__: null, "default": e3 };
          if (null === e3 || "object" != _typeof2(e3) && "function" != typeof e3) return f;
          if (o = t2 ? n : r) {
            if (o.has(e3)) return o.get(e3);
            o.set(e3, f);
          }
          for (var _t in e3) "default" !== _t && {}.hasOwnProperty.call(e3, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e3, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e3[_t]);
          return f;
        })(e, t);
      }
      function create2() {
        var out = new glMatrix.ARRAY_TYPE(16);
        if (glMatrix.ARRAY_TYPE != Float32Array) {
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          out[4] = 0;
          out[6] = 0;
          out[7] = 0;
          out[8] = 0;
          out[9] = 0;
          out[11] = 0;
          out[12] = 0;
          out[13] = 0;
          out[14] = 0;
        }
        out[0] = 1;
        out[5] = 1;
        out[10] = 1;
        out[15] = 1;
        return out;
      }
      function clone8(a2) {
        var out = new glMatrix.ARRAY_TYPE(16);
        out[0] = a2[0];
        out[1] = a2[1];
        out[2] = a2[2];
        out[3] = a2[3];
        out[4] = a2[4];
        out[5] = a2[5];
        out[6] = a2[6];
        out[7] = a2[7];
        out[8] = a2[8];
        out[9] = a2[9];
        out[10] = a2[10];
        out[11] = a2[11];
        out[12] = a2[12];
        out[13] = a2[13];
        out[14] = a2[14];
        out[15] = a2[15];
        return out;
      }
      function copy(out, a2) {
        out[0] = a2[0];
        out[1] = a2[1];
        out[2] = a2[2];
        out[3] = a2[3];
        out[4] = a2[4];
        out[5] = a2[5];
        out[6] = a2[6];
        out[7] = a2[7];
        out[8] = a2[8];
        out[9] = a2[9];
        out[10] = a2[10];
        out[11] = a2[11];
        out[12] = a2[12];
        out[13] = a2[13];
        out[14] = a2[14];
        out[15] = a2[15];
        return out;
      }
      function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        var out = new glMatrix.ARRAY_TYPE(16);
        out[0] = m00;
        out[1] = m01;
        out[2] = m02;
        out[3] = m03;
        out[4] = m10;
        out[5] = m11;
        out[6] = m12;
        out[7] = m13;
        out[8] = m20;
        out[9] = m21;
        out[10] = m22;
        out[11] = m23;
        out[12] = m30;
        out[13] = m31;
        out[14] = m32;
        out[15] = m33;
        return out;
      }
      function set6(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        out[0] = m00;
        out[1] = m01;
        out[2] = m02;
        out[3] = m03;
        out[4] = m10;
        out[5] = m11;
        out[6] = m12;
        out[7] = m13;
        out[8] = m20;
        out[9] = m21;
        out[10] = m22;
        out[11] = m23;
        out[12] = m30;
        out[13] = m31;
        out[14] = m32;
        out[15] = m33;
        return out;
      }
      function identity3(out) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = 1;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 1;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
      function transpose2(out, a2) {
        if (out === a2) {
          var a01 = a2[1], a02 = a2[2], a03 = a2[3];
          var a12 = a2[6], a13 = a2[7];
          var a23 = a2[11];
          out[1] = a2[4];
          out[2] = a2[8];
          out[3] = a2[12];
          out[4] = a01;
          out[6] = a2[9];
          out[7] = a2[13];
          out[8] = a02;
          out[9] = a12;
          out[11] = a2[14];
          out[12] = a03;
          out[13] = a13;
          out[14] = a23;
        } else {
          out[0] = a2[0];
          out[1] = a2[4];
          out[2] = a2[8];
          out[3] = a2[12];
          out[4] = a2[1];
          out[5] = a2[5];
          out[6] = a2[9];
          out[7] = a2[13];
          out[8] = a2[2];
          out[9] = a2[6];
          out[10] = a2[10];
          out[11] = a2[14];
          out[12] = a2[3];
          out[13] = a2[7];
          out[14] = a2[11];
          out[15] = a2[15];
        }
        return out;
      }
      function invert(out, a2) {
        var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
        var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
        var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
        var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
        var b00 = a00 * a11 - a01 * a10;
        var b01 = a00 * a12 - a02 * a10;
        var b02 = a00 * a13 - a03 * a10;
        var b03 = a01 * a12 - a02 * a11;
        var b04 = a01 * a13 - a03 * a11;
        var b05 = a02 * a13 - a03 * a12;
        var b06 = a20 * a31 - a21 * a30;
        var b07 = a20 * a32 - a22 * a30;
        var b08 = a20 * a33 - a23 * a30;
        var b09 = a21 * a32 - a22 * a31;
        var b10 = a21 * a33 - a23 * a31;
        var b11 = a22 * a33 - a23 * a32;
        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        if (!det) {
          return null;
        }
        det = 1 / det;
        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
        out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
        out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
        out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
        out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
        out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
        out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
        out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
        out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
        out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
        out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
        out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
        out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
        out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
        out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
        out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
        return out;
      }
      function adjoint(out, a2) {
        var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
        var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
        var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
        var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
        var b00 = a00 * a11 - a01 * a10;
        var b01 = a00 * a12 - a02 * a10;
        var b02 = a00 * a13 - a03 * a10;
        var b03 = a01 * a12 - a02 * a11;
        var b04 = a01 * a13 - a03 * a11;
        var b05 = a02 * a13 - a03 * a12;
        var b06 = a20 * a31 - a21 * a30;
        var b07 = a20 * a32 - a22 * a30;
        var b08 = a20 * a33 - a23 * a30;
        var b09 = a21 * a32 - a22 * a31;
        var b10 = a21 * a33 - a23 * a31;
        var b11 = a22 * a33 - a23 * a32;
        out[0] = a11 * b11 - a12 * b10 + a13 * b09;
        out[1] = a02 * b10 - a01 * b11 - a03 * b09;
        out[2] = a31 * b05 - a32 * b04 + a33 * b03;
        out[3] = a22 * b04 - a21 * b05 - a23 * b03;
        out[4] = a12 * b08 - a10 * b11 - a13 * b07;
        out[5] = a00 * b11 - a02 * b08 + a03 * b07;
        out[6] = a32 * b02 - a30 * b05 - a33 * b01;
        out[7] = a20 * b05 - a22 * b02 + a23 * b01;
        out[8] = a10 * b10 - a11 * b08 + a13 * b06;
        out[9] = a01 * b08 - a00 * b10 - a03 * b06;
        out[10] = a30 * b04 - a31 * b02 + a33 * b00;
        out[11] = a21 * b02 - a20 * b04 - a23 * b00;
        out[12] = a11 * b07 - a10 * b09 - a12 * b06;
        out[13] = a00 * b09 - a01 * b07 + a02 * b06;
        out[14] = a31 * b01 - a30 * b03 - a32 * b00;
        out[15] = a20 * b03 - a21 * b01 + a22 * b00;
        return out;
      }
      function determinant2(a2) {
        var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
        var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
        var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
        var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
        var b0 = a00 * a11 - a01 * a10;
        var b1 = a00 * a12 - a02 * a10;
        var b2 = a01 * a12 - a02 * a11;
        var b3 = a20 * a31 - a21 * a30;
        var b4 = a20 * a32 - a22 * a30;
        var b5 = a21 * a32 - a22 * a31;
        var b6 = a00 * b5 - a01 * b4 + a02 * b3;
        var b7 = a10 * b5 - a11 * b4 + a12 * b3;
        var b8 = a20 * b2 - a21 * b1 + a22 * b0;
        var b9 = a30 * b2 - a31 * b1 + a32 * b0;
        return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;
      }
      function multiply2(out, a2, b) {
        var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
        var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
        var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
        var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
        var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
        out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        b0 = b[4];
        b1 = b[5];
        b2 = b[6];
        b3 = b[7];
        out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        b0 = b[8];
        b1 = b[9];
        b2 = b[10];
        b3 = b[11];
        out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        b0 = b[12];
        b1 = b[13];
        b2 = b[14];
        b3 = b[15];
        out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        return out;
      }
      function translate3(out, a2, v) {
        var x3 = v[0], y3 = v[1], z = v[2];
        var a00, a01, a02, a03;
        var a10, a11, a12, a13;
        var a20, a21, a22, a23;
        if (a2 === out) {
          out[12] = a2[0] * x3 + a2[4] * y3 + a2[8] * z + a2[12];
          out[13] = a2[1] * x3 + a2[5] * y3 + a2[9] * z + a2[13];
          out[14] = a2[2] * x3 + a2[6] * y3 + a2[10] * z + a2[14];
          out[15] = a2[3] * x3 + a2[7] * y3 + a2[11] * z + a2[15];
        } else {
          a00 = a2[0];
          a01 = a2[1];
          a02 = a2[2];
          a03 = a2[3];
          a10 = a2[4];
          a11 = a2[5];
          a12 = a2[6];
          a13 = a2[7];
          a20 = a2[8];
          a21 = a2[9];
          a22 = a2[10];
          a23 = a2[11];
          out[0] = a00;
          out[1] = a01;
          out[2] = a02;
          out[3] = a03;
          out[4] = a10;
          out[5] = a11;
          out[6] = a12;
          out[7] = a13;
          out[8] = a20;
          out[9] = a21;
          out[10] = a22;
          out[11] = a23;
          out[12] = a00 * x3 + a10 * y3 + a20 * z + a2[12];
          out[13] = a01 * x3 + a11 * y3 + a21 * z + a2[13];
          out[14] = a02 * x3 + a12 * y3 + a22 * z + a2[14];
          out[15] = a03 * x3 + a13 * y3 + a23 * z + a2[15];
        }
        return out;
      }
      function scale4(out, a2, v) {
        var x3 = v[0], y3 = v[1], z = v[2];
        out[0] = a2[0] * x3;
        out[1] = a2[1] * x3;
        out[2] = a2[2] * x3;
        out[3] = a2[3] * x3;
        out[4] = a2[4] * y3;
        out[5] = a2[5] * y3;
        out[6] = a2[6] * y3;
        out[7] = a2[7] * y3;
        out[8] = a2[8] * z;
        out[9] = a2[9] * z;
        out[10] = a2[10] * z;
        out[11] = a2[11] * z;
        out[12] = a2[12];
        out[13] = a2[13];
        out[14] = a2[14];
        out[15] = a2[15];
        return out;
      }
      function rotate3(out, a2, rad2, axis) {
        var x3 = axis[0], y3 = axis[1], z = axis[2];
        var len = Math.sqrt(x3 * x3 + y3 * y3 + z * z);
        var s, c2, t;
        var a00, a01, a02, a03;
        var a10, a11, a12, a13;
        var a20, a21, a22, a23;
        var b00, b01, b02;
        var b10, b11, b12;
        var b20, b21, b22;
        if (len < glMatrix.EPSILON) {
          return null;
        }
        len = 1 / len;
        x3 *= len;
        y3 *= len;
        z *= len;
        s = Math.sin(rad2);
        c2 = Math.cos(rad2);
        t = 1 - c2;
        a00 = a2[0];
        a01 = a2[1];
        a02 = a2[2];
        a03 = a2[3];
        a10 = a2[4];
        a11 = a2[5];
        a12 = a2[6];
        a13 = a2[7];
        a20 = a2[8];
        a21 = a2[9];
        a22 = a2[10];
        a23 = a2[11];
        b00 = x3 * x3 * t + c2;
        b01 = y3 * x3 * t + z * s;
        b02 = z * x3 * t - y3 * s;
        b10 = x3 * y3 * t - z * s;
        b11 = y3 * y3 * t + c2;
        b12 = z * y3 * t + x3 * s;
        b20 = x3 * z * t + y3 * s;
        b21 = y3 * z * t - x3 * s;
        b22 = z * z * t + c2;
        out[0] = a00 * b00 + a10 * b01 + a20 * b02;
        out[1] = a01 * b00 + a11 * b01 + a21 * b02;
        out[2] = a02 * b00 + a12 * b01 + a22 * b02;
        out[3] = a03 * b00 + a13 * b01 + a23 * b02;
        out[4] = a00 * b10 + a10 * b11 + a20 * b12;
        out[5] = a01 * b10 + a11 * b11 + a21 * b12;
        out[6] = a02 * b10 + a12 * b11 + a22 * b12;
        out[7] = a03 * b10 + a13 * b11 + a23 * b12;
        out[8] = a00 * b20 + a10 * b21 + a20 * b22;
        out[9] = a01 * b20 + a11 * b21 + a21 * b22;
        out[10] = a02 * b20 + a12 * b21 + a22 * b22;
        out[11] = a03 * b20 + a13 * b21 + a23 * b22;
        if (a2 !== out) {
          out[12] = a2[12];
          out[13] = a2[13];
          out[14] = a2[14];
          out[15] = a2[15];
        }
        return out;
      }
      function rotateX2(out, a2, rad2) {
        var s = Math.sin(rad2);
        var c2 = Math.cos(rad2);
        var a10 = a2[4];
        var a11 = a2[5];
        var a12 = a2[6];
        var a13 = a2[7];
        var a20 = a2[8];
        var a21 = a2[9];
        var a22 = a2[10];
        var a23 = a2[11];
        if (a2 !== out) {
          out[0] = a2[0];
          out[1] = a2[1];
          out[2] = a2[2];
          out[3] = a2[3];
          out[12] = a2[12];
          out[13] = a2[13];
          out[14] = a2[14];
          out[15] = a2[15];
        }
        out[4] = a10 * c2 + a20 * s;
        out[5] = a11 * c2 + a21 * s;
        out[6] = a12 * c2 + a22 * s;
        out[7] = a13 * c2 + a23 * s;
        out[8] = a20 * c2 - a10 * s;
        out[9] = a21 * c2 - a11 * s;
        out[10] = a22 * c2 - a12 * s;
        out[11] = a23 * c2 - a13 * s;
        return out;
      }
      function rotateY2(out, a2, rad2) {
        var s = Math.sin(rad2);
        var c2 = Math.cos(rad2);
        var a00 = a2[0];
        var a01 = a2[1];
        var a02 = a2[2];
        var a03 = a2[3];
        var a20 = a2[8];
        var a21 = a2[9];
        var a22 = a2[10];
        var a23 = a2[11];
        if (a2 !== out) {
          out[4] = a2[4];
          out[5] = a2[5];
          out[6] = a2[6];
          out[7] = a2[7];
          out[12] = a2[12];
          out[13] = a2[13];
          out[14] = a2[14];
          out[15] = a2[15];
        }
        out[0] = a00 * c2 - a20 * s;
        out[1] = a01 * c2 - a21 * s;
        out[2] = a02 * c2 - a22 * s;
        out[3] = a03 * c2 - a23 * s;
        out[8] = a00 * s + a20 * c2;
        out[9] = a01 * s + a21 * c2;
        out[10] = a02 * s + a22 * c2;
        out[11] = a03 * s + a23 * c2;
        return out;
      }
      function rotateZ2(out, a2, rad2) {
        var s = Math.sin(rad2);
        var c2 = Math.cos(rad2);
        var a00 = a2[0];
        var a01 = a2[1];
        var a02 = a2[2];
        var a03 = a2[3];
        var a10 = a2[4];
        var a11 = a2[5];
        var a12 = a2[6];
        var a13 = a2[7];
        if (a2 !== out) {
          out[8] = a2[8];
          out[9] = a2[9];
          out[10] = a2[10];
          out[11] = a2[11];
          out[12] = a2[12];
          out[13] = a2[13];
          out[14] = a2[14];
          out[15] = a2[15];
        }
        out[0] = a00 * c2 + a10 * s;
        out[1] = a01 * c2 + a11 * s;
        out[2] = a02 * c2 + a12 * s;
        out[3] = a03 * c2 + a13 * s;
        out[4] = a10 * c2 - a00 * s;
        out[5] = a11 * c2 - a01 * s;
        out[6] = a12 * c2 - a02 * s;
        out[7] = a13 * c2 - a03 * s;
        return out;
      }
      function fromTranslation(out, v) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = 1;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 1;
        out[11] = 0;
        out[12] = v[0];
        out[13] = v[1];
        out[14] = v[2];
        out[15] = 1;
        return out;
      }
      function fromScaling(out, v) {
        out[0] = v[0];
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = v[1];
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = v[2];
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
      function fromRotation(out, rad2, axis) {
        var x3 = axis[0], y3 = axis[1], z = axis[2];
        var len = Math.sqrt(x3 * x3 + y3 * y3 + z * z);
        var s, c2, t;
        if (len < glMatrix.EPSILON) {
          return null;
        }
        len = 1 / len;
        x3 *= len;
        y3 *= len;
        z *= len;
        s = Math.sin(rad2);
        c2 = Math.cos(rad2);
        t = 1 - c2;
        out[0] = x3 * x3 * t + c2;
        out[1] = y3 * x3 * t + z * s;
        out[2] = z * x3 * t - y3 * s;
        out[3] = 0;
        out[4] = x3 * y3 * t - z * s;
        out[5] = y3 * y3 * t + c2;
        out[6] = z * y3 * t + x3 * s;
        out[7] = 0;
        out[8] = x3 * z * t + y3 * s;
        out[9] = y3 * z * t - x3 * s;
        out[10] = z * z * t + c2;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
      function fromXRotation(out, rad2) {
        var s = Math.sin(rad2);
        var c2 = Math.cos(rad2);
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = c2;
        out[6] = s;
        out[7] = 0;
        out[8] = 0;
        out[9] = -s;
        out[10] = c2;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
      function fromYRotation(out, rad2) {
        var s = Math.sin(rad2);
        var c2 = Math.cos(rad2);
        out[0] = c2;
        out[1] = 0;
        out[2] = -s;
        out[3] = 0;
        out[4] = 0;
        out[5] = 1;
        out[6] = 0;
        out[7] = 0;
        out[8] = s;
        out[9] = 0;
        out[10] = c2;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
      function fromZRotation(out, rad2) {
        var s = Math.sin(rad2);
        var c2 = Math.cos(rad2);
        out[0] = c2;
        out[1] = s;
        out[2] = 0;
        out[3] = 0;
        out[4] = -s;
        out[5] = c2;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 1;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
      function fromRotationTranslation(out, q, v) {
        var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
        var x22 = x3 + x3;
        var y22 = y3 + y3;
        var z2 = z + z;
        var xx = x3 * x22;
        var xy = x3 * y22;
        var xz = x3 * z2;
        var yy = y3 * y22;
        var yz = y3 * z2;
        var zz = z * z2;
        var wx = w * x22;
        var wy = w * y22;
        var wz = w * z2;
        out[0] = 1 - (yy + zz);
        out[1] = xy + wz;
        out[2] = xz - wy;
        out[3] = 0;
        out[4] = xy - wz;
        out[5] = 1 - (xx + zz);
        out[6] = yz + wx;
        out[7] = 0;
        out[8] = xz + wy;
        out[9] = yz - wx;
        out[10] = 1 - (xx + yy);
        out[11] = 0;
        out[12] = v[0];
        out[13] = v[1];
        out[14] = v[2];
        out[15] = 1;
        return out;
      }
      function fromQuat2(out, a2) {
        var translation = new glMatrix.ARRAY_TYPE(3);
        var bx = -a2[0], by = -a2[1], bz = -a2[2], bw = a2[3], ax = a2[4], ay = a2[5], az = a2[6], aw = a2[7];
        var magnitude = bx * bx + by * by + bz * bz + bw * bw;
        if (magnitude > 0) {
          translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
          translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
          translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
        } else {
          translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
          translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
          translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
        }
        fromRotationTranslation(out, a2, translation);
        return out;
      }
      function getTranslation(out, mat) {
        out[0] = mat[12];
        out[1] = mat[13];
        out[2] = mat[14];
        return out;
      }
      function getScaling(out, mat) {
        var m11 = mat[0];
        var m12 = mat[1];
        var m13 = mat[2];
        var m21 = mat[4];
        var m22 = mat[5];
        var m23 = mat[6];
        var m31 = mat[8];
        var m32 = mat[9];
        var m33 = mat[10];
        out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
        out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
        out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
        return out;
      }
      function getRotation(out, mat) {
        var scaling = new glMatrix.ARRAY_TYPE(3);
        getScaling(scaling, mat);
        var is1 = 1 / scaling[0];
        var is2 = 1 / scaling[1];
        var is3 = 1 / scaling[2];
        var sm11 = mat[0] * is1;
        var sm12 = mat[1] * is2;
        var sm13 = mat[2] * is3;
        var sm21 = mat[4] * is1;
        var sm22 = mat[5] * is2;
        var sm23 = mat[6] * is3;
        var sm31 = mat[8] * is1;
        var sm32 = mat[9] * is2;
        var sm33 = mat[10] * is3;
        var trace = sm11 + sm22 + sm33;
        var S2 = 0;
        if (trace > 0) {
          S2 = Math.sqrt(trace + 1) * 2;
          out[3] = 0.25 * S2;
          out[0] = (sm23 - sm32) / S2;
          out[1] = (sm31 - sm13) / S2;
          out[2] = (sm12 - sm21) / S2;
        } else if (sm11 > sm22 && sm11 > sm33) {
          S2 = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
          out[3] = (sm23 - sm32) / S2;
          out[0] = 0.25 * S2;
          out[1] = (sm12 + sm21) / S2;
          out[2] = (sm31 + sm13) / S2;
        } else if (sm22 > sm33) {
          S2 = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
          out[3] = (sm31 - sm13) / S2;
          out[0] = (sm12 + sm21) / S2;
          out[1] = 0.25 * S2;
          out[2] = (sm23 + sm32) / S2;
        } else {
          S2 = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
          out[3] = (sm12 - sm21) / S2;
          out[0] = (sm31 + sm13) / S2;
          out[1] = (sm23 + sm32) / S2;
          out[2] = 0.25 * S2;
        }
        return out;
      }
      function decompose2(out_r, out_t, out_s, mat) {
        out_t[0] = mat[12];
        out_t[1] = mat[13];
        out_t[2] = mat[14];
        var m11 = mat[0];
        var m12 = mat[1];
        var m13 = mat[2];
        var m21 = mat[4];
        var m22 = mat[5];
        var m23 = mat[6];
        var m31 = mat[8];
        var m32 = mat[9];
        var m33 = mat[10];
        out_s[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
        out_s[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
        out_s[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
        var is1 = 1 / out_s[0];
        var is2 = 1 / out_s[1];
        var is3 = 1 / out_s[2];
        var sm11 = m11 * is1;
        var sm12 = m12 * is2;
        var sm13 = m13 * is3;
        var sm21 = m21 * is1;
        var sm22 = m22 * is2;
        var sm23 = m23 * is3;
        var sm31 = m31 * is1;
        var sm32 = m32 * is2;
        var sm33 = m33 * is3;
        var trace = sm11 + sm22 + sm33;
        var S2 = 0;
        if (trace > 0) {
          S2 = Math.sqrt(trace + 1) * 2;
          out_r[3] = 0.25 * S2;
          out_r[0] = (sm23 - sm32) / S2;
          out_r[1] = (sm31 - sm13) / S2;
          out_r[2] = (sm12 - sm21) / S2;
        } else if (sm11 > sm22 && sm11 > sm33) {
          S2 = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
          out_r[3] = (sm23 - sm32) / S2;
          out_r[0] = 0.25 * S2;
          out_r[1] = (sm12 + sm21) / S2;
          out_r[2] = (sm31 + sm13) / S2;
        } else if (sm22 > sm33) {
          S2 = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
          out_r[3] = (sm31 - sm13) / S2;
          out_r[0] = (sm12 + sm21) / S2;
          out_r[1] = 0.25 * S2;
          out_r[2] = (sm23 + sm32) / S2;
        } else {
          S2 = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
          out_r[3] = (sm12 - sm21) / S2;
          out_r[0] = (sm31 + sm13) / S2;
          out_r[1] = (sm23 + sm32) / S2;
          out_r[2] = 0.25 * S2;
        }
        return out_r;
      }
      function fromRotationTranslationScale2(out, q, v, s) {
        var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
        var x22 = x3 + x3;
        var y22 = y3 + y3;
        var z2 = z + z;
        var xx = x3 * x22;
        var xy = x3 * y22;
        var xz = x3 * z2;
        var yy = y3 * y22;
        var yz = y3 * z2;
        var zz = z * z2;
        var wx = w * x22;
        var wy = w * y22;
        var wz = w * z2;
        var sx = s[0];
        var sy = s[1];
        var sz = s[2];
        out[0] = (1 - (yy + zz)) * sx;
        out[1] = (xy + wz) * sx;
        out[2] = (xz - wy) * sx;
        out[3] = 0;
        out[4] = (xy - wz) * sy;
        out[5] = (1 - (xx + zz)) * sy;
        out[6] = (yz + wx) * sy;
        out[7] = 0;
        out[8] = (xz + wy) * sz;
        out[9] = (yz - wx) * sz;
        out[10] = (1 - (xx + yy)) * sz;
        out[11] = 0;
        out[12] = v[0];
        out[13] = v[1];
        out[14] = v[2];
        out[15] = 1;
        return out;
      }
      function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
        var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
        var x22 = x3 + x3;
        var y22 = y3 + y3;
        var z2 = z + z;
        var xx = x3 * x22;
        var xy = x3 * y22;
        var xz = x3 * z2;
        var yy = y3 * y22;
        var yz = y3 * z2;
        var zz = z * z2;
        var wx = w * x22;
        var wy = w * y22;
        var wz = w * z2;
        var sx = s[0];
        var sy = s[1];
        var sz = s[2];
        var ox = o[0];
        var oy = o[1];
        var oz = o[2];
        var out0 = (1 - (yy + zz)) * sx;
        var out1 = (xy + wz) * sx;
        var out2 = (xz - wy) * sx;
        var out4 = (xy - wz) * sy;
        var out5 = (1 - (xx + zz)) * sy;
        var out6 = (yz + wx) * sy;
        var out8 = (xz + wy) * sz;
        var out9 = (yz - wx) * sz;
        var out10 = (1 - (xx + yy)) * sz;
        out[0] = out0;
        out[1] = out1;
        out[2] = out2;
        out[3] = 0;
        out[4] = out4;
        out[5] = out5;
        out[6] = out6;
        out[7] = 0;
        out[8] = out8;
        out[9] = out9;
        out[10] = out10;
        out[11] = 0;
        out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
        out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
        out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
        out[15] = 1;
        return out;
      }
      function fromQuat(out, q) {
        var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
        var x22 = x3 + x3;
        var y22 = y3 + y3;
        var z2 = z + z;
        var xx = x3 * x22;
        var yx = y3 * x22;
        var yy = y3 * y22;
        var zx = z * x22;
        var zy = z * y22;
        var zz = z * z2;
        var wx = w * x22;
        var wy = w * y22;
        var wz = w * z2;
        out[0] = 1 - yy - zz;
        out[1] = yx + wz;
        out[2] = zx - wy;
        out[3] = 0;
        out[4] = yx - wz;
        out[5] = 1 - xx - zz;
        out[6] = zy + wx;
        out[7] = 0;
        out[8] = zx + wy;
        out[9] = zy - wx;
        out[10] = 1 - xx - yy;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
      function frustum(out, left, right, bottom, top, near, far) {
        var rl = 1 / (right - left);
        var tb = 1 / (top - bottom);
        var nf = 1 / (near - far);
        out[0] = near * 2 * rl;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = near * 2 * tb;
        out[6] = 0;
        out[7] = 0;
        out[8] = (right + left) * rl;
        out[9] = (top + bottom) * tb;
        out[10] = (far + near) * nf;
        out[11] = -1;
        out[12] = 0;
        out[13] = 0;
        out[14] = far * near * 2 * nf;
        out[15] = 0;
        return out;
      }
      function perspectiveNO(out, fovy, aspect, near, far) {
        var f = 1 / Math.tan(fovy / 2);
        out[0] = f / aspect;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = f;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[11] = -1;
        out[12] = 0;
        out[13] = 0;
        out[15] = 0;
        if (far != null && far !== Infinity) {
          var nf = 1 / (near - far);
          out[10] = (far + near) * nf;
          out[14] = 2 * far * near * nf;
        } else {
          out[10] = -1;
          out[14] = -2 * near;
        }
        return out;
      }
      var perspective = exports.perspective = perspectiveNO;
      function perspectiveZO(out, fovy, aspect, near, far) {
        var f = 1 / Math.tan(fovy / 2);
        out[0] = f / aspect;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = f;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[11] = -1;
        out[12] = 0;
        out[13] = 0;
        out[15] = 0;
        if (far != null && far !== Infinity) {
          var nf = 1 / (near - far);
          out[10] = far * nf;
          out[14] = far * near * nf;
        } else {
          out[10] = -1;
          out[14] = -near;
        }
        return out;
      }
      function perspectiveFromFieldOfView(out, fov, near, far) {
        var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
        var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
        var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
        var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
        var xScale = 2 / (leftTan + rightTan);
        var yScale = 2 / (upTan + downTan);
        out[0] = xScale;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = yScale;
        out[6] = 0;
        out[7] = 0;
        out[8] = -((leftTan - rightTan) * xScale * 0.5);
        out[9] = (upTan - downTan) * yScale * 0.5;
        out[10] = far / (near - far);
        out[11] = -1;
        out[12] = 0;
        out[13] = 0;
        out[14] = far * near / (near - far);
        out[15] = 0;
        return out;
      }
      function orthoNO(out, left, right, bottom, top, near, far) {
        var lr = 1 / (left - right);
        var bt = 1 / (bottom - top);
        var nf = 1 / (near - far);
        out[0] = -2 * lr;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = -2 * bt;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 2 * nf;
        out[11] = 0;
        out[12] = (left + right) * lr;
        out[13] = (top + bottom) * bt;
        out[14] = (far + near) * nf;
        out[15] = 1;
        return out;
      }
      var ortho = exports.ortho = orthoNO;
      function orthoZO(out, left, right, bottom, top, near, far) {
        var lr = 1 / (left - right);
        var bt = 1 / (bottom - top);
        var nf = 1 / (near - far);
        out[0] = -2 * lr;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = -2 * bt;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = nf;
        out[11] = 0;
        out[12] = (left + right) * lr;
        out[13] = (top + bottom) * bt;
        out[14] = near * nf;
        out[15] = 1;
        return out;
      }
      function lookAt(out, eye, center, up) {
        var x0, x1, x22, y0, y1, y22, z0, z1, z2, len;
        var eyex = eye[0];
        var eyey = eye[1];
        var eyez = eye[2];
        var upx = up[0];
        var upy = up[1];
        var upz = up[2];
        var centerx = center[0];
        var centery = center[1];
        var centerz = center[2];
        if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {
          return identity3(out);
        }
        z0 = eyex - centerx;
        z1 = eyey - centery;
        z2 = eyez - centerz;
        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
        z0 *= len;
        z1 *= len;
        z2 *= len;
        x0 = upy * z2 - upz * z1;
        x1 = upz * z0 - upx * z2;
        x22 = upx * z1 - upy * z0;
        len = Math.sqrt(x0 * x0 + x1 * x1 + x22 * x22);
        if (!len) {
          x0 = 0;
          x1 = 0;
          x22 = 0;
        } else {
          len = 1 / len;
          x0 *= len;
          x1 *= len;
          x22 *= len;
        }
        y0 = z1 * x22 - z2 * x1;
        y1 = z2 * x0 - z0 * x22;
        y22 = z0 * x1 - z1 * x0;
        len = Math.sqrt(y0 * y0 + y1 * y1 + y22 * y22);
        if (!len) {
          y0 = 0;
          y1 = 0;
          y22 = 0;
        } else {
          len = 1 / len;
          y0 *= len;
          y1 *= len;
          y22 *= len;
        }
        out[0] = x0;
        out[1] = y0;
        out[2] = z0;
        out[3] = 0;
        out[4] = x1;
        out[5] = y1;
        out[6] = z1;
        out[7] = 0;
        out[8] = x22;
        out[9] = y22;
        out[10] = z2;
        out[11] = 0;
        out[12] = -(x0 * eyex + x1 * eyey + x22 * eyez);
        out[13] = -(y0 * eyex + y1 * eyey + y22 * eyez);
        out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
        out[15] = 1;
        return out;
      }
      function targetTo(out, eye, target, up) {
        var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
        var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
        var len = z0 * z0 + z1 * z1 + z2 * z2;
        if (len > 0) {
          len = 1 / Math.sqrt(len);
          z0 *= len;
          z1 *= len;
          z2 *= len;
        }
        var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x22 = upx * z1 - upy * z0;
        len = x0 * x0 + x1 * x1 + x22 * x22;
        if (len > 0) {
          len = 1 / Math.sqrt(len);
          x0 *= len;
          x1 *= len;
          x22 *= len;
        }
        out[0] = x0;
        out[1] = x1;
        out[2] = x22;
        out[3] = 0;
        out[4] = z1 * x22 - z2 * x1;
        out[5] = z2 * x0 - z0 * x22;
        out[6] = z0 * x1 - z1 * x0;
        out[7] = 0;
        out[8] = z0;
        out[9] = z1;
        out[10] = z2;
        out[11] = 0;
        out[12] = eyex;
        out[13] = eyey;
        out[14] = eyez;
        out[15] = 1;
        return out;
      }
      function str(a2) {
        return "mat4(" + a2[0] + ", " + a2[1] + ", " + a2[2] + ", " + a2[3] + ", " + a2[4] + ", " + a2[5] + ", " + a2[6] + ", " + a2[7] + ", " + a2[8] + ", " + a2[9] + ", " + a2[10] + ", " + a2[11] + ", " + a2[12] + ", " + a2[13] + ", " + a2[14] + ", " + a2[15] + ")";
      }
      function frob(a2) {
        return Math.sqrt(a2[0] * a2[0] + a2[1] * a2[1] + a2[2] * a2[2] + a2[3] * a2[3] + a2[4] * a2[4] + a2[5] * a2[5] + a2[6] * a2[6] + a2[7] * a2[7] + a2[8] * a2[8] + a2[9] * a2[9] + a2[10] * a2[10] + a2[11] * a2[11] + a2[12] * a2[12] + a2[13] * a2[13] + a2[14] * a2[14] + a2[15] * a2[15]);
      }
      function add5(out, a2, b) {
        out[0] = a2[0] + b[0];
        out[1] = a2[1] + b[1];
        out[2] = a2[2] + b[2];
        out[3] = a2[3] + b[3];
        out[4] = a2[4] + b[4];
        out[5] = a2[5] + b[5];
        out[6] = a2[6] + b[6];
        out[7] = a2[7] + b[7];
        out[8] = a2[8] + b[8];
        out[9] = a2[9] + b[9];
        out[10] = a2[10] + b[10];
        out[11] = a2[11] + b[11];
        out[12] = a2[12] + b[12];
        out[13] = a2[13] + b[13];
        out[14] = a2[14] + b[14];
        out[15] = a2[15] + b[15];
        return out;
      }
      function subtract2(out, a2, b) {
        out[0] = a2[0] - b[0];
        out[1] = a2[1] - b[1];
        out[2] = a2[2] - b[2];
        out[3] = a2[3] - b[3];
        out[4] = a2[4] - b[4];
        out[5] = a2[5] - b[5];
        out[6] = a2[6] - b[6];
        out[7] = a2[7] - b[7];
        out[8] = a2[8] - b[8];
        out[9] = a2[9] - b[9];
        out[10] = a2[10] - b[10];
        out[11] = a2[11] - b[11];
        out[12] = a2[12] - b[12];
        out[13] = a2[13] - b[13];
        out[14] = a2[14] - b[14];
        out[15] = a2[15] - b[15];
        return out;
      }
      function multiplyScalar(out, a2, b) {
        out[0] = a2[0] * b;
        out[1] = a2[1] * b;
        out[2] = a2[2] * b;
        out[3] = a2[3] * b;
        out[4] = a2[4] * b;
        out[5] = a2[5] * b;
        out[6] = a2[6] * b;
        out[7] = a2[7] * b;
        out[8] = a2[8] * b;
        out[9] = a2[9] * b;
        out[10] = a2[10] * b;
        out[11] = a2[11] * b;
        out[12] = a2[12] * b;
        out[13] = a2[13] * b;
        out[14] = a2[14] * b;
        out[15] = a2[15] * b;
        return out;
      }
      function multiplyScalarAndAdd(out, a2, b, scale5) {
        out[0] = a2[0] + b[0] * scale5;
        out[1] = a2[1] + b[1] * scale5;
        out[2] = a2[2] + b[2] * scale5;
        out[3] = a2[3] + b[3] * scale5;
        out[4] = a2[4] + b[4] * scale5;
        out[5] = a2[5] + b[5] * scale5;
        out[6] = a2[6] + b[6] * scale5;
        out[7] = a2[7] + b[7] * scale5;
        out[8] = a2[8] + b[8] * scale5;
        out[9] = a2[9] + b[9] * scale5;
        out[10] = a2[10] + b[10] * scale5;
        out[11] = a2[11] + b[11] * scale5;
        out[12] = a2[12] + b[12] * scale5;
        out[13] = a2[13] + b[13] * scale5;
        out[14] = a2[14] + b[14] * scale5;
        out[15] = a2[15] + b[15] * scale5;
        return out;
      }
      function exactEquals(a2, b) {
        return a2[0] === b[0] && a2[1] === b[1] && a2[2] === b[2] && a2[3] === b[3] && a2[4] === b[4] && a2[5] === b[5] && a2[6] === b[6] && a2[7] === b[7] && a2[8] === b[8] && a2[9] === b[9] && a2[10] === b[10] && a2[11] === b[11] && a2[12] === b[12] && a2[13] === b[13] && a2[14] === b[14] && a2[15] === b[15];
      }
      function equals(a2, b) {
        var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
        var a4 = a2[4], a5 = a2[5], a6 = a2[6], a7 = a2[7];
        var a8 = a2[8], a9 = a2[9], a10 = a2[10], a11 = a2[11];
        var a12 = a2[12], a13 = a2[13], a14 = a2[14], a15 = a2[15];
        var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
        var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
        var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
        var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= glMatrix.EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
      }
      var mul = exports.mul = multiply2;
      var sub2 = exports.sub = subtract2;
    }
  });

  // node_modules/gl-matrix/cjs/vec3.js
  var require_vec3 = __commonJS({
    "node_modules/gl-matrix/cjs/vec3.js"(exports) {
      "use strict";
      function _typeof2(o) {
        "@babel/helpers - typeof";
        return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof2(o);
      }
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.add = add5;
      exports.angle = angle2;
      exports.bezier = bezier3;
      exports.ceil = ceil;
      exports.clone = clone8;
      exports.copy = copy;
      exports.create = create2;
      exports.cross = cross3;
      exports.dist = void 0;
      exports.distance = distance6;
      exports.div = void 0;
      exports.divide = divide2;
      exports.dot = dot4;
      exports.equals = equals;
      exports.exactEquals = exactEquals;
      exports.floor = floor;
      exports.forEach = void 0;
      exports.fromValues = fromValues;
      exports.hermite = hermite;
      exports.inverse = inverse2;
      exports.len = void 0;
      exports.length = length;
      exports.lerp = lerp;
      exports.max = max4;
      exports.min = min4;
      exports.mul = void 0;
      exports.multiply = multiply2;
      exports.negate = negate;
      exports.normalize = normalize5;
      exports.random = random;
      exports.rotateX = rotateX2;
      exports.rotateY = rotateY2;
      exports.rotateZ = rotateZ2;
      exports.round = round3;
      exports.scale = scale4;
      exports.scaleAndAdd = scaleAndAdd;
      exports.set = set6;
      exports.slerp = slerp;
      exports.sqrLen = exports.sqrDist = void 0;
      exports.squaredDistance = squaredDistance;
      exports.squaredLength = squaredLength;
      exports.str = str;
      exports.sub = void 0;
      exports.subtract = subtract2;
      exports.transformMat3 = transformMat3;
      exports.transformMat4 = transformMat4;
      exports.transformQuat = transformQuat;
      exports.zero = zero;
      var glMatrix = _interopRequireWildcard(require_common());
      function _interopRequireWildcard(e, t) {
        if ("function" == typeof WeakMap) var r = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
        return (_interopRequireWildcard = function _interopRequireWildcard2(e3, t2) {
          if (!t2 && e3 && e3.__esModule) return e3;
          var o, i, f = { __proto__: null, "default": e3 };
          if (null === e3 || "object" != _typeof2(e3) && "function" != typeof e3) return f;
          if (o = t2 ? n : r) {
            if (o.has(e3)) return o.get(e3);
            o.set(e3, f);
          }
          for (var _t in e3) "default" !== _t && {}.hasOwnProperty.call(e3, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e3, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e3[_t]);
          return f;
        })(e, t);
      }
      function create2() {
        var out = new glMatrix.ARRAY_TYPE(3);
        if (glMatrix.ARRAY_TYPE != Float32Array) {
          out[0] = 0;
          out[1] = 0;
          out[2] = 0;
        }
        return out;
      }
      function clone8(a2) {
        var out = new glMatrix.ARRAY_TYPE(3);
        out[0] = a2[0];
        out[1] = a2[1];
        out[2] = a2[2];
        return out;
      }
      function length(a2) {
        var x3 = a2[0];
        var y3 = a2[1];
        var z = a2[2];
        return Math.sqrt(x3 * x3 + y3 * y3 + z * z);
      }
      function fromValues(x3, y3, z) {
        var out = new glMatrix.ARRAY_TYPE(3);
        out[0] = x3;
        out[1] = y3;
        out[2] = z;
        return out;
      }
      function copy(out, a2) {
        out[0] = a2[0];
        out[1] = a2[1];
        out[2] = a2[2];
        return out;
      }
      function set6(out, x3, y3, z) {
        out[0] = x3;
        out[1] = y3;
        out[2] = z;
        return out;
      }
      function add5(out, a2, b) {
        out[0] = a2[0] + b[0];
        out[1] = a2[1] + b[1];
        out[2] = a2[2] + b[2];
        return out;
      }
      function subtract2(out, a2, b) {
        out[0] = a2[0] - b[0];
        out[1] = a2[1] - b[1];
        out[2] = a2[2] - b[2];
        return out;
      }
      function multiply2(out, a2, b) {
        out[0] = a2[0] * b[0];
        out[1] = a2[1] * b[1];
        out[2] = a2[2] * b[2];
        return out;
      }
      function divide2(out, a2, b) {
        out[0] = a2[0] / b[0];
        out[1] = a2[1] / b[1];
        out[2] = a2[2] / b[2];
        return out;
      }
      function ceil(out, a2) {
        out[0] = Math.ceil(a2[0]);
        out[1] = Math.ceil(a2[1]);
        out[2] = Math.ceil(a2[2]);
        return out;
      }
      function floor(out, a2) {
        out[0] = Math.floor(a2[0]);
        out[1] = Math.floor(a2[1]);
        out[2] = Math.floor(a2[2]);
        return out;
      }
      function min4(out, a2, b) {
        out[0] = Math.min(a2[0], b[0]);
        out[1] = Math.min(a2[1], b[1]);
        out[2] = Math.min(a2[2], b[2]);
        return out;
      }
      function max4(out, a2, b) {
        out[0] = Math.max(a2[0], b[0]);
        out[1] = Math.max(a2[1], b[1]);
        out[2] = Math.max(a2[2], b[2]);
        return out;
      }
      function round3(out, a2) {
        out[0] = glMatrix.round(a2[0]);
        out[1] = glMatrix.round(a2[1]);
        out[2] = glMatrix.round(a2[2]);
        return out;
      }
      function scale4(out, a2, b) {
        out[0] = a2[0] * b;
        out[1] = a2[1] * b;
        out[2] = a2[2] * b;
        return out;
      }
      function scaleAndAdd(out, a2, b, scale5) {
        out[0] = a2[0] + b[0] * scale5;
        out[1] = a2[1] + b[1] * scale5;
        out[2] = a2[2] + b[2] * scale5;
        return out;
      }
      function distance6(a2, b) {
        var x3 = b[0] - a2[0];
        var y3 = b[1] - a2[1];
        var z = b[2] - a2[2];
        return Math.sqrt(x3 * x3 + y3 * y3 + z * z);
      }
      function squaredDistance(a2, b) {
        var x3 = b[0] - a2[0];
        var y3 = b[1] - a2[1];
        var z = b[2] - a2[2];
        return x3 * x3 + y3 * y3 + z * z;
      }
      function squaredLength(a2) {
        var x3 = a2[0];
        var y3 = a2[1];
        var z = a2[2];
        return x3 * x3 + y3 * y3 + z * z;
      }
      function negate(out, a2) {
        out[0] = -a2[0];
        out[1] = -a2[1];
        out[2] = -a2[2];
        return out;
      }
      function inverse2(out, a2) {
        out[0] = 1 / a2[0];
        out[1] = 1 / a2[1];
        out[2] = 1 / a2[2];
        return out;
      }
      function normalize5(out, a2) {
        var x3 = a2[0];
        var y3 = a2[1];
        var z = a2[2];
        var len2 = x3 * x3 + y3 * y3 + z * z;
        if (len2 > 0) {
          len2 = 1 / Math.sqrt(len2);
        }
        out[0] = a2[0] * len2;
        out[1] = a2[1] * len2;
        out[2] = a2[2] * len2;
        return out;
      }
      function dot4(a2, b) {
        return a2[0] * b[0] + a2[1] * b[1] + a2[2] * b[2];
      }
      function cross3(out, a2, b) {
        var ax = a2[0], ay = a2[1], az = a2[2];
        var bx = b[0], by = b[1], bz = b[2];
        out[0] = ay * bz - az * by;
        out[1] = az * bx - ax * bz;
        out[2] = ax * by - ay * bx;
        return out;
      }
      function lerp(out, a2, b, t) {
        var ax = a2[0];
        var ay = a2[1];
        var az = a2[2];
        out[0] = ax + t * (b[0] - ax);
        out[1] = ay + t * (b[1] - ay);
        out[2] = az + t * (b[2] - az);
        return out;
      }
      function slerp(out, a2, b, t) {
        var angle3 = Math.acos(Math.min(Math.max(dot4(a2, b), -1), 1));
        var sinTotal = Math.sin(angle3);
        var ratioA = Math.sin((1 - t) * angle3) / sinTotal;
        var ratioB = Math.sin(t * angle3) / sinTotal;
        out[0] = ratioA * a2[0] + ratioB * b[0];
        out[1] = ratioA * a2[1] + ratioB * b[1];
        out[2] = ratioA * a2[2] + ratioB * b[2];
        return out;
      }
      function hermite(out, a2, b, c2, d2, t) {
        var factorTimes2 = t * t;
        var factor1 = factorTimes2 * (2 * t - 3) + 1;
        var factor2 = factorTimes2 * (t - 2) + t;
        var factor3 = factorTimes2 * (t - 1);
        var factor4 = factorTimes2 * (3 - 2 * t);
        out[0] = a2[0] * factor1 + b[0] * factor2 + c2[0] * factor3 + d2[0] * factor4;
        out[1] = a2[1] * factor1 + b[1] * factor2 + c2[1] * factor3 + d2[1] * factor4;
        out[2] = a2[2] * factor1 + b[2] * factor2 + c2[2] * factor3 + d2[2] * factor4;
        return out;
      }
      function bezier3(out, a2, b, c2, d2, t) {
        var inverseFactor = 1 - t;
        var inverseFactorTimesTwo = inverseFactor * inverseFactor;
        var factorTimes2 = t * t;
        var factor1 = inverseFactorTimesTwo * inverseFactor;
        var factor2 = 3 * t * inverseFactorTimesTwo;
        var factor3 = 3 * factorTimes2 * inverseFactor;
        var factor4 = factorTimes2 * t;
        out[0] = a2[0] * factor1 + b[0] * factor2 + c2[0] * factor3 + d2[0] * factor4;
        out[1] = a2[1] * factor1 + b[1] * factor2 + c2[1] * factor3 + d2[1] * factor4;
        out[2] = a2[2] * factor1 + b[2] * factor2 + c2[2] * factor3 + d2[2] * factor4;
        return out;
      }
      function random(out, scale5) {
        scale5 = scale5 === void 0 ? 1 : scale5;
        var r = glMatrix.RANDOM() * 2 * Math.PI;
        var z = glMatrix.RANDOM() * 2 - 1;
        var zScale = Math.sqrt(1 - z * z) * scale5;
        out[0] = Math.cos(r) * zScale;
        out[1] = Math.sin(r) * zScale;
        out[2] = z * scale5;
        return out;
      }
      function transformMat4(out, a2, m2) {
        var x3 = a2[0], y3 = a2[1], z = a2[2];
        var w = m2[3] * x3 + m2[7] * y3 + m2[11] * z + m2[15];
        w = w || 1;
        out[0] = (m2[0] * x3 + m2[4] * y3 + m2[8] * z + m2[12]) / w;
        out[1] = (m2[1] * x3 + m2[5] * y3 + m2[9] * z + m2[13]) / w;
        out[2] = (m2[2] * x3 + m2[6] * y3 + m2[10] * z + m2[14]) / w;
        return out;
      }
      function transformMat3(out, a2, m2) {
        var x3 = a2[0], y3 = a2[1], z = a2[2];
        out[0] = x3 * m2[0] + y3 * m2[3] + z * m2[6];
        out[1] = x3 * m2[1] + y3 * m2[4] + z * m2[7];
        out[2] = x3 * m2[2] + y3 * m2[5] + z * m2[8];
        return out;
      }
      function transformQuat(out, a2, q) {
        var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
        var vx = a2[0], vy = a2[1], vz = a2[2];
        var tx = qy * vz - qz * vy;
        var ty = qz * vx - qx * vz;
        var tz = qx * vy - qy * vx;
        tx = tx + tx;
        ty = ty + ty;
        tz = tz + tz;
        out[0] = vx + qw * tx + qy * tz - qz * ty;
        out[1] = vy + qw * ty + qz * tx - qx * tz;
        out[2] = vz + qw * tz + qx * ty - qy * tx;
        return out;
      }
      function rotateX2(out, a2, b, rad2) {
        var p = [], r = [];
        p[0] = a2[0] - b[0];
        p[1] = a2[1] - b[1];
        p[2] = a2[2] - b[2];
        r[0] = p[0];
        r[1] = p[1] * Math.cos(rad2) - p[2] * Math.sin(rad2);
        r[2] = p[1] * Math.sin(rad2) + p[2] * Math.cos(rad2);
        out[0] = r[0] + b[0];
        out[1] = r[1] + b[1];
        out[2] = r[2] + b[2];
        return out;
      }
      function rotateY2(out, a2, b, rad2) {
        var p = [], r = [];
        p[0] = a2[0] - b[0];
        p[1] = a2[1] - b[1];
        p[2] = a2[2] - b[2];
        r[0] = p[2] * Math.sin(rad2) + p[0] * Math.cos(rad2);
        r[1] = p[1];
        r[2] = p[2] * Math.cos(rad2) - p[0] * Math.sin(rad2);
        out[0] = r[0] + b[0];
        out[1] = r[1] + b[1];
        out[2] = r[2] + b[2];
        return out;
      }
      function rotateZ2(out, a2, b, rad2) {
        var p = [], r = [];
        p[0] = a2[0] - b[0];
        p[1] = a2[1] - b[1];
        p[2] = a2[2] - b[2];
        r[0] = p[0] * Math.cos(rad2) - p[1] * Math.sin(rad2);
        r[1] = p[0] * Math.sin(rad2) + p[1] * Math.cos(rad2);
        r[2] = p[2];
        out[0] = r[0] + b[0];
        out[1] = r[1] + b[1];
        out[2] = r[2] + b[2];
        return out;
      }
      function angle2(a2, b) {
        var ax = a2[0], ay = a2[1], az = a2[2], bx = b[0], by = b[1], bz = b[2], mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz)), cosine = mag && dot4(a2, b) / mag;
        return Math.acos(Math.min(Math.max(cosine, -1), 1));
      }
      function zero(out) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        return out;
      }
      function str(a2) {
        return "vec3(" + a2[0] + ", " + a2[1] + ", " + a2[2] + ")";
      }
      function exactEquals(a2, b) {
        return a2[0] === b[0] && a2[1] === b[1] && a2[2] === b[2];
      }
      function equals(a2, b) {
        var a0 = a2[0], a1 = a2[1], a22 = a2[2];
        var b0 = b[0], b1 = b[1], b2 = b[2];
        return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= glMatrix.EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2));
      }
      var sub2 = exports.sub = subtract2;
      var mul = exports.mul = multiply2;
      var div = exports.div = divide2;
      var dist = exports.dist = distance6;
      var sqrDist = exports.sqrDist = squaredDistance;
      var len = exports.len = length;
      var sqrLen = exports.sqrLen = squaredLength;
      var forEach = exports.forEach = (function() {
        var vec = create2();
        return function(a2, stride, offset, count, fn, arg) {
          var i, l;
          if (!stride) {
            stride = 3;
          }
          if (!offset) {
            offset = 0;
          }
          if (count) {
            l = Math.min(count * stride + offset, a2.length);
          } else {
            l = a2.length;
          }
          for (i = offset; i < l; i += stride) {
            vec[0] = a2[i];
            vec[1] = a2[i + 1];
            vec[2] = a2[i + 2];
            fn(vec, vec, arg);
            a2[i] = vec[0];
            a2[i + 1] = vec[1];
            a2[i + 2] = vec[2];
          }
          return a2;
        };
      })();
    }
  });

  // node_modules/gl-matrix/cjs/vec4.js
  var require_vec4 = __commonJS({
    "node_modules/gl-matrix/cjs/vec4.js"(exports) {
      "use strict";
      function _typeof2(o) {
        "@babel/helpers - typeof";
        return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof2(o);
      }
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.add = add5;
      exports.ceil = ceil;
      exports.clone = clone8;
      exports.copy = copy;
      exports.create = create2;
      exports.cross = cross3;
      exports.dist = void 0;
      exports.distance = distance6;
      exports.div = void 0;
      exports.divide = divide2;
      exports.dot = dot4;
      exports.equals = equals;
      exports.exactEquals = exactEquals;
      exports.floor = floor;
      exports.forEach = void 0;
      exports.fromValues = fromValues;
      exports.inverse = inverse2;
      exports.len = void 0;
      exports.length = length;
      exports.lerp = lerp;
      exports.max = max4;
      exports.min = min4;
      exports.mul = void 0;
      exports.multiply = multiply2;
      exports.negate = negate;
      exports.normalize = normalize5;
      exports.random = random;
      exports.round = round3;
      exports.scale = scale4;
      exports.scaleAndAdd = scaleAndAdd;
      exports.set = set6;
      exports.sqrLen = exports.sqrDist = void 0;
      exports.squaredDistance = squaredDistance;
      exports.squaredLength = squaredLength;
      exports.str = str;
      exports.sub = void 0;
      exports.subtract = subtract2;
      exports.transformMat4 = transformMat4;
      exports.transformQuat = transformQuat;
      exports.zero = zero;
      var glMatrix = _interopRequireWildcard(require_common());
      function _interopRequireWildcard(e, t) {
        if ("function" == typeof WeakMap) var r = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
        return (_interopRequireWildcard = function _interopRequireWildcard2(e3, t2) {
          if (!t2 && e3 && e3.__esModule) return e3;
          var o, i, f = { __proto__: null, "default": e3 };
          if (null === e3 || "object" != _typeof2(e3) && "function" != typeof e3) return f;
          if (o = t2 ? n : r) {
            if (o.has(e3)) return o.get(e3);
            o.set(e3, f);
          }
          for (var _t in e3) "default" !== _t && {}.hasOwnProperty.call(e3, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e3, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e3[_t]);
          return f;
        })(e, t);
      }
      function create2() {
        var out = new glMatrix.ARRAY_TYPE(4);
        if (glMatrix.ARRAY_TYPE != Float32Array) {
          out[0] = 0;
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
        }
        return out;
      }
      function clone8(a2) {
        var out = new glMatrix.ARRAY_TYPE(4);
        out[0] = a2[0];
        out[1] = a2[1];
        out[2] = a2[2];
        out[3] = a2[3];
        return out;
      }
      function fromValues(x3, y3, z, w) {
        var out = new glMatrix.ARRAY_TYPE(4);
        out[0] = x3;
        out[1] = y3;
        out[2] = z;
        out[3] = w;
        return out;
      }
      function copy(out, a2) {
        out[0] = a2[0];
        out[1] = a2[1];
        out[2] = a2[2];
        out[3] = a2[3];
        return out;
      }
      function set6(out, x3, y3, z, w) {
        out[0] = x3;
        out[1] = y3;
        out[2] = z;
        out[3] = w;
        return out;
      }
      function add5(out, a2, b) {
        out[0] = a2[0] + b[0];
        out[1] = a2[1] + b[1];
        out[2] = a2[2] + b[2];
        out[3] = a2[3] + b[3];
        return out;
      }
      function subtract2(out, a2, b) {
        out[0] = a2[0] - b[0];
        out[1] = a2[1] - b[1];
        out[2] = a2[2] - b[2];
        out[3] = a2[3] - b[3];
        return out;
      }
      function multiply2(out, a2, b) {
        out[0] = a2[0] * b[0];
        out[1] = a2[1] * b[1];
        out[2] = a2[2] * b[2];
        out[3] = a2[3] * b[3];
        return out;
      }
      function divide2(out, a2, b) {
        out[0] = a2[0] / b[0];
        out[1] = a2[1] / b[1];
        out[2] = a2[2] / b[2];
        out[3] = a2[3] / b[3];
        return out;
      }
      function ceil(out, a2) {
        out[0] = Math.ceil(a2[0]);
        out[1] = Math.ceil(a2[1]);
        out[2] = Math.ceil(a2[2]);
        out[3] = Math.ceil(a2[3]);
        return out;
      }
      function floor(out, a2) {
        out[0] = Math.floor(a2[0]);
        out[1] = Math.floor(a2[1]);
        out[2] = Math.floor(a2[2]);
        out[3] = Math.floor(a2[3]);
        return out;
      }
      function min4(out, a2, b) {
        out[0] = Math.min(a2[0], b[0]);
        out[1] = Math.min(a2[1], b[1]);
        out[2] = Math.min(a2[2], b[2]);
        out[3] = Math.min(a2[3], b[3]);
        return out;
      }
      function max4(out, a2, b) {
        out[0] = Math.max(a2[0], b[0]);
        out[1] = Math.max(a2[1], b[1]);
        out[2] = Math.max(a2[2], b[2]);
        out[3] = Math.max(a2[3], b[3]);
        return out;
      }
      function round3(out, a2) {
        out[0] = glMatrix.round(a2[0]);
        out[1] = glMatrix.round(a2[1]);
        out[2] = glMatrix.round(a2[2]);
        out[3] = glMatrix.round(a2[3]);
        return out;
      }
      function scale4(out, a2, b) {
        out[0] = a2[0] * b;
        out[1] = a2[1] * b;
        out[2] = a2[2] * b;
        out[3] = a2[3] * b;
        return out;
      }
      function scaleAndAdd(out, a2, b, scale5) {
        out[0] = a2[0] + b[0] * scale5;
        out[1] = a2[1] + b[1] * scale5;
        out[2] = a2[2] + b[2] * scale5;
        out[3] = a2[3] + b[3] * scale5;
        return out;
      }
      function distance6(a2, b) {
        var x3 = b[0] - a2[0];
        var y3 = b[1] - a2[1];
        var z = b[2] - a2[2];
        var w = b[3] - a2[3];
        return Math.sqrt(x3 * x3 + y3 * y3 + z * z + w * w);
      }
      function squaredDistance(a2, b) {
        var x3 = b[0] - a2[0];
        var y3 = b[1] - a2[1];
        var z = b[2] - a2[2];
        var w = b[3] - a2[3];
        return x3 * x3 + y3 * y3 + z * z + w * w;
      }
      function length(a2) {
        var x3 = a2[0];
        var y3 = a2[1];
        var z = a2[2];
        var w = a2[3];
        return Math.sqrt(x3 * x3 + y3 * y3 + z * z + w * w);
      }
      function squaredLength(a2) {
        var x3 = a2[0];
        var y3 = a2[1];
        var z = a2[2];
        var w = a2[3];
        return x3 * x3 + y3 * y3 + z * z + w * w;
      }
      function negate(out, a2) {
        out[0] = -a2[0];
        out[1] = -a2[1];
        out[2] = -a2[2];
        out[3] = -a2[3];
        return out;
      }
      function inverse2(out, a2) {
        out[0] = 1 / a2[0];
        out[1] = 1 / a2[1];
        out[2] = 1 / a2[2];
        out[3] = 1 / a2[3];
        return out;
      }
      function normalize5(out, a2) {
        var x3 = a2[0];
        var y3 = a2[1];
        var z = a2[2];
        var w = a2[3];
        var len2 = x3 * x3 + y3 * y3 + z * z + w * w;
        if (len2 > 0) {
          len2 = 1 / Math.sqrt(len2);
        }
        out[0] = x3 * len2;
        out[1] = y3 * len2;
        out[2] = z * len2;
        out[3] = w * len2;
        return out;
      }
      function dot4(a2, b) {
        return a2[0] * b[0] + a2[1] * b[1] + a2[2] * b[2] + a2[3] * b[3];
      }
      function cross3(out, u, v, w) {
        var A3 = v[0] * w[1] - v[1] * w[0], B3 = v[0] * w[2] - v[2] * w[0], C3 = v[0] * w[3] - v[3] * w[0], D = v[1] * w[2] - v[2] * w[1], E2 = v[1] * w[3] - v[3] * w[1], F = v[2] * w[3] - v[3] * w[2];
        var G = u[0];
        var H = u[1];
        var I = u[2];
        var J = u[3];
        out[0] = H * F - I * E2 + J * D;
        out[1] = -(G * F) + I * C3 - J * B3;
        out[2] = G * E2 - H * C3 + J * A3;
        out[3] = -(G * D) + H * B3 - I * A3;
        return out;
      }
      function lerp(out, a2, b, t) {
        var ax = a2[0];
        var ay = a2[1];
        var az = a2[2];
        var aw = a2[3];
        out[0] = ax + t * (b[0] - ax);
        out[1] = ay + t * (b[1] - ay);
        out[2] = az + t * (b[2] - az);
        out[3] = aw + t * (b[3] - aw);
        return out;
      }
      function random(out, scale5) {
        scale5 = scale5 === void 0 ? 1 : scale5;
        var v1, v2, v3, v4;
        var s1, s2;
        var rand;
        rand = glMatrix.RANDOM();
        v1 = rand * 2 - 1;
        v2 = (4 * glMatrix.RANDOM() - 2) * Math.sqrt(rand * -rand + rand);
        s1 = v1 * v1 + v2 * v2;
        rand = glMatrix.RANDOM();
        v3 = rand * 2 - 1;
        v4 = (4 * glMatrix.RANDOM() - 2) * Math.sqrt(rand * -rand + rand);
        s2 = v3 * v3 + v4 * v4;
        var d2 = Math.sqrt((1 - s1) / s2);
        out[0] = scale5 * v1;
        out[1] = scale5 * v2;
        out[2] = scale5 * v3 * d2;
        out[3] = scale5 * v4 * d2;
        return out;
      }
      function transformMat4(out, a2, m2) {
        var x3 = a2[0], y3 = a2[1], z = a2[2], w = a2[3];
        out[0] = m2[0] * x3 + m2[4] * y3 + m2[8] * z + m2[12] * w;
        out[1] = m2[1] * x3 + m2[5] * y3 + m2[9] * z + m2[13] * w;
        out[2] = m2[2] * x3 + m2[6] * y3 + m2[10] * z + m2[14] * w;
        out[3] = m2[3] * x3 + m2[7] * y3 + m2[11] * z + m2[15] * w;
        return out;
      }
      function transformQuat(out, a2, q) {
        var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
        var vx = a2[0], vy = a2[1], vz = a2[2];
        var tx = qy * vz - qz * vy;
        var ty = qz * vx - qx * vz;
        var tz = qx * vy - qy * vx;
        tx = tx + tx;
        ty = ty + ty;
        tz = tz + tz;
        out[0] = vx + qw * tx + qy * tz - qz * ty;
        out[1] = vy + qw * ty + qz * tx - qx * tz;
        out[2] = vz + qw * tz + qx * ty - qy * tx;
        out[3] = a2[3];
        return out;
      }
      function zero(out) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        return out;
      }
      function str(a2) {
        return "vec4(" + a2[0] + ", " + a2[1] + ", " + a2[2] + ", " + a2[3] + ")";
      }
      function exactEquals(a2, b) {
        return a2[0] === b[0] && a2[1] === b[1] && a2[2] === b[2] && a2[3] === b[3];
      }
      function equals(a2, b) {
        var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
        var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
        return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= glMatrix.EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
      }
      var sub2 = exports.sub = subtract2;
      var mul = exports.mul = multiply2;
      var div = exports.div = divide2;
      var dist = exports.dist = distance6;
      var sqrDist = exports.sqrDist = squaredDistance;
      var len = exports.len = length;
      var sqrLen = exports.sqrLen = squaredLength;
      var forEach = exports.forEach = (function() {
        var vec = create2();
        return function(a2, stride, offset, count, fn, arg) {
          var i, l;
          if (!stride) {
            stride = 4;
          }
          if (!offset) {
            offset = 0;
          }
          if (count) {
            l = Math.min(count * stride + offset, a2.length);
          } else {
            l = a2.length;
          }
          for (i = offset; i < l; i += stride) {
            vec[0] = a2[i];
            vec[1] = a2[i + 1];
            vec[2] = a2[i + 2];
            vec[3] = a2[i + 3];
            fn(vec, vec, arg);
            a2[i] = vec[0];
            a2[i + 1] = vec[1];
            a2[i + 2] = vec[2];
            a2[i + 3] = vec[3];
          }
          return a2;
        };
      })();
    }
  });

  // node_modules/gl-matrix/cjs/quat.js
  var require_quat = __commonJS({
    "node_modules/gl-matrix/cjs/quat.js"(exports) {
      "use strict";
      function _typeof2(o) {
        "@babel/helpers - typeof";
        return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof2(o);
      }
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.add = void 0;
      exports.calculateW = calculateW;
      exports.clone = void 0;
      exports.conjugate = conjugate;
      exports.copy = void 0;
      exports.create = create2;
      exports.dot = void 0;
      exports.equals = equals;
      exports.exactEquals = void 0;
      exports.exp = exp;
      exports.fromEuler = fromEuler;
      exports.fromMat3 = fromMat3;
      exports.fromValues = void 0;
      exports.getAngle = getAngle3;
      exports.getAxisAngle = getAxisAngle;
      exports.identity = identity3;
      exports.invert = invert;
      exports.lerp = exports.length = exports.len = void 0;
      exports.ln = ln;
      exports.mul = void 0;
      exports.multiply = multiply2;
      exports.normalize = void 0;
      exports.pow = pow2;
      exports.random = random;
      exports.rotateX = rotateX2;
      exports.rotateY = rotateY2;
      exports.rotateZ = rotateZ2;
      exports.setAxes = exports.set = exports.scale = exports.rotationTo = void 0;
      exports.setAxisAngle = setAxisAngle;
      exports.slerp = slerp;
      exports.squaredLength = exports.sqrLen = exports.sqlerp = void 0;
      exports.str = str;
      var glMatrix = _interopRequireWildcard(require_common());
      var mat32 = _interopRequireWildcard(require_mat3());
      var vec35 = _interopRequireWildcard(require_vec3());
      var vec42 = _interopRequireWildcard(require_vec4());
      function _interopRequireWildcard(e, t) {
        if ("function" == typeof WeakMap) var r = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
        return (_interopRequireWildcard = function _interopRequireWildcard2(e3, t2) {
          if (!t2 && e3 && e3.__esModule) return e3;
          var o, i, f = { __proto__: null, "default": e3 };
          if (null === e3 || "object" != _typeof2(e3) && "function" != typeof e3) return f;
          if (o = t2 ? n : r) {
            if (o.has(e3)) return o.get(e3);
            o.set(e3, f);
          }
          for (var _t in e3) "default" !== _t && {}.hasOwnProperty.call(e3, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e3, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e3[_t]);
          return f;
        })(e, t);
      }
      function create2() {
        var out = new glMatrix.ARRAY_TYPE(4);
        if (glMatrix.ARRAY_TYPE != Float32Array) {
          out[0] = 0;
          out[1] = 0;
          out[2] = 0;
        }
        out[3] = 1;
        return out;
      }
      function identity3(out) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      }
      function setAxisAngle(out, axis, rad2) {
        rad2 = rad2 * 0.5;
        var s = Math.sin(rad2);
        out[0] = s * axis[0];
        out[1] = s * axis[1];
        out[2] = s * axis[2];
        out[3] = Math.cos(rad2);
        return out;
      }
      function getAxisAngle(out_axis, q) {
        var rad2 = Math.acos(q[3]) * 2;
        var s = Math.sin(rad2 / 2);
        if (s > glMatrix.EPSILON) {
          out_axis[0] = q[0] / s;
          out_axis[1] = q[1] / s;
          out_axis[2] = q[2] / s;
        } else {
          out_axis[0] = 1;
          out_axis[1] = 0;
          out_axis[2] = 0;
        }
        return rad2;
      }
      function getAngle3(a2, b) {
        var dotproduct = dot4(a2, b);
        return Math.acos(2 * dotproduct * dotproduct - 1);
      }
      function multiply2(out, a2, b) {
        var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
        var bx = b[0], by = b[1], bz = b[2], bw = b[3];
        out[0] = ax * bw + aw * bx + ay * bz - az * by;
        out[1] = ay * bw + aw * by + az * bx - ax * bz;
        out[2] = az * bw + aw * bz + ax * by - ay * bx;
        out[3] = aw * bw - ax * bx - ay * by - az * bz;
        return out;
      }
      function rotateX2(out, a2, rad2) {
        rad2 *= 0.5;
        var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
        var bx = Math.sin(rad2), bw = Math.cos(rad2);
        out[0] = ax * bw + aw * bx;
        out[1] = ay * bw + az * bx;
        out[2] = az * bw - ay * bx;
        out[3] = aw * bw - ax * bx;
        return out;
      }
      function rotateY2(out, a2, rad2) {
        rad2 *= 0.5;
        var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
        var by = Math.sin(rad2), bw = Math.cos(rad2);
        out[0] = ax * bw - az * by;
        out[1] = ay * bw + aw * by;
        out[2] = az * bw + ax * by;
        out[3] = aw * bw - ay * by;
        return out;
      }
      function rotateZ2(out, a2, rad2) {
        rad2 *= 0.5;
        var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
        var bz = Math.sin(rad2), bw = Math.cos(rad2);
        out[0] = ax * bw + ay * bz;
        out[1] = ay * bw - ax * bz;
        out[2] = az * bw + aw * bz;
        out[3] = aw * bw - az * bz;
        return out;
      }
      function calculateW(out, a2) {
        var x3 = a2[0], y3 = a2[1], z = a2[2];
        out[0] = x3;
        out[1] = y3;
        out[2] = z;
        out[3] = Math.sqrt(Math.abs(1 - x3 * x3 - y3 * y3 - z * z));
        return out;
      }
      function exp(out, a2) {
        var x3 = a2[0], y3 = a2[1], z = a2[2], w = a2[3];
        var r = Math.sqrt(x3 * x3 + y3 * y3 + z * z);
        var et = Math.exp(w);
        var s = r > 0 ? et * Math.sin(r) / r : 0;
        out[0] = x3 * s;
        out[1] = y3 * s;
        out[2] = z * s;
        out[3] = et * Math.cos(r);
        return out;
      }
      function ln(out, a2) {
        var x3 = a2[0], y3 = a2[1], z = a2[2], w = a2[3];
        var r = Math.sqrt(x3 * x3 + y3 * y3 + z * z);
        var t = r > 0 ? Math.atan2(r, w) / r : 0;
        out[0] = x3 * t;
        out[1] = y3 * t;
        out[2] = z * t;
        out[3] = 0.5 * Math.log(x3 * x3 + y3 * y3 + z * z + w * w);
        return out;
      }
      function pow2(out, a2, b) {
        ln(out, a2);
        scale4(out, out, b);
        exp(out, out);
        return out;
      }
      function slerp(out, a2, b, t) {
        var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
        var bx = b[0], by = b[1], bz = b[2], bw = b[3];
        var omega, cosom, sinom, scale0, scale1;
        cosom = ax * bx + ay * by + az * bz + aw * bw;
        if (cosom < 0) {
          cosom = -cosom;
          bx = -bx;
          by = -by;
          bz = -bz;
          bw = -bw;
        }
        if (1 - cosom > glMatrix.EPSILON) {
          omega = Math.acos(cosom);
          sinom = Math.sin(omega);
          scale0 = Math.sin((1 - t) * omega) / sinom;
          scale1 = Math.sin(t * omega) / sinom;
        } else {
          scale0 = 1 - t;
          scale1 = t;
        }
        out[0] = scale0 * ax + scale1 * bx;
        out[1] = scale0 * ay + scale1 * by;
        out[2] = scale0 * az + scale1 * bz;
        out[3] = scale0 * aw + scale1 * bw;
        return out;
      }
      function random(out) {
        var u1 = glMatrix.RANDOM();
        var u2 = glMatrix.RANDOM();
        var u3 = glMatrix.RANDOM();
        var sqrt1MinusU1 = Math.sqrt(1 - u1);
        var sqrtU1 = Math.sqrt(u1);
        out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
        out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
        out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
        out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
        return out;
      }
      function invert(out, a2) {
        var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
        var dot5 = a0 * a0 + a1 * a1 + a22 * a22 + a3 * a3;
        var invDot = dot5 ? 1 / dot5 : 0;
        out[0] = -a0 * invDot;
        out[1] = -a1 * invDot;
        out[2] = -a22 * invDot;
        out[3] = a3 * invDot;
        return out;
      }
      function conjugate(out, a2) {
        out[0] = -a2[0];
        out[1] = -a2[1];
        out[2] = -a2[2];
        out[3] = a2[3];
        return out;
      }
      function fromMat3(out, m2) {
        var fTrace = m2[0] + m2[4] + m2[8];
        var fRoot;
        if (fTrace > 0) {
          fRoot = Math.sqrt(fTrace + 1);
          out[3] = 0.5 * fRoot;
          fRoot = 0.5 / fRoot;
          out[0] = (m2[5] - m2[7]) * fRoot;
          out[1] = (m2[6] - m2[2]) * fRoot;
          out[2] = (m2[1] - m2[3]) * fRoot;
        } else {
          var i = 0;
          if (m2[4] > m2[0]) i = 1;
          if (m2[8] > m2[i * 3 + i]) i = 2;
          var j = (i + 1) % 3;
          var k = (i + 2) % 3;
          fRoot = Math.sqrt(m2[i * 3 + i] - m2[j * 3 + j] - m2[k * 3 + k] + 1);
          out[i] = 0.5 * fRoot;
          fRoot = 0.5 / fRoot;
          out[3] = (m2[j * 3 + k] - m2[k * 3 + j]) * fRoot;
          out[j] = (m2[j * 3 + i] + m2[i * 3 + j]) * fRoot;
          out[k] = (m2[k * 3 + i] + m2[i * 3 + k]) * fRoot;
        }
        return out;
      }
      function fromEuler(out, x3, y3, z) {
        var order2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : glMatrix.ANGLE_ORDER;
        var halfToRad = Math.PI / 360;
        x3 *= halfToRad;
        z *= halfToRad;
        y3 *= halfToRad;
        var sx = Math.sin(x3);
        var cx = Math.cos(x3);
        var sy = Math.sin(y3);
        var cy = Math.cos(y3);
        var sz = Math.sin(z);
        var cz = Math.cos(z);
        switch (order2) {
          case "xyz":
            out[0] = sx * cy * cz + cx * sy * sz;
            out[1] = cx * sy * cz - sx * cy * sz;
            out[2] = cx * cy * sz + sx * sy * cz;
            out[3] = cx * cy * cz - sx * sy * sz;
            break;
          case "xzy":
            out[0] = sx * cy * cz - cx * sy * sz;
            out[1] = cx * sy * cz - sx * cy * sz;
            out[2] = cx * cy * sz + sx * sy * cz;
            out[3] = cx * cy * cz + sx * sy * sz;
            break;
          case "yxz":
            out[0] = sx * cy * cz + cx * sy * sz;
            out[1] = cx * sy * cz - sx * cy * sz;
            out[2] = cx * cy * sz - sx * sy * cz;
            out[3] = cx * cy * cz + sx * sy * sz;
            break;
          case "yzx":
            out[0] = sx * cy * cz + cx * sy * sz;
            out[1] = cx * sy * cz + sx * cy * sz;
            out[2] = cx * cy * sz - sx * sy * cz;
            out[3] = cx * cy * cz - sx * sy * sz;
            break;
          case "zxy":
            out[0] = sx * cy * cz - cx * sy * sz;
            out[1] = cx * sy * cz + sx * cy * sz;
            out[2] = cx * cy * sz + sx * sy * cz;
            out[3] = cx * cy * cz - sx * sy * sz;
            break;
          case "zyx":
            out[0] = sx * cy * cz - cx * sy * sz;
            out[1] = cx * sy * cz + sx * cy * sz;
            out[2] = cx * cy * sz - sx * sy * cz;
            out[3] = cx * cy * cz + sx * sy * sz;
            break;
          default:
            throw new Error("Unknown angle order " + order2);
        }
        return out;
      }
      function str(a2) {
        return "quat(" + a2[0] + ", " + a2[1] + ", " + a2[2] + ", " + a2[3] + ")";
      }
      var clone8 = exports.clone = vec42.clone;
      var fromValues = exports.fromValues = vec42.fromValues;
      var copy = exports.copy = vec42.copy;
      var set6 = exports.set = vec42.set;
      var add5 = exports.add = vec42.add;
      var mul = exports.mul = multiply2;
      var scale4 = exports.scale = vec42.scale;
      var dot4 = exports.dot = vec42.dot;
      var lerp = exports.lerp = vec42.lerp;
      var length = exports.length = vec42.length;
      var len = exports.len = length;
      var squaredLength = exports.squaredLength = vec42.squaredLength;
      var sqrLen = exports.sqrLen = squaredLength;
      var normalize5 = exports.normalize = vec42.normalize;
      var exactEquals = exports.exactEquals = vec42.exactEquals;
      function equals(a2, b) {
        return Math.abs(vec42.dot(a2, b)) >= 1 - glMatrix.EPSILON;
      }
      var rotationTo = exports.rotationTo = (function() {
        var tmpvec3 = vec35.create();
        var xUnitVec3 = vec35.fromValues(1, 0, 0);
        var yUnitVec3 = vec35.fromValues(0, 1, 0);
        return function(out, a2, b) {
          var dot5 = vec35.dot(a2, b);
          if (dot5 < -0.999999) {
            vec35.cross(tmpvec3, xUnitVec3, a2);
            if (vec35.len(tmpvec3) < 1e-6) vec35.cross(tmpvec3, yUnitVec3, a2);
            vec35.normalize(tmpvec3, tmpvec3);
            setAxisAngle(out, tmpvec3, Math.PI);
            return out;
          } else if (dot5 > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
          } else {
            vec35.cross(tmpvec3, a2, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot5;
            return normalize5(out, out);
          }
        };
      })();
      var sqlerp = exports.sqlerp = (function() {
        var temp1 = create2();
        var temp2 = create2();
        return function(out, a2, b, c2, d2, t) {
          slerp(temp1, a2, d2, t);
          slerp(temp2, b, c2, t);
          slerp(out, temp1, temp2, 2 * t * (1 - t));
          return out;
        };
      })();
      var setAxes = exports.setAxes = (function() {
        var matr = mat32.create();
        return function(out, view, right, up) {
          matr[0] = right[0];
          matr[3] = right[1];
          matr[6] = right[2];
          matr[1] = up[0];
          matr[4] = up[1];
          matr[7] = up[2];
          matr[2] = -view[0];
          matr[5] = -view[1];
          matr[8] = -view[2];
          return normalize5(out, fromMat3(out, matr));
        };
      })();
    }
  });

  // node_modules/gl-matrix/cjs/quat2.js
  var require_quat2 = __commonJS({
    "node_modules/gl-matrix/cjs/quat2.js"(exports) {
      "use strict";
      function _typeof2(o) {
        "@babel/helpers - typeof";
        return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof2(o);
      }
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.add = add5;
      exports.clone = clone8;
      exports.conjugate = conjugate;
      exports.copy = copy;
      exports.create = create2;
      exports.dot = void 0;
      exports.equals = equals;
      exports.exactEquals = exactEquals;
      exports.fromMat4 = fromMat4;
      exports.fromRotation = fromRotation;
      exports.fromRotationTranslation = fromRotationTranslation;
      exports.fromRotationTranslationValues = fromRotationTranslationValues;
      exports.fromTranslation = fromTranslation;
      exports.fromValues = fromValues;
      exports.getDual = getDual;
      exports.getReal = void 0;
      exports.getTranslation = getTranslation;
      exports.identity = identity3;
      exports.invert = invert;
      exports.length = exports.len = void 0;
      exports.lerp = lerp;
      exports.mul = void 0;
      exports.multiply = multiply2;
      exports.normalize = normalize5;
      exports.rotateAroundAxis = rotateAroundAxis;
      exports.rotateByQuatAppend = rotateByQuatAppend;
      exports.rotateByQuatPrepend = rotateByQuatPrepend;
      exports.rotateX = rotateX2;
      exports.rotateY = rotateY2;
      exports.rotateZ = rotateZ2;
      exports.scale = scale4;
      exports.set = set6;
      exports.setDual = setDual;
      exports.squaredLength = exports.sqrLen = exports.setReal = void 0;
      exports.str = str;
      exports.translate = translate3;
      var glMatrix = _interopRequireWildcard(require_common());
      var quat3 = _interopRequireWildcard(require_quat());
      var mat46 = _interopRequireWildcard(require_mat4());
      function _interopRequireWildcard(e, t) {
        if ("function" == typeof WeakMap) var r = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
        return (_interopRequireWildcard = function _interopRequireWildcard2(e3, t2) {
          if (!t2 && e3 && e3.__esModule) return e3;
          var o, i, f = { __proto__: null, "default": e3 };
          if (null === e3 || "object" != _typeof2(e3) && "function" != typeof e3) return f;
          if (o = t2 ? n : r) {
            if (o.has(e3)) return o.get(e3);
            o.set(e3, f);
          }
          for (var _t in e3) "default" !== _t && {}.hasOwnProperty.call(e3, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e3, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e3[_t]);
          return f;
        })(e, t);
      }
      function create2() {
        var dq = new glMatrix.ARRAY_TYPE(8);
        if (glMatrix.ARRAY_TYPE != Float32Array) {
          dq[0] = 0;
          dq[1] = 0;
          dq[2] = 0;
          dq[4] = 0;
          dq[5] = 0;
          dq[6] = 0;
          dq[7] = 0;
        }
        dq[3] = 1;
        return dq;
      }
      function clone8(a2) {
        var dq = new glMatrix.ARRAY_TYPE(8);
        dq[0] = a2[0];
        dq[1] = a2[1];
        dq[2] = a2[2];
        dq[3] = a2[3];
        dq[4] = a2[4];
        dq[5] = a2[5];
        dq[6] = a2[6];
        dq[7] = a2[7];
        return dq;
      }
      function fromValues(x1, y1, z1, w1, x22, y22, z2, w2) {
        var dq = new glMatrix.ARRAY_TYPE(8);
        dq[0] = x1;
        dq[1] = y1;
        dq[2] = z1;
        dq[3] = w1;
        dq[4] = x22;
        dq[5] = y22;
        dq[6] = z2;
        dq[7] = w2;
        return dq;
      }
      function fromRotationTranslationValues(x1, y1, z1, w1, x22, y22, z2) {
        var dq = new glMatrix.ARRAY_TYPE(8);
        dq[0] = x1;
        dq[1] = y1;
        dq[2] = z1;
        dq[3] = w1;
        var ax = x22 * 0.5, ay = y22 * 0.5, az = z2 * 0.5;
        dq[4] = ax * w1 + ay * z1 - az * y1;
        dq[5] = ay * w1 + az * x1 - ax * z1;
        dq[6] = az * w1 + ax * y1 - ay * x1;
        dq[7] = -ax * x1 - ay * y1 - az * z1;
        return dq;
      }
      function fromRotationTranslation(out, q, t) {
        var ax = t[0] * 0.5, ay = t[1] * 0.5, az = t[2] * 0.5, bx = q[0], by = q[1], bz = q[2], bw = q[3];
        out[0] = bx;
        out[1] = by;
        out[2] = bz;
        out[3] = bw;
        out[4] = ax * bw + ay * bz - az * by;
        out[5] = ay * bw + az * bx - ax * bz;
        out[6] = az * bw + ax * by - ay * bx;
        out[7] = -ax * bx - ay * by - az * bz;
        return out;
      }
      function fromTranslation(out, t) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        out[4] = t[0] * 0.5;
        out[5] = t[1] * 0.5;
        out[6] = t[2] * 0.5;
        out[7] = 0;
        return out;
      }
      function fromRotation(out, q) {
        out[0] = q[0];
        out[1] = q[1];
        out[2] = q[2];
        out[3] = q[3];
        out[4] = 0;
        out[5] = 0;
        out[6] = 0;
        out[7] = 0;
        return out;
      }
      function fromMat4(out, a2) {
        var outer = quat3.create();
        mat46.getRotation(outer, a2);
        var t = new glMatrix.ARRAY_TYPE(3);
        mat46.getTranslation(t, a2);
        fromRotationTranslation(out, outer, t);
        return out;
      }
      function copy(out, a2) {
        out[0] = a2[0];
        out[1] = a2[1];
        out[2] = a2[2];
        out[3] = a2[3];
        out[4] = a2[4];
        out[5] = a2[5];
        out[6] = a2[6];
        out[7] = a2[7];
        return out;
      }
      function identity3(out) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        out[4] = 0;
        out[5] = 0;
        out[6] = 0;
        out[7] = 0;
        return out;
      }
      function set6(out, x1, y1, z1, w1, x22, y22, z2, w2) {
        out[0] = x1;
        out[1] = y1;
        out[2] = z1;
        out[3] = w1;
        out[4] = x22;
        out[5] = y22;
        out[6] = z2;
        out[7] = w2;
        return out;
      }
      var getReal = exports.getReal = quat3.copy;
      function getDual(out, a2) {
        out[0] = a2[4];
        out[1] = a2[5];
        out[2] = a2[6];
        out[3] = a2[7];
        return out;
      }
      var setReal = exports.setReal = quat3.copy;
      function setDual(out, q) {
        out[4] = q[0];
        out[5] = q[1];
        out[6] = q[2];
        out[7] = q[3];
        return out;
      }
      function getTranslation(out, a2) {
        var ax = a2[4], ay = a2[5], az = a2[6], aw = a2[7], bx = -a2[0], by = -a2[1], bz = -a2[2], bw = a2[3];
        out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
        out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
        out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
        return out;
      }
      function translate3(out, a2, v) {
        var ax1 = a2[0], ay1 = a2[1], az1 = a2[2], aw1 = a2[3], bx1 = v[0] * 0.5, by1 = v[1] * 0.5, bz1 = v[2] * 0.5, ax2 = a2[4], ay2 = a2[5], az2 = a2[6], aw2 = a2[7];
        out[0] = ax1;
        out[1] = ay1;
        out[2] = az1;
        out[3] = aw1;
        out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
        out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
        out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
        out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
        return out;
      }
      function rotateX2(out, a2, rad2) {
        var bx = -a2[0], by = -a2[1], bz = -a2[2], bw = a2[3], ax = a2[4], ay = a2[5], az = a2[6], aw = a2[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
        quat3.rotateX(out, a2, rad2);
        bx = out[0];
        by = out[1];
        bz = out[2];
        bw = out[3];
        out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
        out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
        out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
        out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
        return out;
      }
      function rotateY2(out, a2, rad2) {
        var bx = -a2[0], by = -a2[1], bz = -a2[2], bw = a2[3], ax = a2[4], ay = a2[5], az = a2[6], aw = a2[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
        quat3.rotateY(out, a2, rad2);
        bx = out[0];
        by = out[1];
        bz = out[2];
        bw = out[3];
        out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
        out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
        out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
        out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
        return out;
      }
      function rotateZ2(out, a2, rad2) {
        var bx = -a2[0], by = -a2[1], bz = -a2[2], bw = a2[3], ax = a2[4], ay = a2[5], az = a2[6], aw = a2[7], ax1 = ax * bw + aw * bx + ay * bz - az * by, ay1 = ay * bw + aw * by + az * bx - ax * bz, az1 = az * bw + aw * bz + ax * by - ay * bx, aw1 = aw * bw - ax * bx - ay * by - az * bz;
        quat3.rotateZ(out, a2, rad2);
        bx = out[0];
        by = out[1];
        bz = out[2];
        bw = out[3];
        out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
        out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
        out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
        out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
        return out;
      }
      function rotateByQuatAppend(out, a2, q) {
        var qx = q[0], qy = q[1], qz = q[2], qw = q[3], ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
        out[0] = ax * qw + aw * qx + ay * qz - az * qy;
        out[1] = ay * qw + aw * qy + az * qx - ax * qz;
        out[2] = az * qw + aw * qz + ax * qy - ay * qx;
        out[3] = aw * qw - ax * qx - ay * qy - az * qz;
        ax = a2[4];
        ay = a2[5];
        az = a2[6];
        aw = a2[7];
        out[4] = ax * qw + aw * qx + ay * qz - az * qy;
        out[5] = ay * qw + aw * qy + az * qx - ax * qz;
        out[6] = az * qw + aw * qz + ax * qy - ay * qx;
        out[7] = aw * qw - ax * qx - ay * qy - az * qz;
        return out;
      }
      function rotateByQuatPrepend(out, q, a2) {
        var qx = q[0], qy = q[1], qz = q[2], qw = q[3], bx = a2[0], by = a2[1], bz = a2[2], bw = a2[3];
        out[0] = qx * bw + qw * bx + qy * bz - qz * by;
        out[1] = qy * bw + qw * by + qz * bx - qx * bz;
        out[2] = qz * bw + qw * bz + qx * by - qy * bx;
        out[3] = qw * bw - qx * bx - qy * by - qz * bz;
        bx = a2[4];
        by = a2[5];
        bz = a2[6];
        bw = a2[7];
        out[4] = qx * bw + qw * bx + qy * bz - qz * by;
        out[5] = qy * bw + qw * by + qz * bx - qx * bz;
        out[6] = qz * bw + qw * bz + qx * by - qy * bx;
        out[7] = qw * bw - qx * bx - qy * by - qz * bz;
        return out;
      }
      function rotateAroundAxis(out, a2, axis, rad2) {
        if (Math.abs(rad2) < glMatrix.EPSILON) {
          return copy(out, a2);
        }
        var axisLength = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);
        rad2 = rad2 * 0.5;
        var s = Math.sin(rad2);
        var bx = s * axis[0] / axisLength;
        var by = s * axis[1] / axisLength;
        var bz = s * axis[2] / axisLength;
        var bw = Math.cos(rad2);
        var ax1 = a2[0], ay1 = a2[1], az1 = a2[2], aw1 = a2[3];
        out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
        out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
        out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
        out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
        var ax = a2[4], ay = a2[5], az = a2[6], aw = a2[7];
        out[4] = ax * bw + aw * bx + ay * bz - az * by;
        out[5] = ay * bw + aw * by + az * bx - ax * bz;
        out[6] = az * bw + aw * bz + ax * by - ay * bx;
        out[7] = aw * bw - ax * bx - ay * by - az * bz;
        return out;
      }
      function add5(out, a2, b) {
        out[0] = a2[0] + b[0];
        out[1] = a2[1] + b[1];
        out[2] = a2[2] + b[2];
        out[3] = a2[3] + b[3];
        out[4] = a2[4] + b[4];
        out[5] = a2[5] + b[5];
        out[6] = a2[6] + b[6];
        out[7] = a2[7] + b[7];
        return out;
      }
      function multiply2(out, a2, b) {
        var ax0 = a2[0], ay0 = a2[1], az0 = a2[2], aw0 = a2[3], bx1 = b[4], by1 = b[5], bz1 = b[6], bw1 = b[7], ax1 = a2[4], ay1 = a2[5], az1 = a2[6], aw1 = a2[7], bx0 = b[0], by0 = b[1], bz0 = b[2], bw0 = b[3];
        out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
        out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
        out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
        out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
        out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
        out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
        out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
        out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
        return out;
      }
      var mul = exports.mul = multiply2;
      function scale4(out, a2, b) {
        out[0] = a2[0] * b;
        out[1] = a2[1] * b;
        out[2] = a2[2] * b;
        out[3] = a2[3] * b;
        out[4] = a2[4] * b;
        out[5] = a2[5] * b;
        out[6] = a2[6] * b;
        out[7] = a2[7] * b;
        return out;
      }
      var dot4 = exports.dot = quat3.dot;
      function lerp(out, a2, b, t) {
        var mt = 1 - t;
        if (dot4(a2, b) < 0) t = -t;
        out[0] = a2[0] * mt + b[0] * t;
        out[1] = a2[1] * mt + b[1] * t;
        out[2] = a2[2] * mt + b[2] * t;
        out[3] = a2[3] * mt + b[3] * t;
        out[4] = a2[4] * mt + b[4] * t;
        out[5] = a2[5] * mt + b[5] * t;
        out[6] = a2[6] * mt + b[6] * t;
        out[7] = a2[7] * mt + b[7] * t;
        return out;
      }
      function invert(out, a2) {
        var sqlen = squaredLength(a2);
        out[0] = -a2[0] / sqlen;
        out[1] = -a2[1] / sqlen;
        out[2] = -a2[2] / sqlen;
        out[3] = a2[3] / sqlen;
        out[4] = -a2[4] / sqlen;
        out[5] = -a2[5] / sqlen;
        out[6] = -a2[6] / sqlen;
        out[7] = a2[7] / sqlen;
        return out;
      }
      function conjugate(out, a2) {
        out[0] = -a2[0];
        out[1] = -a2[1];
        out[2] = -a2[2];
        out[3] = a2[3];
        out[4] = -a2[4];
        out[5] = -a2[5];
        out[6] = -a2[6];
        out[7] = a2[7];
        return out;
      }
      var length = exports.length = quat3.length;
      var len = exports.len = length;
      var squaredLength = exports.squaredLength = quat3.squaredLength;
      var sqrLen = exports.sqrLen = squaredLength;
      function normalize5(out, a2) {
        var magnitude = squaredLength(a2);
        if (magnitude > 0) {
          magnitude = Math.sqrt(magnitude);
          var a0 = a2[0] / magnitude;
          var a1 = a2[1] / magnitude;
          var a22 = a2[2] / magnitude;
          var a3 = a2[3] / magnitude;
          var b0 = a2[4];
          var b1 = a2[5];
          var b2 = a2[6];
          var b3 = a2[7];
          var a_dot_b = a0 * b0 + a1 * b1 + a22 * b2 + a3 * b3;
          out[0] = a0;
          out[1] = a1;
          out[2] = a22;
          out[3] = a3;
          out[4] = (b0 - a0 * a_dot_b) / magnitude;
          out[5] = (b1 - a1 * a_dot_b) / magnitude;
          out[6] = (b2 - a22 * a_dot_b) / magnitude;
          out[7] = (b3 - a3 * a_dot_b) / magnitude;
        }
        return out;
      }
      function str(a2) {
        return "quat2(" + a2[0] + ", " + a2[1] + ", " + a2[2] + ", " + a2[3] + ", " + a2[4] + ", " + a2[5] + ", " + a2[6] + ", " + a2[7] + ")";
      }
      function exactEquals(a2, b) {
        return a2[0] === b[0] && a2[1] === b[1] && a2[2] === b[2] && a2[3] === b[3] && a2[4] === b[4] && a2[5] === b[5] && a2[6] === b[6] && a2[7] === b[7];
      }
      function equals(a2, b) {
        var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3], a4 = a2[4], a5 = a2[5], a6 = a2[6], a7 = a2[7];
        var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
        return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= glMatrix.EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7));
      }
    }
  });

  // node_modules/gl-matrix/cjs/vec2.js
  var require_vec2 = __commonJS({
    "node_modules/gl-matrix/cjs/vec2.js"(exports) {
      "use strict";
      function _typeof2(o) {
        "@babel/helpers - typeof";
        return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof2(o);
      }
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.add = add5;
      exports.angle = angle2;
      exports.ceil = ceil;
      exports.clone = clone8;
      exports.copy = copy;
      exports.create = create2;
      exports.cross = cross3;
      exports.dist = void 0;
      exports.distance = distance6;
      exports.div = void 0;
      exports.divide = divide2;
      exports.dot = dot4;
      exports.equals = equals;
      exports.exactEquals = exactEquals;
      exports.floor = floor;
      exports.forEach = void 0;
      exports.fromValues = fromValues;
      exports.inverse = inverse2;
      exports.len = void 0;
      exports.length = length;
      exports.lerp = lerp;
      exports.max = max4;
      exports.min = min4;
      exports.mul = void 0;
      exports.multiply = multiply2;
      exports.negate = negate;
      exports.normalize = normalize5;
      exports.random = random;
      exports.rotate = rotate3;
      exports.round = round3;
      exports.scale = scale4;
      exports.scaleAndAdd = scaleAndAdd;
      exports.set = set6;
      exports.signedAngle = signedAngle;
      exports.sqrLen = exports.sqrDist = void 0;
      exports.squaredDistance = squaredDistance;
      exports.squaredLength = squaredLength;
      exports.str = str;
      exports.sub = void 0;
      exports.subtract = subtract2;
      exports.transformMat2 = transformMat2;
      exports.transformMat2d = transformMat2d;
      exports.transformMat3 = transformMat3;
      exports.transformMat4 = transformMat4;
      exports.zero = zero;
      var glMatrix = _interopRequireWildcard(require_common());
      function _interopRequireWildcard(e, t) {
        if ("function" == typeof WeakMap) var r = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
        return (_interopRequireWildcard = function _interopRequireWildcard2(e3, t2) {
          if (!t2 && e3 && e3.__esModule) return e3;
          var o, i, f = { __proto__: null, "default": e3 };
          if (null === e3 || "object" != _typeof2(e3) && "function" != typeof e3) return f;
          if (o = t2 ? n : r) {
            if (o.has(e3)) return o.get(e3);
            o.set(e3, f);
          }
          for (var _t in e3) "default" !== _t && {}.hasOwnProperty.call(e3, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e3, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e3[_t]);
          return f;
        })(e, t);
      }
      function create2() {
        var out = new glMatrix.ARRAY_TYPE(2);
        if (glMatrix.ARRAY_TYPE != Float32Array) {
          out[0] = 0;
          out[1] = 0;
        }
        return out;
      }
      function clone8(a2) {
        var out = new glMatrix.ARRAY_TYPE(2);
        out[0] = a2[0];
        out[1] = a2[1];
        return out;
      }
      function fromValues(x3, y3) {
        var out = new glMatrix.ARRAY_TYPE(2);
        out[0] = x3;
        out[1] = y3;
        return out;
      }
      function copy(out, a2) {
        out[0] = a2[0];
        out[1] = a2[1];
        return out;
      }
      function set6(out, x3, y3) {
        out[0] = x3;
        out[1] = y3;
        return out;
      }
      function add5(out, a2, b) {
        out[0] = a2[0] + b[0];
        out[1] = a2[1] + b[1];
        return out;
      }
      function subtract2(out, a2, b) {
        out[0] = a2[0] - b[0];
        out[1] = a2[1] - b[1];
        return out;
      }
      function multiply2(out, a2, b) {
        out[0] = a2[0] * b[0];
        out[1] = a2[1] * b[1];
        return out;
      }
      function divide2(out, a2, b) {
        out[0] = a2[0] / b[0];
        out[1] = a2[1] / b[1];
        return out;
      }
      function ceil(out, a2) {
        out[0] = Math.ceil(a2[0]);
        out[1] = Math.ceil(a2[1]);
        return out;
      }
      function floor(out, a2) {
        out[0] = Math.floor(a2[0]);
        out[1] = Math.floor(a2[1]);
        return out;
      }
      function min4(out, a2, b) {
        out[0] = Math.min(a2[0], b[0]);
        out[1] = Math.min(a2[1], b[1]);
        return out;
      }
      function max4(out, a2, b) {
        out[0] = Math.max(a2[0], b[0]);
        out[1] = Math.max(a2[1], b[1]);
        return out;
      }
      function round3(out, a2) {
        out[0] = glMatrix.round(a2[0]);
        out[1] = glMatrix.round(a2[1]);
        return out;
      }
      function scale4(out, a2, b) {
        out[0] = a2[0] * b;
        out[1] = a2[1] * b;
        return out;
      }
      function scaleAndAdd(out, a2, b, scale5) {
        out[0] = a2[0] + b[0] * scale5;
        out[1] = a2[1] + b[1] * scale5;
        return out;
      }
      function distance6(a2, b) {
        var x3 = b[0] - a2[0], y3 = b[1] - a2[1];
        return Math.sqrt(x3 * x3 + y3 * y3);
      }
      function squaredDistance(a2, b) {
        var x3 = b[0] - a2[0], y3 = b[1] - a2[1];
        return x3 * x3 + y3 * y3;
      }
      function length(a2) {
        var x3 = a2[0], y3 = a2[1];
        return Math.sqrt(x3 * x3 + y3 * y3);
      }
      function squaredLength(a2) {
        var x3 = a2[0], y3 = a2[1];
        return x3 * x3 + y3 * y3;
      }
      function negate(out, a2) {
        out[0] = -a2[0];
        out[1] = -a2[1];
        return out;
      }
      function inverse2(out, a2) {
        out[0] = 1 / a2[0];
        out[1] = 1 / a2[1];
        return out;
      }
      function normalize5(out, a2) {
        var x3 = a2[0], y3 = a2[1];
        var len2 = x3 * x3 + y3 * y3;
        if (len2 > 0) {
          len2 = 1 / Math.sqrt(len2);
        }
        out[0] = a2[0] * len2;
        out[1] = a2[1] * len2;
        return out;
      }
      function dot4(a2, b) {
        return a2[0] * b[0] + a2[1] * b[1];
      }
      function cross3(out, a2, b) {
        var z = a2[0] * b[1] - a2[1] * b[0];
        out[0] = out[1] = 0;
        out[2] = z;
        return out;
      }
      function lerp(out, a2, b, t) {
        var ax = a2[0], ay = a2[1];
        out[0] = ax + t * (b[0] - ax);
        out[1] = ay + t * (b[1] - ay);
        return out;
      }
      function random(out, scale5) {
        scale5 = scale5 === void 0 ? 1 : scale5;
        var r = glMatrix.RANDOM() * 2 * Math.PI;
        out[0] = Math.cos(r) * scale5;
        out[1] = Math.sin(r) * scale5;
        return out;
      }
      function transformMat2(out, a2, m2) {
        var x3 = a2[0], y3 = a2[1];
        out[0] = m2[0] * x3 + m2[2] * y3;
        out[1] = m2[1] * x3 + m2[3] * y3;
        return out;
      }
      function transformMat2d(out, a2, m2) {
        var x3 = a2[0], y3 = a2[1];
        out[0] = m2[0] * x3 + m2[2] * y3 + m2[4];
        out[1] = m2[1] * x3 + m2[3] * y3 + m2[5];
        return out;
      }
      function transformMat3(out, a2, m2) {
        var x3 = a2[0], y3 = a2[1];
        out[0] = m2[0] * x3 + m2[3] * y3 + m2[6];
        out[1] = m2[1] * x3 + m2[4] * y3 + m2[7];
        return out;
      }
      function transformMat4(out, a2, m2) {
        var x3 = a2[0];
        var y3 = a2[1];
        out[0] = m2[0] * x3 + m2[4] * y3 + m2[12];
        out[1] = m2[1] * x3 + m2[5] * y3 + m2[13];
        return out;
      }
      function rotate3(out, a2, b, rad2) {
        var p0 = a2[0] - b[0], p1 = a2[1] - b[1], sinC = Math.sin(rad2), cosC = Math.cos(rad2);
        out[0] = p0 * cosC - p1 * sinC + b[0];
        out[1] = p0 * sinC + p1 * cosC + b[1];
        return out;
      }
      function angle2(a2, b) {
        var ax = a2[0], ay = a2[1], bx = b[0], by = b[1];
        return Math.abs(Math.atan2(ay * bx - ax * by, ax * bx + ay * by));
      }
      function signedAngle(a2, b) {
        var ax = a2[0], ay = a2[1], bx = b[0], by = b[1];
        return Math.atan2(ax * by - ay * bx, ax * bx + ay * by);
      }
      function zero(out) {
        out[0] = 0;
        out[1] = 0;
        return out;
      }
      function str(a2) {
        return "vec2(" + a2[0] + ", " + a2[1] + ")";
      }
      function exactEquals(a2, b) {
        return a2[0] === b[0] && a2[1] === b[1];
      }
      function equals(a2, b) {
        var a0 = a2[0], a1 = a2[1];
        var b0 = b[0], b1 = b[1];
        return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
      }
      var len = exports.len = length;
      var sub2 = exports.sub = subtract2;
      var mul = exports.mul = multiply2;
      var div = exports.div = divide2;
      var dist = exports.dist = distance6;
      var sqrDist = exports.sqrDist = squaredDistance;
      var sqrLen = exports.sqrLen = squaredLength;
      var forEach = exports.forEach = (function() {
        var vec = create2();
        return function(a2, stride, offset, count, fn, arg) {
          var i, l;
          if (!stride) {
            stride = 2;
          }
          if (!offset) {
            offset = 0;
          }
          if (count) {
            l = Math.min(count * stride + offset, a2.length);
          } else {
            l = a2.length;
          }
          for (i = offset; i < l; i += stride) {
            vec[0] = a2[i];
            vec[1] = a2[i + 1];
            fn(vec, vec, arg);
            a2[i] = vec[0];
            a2[i + 1] = vec[1];
          }
          return a2;
        };
      })();
    }
  });

  // node_modules/gl-matrix/cjs/index.js
  var require_cjs = __commonJS({
    "node_modules/gl-matrix/cjs/index.js"(exports) {
      "use strict";
      function _typeof2(o) {
        "@babel/helpers - typeof";
        return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof2(o);
      }
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.vec4 = exports.vec3 = exports.vec2 = exports.quat2 = exports.quat = exports.mat4 = exports.mat3 = exports.mat2d = exports.mat2 = exports.glMatrix = void 0;
      var glMatrix = _interopRequireWildcard(require_common());
      exports.glMatrix = glMatrix;
      var mat2 = _interopRequireWildcard(require_mat2());
      exports.mat2 = mat2;
      var mat2d = _interopRequireWildcard(require_mat2d());
      exports.mat2d = mat2d;
      var mat32 = _interopRequireWildcard(require_mat3());
      exports.mat3 = mat32;
      var mat46 = _interopRequireWildcard(require_mat4());
      exports.mat4 = mat46;
      var quat3 = _interopRequireWildcard(require_quat());
      exports.quat = quat3;
      var quat22 = _interopRequireWildcard(require_quat2());
      exports.quat2 = quat22;
      var vec23 = _interopRequireWildcard(require_vec2());
      exports.vec2 = vec23;
      var vec35 = _interopRequireWildcard(require_vec3());
      exports.vec3 = vec35;
      var vec42 = _interopRequireWildcard(require_vec4());
      exports.vec4 = vec42;
      function _interopRequireWildcard(e, t) {
        if ("function" == typeof WeakMap) var r = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
        return (_interopRequireWildcard = function _interopRequireWildcard2(e3, t2) {
          if (!t2 && e3 && e3.__esModule) return e3;
          var o, i, f = { __proto__: null, "default": e3 };
          if (null === e3 || "object" != _typeof2(e3) && "function" != typeof e3) return f;
          if (o = t2 ? n : r) {
            if (o.has(e3)) return o.get(e3);
            o.set(e3, f);
          }
          for (var _t in e3) "default" !== _t && {}.hasOwnProperty.call(e3, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e3, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e3[_t]);
          return f;
        })(e, t);
      }
    }
  });

  // node_modules/tslib/tslib.es6.mjs
  var tslib_es6_exports = {};
  __export(tslib_es6_exports, {
    __addDisposableResource: () => __addDisposableResource,
    __assign: () => __assign,
    __asyncDelegator: () => __asyncDelegator,
    __asyncGenerator: () => __asyncGenerator,
    __asyncValues: () => __asyncValues,
    __await: () => __await,
    __awaiter: () => __awaiter,
    __classPrivateFieldGet: () => __classPrivateFieldGet,
    __classPrivateFieldIn: () => __classPrivateFieldIn,
    __classPrivateFieldSet: () => __classPrivateFieldSet,
    __createBinding: () => __createBinding,
    __decorate: () => __decorate,
    __disposeResources: () => __disposeResources,
    __esDecorate: () => __esDecorate,
    __exportStar: () => __exportStar,
    __extends: () => __extends,
    __generator: () => __generator,
    __importDefault: () => __importDefault,
    __importStar: () => __importStar,
    __makeTemplateObject: () => __makeTemplateObject,
    __metadata: () => __metadata,
    __param: () => __param,
    __propKey: () => __propKey,
    __read: () => __read,
    __rest: () => __rest,
    __rewriteRelativeImportExtension: () => __rewriteRelativeImportExtension,
    __runInitializers: () => __runInitializers,
    __setFunctionName: () => __setFunctionName,
    __spread: () => __spread,
    __spreadArray: () => __spreadArray,
    __spreadArrays: () => __spreadArrays,
    __values: () => __values,
    default: () => tslib_es6_default
  });
  function __extends(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  }
  function __decorate(decorators, target, key, desc) {
    var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d2 = decorators[i]) r = (c2 < 3 ? d2(r) : c2 > 3 ? d2(target, key, r) : d2(target, key)) || r;
    return c2 > 3 && r && Object.defineProperty(target, key, r), r;
  }
  function __param(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  }
  function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
      if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
      return f;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _2, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function(f) {
        if (done) throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f || null));
      };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
        if (result === void 0) continue;
        if (result === null || typeof result !== "object") throw new TypeError("Object expected");
        if (_2 = accept(result.get)) descriptor.get = _2;
        if (_2 = accept(result.set)) descriptor.set = _2;
        if (_2 = accept(result.init)) initializers.unshift(_2);
      } else if (_2 = accept(result)) {
        if (kind === "field") initializers.unshift(_2);
        else descriptor[key] = _2;
      }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  }
  function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
  }
  function __propKey(x3) {
    return typeof x3 === "symbol" ? x3 : "".concat(x3);
  }
  function __setFunctionName(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
  }
  function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y3, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step2([n, v]);
      };
    }
    function step2(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2) try {
        if (f = 1, y3 && (t = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t = y3["return"]) && t.call(y3), 0) : y3.next) && !(t = t.call(y3, op[1])).done) return t;
        if (y3 = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t[1]) {
              _2.label = t[1];
              t = op;
              break;
            }
            if (t && _2.label < t[2]) {
              _2.label = t[2];
              _2.ops.push(op);
              break;
            }
            if (t[2]) _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e) {
        op = [6, e];
        y3 = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __exportStar(m2, o) {
    for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m2, p);
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
    if (m2) return m2.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m2 = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m2) return o;
    var i = m2.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m2 = i["return"])) m2.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  }
  function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
    return ar;
  }
  function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a2 = arguments[i], j = 0, jl = a2.length; j < jl; j++, k++)
        r[k] = a2[j];
    return r;
  }
  function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  }
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function awaitReturn(f) {
      return function(v) {
        return Promise.resolve(v).then(f, reject);
      };
    }
    function verb(n, f) {
      if (g[n]) {
        i[n] = function(v) {
          return new Promise(function(a2, b) {
            q.push([n, v, a2, b]) > 1 || resume(n, v);
          });
        };
        if (f) i[n] = f(i[n]);
      }
    }
    function resume(n, v) {
      try {
        step2(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step2(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
  }
  function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
      throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
      return this;
    }, i;
    function verb(n, f) {
      i[n] = o[n] ? function(v) {
        return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
      } : f;
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m2 = o[Symbol.asyncIterator], i;
    return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d2, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d2 });
      }, reject);
    }
  }
  function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
      Object.defineProperty(cooked, "raw", { value: raw });
    } else {
      cooked.raw = raw;
    }
    return cooked;
  }
  function __importStar(mod3) {
    if (mod3 && mod3.__esModule) return mod3;
    var result = {};
    if (mod3 != null) {
      for (var k = ownKeys2(mod3), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod3, k[i]);
    }
    __setModuleDefault(result, mod3);
    return result;
  }
  function __importDefault(mod3) {
    return mod3 && mod3.__esModule ? mod3 : { default: mod3 };
  }
  function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  }
  function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  }
  function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
  }
  function __addDisposableResource(env, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
      var dispose, inner;
      if (async) {
        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
        if (async) inner = dispose;
      }
      if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
      if (inner) dispose = function() {
        try {
          inner.call(this);
        } catch (e) {
          return Promise.reject(e);
        }
      };
      env.stack.push({ value, dispose, async });
    } else if (async) {
      env.stack.push({ async: true });
    }
    return value;
  }
  function __disposeResources(env) {
    function fail(e) {
      env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
          } else s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
      if (env.hasError) throw env.error;
    }
    return next();
  }
  function __rewriteRelativeImportExtension(path, preserveJsx) {
    if (typeof path === "string" && /^\.\.?\//.test(path)) {
      return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m2, tsx, d2, ext, cm) {
        return tsx ? preserveJsx ? ".jsx" : ".js" : d2 && (!ext || !cm) ? m2 : d2 + ext + "." + cm.toLowerCase() + "js";
      });
    }
    return path;
  }
  var extendStatics, __assign, __createBinding, __setModuleDefault, ownKeys2, _SuppressedError, tslib_es6_default;
  var init_tslib_es6 = __esm({
    "node_modules/tslib/tslib.es6.mjs"() {
      extendStatics = function(d2, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
          d3.__proto__ = b2;
        } || function(d3, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d3[p] = b2[p];
        };
        return extendStatics(d2, b);
      };
      __assign = function() {
        __assign = Object.assign || function __assign2(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      __createBinding = Object.create ? (function(o, m2, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m2, k);
        if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m2[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m2, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m2[k];
      });
      __setModuleDefault = Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      };
      ownKeys2 = function(o) {
        ownKeys2 = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys2(o);
      };
      _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
      };
      tslib_es6_default = {
        __extends,
        __assign,
        __rest,
        __decorate,
        __param,
        __esDecorate,
        __runInitializers,
        __propKey,
        __setFunctionName,
        __metadata,
        __awaiter,
        __generator,
        __createBinding,
        __exportStar,
        __values,
        __read,
        __spread,
        __spreadArrays,
        __spreadArray,
        __await,
        __asyncGenerator,
        __asyncDelegator,
        __asyncValues,
        __makeTemplateObject,
        __importStar,
        __importDefault,
        __classPrivateFieldGet,
        __classPrivateFieldSet,
        __classPrivateFieldIn,
        __addDisposableResource,
        __disposeResources,
        __rewriteRelativeImportExtension
      };
    }
  });

  // node_modules/@antv/util/lib/color/rgb2arr.js
  var require_rgb2arr = __commonJS({
    "node_modules/@antv/util/lib/color/rgb2arr.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.rgb2arr = rgb2arr;
      function rgb2arr(str) {
        return [parseInt(str.substr(1, 2), 16), parseInt(str.substr(3, 2), 16), parseInt(str.substr(5, 2), 16)];
      }
    }
  });

  // node_modules/@antv/util/lib/color/arr2rgb.js
  var require_arr2rgb = __commonJS({
    "node_modules/@antv/util/lib/color/arr2rgb.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toHex = toHex;
      exports.arr2rgb = arr2rgb;
      function toHex(value) {
        var x16Value = Math.round(value).toString(16);
        return x16Value.length === 1 ? "0".concat(x16Value) : x16Value;
      }
      function arr2rgb(arr) {
        return "#".concat(toHex(arr[0])).concat(toHex(arr[1])).concat(toHex(arr[2]));
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/is-array-like.js
  var require_is_array_like = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-array-like.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var isArrayLike = function(value) {
        return value !== null && typeof value !== "function" && isFinite(value.length);
      };
      exports.default = isArrayLike;
    }
  });

  // node_modules/@antv/util/lib/lodash/contains.js
  var require_contains = __commonJS({
    "node_modules/@antv/util/lib/lodash/contains.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_like_1 = tslib_1.__importDefault(require_is_array_like());
      var contains = function(arr, value) {
        if (!(0, is_array_like_1.default)(arr)) {
          return false;
        }
        return arr.indexOf(value) > -1;
      };
      exports.default = contains;
    }
  });

  // node_modules/@antv/util/lib/lodash/filter.js
  var require_filter = __commonJS({
    "node_modules/@antv/util/lib/lodash/filter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_like_1 = tslib_1.__importDefault(require_is_array_like());
      var filter = function(arr, func) {
        if (!(0, is_array_like_1.default)(arr)) {
          return arr;
        }
        var result = [];
        for (var index2 = 0; index2 < arr.length; index2++) {
          var value = arr[index2];
          if (func(value, index2)) {
            result.push(value);
          }
        }
        return result;
      };
      exports.default = filter;
    }
  });

  // node_modules/@antv/util/lib/lodash/difference.js
  var require_difference = __commonJS({
    "node_modules/@antv/util/lib/lodash/difference.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var filter_1 = tslib_1.__importDefault(require_filter());
      var contains_1 = tslib_1.__importDefault(require_contains());
      var difference2 = function(arr, values2) {
        if (values2 === void 0) {
          values2 = [];
        }
        return (0, filter_1.default)(arr, function(value) {
          return !(0, contains_1.default)(values2, value);
        });
      };
      exports.default = difference2;
    }
  });

  // node_modules/@antv/util/lib/lodash/is-function.js
  var require_is_function = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-function.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = isFunction35;
      function isFunction35(value) {
        return typeof value === "function";
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/is-nil.js
  var require_is_nil = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-nil.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = isNil11;
      function isNil11(value) {
        return value === null || value === void 0;
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/is-array.js
  var require_is_array = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-array.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = isArray7;
      function isArray7(value) {
        return Array.isArray(value);
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/is-object.js
  var require_is_object = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-object.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = (function(value) {
        var type = typeof value;
        return value !== null && type === "object" || type === "function";
      });
    }
  });

  // node_modules/@antv/util/lib/lodash/each.js
  var require_each = __commonJS({
    "node_modules/@antv/util/lib/lodash/each.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_1 = tslib_1.__importDefault(require_is_array());
      var is_object_1 = tslib_1.__importDefault(require_is_object());
      function each2(elements, func) {
        if (!elements) {
          return;
        }
        var rst;
        if ((0, is_array_1.default)(elements)) {
          for (var i = 0, len = elements.length; i < len; i++) {
            rst = func(elements[i], i);
            if (rst === false) {
              break;
            }
          }
        } else if ((0, is_object_1.default)(elements)) {
          for (var k in elements) {
            if (elements.hasOwnProperty(k)) {
              rst = func(elements[k], k);
              if (rst === false) {
                break;
              }
            }
          }
        }
      }
      exports.default = each2;
    }
  });

  // node_modules/@antv/util/lib/lodash/keys.js
  var require_keys = __commonJS({
    "node_modules/@antv/util/lib/lodash/keys.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var each_1 = tslib_1.__importDefault(require_each());
      var is_function_1 = tslib_1.__importDefault(require_is_function());
      var keys = Object.keys ? function(obj) {
        return Object.keys(obj);
      } : function(obj) {
        var result = [];
        (0, each_1.default)(obj, function(value, key) {
          if (!((0, is_function_1.default)(obj) && key === "prototype")) {
            result.push(key);
          }
        });
        return result;
      };
      exports.default = keys;
    }
  });

  // node_modules/@antv/util/lib/lodash/is-match.js
  var require_is_match = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-match.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_nil_1 = tslib_1.__importDefault(require_is_nil());
      var keys_1 = tslib_1.__importDefault(require_keys());
      function isMatch(obj, attrs) {
        var _keys = (0, keys_1.default)(attrs);
        var length = _keys.length;
        if ((0, is_nil_1.default)(obj))
          return !length;
        for (var i = 0; i < length; i += 1) {
          var key = _keys[i];
          if (attrs[key] !== obj[key] || !(key in obj)) {
            return false;
          }
        }
        return true;
      }
      exports.default = isMatch;
    }
  });

  // node_modules/@antv/util/lib/lodash/is-object-like.js
  var require_is_object_like = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-object-like.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var isObjectLike = function(value) {
        return typeof value === "object" && value !== null;
      };
      exports.default = isObjectLike;
    }
  });

  // node_modules/@antv/util/lib/lodash/is-type.js
  var require_is_type = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-type.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var toString3 = {}.toString;
      var isType2 = function(value, type) {
        return toString3.call(value) === "[object " + type + "]";
      };
      exports.default = isType2;
    }
  });

  // node_modules/@antv/util/lib/lodash/is-plain-object.js
  var require_is_plain_object = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-plain-object.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_object_like_1 = tslib_1.__importDefault(require_is_object_like());
      var is_type_1 = tslib_1.__importDefault(require_is_type());
      var isPlainObject2 = function(value) {
        if (!(0, is_object_like_1.default)(value) || !(0, is_type_1.default)(value, "Object")) {
          return false;
        }
        if (Object.getPrototypeOf(value) === null) {
          return true;
        }
        var proto = value;
        while (Object.getPrototypeOf(proto) !== null) {
          proto = Object.getPrototypeOf(proto);
        }
        return Object.getPrototypeOf(value) === proto;
      };
      exports.default = isPlainObject2;
    }
  });

  // node_modules/@antv/util/lib/lodash/find.js
  var require_find = __commonJS({
    "node_modules/@antv/util/lib/lodash/find.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_function_1 = tslib_1.__importDefault(require_is_function());
      var is_match_1 = tslib_1.__importDefault(require_is_match());
      var is_array_1 = tslib_1.__importDefault(require_is_array());
      var is_plain_object_1 = tslib_1.__importDefault(require_is_plain_object());
      function find4(arr, predicate) {
        if (!(0, is_array_1.default)(arr))
          return null;
        var _predicate;
        if ((0, is_function_1.default)(predicate)) {
          _predicate = predicate;
        }
        if ((0, is_plain_object_1.default)(predicate)) {
          _predicate = function(a2) {
            return (0, is_match_1.default)(a2, predicate);
          };
        }
        if (_predicate) {
          for (var i = 0; i < arr.length; i += 1) {
            if (_predicate(arr[i])) {
              return arr[i];
            }
          }
        }
        return null;
      }
      exports.default = find4;
    }
  });

  // node_modules/@antv/util/lib/lodash/find-index.js
  var require_find_index = __commonJS({
    "node_modules/@antv/util/lib/lodash/find-index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function findIndex(arr, predicate, fromIndex) {
        if (fromIndex === void 0) {
          fromIndex = 0;
        }
        for (var i = fromIndex; i < arr.length; i++) {
          if (predicate(arr[i], i)) {
            return i;
          }
        }
        return -1;
      }
      exports.default = findIndex;
    }
  });

  // node_modules/@antv/util/lib/lodash/first-value.js
  var require_first_value = __commonJS({
    "node_modules/@antv/util/lib/lodash/first-value.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_nil_1 = tslib_1.__importDefault(require_is_nil());
      var is_array_1 = tslib_1.__importDefault(require_is_array());
      var firstValue = function(data2, name) {
        var rst = null;
        for (var i = 0; i < data2.length; i++) {
          var obj = data2[i];
          var value = obj[name];
          if (!(0, is_nil_1.default)(value)) {
            if ((0, is_array_1.default)(value)) {
              rst = value[0];
            } else {
              rst = value;
            }
            break;
          }
        }
        return rst;
      };
      exports.default = firstValue;
    }
  });

  // node_modules/@antv/util/lib/lodash/flatten.js
  var require_flatten = __commonJS({
    "node_modules/@antv/util/lib/lodash/flatten.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_1 = tslib_1.__importDefault(require_is_array());
      var flatten2 = function(arr) {
        if (!(0, is_array_1.default)(arr)) {
          return [];
        }
        var rst = [];
        for (var i = 0; i < arr.length; i++) {
          rst = rst.concat(arr[i]);
        }
        return rst;
      };
      exports.default = flatten2;
    }
  });

  // node_modules/@antv/util/lib/lodash/flatten-deep.js
  var require_flatten_deep = __commonJS({
    "node_modules/@antv/util/lib/lodash/flatten-deep.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_1 = tslib_1.__importDefault(require_is_array());
      var flattenDeep = function(arr, result) {
        if (result === void 0) {
          result = [];
        }
        if (!(0, is_array_1.default)(arr)) {
          result.push(arr);
        } else {
          for (var i = 0; i < arr.length; i += 1) {
            flattenDeep(arr[i], result);
          }
        }
        return result;
      };
      exports.default = flattenDeep;
    }
  });

  // node_modules/@antv/util/lib/lodash/max.js
  var require_max = __commonJS({
    "node_modules/@antv/util/lib/lodash/max.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = max4;
      function max4(arr) {
        if (!Array.isArray(arr))
          return -Infinity;
        var length = arr.length;
        if (!length)
          return -Infinity;
        var max5 = arr[0];
        for (var i = 1; i < length; i++) {
          max5 = Math.max(max5, arr[i]);
        }
        return max5;
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/min.js
  var require_min = __commonJS({
    "node_modules/@antv/util/lib/lodash/min.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_1 = tslib_1.__importDefault(require_is_array());
      exports.default = (function(arr) {
        if (!(0, is_array_1.default)(arr)) {
          return void 0;
        }
        return arr.reduce(function(prev, curr) {
          return Math.min(prev, curr);
        }, arr[0]);
      });
    }
  });

  // node_modules/@antv/util/lib/lodash/get-range.js
  var require_get_range = __commonJS({
    "node_modules/@antv/util/lib/lodash/get-range.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_1 = tslib_1.__importDefault(require_is_array());
      var max_1 = tslib_1.__importDefault(require_max());
      var min_1 = tslib_1.__importDefault(require_min());
      var getRange2 = function(values2) {
        var filterValues = values2.filter(function(v) {
          return !isNaN(v);
        });
        if (!filterValues.length) {
          return {
            min: 0,
            max: 0
          };
        }
        if ((0, is_array_1.default)(values2[0])) {
          var tmp2 = [];
          for (var i = 0; i < values2.length; i++) {
            tmp2 = tmp2.concat(values2[i]);
          }
          filterValues = tmp2;
        }
        var max4 = (0, max_1.default)(filterValues);
        var min4 = (0, min_1.default)(filterValues);
        return {
          min: min4,
          max: max4
        };
      };
      exports.default = getRange2;
    }
  });

  // node_modules/@antv/util/lib/lodash/pull.js
  var require_pull = __commonJS({
    "node_modules/@antv/util/lib/lodash/pull.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var arrPrototype2 = Array.prototype;
      var splice4 = arrPrototype2.splice;
      var indexOf2 = arrPrototype2.indexOf;
      var pull = function(arr) {
        var values2 = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          values2[_i - 1] = arguments[_i];
        }
        for (var i = 0; i < values2.length; i++) {
          var value = values2[i];
          var fromIndex = -1;
          while ((fromIndex = indexOf2.call(arr, value)) > -1) {
            splice4.call(arr, fromIndex, 1);
          }
        }
        return arr;
      };
      exports.default = pull;
    }
  });

  // node_modules/@antv/util/lib/lodash/pull-at.js
  var require_pull_at = __commonJS({
    "node_modules/@antv/util/lib/lodash/pull-at.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_like_1 = tslib_1.__importDefault(require_is_array_like());
      var splice4 = Array.prototype.splice;
      var pullAt = function pullAt2(arr, indexes) {
        if (!(0, is_array_like_1.default)(arr)) {
          return [];
        }
        var length = arr ? indexes.length : 0;
        var last2 = length - 1;
        while (length--) {
          var previous = void 0;
          var index2 = indexes[length];
          if (length === last2 || index2 !== previous) {
            previous = index2;
            splice4.call(arr, index2, 1);
          }
        }
        return arr;
      };
      exports.default = pullAt;
    }
  });

  // node_modules/@antv/util/lib/lodash/reduce.js
  var require_reduce = __commonJS({
    "node_modules/@antv/util/lib/lodash/reduce.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var each_1 = tslib_1.__importDefault(require_each());
      var is_array_1 = tslib_1.__importDefault(require_is_array());
      var is_plain_object_1 = tslib_1.__importDefault(require_is_plain_object());
      var reduce = function(arr, fn, init) {
        if (!(0, is_array_1.default)(arr) && !(0, is_plain_object_1.default)(arr)) {
          return arr;
        }
        var result = init;
        (0, each_1.default)(arr, function(data2, i) {
          result = fn(result, data2, i);
        });
        return result;
      };
      exports.default = reduce;
    }
  });

  // node_modules/@antv/util/lib/lodash/remove.js
  var require_remove = __commonJS({
    "node_modules/@antv/util/lib/lodash/remove.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_like_1 = tslib_1.__importDefault(require_is_array_like());
      var pull_at_1 = tslib_1.__importDefault(require_pull_at());
      var remove = function(arr, predicate) {
        var result = [];
        if (!(0, is_array_like_1.default)(arr)) {
          return result;
        }
        var i = -1;
        var indexes = [];
        var length = arr.length;
        while (++i < length) {
          var value = arr[i];
          if (predicate(value, i, arr)) {
            result.push(value);
            indexes.push(i);
          }
        }
        (0, pull_at_1.default)(arr, indexes);
        return result;
      };
      exports.default = remove;
    }
  });

  // node_modules/@antv/util/lib/lodash/is-string.js
  var require_is_string = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-string.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = isString16;
      function isString16(value) {
        return typeof value === "string";
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/sort-by.js
  var require_sort_by = __commonJS({
    "node_modules/@antv/util/lib/lodash/sort-by.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_1 = tslib_1.__importDefault(require_is_array());
      var is_string_1 = tslib_1.__importDefault(require_is_string());
      var is_function_1 = tslib_1.__importDefault(require_is_function());
      function sortBy(arr, key) {
        var comparer;
        if ((0, is_function_1.default)(key)) {
          comparer = function(a2, b) {
            return key(a2) - key(b);
          };
        } else {
          var keys_1 = [];
          if ((0, is_string_1.default)(key)) {
            keys_1.push(key);
          } else if ((0, is_array_1.default)(key)) {
            keys_1 = key;
          }
          comparer = function(a2, b) {
            for (var i = 0; i < keys_1.length; i += 1) {
              var prop = keys_1[i];
              if (a2[prop] > b[prop]) {
                return 1;
              }
              if (a2[prop] < b[prop]) {
                return -1;
              }
            }
            return 0;
          };
        }
        arr.sort(comparer);
        return arr;
      }
      exports.default = sortBy;
    }
  });

  // node_modules/@antv/util/lib/lodash/uniq.js
  var require_uniq = __commonJS({
    "node_modules/@antv/util/lib/lodash/uniq.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = uniq3;
      function uniq3(arr, cache) {
        if (cache === void 0) {
          cache = /* @__PURE__ */ new Map();
        }
        var r = [];
        if (Array.isArray(arr)) {
          for (var i = 0, len = arr.length; i < len; i++) {
            var item = arr[i];
            if (!cache.has(item)) {
              r.push(item);
              cache.set(item, true);
            }
          }
        }
        return r;
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/union.js
  var require_union = __commonJS({
    "node_modules/@antv/util/lib/lodash/union.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var uniq_1 = tslib_1.__importDefault(require_uniq());
      var union = function() {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          sources[_i] = arguments[_i];
        }
        return (0, uniq_1.default)([].concat.apply([], sources));
      };
      exports.default = union;
    }
  });

  // node_modules/@antv/util/lib/lodash/values-of-key.js
  var require_values_of_key = __commonJS({
    "node_modules/@antv/util/lib/lodash/values-of-key.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_1 = tslib_1.__importDefault(require_is_array());
      var is_nil_1 = tslib_1.__importDefault(require_is_nil());
      exports.default = (function(data2, name) {
        var rst = [];
        var tmpMap = {};
        for (var i = 0; i < data2.length; i++) {
          var obj = data2[i];
          var value = obj[name];
          if (!(0, is_nil_1.default)(value)) {
            if (!(0, is_array_1.default)(value)) {
              value = [value];
            }
            for (var j = 0; j < value.length; j++) {
              var val = value[j];
              if (!tmpMap[val]) {
                rst.push(val);
                tmpMap[val] = true;
              }
            }
          }
        }
        return rst;
      });
    }
  });

  // node_modules/@antv/util/lib/lodash/head.js
  var require_head = __commonJS({
    "node_modules/@antv/util/lib/lodash/head.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = head2;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_like_1 = tslib_1.__importDefault(require_is_array_like());
      function head2(o) {
        if ((0, is_array_like_1.default)(o)) {
          return o[0];
        }
        return void 0;
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/last.js
  var require_last = __commonJS({
    "node_modules/@antv/util/lib/lodash/last.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = last2;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_like_1 = tslib_1.__importDefault(require_is_array_like());
      function last2(o) {
        if ((0, is_array_like_1.default)(o)) {
          var arr = o;
          return arr[arr.length - 1];
        }
        return void 0;
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/starts-with.js
  var require_starts_with = __commonJS({
    "node_modules/@antv/util/lib/lodash/starts-with.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_1 = tslib_1.__importDefault(require_is_array());
      var is_string_1 = tslib_1.__importDefault(require_is_string());
      function startsWith3(arr, e) {
        return (0, is_array_1.default)(arr) || (0, is_string_1.default)(arr) ? arr[0] === e : false;
      }
      exports.default = startsWith3;
    }
  });

  // node_modules/@antv/util/lib/lodash/ends-with.js
  var require_ends_with = __commonJS({
    "node_modules/@antv/util/lib/lodash/ends-with.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_1 = tslib_1.__importDefault(require_is_array());
      var is_string_1 = tslib_1.__importDefault(require_is_string());
      function endsWith(arr, e) {
        return (0, is_array_1.default)(arr) || (0, is_string_1.default)(arr) ? arr[arr.length - 1] === e : false;
      }
      exports.default = endsWith;
    }
  });

  // node_modules/@antv/util/lib/lodash/every.js
  var require_every = __commonJS({
    "node_modules/@antv/util/lib/lodash/every.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var every = function(arr, func) {
        for (var i = 0; i < arr.length; i++) {
          if (!func(arr[i], i))
            return false;
        }
        return true;
      };
      exports.default = every;
    }
  });

  // node_modules/@antv/util/lib/lodash/some.js
  var require_some = __commonJS({
    "node_modules/@antv/util/lib/lodash/some.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var some = function(arr, func) {
        for (var i = 0; i < arr.length; i++) {
          if (func(arr[i], i))
            return true;
        }
        return false;
      };
      exports.default = some;
    }
  });

  // node_modules/@antv/util/lib/lodash/group-by.js
  var require_group_by = __commonJS({
    "node_modules/@antv/util/lib/lodash/group-by.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_1 = tslib_1.__importDefault(require_is_array());
      var is_function_1 = tslib_1.__importDefault(require_is_function());
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function groupBy6(data2, condition) {
        if (!condition || !(0, is_array_1.default)(data2)) {
          return {};
        }
        var result = {};
        var predicate = (0, is_function_1.default)(condition) ? condition : function(item2) {
          return item2[condition];
        };
        var key;
        for (var i = 0; i < data2.length; i++) {
          var item = data2[i];
          key = predicate(item);
          if (hasOwnProperty.call(result, key)) {
            result[key].push(item);
          } else {
            result[key] = [item];
          }
        }
        return result;
      }
      exports.default = groupBy6;
    }
  });

  // node_modules/@antv/util/lib/lodash/group-to-map.js
  var require_group_to_map = __commonJS({
    "node_modules/@antv/util/lib/lodash/group-to-map.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = groupToMap2;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_1 = tslib_1.__importDefault(require_is_array());
      var is_function_1 = tslib_1.__importDefault(require_is_function());
      var group_by_1 = tslib_1.__importDefault(require_group_by());
      function groupToMap2(data2, condition) {
        if (!condition) {
          return {
            0: data2
          };
        }
        if (!(0, is_function_1.default)(condition)) {
          var paramscondition_1 = (0, is_array_1.default)(condition) ? condition : condition.replace(/\s+/g, "").split("*");
          condition = function(row2) {
            var unique = "_";
            for (var i = 0, l = paramscondition_1.length; i < l; i++) {
              unique += row2[paramscondition_1[i]] && row2[paramscondition_1[i]].toString();
            }
            return unique;
          };
        }
        return (0, group_by_1.default)(data2, condition);
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/group.js
  var require_group = __commonJS({
    "node_modules/@antv/util/lib/lodash/group.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var group_to_map_1 = tslib_1.__importDefault(require_group_to_map());
      exports.default = (function(data2, condition) {
        if (!condition) {
          return [data2];
        }
        var groups = (0, group_to_map_1.default)(data2, condition);
        var array = [];
        for (var i in groups) {
          array.push(groups[i]);
        }
        return array;
      });
    }
  });

  // node_modules/@antv/util/lib/lodash/get-wrap-behavior.js
  var require_get_wrap_behavior = __commonJS({
    "node_modules/@antv/util/lib/lodash/get-wrap-behavior.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function getWrapBehavior(obj, action) {
        return obj["_wrap_" + action];
      }
      exports.default = getWrapBehavior;
    }
  });

  // node_modules/@antv/util/lib/lodash/wrap-behavior.js
  var require_wrap_behavior = __commonJS({
    "node_modules/@antv/util/lib/lodash/wrap-behavior.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function wrapBehavior(obj, action) {
        if (obj["_wrap_" + action]) {
          return obj["_wrap_" + action];
        }
        var method = function(e) {
          obj[action](e);
        };
        obj["_wrap_" + action] = method;
        return method;
      }
      exports.default = wrapBehavior;
    }
  });

  // node_modules/@antv/util/lib/lodash/number2color.js
  var require_number2color = __commonJS({
    "node_modules/@antv/util/lib/lodash/number2color.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var numColorCache = {};
      function numberToColor(num) {
        var color2 = numColorCache[num];
        if (!color2) {
          var str = num.toString(16);
          for (var i = str.length; i < 6; i++) {
            str = "0" + str;
          }
          color2 = "#" + str;
          numColorCache[num] = color2;
        }
        return color2;
      }
      exports.default = numberToColor;
    }
  });

  // node_modules/@antv/util/lib/lodash/parse-radius.js
  var require_parse_radius = __commonJS({
    "node_modules/@antv/util/lib/lodash/parse-radius.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_1 = tslib_1.__importDefault(require_is_array());
      function parseRadius(radius) {
        var r1 = 0, r2 = 0, r3 = 0, r4 = 0;
        if ((0, is_array_1.default)(radius)) {
          if (radius.length === 1) {
            r1 = r2 = r3 = r4 = radius[0];
          } else if (radius.length === 2) {
            r1 = r3 = radius[0];
            r2 = r4 = radius[1];
          } else if (radius.length === 3) {
            r1 = radius[0];
            r2 = r4 = radius[1];
            r3 = radius[2];
          } else {
            r1 = radius[0];
            r2 = radius[1];
            r3 = radius[2];
            r4 = radius[3];
          }
        } else {
          r1 = r2 = r3 = r4 = radius;
        }
        return {
          r1,
          r2,
          r3,
          r4
        };
      }
      exports.default = parseRadius;
    }
  });

  // node_modules/@antv/util/lib/lodash/clamp.js
  var require_clamp = __commonJS({
    "node_modules/@antv/util/lib/lodash/clamp.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var clamp12 = function(a2, min4, max4) {
        if (a2 < min4) {
          return min4;
        } else if (a2 > max4) {
          return max4;
        }
        return a2;
      };
      exports.default = clamp12;
    }
  });

  // node_modules/@antv/util/lib/lodash/fixed-base.js
  var require_fixed_base = __commonJS({
    "node_modules/@antv/util/lib/lodash/fixed-base.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var fixedBase = function(v, base) {
        var str = base.toString();
        var index2 = str.indexOf(".");
        if (index2 === -1) {
          return Math.round(v);
        }
        var length = str.substr(index2 + 1).length;
        if (length > 20) {
          length = 20;
        }
        return parseFloat(v.toFixed(length));
      };
      exports.default = fixedBase;
    }
  });

  // node_modules/@antv/util/lib/lodash/is-number.js
  var require_is_number = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-number.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = isNumber34;
      function isNumber34(value) {
        return typeof value === "number";
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/is-decimal.js
  var require_is_decimal = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-decimal.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = isDecimal;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_number_1 = tslib_1.__importDefault(require_is_number());
      function isDecimal(num) {
        return (0, is_number_1.default)(num) && num % 1 !== 0;
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/is-even.js
  var require_is_even = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-even.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = isEven;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_number_1 = tslib_1.__importDefault(require_is_number());
      function isEven(num) {
        return (0, is_number_1.default)(num) && num % 2 === 0;
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/is-integer.js
  var require_is_integer = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-integer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = isInteger2;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_number_1 = tslib_1.__importDefault(require_is_number());
      function isInteger2(value) {
        return (0, is_number_1.default)(value) && value % 1 === 0;
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/is-negative.js
  var require_is_negative = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-negative.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = isNegative;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_number_1 = tslib_1.__importDefault(require_is_number());
      function isNegative(num) {
        return (0, is_number_1.default)(num) && num < 0;
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/is-number-equal.js
  var require_is_number_equal = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-number-equal.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = isNumberEqual4;
      var PRECISION = 1e-5;
      function isNumberEqual4(a2, b, precision) {
        if (precision === void 0) {
          precision = PRECISION;
        }
        return a2 === b || Math.abs(a2 - b) < precision;
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/is-odd.js
  var require_is_odd = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-odd.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = isOdd;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_number_1 = tslib_1.__importDefault(require_is_number());
      function isOdd(num) {
        return (0, is_number_1.default)(num) && num % 2 !== 0;
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/is-positive.js
  var require_is_positive = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-positive.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_number_1 = tslib_1.__importDefault(require_is_number());
      var isPositive = function(num) {
        return (0, is_number_1.default)(num) && num > 0;
      };
      exports.default = isPositive;
    }
  });

  // node_modules/@antv/util/lib/lodash/max-by.js
  var require_max_by = __commonJS({
    "node_modules/@antv/util/lib/lodash/max-by.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_1 = tslib_1.__importDefault(require_is_array());
      var is_function_1 = tslib_1.__importDefault(require_is_function());
      exports.default = (function(arr, fn) {
        if (!(0, is_array_1.default)(arr)) {
          return void 0;
        }
        var maxItem;
        var max4 = -Infinity;
        for (var i = 0; i < arr.length; i++) {
          var item = arr[i];
          var v = (0, is_function_1.default)(fn) ? fn(item) : item[fn];
          if (v > max4) {
            maxItem = item;
            max4 = v;
          }
        }
        return maxItem;
      });
    }
  });

  // node_modules/@antv/util/lib/lodash/min-by.js
  var require_min_by = __commonJS({
    "node_modules/@antv/util/lib/lodash/min-by.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_1 = tslib_1.__importDefault(require_is_array());
      var is_function_1 = tslib_1.__importDefault(require_is_function());
      exports.default = (function(arr, fn) {
        if (!(0, is_array_1.default)(arr)) {
          return void 0;
        }
        var minItem;
        var min4 = Infinity;
        for (var i = 0; i < arr.length; i++) {
          var item = arr[i];
          var v = (0, is_function_1.default)(fn) ? fn(item) : item[fn];
          if (v < min4) {
            minItem = item;
            min4 = v;
          }
        }
        return minItem;
      });
    }
  });

  // node_modules/@antv/util/lib/lodash/mod.js
  var require_mod = __commonJS({
    "node_modules/@antv/util/lib/lodash/mod.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var mod3 = function(n, m2) {
        return (n % m2 + m2) % m2;
      };
      exports.default = mod3;
    }
  });

  // node_modules/@antv/util/lib/lodash/to-degree.js
  var require_to_degree = __commonJS({
    "node_modules/@antv/util/lib/lodash/to-degree.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var DEGREE2 = 180 / Math.PI;
      var toDegree = function(radian) {
        return DEGREE2 * radian;
      };
      exports.default = toDegree;
    }
  });

  // node_modules/@antv/util/lib/lodash/to-integer.js
  var require_to_integer = __commonJS({
    "node_modules/@antv/util/lib/lodash/to-integer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = parseInt;
    }
  });

  // node_modules/@antv/util/lib/lodash/to-radian.js
  var require_to_radian = __commonJS({
    "node_modules/@antv/util/lib/lodash/to-radian.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var RADIAN2 = Math.PI / 180;
      var toRadian = function(degree3) {
        return RADIAN2 * degree3;
      };
      exports.default = toRadian;
    }
  });

  // node_modules/@antv/util/lib/lodash/for-in.js
  var require_for_in = __commonJS({
    "node_modules/@antv/util/lib/lodash/for-in.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var each_1 = tslib_1.__importDefault(require_each());
      exports.default = each_1.default;
    }
  });

  // node_modules/@antv/util/lib/lodash/has.js
  var require_has = __commonJS({
    "node_modules/@antv/util/lib/lodash/has.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = (function(obj, key) {
        return obj.hasOwnProperty(key);
      });
    }
  });

  // node_modules/@antv/util/lib/lodash/has-key.js
  var require_has_key = __commonJS({
    "node_modules/@antv/util/lib/lodash/has-key.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var has_1 = tslib_1.__importDefault(require_has());
      exports.default = has_1.default;
    }
  });

  // node_modules/@antv/util/lib/lodash/values.js
  var require_values = __commonJS({
    "node_modules/@antv/util/lib/lodash/values.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var each_1 = tslib_1.__importDefault(require_each());
      var is_function_1 = tslib_1.__importDefault(require_is_function());
      var values2 = Object.values ? function(obj) {
        return Object.values(obj);
      } : function(obj) {
        var result = [];
        (0, each_1.default)(obj, function(value, key) {
          if (!((0, is_function_1.default)(obj) && key === "prototype")) {
            result.push(value);
          }
        });
        return result;
      };
      exports.default = values2;
    }
  });

  // node_modules/@antv/util/lib/lodash/has-value.js
  var require_has_value = __commonJS({
    "node_modules/@antv/util/lib/lodash/has-value.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var contains_1 = tslib_1.__importDefault(require_contains());
      var values_1 = tslib_1.__importDefault(require_values());
      exports.default = (function(obj, value) {
        return (0, contains_1.default)((0, values_1.default)(obj), value);
      });
    }
  });

  // node_modules/@antv/util/lib/lodash/to-string.js
  var require_to_string = __commonJS({
    "node_modules/@antv/util/lib/lodash/to-string.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_nil_1 = tslib_1.__importDefault(require_is_nil());
      exports.default = (function(value) {
        if ((0, is_nil_1.default)(value))
          return "";
        return value.toString();
      });
    }
  });

  // node_modules/@antv/util/lib/lodash/lower-case.js
  var require_lower_case = __commonJS({
    "node_modules/@antv/util/lib/lodash/lower-case.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var to_string_1 = tslib_1.__importDefault(require_to_string());
      var lowerCase = function(str) {
        return (0, to_string_1.default)(str).toLowerCase();
      };
      exports.default = lowerCase;
    }
  });

  // node_modules/@antv/util/lib/lodash/lower-first.js
  var require_lower_first = __commonJS({
    "node_modules/@antv/util/lib/lodash/lower-first.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var to_string_1 = tslib_1.__importDefault(require_to_string());
      var lowerFirst2 = function(value) {
        var str = (0, to_string_1.default)(value);
        return str.charAt(0).toLowerCase() + str.substring(1);
      };
      exports.default = lowerFirst2;
    }
  });

  // node_modules/@antv/util/lib/lodash/substitute.js
  var require_substitute = __commonJS({
    "node_modules/@antv/util/lib/lodash/substitute.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function substitute2(str, o) {
        if (!str || !o) {
          return str;
        }
        return str.replace(/\\?\{([^{}]+)\}/g, function(match2, name) {
          if (match2.charAt(0) === "\\") {
            return match2.slice(1);
          }
          return o[name] === void 0 ? "" : o[name];
        });
      }
      exports.default = substitute2;
    }
  });

  // node_modules/@antv/util/lib/lodash/upper-case.js
  var require_upper_case = __commonJS({
    "node_modules/@antv/util/lib/lodash/upper-case.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var to_string_1 = tslib_1.__importDefault(require_to_string());
      var upperCase = function(str) {
        return (0, to_string_1.default)(str).toUpperCase();
      };
      exports.default = upperCase;
    }
  });

  // node_modules/@antv/util/lib/lodash/upper-first.js
  var require_upper_first = __commonJS({
    "node_modules/@antv/util/lib/lodash/upper-first.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var to_string_1 = tslib_1.__importDefault(require_to_string());
      var upperFirst4 = function(value) {
        var str = (0, to_string_1.default)(value);
        return str.charAt(0).toUpperCase() + str.substring(1);
      };
      exports.default = upperFirst4;
    }
  });

  // node_modules/@antv/util/lib/lodash/get-type.js
  var require_get_type = __commonJS({
    "node_modules/@antv/util/lib/lodash/get-type.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var toString3 = {}.toString;
      var getType2 = function(value) {
        return toString3.call(value).replace(/^\[object /, "").replace(/]$/, "");
      };
      exports.default = getType2;
    }
  });

  // node_modules/@antv/util/lib/lodash/is-arguments.js
  var require_is_arguments = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-arguments.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_type_1 = tslib_1.__importDefault(require_is_type());
      var isArguments = function(value) {
        return (0, is_type_1.default)(value, "Arguments");
      };
      exports.default = isArguments;
    }
  });

  // node_modules/@antv/util/lib/lodash/is-boolean.js
  var require_is_boolean = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-boolean.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_type_1 = tslib_1.__importDefault(require_is_type());
      var isBoolean4 = function(value) {
        return (0, is_type_1.default)(value, "Boolean");
      };
      exports.default = isBoolean4;
    }
  });

  // node_modules/@antv/util/lib/lodash/is-date.js
  var require_is_date = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-date.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = isDate2;
      function isDate2(value) {
        return value instanceof Date;
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/is-error.js
  var require_is_error = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-error.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_type_1 = tslib_1.__importDefault(require_is_type());
      var isError = function(value) {
        return (0, is_type_1.default)(value, "Error");
      };
      exports.default = isError;
    }
  });

  // node_modules/@antv/util/lib/lodash/is-finite.js
  var require_is_finite = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-finite.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = default_12;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_number_1 = tslib_1.__importDefault(require_is_number());
      function default_12(value) {
        return (0, is_number_1.default)(value) && isFinite(value);
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/is-null.js
  var require_is_null = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-null.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = isNull2;
      function isNull2(value) {
        return value === null;
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/is-prototype.js
  var require_is_prototype = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-prototype.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var objectProto2 = Object.prototype;
      var isPrototype = function(value) {
        var Ctor = value && value.constructor;
        var proto = typeof Ctor === "function" && Ctor.prototype || objectProto2;
        return value === proto;
      };
      exports.default = isPrototype;
    }
  });

  // node_modules/@antv/util/lib/lodash/is-reg-exp.js
  var require_is_reg_exp = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-reg-exp.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_type_1 = tslib_1.__importDefault(require_is_type());
      var isRegExp = function(str) {
        return (0, is_type_1.default)(str, "RegExp");
      };
      exports.default = isRegExp;
    }
  });

  // node_modules/@antv/util/lib/lodash/is-undefined.js
  var require_is_undefined = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-undefined.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var isUndefined5 = function(value) {
        return value === void 0;
      };
      exports.default = isUndefined5;
    }
  });

  // node_modules/@antv/util/lib/lodash/is-element.js
  var require_is_element = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-element.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = isElement4;
      function isElement4(value) {
        return value instanceof Element || value instanceof Document;
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/request-animation-frame.js
  var require_request_animation_frame = __commonJS({
    "node_modules/@antv/util/lib/lodash/request-animation-frame.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = requestAnimationFrame2;
      function requestAnimationFrame2(fn) {
        var method = window.requestAnimationFrame || // @ts-ignore
        window.webkitRequestAnimationFrame || // @ts-ignore
        window.mozRequestAnimationFrame || // @ts-ignore
        window.msRequestAnimationFrame || function(f) {
          return setTimeout(f, 16);
        };
        return method(fn);
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/clear-animation-frame.js
  var require_clear_animation_frame = __commonJS({
    "node_modules/@antv/util/lib/lodash/clear-animation-frame.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = cancelAnimationFrame2;
      function cancelAnimationFrame2(handler) {
        var method = window.cancelAnimationFrame || // @ts-ignore
        window.webkitCancelAnimationFrame || // @ts-ignore
        window.mozCancelAnimationFrame || // @ts-ignore
        window.msCancelAnimationFrame || clearTimeout;
        method(handler);
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/mix.js
  var require_mix = __commonJS({
    "node_modules/@antv/util/lib/lodash/mix.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = mix2;
      function _mix(dist, obj) {
        for (var key in obj) {
          if (obj.hasOwnProperty(key) && key !== "constructor" && obj[key] !== void 0) {
            dist[key] = obj[key];
          }
        }
      }
      function mix2(dist, src1, src2, src3) {
        if (src1)
          _mix(dist, src1);
        if (src2)
          _mix(dist, src2);
        if (src3)
          _mix(dist, src3);
        return dist;
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/augment.js
  var require_augment = __commonJS({
    "node_modules/@antv/util/lib/lodash/augment.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var mix_1 = tslib_1.__importDefault(require_mix());
      var is_function_1 = tslib_1.__importDefault(require_is_function());
      var augment = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var c2 = args[0];
        for (var i = 1; i < args.length; i++) {
          var obj = args[i];
          if ((0, is_function_1.default)(obj)) {
            obj = obj.prototype;
          }
          (0, mix_1.default)(c2.prototype, obj);
        }
      };
      exports.default = augment;
    }
  });

  // node_modules/@antv/util/lib/lodash/clone.js
  var require_clone = __commonJS({
    "node_modules/@antv/util/lib/lodash/clone.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_1 = tslib_1.__importDefault(require_is_array());
      var clone8 = function(obj) {
        if (typeof obj !== "object" || obj === null) {
          return obj;
        }
        var rst;
        if ((0, is_array_1.default)(obj)) {
          rst = [];
          for (var i = 0, l = obj.length; i < l; i++) {
            if (typeof obj[i] === "object" && obj[i] != null) {
              rst[i] = clone8(obj[i]);
            } else {
              rst[i] = obj[i];
            }
          }
        } else {
          rst = {};
          for (var k in obj) {
            if (typeof obj[k] === "object" && obj[k] != null) {
              rst[k] = clone8(obj[k]);
            } else {
              rst[k] = obj[k];
            }
          }
        }
        return rst;
      };
      exports.default = clone8;
    }
  });

  // node_modules/@antv/util/lib/lodash/debounce.js
  var require_debounce = __commonJS({
    "node_modules/@antv/util/lib/lodash/debounce.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function debounce6(func, wait, immediate) {
        var timeout2;
        return function() {
          var context = this, args = arguments;
          var later = function() {
            timeout2 = null;
            if (!immediate) {
              func.apply(context, args);
            }
          };
          var callNow = immediate && !timeout2;
          clearTimeout(timeout2);
          timeout2 = setTimeout(later, wait);
          if (callNow) {
            func.apply(context, args);
          }
        };
      }
      exports.default = debounce6;
    }
  });

  // node_modules/@antv/util/lib/lodash/memoize.js
  var require_memoize = __commonJS({
    "node_modules/@antv/util/lib/lodash/memoize.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = memoize4;
      function flru(max4) {
        var num, curr, prev;
        var limit = max4 || 1;
        function keep(key, value) {
          if (++num > limit) {
            prev = curr;
            reset(1);
            ++num;
          }
          curr[key] = value;
        }
        function reset(isPartial) {
          num = 0;
          curr = /* @__PURE__ */ Object.create(null);
          isPartial || (prev = /* @__PURE__ */ Object.create(null));
        }
        reset();
        return {
          clear: reset,
          has: function(key) {
            return curr[key] !== void 0 || prev[key] !== void 0;
          },
          get: function(key) {
            var val = curr[key];
            if (val !== void 0)
              return val;
            if ((val = prev[key]) !== void 0) {
              keep(key, val);
              return val;
            }
          },
          set: function(key, value) {
            if (curr[key] !== void 0) {
              curr[key] = value;
            } else {
              keep(key, value);
            }
          }
        };
      }
      var CacheMap = /* @__PURE__ */ new Map();
      function memoize4(fn, resolver, maxSize) {
        if (maxSize === void 0) {
          maxSize = 128;
        }
        var memoized = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var key = resolver ? resolver.apply(this, args) : args[0];
          if (!CacheMap.has(fn))
            CacheMap.set(fn, flru(maxSize));
          var cache = CacheMap.get(fn);
          if (cache.has(key))
            return cache.get(key);
          var result = fn.apply(this, args);
          cache.set(key, result);
          return result;
        };
        return memoized;
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/deep-mix.js
  var require_deep_mix = __commonJS({
    "node_modules/@antv/util/lib/lodash/deep-mix.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_1 = tslib_1.__importDefault(require_is_array());
      var is_plain_object_1 = tslib_1.__importDefault(require_is_plain_object());
      var MAX_MIX_LEVEL2 = 5;
      function hasOwn(object, property) {
        if (Object.hasOwn) {
          return Object.hasOwn(object, property);
        }
        if (object == null) {
          throw new TypeError("Cannot convert undefined or null to object");
        }
        return Object.prototype.hasOwnProperty.call(Object(object), property);
      }
      function _deepMix(dist, src, level, maxLevel) {
        level = level || 0;
        maxLevel = maxLevel || MAX_MIX_LEVEL2;
        for (var key in src) {
          if (hasOwn(src, key)) {
            var value = src[key];
            if (value !== null && (0, is_plain_object_1.default)(value)) {
              if (!(0, is_plain_object_1.default)(dist[key])) {
                dist[key] = {};
              }
              if (level < maxLevel) {
                _deepMix(dist[key], value, level + 1, maxLevel);
              } else {
                dist[key] = src[key];
              }
            } else if ((0, is_array_1.default)(value)) {
              dist[key] = [];
              dist[key] = dist[key].concat(value);
            } else if (value !== void 0) {
              dist[key] = value;
            }
          }
        }
      }
      var deepMix12 = function(rst) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        for (var i = 0; i < args.length; i += 1) {
          _deepMix(rst, args[i]);
        }
        return rst;
      };
      exports.default = deepMix12;
    }
  });

  // node_modules/@antv/util/lib/lodash/extend.js
  var require_extend = __commonJS({
    "node_modules/@antv/util/lib/lodash/extend.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var mix_1 = tslib_1.__importDefault(require_mix());
      var is_function_1 = tslib_1.__importDefault(require_is_function());
      var extend2 = function(subclass, superclass, overrides, staticOverrides) {
        if (!(0, is_function_1.default)(superclass)) {
          overrides = superclass;
          superclass = subclass;
          subclass = function() {
          };
        }
        var create2 = Object.create ? function(proto, c2) {
          return Object.create(proto, {
            constructor: {
              value: c2
            }
          });
        } : function(proto, c2) {
          function Tmp() {
          }
          Tmp.prototype = proto;
          var o = new Tmp();
          o.constructor = c2;
          return o;
        };
        var superObj = create2(superclass.prototype, subclass);
        subclass.prototype = (0, mix_1.default)(superObj, subclass.prototype);
        subclass.superclass = create2(superclass.prototype, superclass);
        (0, mix_1.default)(superObj, overrides);
        (0, mix_1.default)(subclass, staticOverrides);
        return subclass;
      };
      exports.default = extend2;
    }
  });

  // node_modules/@antv/util/lib/lodash/index-of.js
  var require_index_of = __commonJS({
    "node_modules/@antv/util/lib/lodash/index-of.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_like_1 = tslib_1.__importDefault(require_is_array_like());
      var indexOf2 = function(arr, obj) {
        if (!(0, is_array_like_1.default)(arr)) {
          return -1;
        }
        var m2 = Array.prototype.indexOf;
        if (m2) {
          return m2.call(arr, obj);
        }
        var index2 = -1;
        for (var i = 0; i < arr.length; i++) {
          if (arr[i] === obj) {
            index2 = i;
            break;
          }
        }
        return index2;
      };
      exports.default = indexOf2;
    }
  });

  // node_modules/@antv/util/lib/lodash/is-empty.js
  var require_is_empty = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-empty.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_nil_1 = tslib_1.__importDefault(require_is_nil());
      var is_array_like_1 = tslib_1.__importDefault(require_is_array_like());
      var get_type_1 = tslib_1.__importDefault(require_get_type());
      var is_prototype_1 = tslib_1.__importDefault(require_is_prototype());
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function isEmpty7(value) {
        if ((0, is_nil_1.default)(value)) {
          return true;
        }
        if ((0, is_array_like_1.default)(value)) {
          return !value.length;
        }
        var type = (0, get_type_1.default)(value);
        if (type === "Map" || type === "Set") {
          return !value.size;
        }
        if ((0, is_prototype_1.default)(value)) {
          return !Object.keys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      exports.default = isEmpty7;
    }
  });

  // node_modules/@antv/util/lib/lodash/is-equal.js
  var require_is_equal = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-equal.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_object_like_1 = tslib_1.__importDefault(require_is_object_like());
      var is_array_like_1 = tslib_1.__importDefault(require_is_array_like());
      var is_string_1 = tslib_1.__importDefault(require_is_string());
      var isEqual15 = function(value, other) {
        if (value === other) {
          return true;
        }
        if (!value || !other) {
          return false;
        }
        if ((0, is_string_1.default)(value) || (0, is_string_1.default)(other)) {
          return false;
        }
        if ((0, is_array_like_1.default)(value) || (0, is_array_like_1.default)(other)) {
          if (value.length !== other.length) {
            return false;
          }
          var rst = true;
          for (var i = 0; i < value.length; i++) {
            rst = isEqual15(value[i], other[i]);
            if (!rst) {
              break;
            }
          }
          return rst;
        }
        if ((0, is_object_like_1.default)(value) || (0, is_object_like_1.default)(other)) {
          var valueKeys = Object.keys(value);
          var otherKeys = Object.keys(other);
          if (valueKeys.length !== otherKeys.length) {
            return false;
          }
          var rst = true;
          for (var i = 0; i < valueKeys.length; i++) {
            rst = isEqual15(value[valueKeys[i]], other[valueKeys[i]]);
            if (!rst) {
              break;
            }
          }
          return rst;
        }
        return false;
      };
      exports.default = isEqual15;
    }
  });

  // node_modules/@antv/util/lib/lodash/is-equal-with.js
  var require_is_equal_with = __commonJS({
    "node_modules/@antv/util/lib/lodash/is-equal-with.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_function_1 = tslib_1.__importDefault(require_is_function());
      var is_equal_1 = tslib_1.__importDefault(require_is_equal());
      exports.default = (function(value, other, fn) {
        if (!(0, is_function_1.default)(fn)) {
          return (0, is_equal_1.default)(value, other);
        }
        return !!fn(value, other);
      });
    }
  });

  // node_modules/@antv/util/lib/lodash/map.js
  var require_map = __commonJS({
    "node_modules/@antv/util/lib/lodash/map.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_like_1 = tslib_1.__importDefault(require_is_array_like());
      var map = function(arr, func) {
        if (!(0, is_array_like_1.default)(arr)) {
          return arr;
        }
        var result = [];
        for (var index2 = 0; index2 < arr.length; index2++) {
          var value = arr[index2];
          result.push(func(value, index2));
        }
        return result;
      };
      exports.default = map;
    }
  });

  // node_modules/@antv/util/lib/lodash/map-values.js
  var require_map_values = __commonJS({
    "node_modules/@antv/util/lib/lodash/map-values.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_nil_1 = tslib_1.__importDefault(require_is_nil());
      var is_object_1 = tslib_1.__importDefault(require_is_object());
      var identity3 = function(v) {
        return v;
      };
      exports.default = (function(object, func) {
        if (func === void 0) {
          func = identity3;
        }
        var r = {};
        if ((0, is_object_1.default)(object) && !(0, is_nil_1.default)(object)) {
          Object.keys(object).forEach(function(key) {
            r[key] = func(object[key], key);
          });
        }
        return r;
      });
    }
  });

  // node_modules/@antv/util/lib/lodash/get.js
  var require_get = __commonJS({
    "node_modules/@antv/util/lib/lodash/get.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_string_1 = tslib_1.__importDefault(require_is_string());
      exports.default = (function(obj, key, defaultValue) {
        var p = 0;
        var keyArr = (0, is_string_1.default)(key) ? key.split(".") : key;
        while (obj && p < keyArr.length) {
          obj = obj[keyArr[p++]];
        }
        return obj === void 0 || p < keyArr.length ? defaultValue : obj;
      });
    }
  });

  // node_modules/@antv/util/lib/lodash/set.js
  var require_set = __commonJS({
    "node_modules/@antv/util/lib/lodash/set.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_object_1 = tslib_1.__importDefault(require_is_object());
      var is_string_1 = tslib_1.__importDefault(require_is_string());
      var is_number_1 = tslib_1.__importDefault(require_is_number());
      exports.default = (function(obj, path, value) {
        var o = obj;
        var keyArr = (0, is_string_1.default)(path) ? path.split(".") : path;
        keyArr.forEach(function(key, idx) {
          if (idx < keyArr.length - 1) {
            if (!(0, is_object_1.default)(o[key])) {
              o[key] = (0, is_number_1.default)(keyArr[idx + 1]) ? [] : {};
            }
            o = o[key];
          } else {
            o[key] = value;
          }
        });
        return obj;
      });
    }
  });

  // node_modules/@antv/util/lib/lodash/pick.js
  var require_pick = __commonJS({
    "node_modules/@antv/util/lib/lodash/pick.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var each_1 = tslib_1.__importDefault(require_each());
      var is_plain_object_1 = tslib_1.__importDefault(require_is_plain_object());
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      exports.default = (function(object, keys) {
        if (object === null || !(0, is_plain_object_1.default)(object)) {
          return {};
        }
        var result = {};
        (0, each_1.default)(keys, function(key) {
          if (hasOwnProperty.call(object, key)) {
            result[key] = object[key];
          }
        });
        return result;
      });
    }
  });

  // node_modules/@antv/util/lib/lodash/omit.js
  var require_omit = __commonJS({
    "node_modules/@antv/util/lib/lodash/omit.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var reduce_1 = tslib_1.__importDefault(require_reduce());
      exports.default = (function(obj, keys) {
        return (0, reduce_1.default)(obj, function(r, curr, key) {
          if (!keys.includes(key)) {
            r[key] = curr;
          }
          return r;
        }, {});
      });
    }
  });

  // node_modules/@antv/util/lib/lodash/throttle.js
  var require_throttle = __commonJS({
    "node_modules/@antv/util/lib/lodash/throttle.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = (function(func, wait, options) {
        var timeout2, context, args, result;
        var previous = 0;
        if (!options)
          options = {};
        var later = function() {
          previous = options.leading === false ? 0 : Date.now();
          timeout2 = null;
          result = func.apply(context, args);
          if (!timeout2)
            context = args = null;
        };
        var throttled = function() {
          var now2 = Date.now();
          if (!previous && options.leading === false)
            previous = now2;
          var remaining = wait - (now2 - previous);
          context = this;
          args = arguments;
          if (remaining <= 0 || remaining > wait) {
            if (timeout2) {
              clearTimeout(timeout2);
              timeout2 = null;
            }
            previous = now2;
            result = func.apply(context, args);
            if (!timeout2)
              context = args = null;
          } else if (!timeout2 && options.trailing !== false) {
            timeout2 = setTimeout(later, remaining);
          }
          return result;
        };
        throttled.cancel = function() {
          clearTimeout(timeout2);
          previous = 0;
          timeout2 = context = args = null;
        };
        return throttled;
      });
    }
  });

  // node_modules/@antv/util/lib/lodash/to-array.js
  var require_to_array = __commonJS({
    "node_modules/@antv/util/lib/lodash/to-array.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_array_like_1 = tslib_1.__importDefault(require_is_array_like());
      exports.default = (function(value) {
        return (0, is_array_like_1.default)(value) ? Array.prototype.slice.call(value) : [];
      });
    }
  });

  // node_modules/@antv/util/lib/lodash/unique-id.js
  var require_unique_id = __commonJS({
    "node_modules/@antv/util/lib/lodash/unique-id.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var map = {};
      exports.default = (function(prefix) {
        prefix = prefix || "g";
        if (!map[prefix]) {
          map[prefix] = 1;
        } else {
          map[prefix] += 1;
        }
        return prefix + map[prefix];
      });
    }
  });

  // node_modules/@antv/util/lib/lodash/noop.js
  var require_noop = __commonJS({
    "node_modules/@antv/util/lib/lodash/noop.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = (function() {
      });
    }
  });

  // node_modules/@antv/util/lib/lodash/identity.js
  var require_identity = __commonJS({
    "node_modules/@antv/util/lib/lodash/identity.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = (function(v) {
        return v;
      });
    }
  });

  // node_modules/@antv/util/lib/lodash/size.js
  var require_size = __commonJS({
    "node_modules/@antv/util/lib/lodash/size.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = size2;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_nil_1 = tslib_1.__importDefault(require_is_nil());
      var is_array_like_1 = tslib_1.__importDefault(require_is_array_like());
      function size2(o) {
        if ((0, is_nil_1.default)(o)) {
          return 0;
        }
        if ((0, is_array_like_1.default)(o)) {
          return o.length;
        }
        return Object.keys(o).length;
      }
    }
  });

  // node_modules/@antv/util/lib/lodash/cache.js
  var require_cache = __commonJS({
    "node_modules/@antv/util/lib/lodash/cache.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var default_12 = (
        /** @class */
        (function() {
          function default_13() {
            this.map = {};
          }
          default_13.prototype.has = function(key) {
            return this.map[key] !== void 0;
          };
          default_13.prototype.get = function(key, def) {
            var v = this.map[key];
            return v === void 0 ? def : v;
          };
          default_13.prototype.set = function(key, value) {
            this.map[key] = value;
          };
          default_13.prototype.clear = function() {
            this.map = {};
          };
          default_13.prototype.delete = function(key) {
            delete this.map[key];
          };
          default_13.prototype.size = function() {
            return Object.keys(this.map).length;
          };
          return default_13;
        })()
      );
      exports.default = default_12;
    }
  });

  // node_modules/@antv/util/lib/lodash/index.js
  var require_lodash = __commonJS({
    "node_modules/@antv/util/lib/lodash/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.has = exports.forIn = exports.toRadian = exports.toInteger = exports.toDegree = exports.mod = exports.minBy = exports.min = exports.maxBy = exports.max = exports.isPositive = exports.isOdd = exports.isNumberEqual = exports.isNegative = exports.isInteger = exports.isEven = exports.isDecimal = exports.fixedBase = exports.clamp = exports.parseRadius = exports.number2color = exports.wrapBehavior = exports.getWrapBehavior = exports.groupToMap = exports.groupBy = exports.group = exports.some = exports.every = exports.filter = exports.endsWith = exports.startsWith = exports.last = exports.head = exports.valuesOfKey = exports.uniq = exports.union = exports.sortBy = exports.remove = exports.reduce = exports.pullAt = exports.pull = exports.getRange = exports.flattenDeep = exports.flatten = exports.firstValue = exports.findIndex = exports.find = exports.difference = exports.includes = exports.contains = void 0;
      exports.set = exports.get = exports.assign = exports.mix = exports.mapValues = exports.map = exports.isEqualWith = exports.isEqual = exports.isEmpty = exports.indexOf = exports.extend = exports.each = exports.deepMix = exports.memoize = exports.debounce = exports.clone = exports.augment = exports.clearAnimationFrame = exports.requestAnimationFrame = exports.isElement = exports.isUndefined = exports.isType = exports.isString = exports.isRegExp = exports.isPrototype = exports.isPlainObject = exports.isObjectLike = exports.isObject = exports.isNumber = exports.isNull = exports.isNil = exports.isFinite = exports.isFunction = exports.isError = exports.isDate = exports.isBoolean = exports.isArrayLike = exports.isArray = exports.isArguments = exports.getType = exports.upperFirst = exports.upperCase = exports.substitute = exports.lowerFirst = exports.lowerCase = exports.values = exports.isMatch = exports.keys = exports.hasValue = exports.hasKey = void 0;
      exports.Cache = exports.size = exports.identity = exports.noop = exports.uniqueId = exports.toString = exports.toArray = exports.throttle = exports.omit = exports.pick = void 0;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var contains_1 = require_contains();
      Object.defineProperty(exports, "contains", { enumerable: true, get: function() {
        return tslib_1.__importDefault(contains_1).default;
      } });
      Object.defineProperty(exports, "includes", { enumerable: true, get: function() {
        return tslib_1.__importDefault(contains_1).default;
      } });
      var difference_1 = require_difference();
      Object.defineProperty(exports, "difference", { enumerable: true, get: function() {
        return tslib_1.__importDefault(difference_1).default;
      } });
      var find_1 = require_find();
      Object.defineProperty(exports, "find", { enumerable: true, get: function() {
        return tslib_1.__importDefault(find_1).default;
      } });
      var find_index_1 = require_find_index();
      Object.defineProperty(exports, "findIndex", { enumerable: true, get: function() {
        return tslib_1.__importDefault(find_index_1).default;
      } });
      var first_value_1 = require_first_value();
      Object.defineProperty(exports, "firstValue", { enumerable: true, get: function() {
        return tslib_1.__importDefault(first_value_1).default;
      } });
      var flatten_1 = require_flatten();
      Object.defineProperty(exports, "flatten", { enumerable: true, get: function() {
        return tslib_1.__importDefault(flatten_1).default;
      } });
      var flatten_deep_1 = require_flatten_deep();
      Object.defineProperty(exports, "flattenDeep", { enumerable: true, get: function() {
        return tslib_1.__importDefault(flatten_deep_1).default;
      } });
      var get_range_1 = require_get_range();
      Object.defineProperty(exports, "getRange", { enumerable: true, get: function() {
        return tslib_1.__importDefault(get_range_1).default;
      } });
      var pull_1 = require_pull();
      Object.defineProperty(exports, "pull", { enumerable: true, get: function() {
        return tslib_1.__importDefault(pull_1).default;
      } });
      var pull_at_1 = require_pull_at();
      Object.defineProperty(exports, "pullAt", { enumerable: true, get: function() {
        return tslib_1.__importDefault(pull_at_1).default;
      } });
      var reduce_1 = require_reduce();
      Object.defineProperty(exports, "reduce", { enumerable: true, get: function() {
        return tslib_1.__importDefault(reduce_1).default;
      } });
      var remove_1 = require_remove();
      Object.defineProperty(exports, "remove", { enumerable: true, get: function() {
        return tslib_1.__importDefault(remove_1).default;
      } });
      var sort_by_1 = require_sort_by();
      Object.defineProperty(exports, "sortBy", { enumerable: true, get: function() {
        return tslib_1.__importDefault(sort_by_1).default;
      } });
      var union_1 = require_union();
      Object.defineProperty(exports, "union", { enumerable: true, get: function() {
        return tslib_1.__importDefault(union_1).default;
      } });
      var uniq_1 = require_uniq();
      Object.defineProperty(exports, "uniq", { enumerable: true, get: function() {
        return tslib_1.__importDefault(uniq_1).default;
      } });
      var values_of_key_1 = require_values_of_key();
      Object.defineProperty(exports, "valuesOfKey", { enumerable: true, get: function() {
        return tslib_1.__importDefault(values_of_key_1).default;
      } });
      var head_1 = require_head();
      Object.defineProperty(exports, "head", { enumerable: true, get: function() {
        return tslib_1.__importDefault(head_1).default;
      } });
      var last_1 = require_last();
      Object.defineProperty(exports, "last", { enumerable: true, get: function() {
        return tslib_1.__importDefault(last_1).default;
      } });
      var starts_with_1 = require_starts_with();
      Object.defineProperty(exports, "startsWith", { enumerable: true, get: function() {
        return tslib_1.__importDefault(starts_with_1).default;
      } });
      var ends_with_1 = require_ends_with();
      Object.defineProperty(exports, "endsWith", { enumerable: true, get: function() {
        return tslib_1.__importDefault(ends_with_1).default;
      } });
      var filter_1 = require_filter();
      Object.defineProperty(exports, "filter", { enumerable: true, get: function() {
        return tslib_1.__importDefault(filter_1).default;
      } });
      var every_1 = require_every();
      Object.defineProperty(exports, "every", { enumerable: true, get: function() {
        return tslib_1.__importDefault(every_1).default;
      } });
      var some_1 = require_some();
      Object.defineProperty(exports, "some", { enumerable: true, get: function() {
        return tslib_1.__importDefault(some_1).default;
      } });
      var group_1 = require_group();
      Object.defineProperty(exports, "group", { enumerable: true, get: function() {
        return tslib_1.__importDefault(group_1).default;
      } });
      var group_by_1 = require_group_by();
      Object.defineProperty(exports, "groupBy", { enumerable: true, get: function() {
        return tslib_1.__importDefault(group_by_1).default;
      } });
      var group_to_map_1 = require_group_to_map();
      Object.defineProperty(exports, "groupToMap", { enumerable: true, get: function() {
        return tslib_1.__importDefault(group_to_map_1).default;
      } });
      var get_wrap_behavior_1 = require_get_wrap_behavior();
      Object.defineProperty(exports, "getWrapBehavior", { enumerable: true, get: function() {
        return tslib_1.__importDefault(get_wrap_behavior_1).default;
      } });
      var wrap_behavior_1 = require_wrap_behavior();
      Object.defineProperty(exports, "wrapBehavior", { enumerable: true, get: function() {
        return tslib_1.__importDefault(wrap_behavior_1).default;
      } });
      var number2color_1 = require_number2color();
      Object.defineProperty(exports, "number2color", { enumerable: true, get: function() {
        return tslib_1.__importDefault(number2color_1).default;
      } });
      var parse_radius_1 = require_parse_radius();
      Object.defineProperty(exports, "parseRadius", { enumerable: true, get: function() {
        return tslib_1.__importDefault(parse_radius_1).default;
      } });
      var clamp_1 = require_clamp();
      Object.defineProperty(exports, "clamp", { enumerable: true, get: function() {
        return tslib_1.__importDefault(clamp_1).default;
      } });
      var fixed_base_1 = require_fixed_base();
      Object.defineProperty(exports, "fixedBase", { enumerable: true, get: function() {
        return tslib_1.__importDefault(fixed_base_1).default;
      } });
      var is_decimal_1 = require_is_decimal();
      Object.defineProperty(exports, "isDecimal", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_decimal_1).default;
      } });
      var is_even_1 = require_is_even();
      Object.defineProperty(exports, "isEven", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_even_1).default;
      } });
      var is_integer_1 = require_is_integer();
      Object.defineProperty(exports, "isInteger", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_integer_1).default;
      } });
      var is_negative_1 = require_is_negative();
      Object.defineProperty(exports, "isNegative", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_negative_1).default;
      } });
      var is_number_equal_1 = require_is_number_equal();
      Object.defineProperty(exports, "isNumberEqual", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_number_equal_1).default;
      } });
      var is_odd_1 = require_is_odd();
      Object.defineProperty(exports, "isOdd", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_odd_1).default;
      } });
      var is_positive_1 = require_is_positive();
      Object.defineProperty(exports, "isPositive", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_positive_1).default;
      } });
      var max_1 = require_max();
      Object.defineProperty(exports, "max", { enumerable: true, get: function() {
        return tslib_1.__importDefault(max_1).default;
      } });
      var max_by_1 = require_max_by();
      Object.defineProperty(exports, "maxBy", { enumerable: true, get: function() {
        return tslib_1.__importDefault(max_by_1).default;
      } });
      var min_1 = require_min();
      Object.defineProperty(exports, "min", { enumerable: true, get: function() {
        return tslib_1.__importDefault(min_1).default;
      } });
      var min_by_1 = require_min_by();
      Object.defineProperty(exports, "minBy", { enumerable: true, get: function() {
        return tslib_1.__importDefault(min_by_1).default;
      } });
      var mod_1 = require_mod();
      Object.defineProperty(exports, "mod", { enumerable: true, get: function() {
        return tslib_1.__importDefault(mod_1).default;
      } });
      var to_degree_1 = require_to_degree();
      Object.defineProperty(exports, "toDegree", { enumerable: true, get: function() {
        return tslib_1.__importDefault(to_degree_1).default;
      } });
      var to_integer_1 = require_to_integer();
      Object.defineProperty(exports, "toInteger", { enumerable: true, get: function() {
        return tslib_1.__importDefault(to_integer_1).default;
      } });
      var to_radian_1 = require_to_radian();
      Object.defineProperty(exports, "toRadian", { enumerable: true, get: function() {
        return tslib_1.__importDefault(to_radian_1).default;
      } });
      var for_in_1 = require_for_in();
      Object.defineProperty(exports, "forIn", { enumerable: true, get: function() {
        return tslib_1.__importDefault(for_in_1).default;
      } });
      var has_1 = require_has();
      Object.defineProperty(exports, "has", { enumerable: true, get: function() {
        return tslib_1.__importDefault(has_1).default;
      } });
      var has_key_1 = require_has_key();
      Object.defineProperty(exports, "hasKey", { enumerable: true, get: function() {
        return tslib_1.__importDefault(has_key_1).default;
      } });
      var has_value_1 = require_has_value();
      Object.defineProperty(exports, "hasValue", { enumerable: true, get: function() {
        return tslib_1.__importDefault(has_value_1).default;
      } });
      var keys_1 = require_keys();
      Object.defineProperty(exports, "keys", { enumerable: true, get: function() {
        return tslib_1.__importDefault(keys_1).default;
      } });
      var is_match_1 = require_is_match();
      Object.defineProperty(exports, "isMatch", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_match_1).default;
      } });
      var values_1 = require_values();
      Object.defineProperty(exports, "values", { enumerable: true, get: function() {
        return tslib_1.__importDefault(values_1).default;
      } });
      var lower_case_1 = require_lower_case();
      Object.defineProperty(exports, "lowerCase", { enumerable: true, get: function() {
        return tslib_1.__importDefault(lower_case_1).default;
      } });
      var lower_first_1 = require_lower_first();
      Object.defineProperty(exports, "lowerFirst", { enumerable: true, get: function() {
        return tslib_1.__importDefault(lower_first_1).default;
      } });
      var substitute_1 = require_substitute();
      Object.defineProperty(exports, "substitute", { enumerable: true, get: function() {
        return tslib_1.__importDefault(substitute_1).default;
      } });
      var upper_case_1 = require_upper_case();
      Object.defineProperty(exports, "upperCase", { enumerable: true, get: function() {
        return tslib_1.__importDefault(upper_case_1).default;
      } });
      var upper_first_1 = require_upper_first();
      Object.defineProperty(exports, "upperFirst", { enumerable: true, get: function() {
        return tslib_1.__importDefault(upper_first_1).default;
      } });
      var get_type_1 = require_get_type();
      Object.defineProperty(exports, "getType", { enumerable: true, get: function() {
        return tslib_1.__importDefault(get_type_1).default;
      } });
      var is_arguments_1 = require_is_arguments();
      Object.defineProperty(exports, "isArguments", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_arguments_1).default;
      } });
      var is_array_1 = require_is_array();
      Object.defineProperty(exports, "isArray", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_array_1).default;
      } });
      var is_array_like_1 = require_is_array_like();
      Object.defineProperty(exports, "isArrayLike", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_array_like_1).default;
      } });
      var is_boolean_1 = require_is_boolean();
      Object.defineProperty(exports, "isBoolean", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_boolean_1).default;
      } });
      var is_date_1 = require_is_date();
      Object.defineProperty(exports, "isDate", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_date_1).default;
      } });
      var is_error_1 = require_is_error();
      Object.defineProperty(exports, "isError", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_error_1).default;
      } });
      var is_function_1 = require_is_function();
      Object.defineProperty(exports, "isFunction", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_function_1).default;
      } });
      var is_finite_1 = require_is_finite();
      Object.defineProperty(exports, "isFinite", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_finite_1).default;
      } });
      var is_nil_1 = require_is_nil();
      Object.defineProperty(exports, "isNil", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_nil_1).default;
      } });
      var is_null_1 = require_is_null();
      Object.defineProperty(exports, "isNull", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_null_1).default;
      } });
      var is_number_1 = require_is_number();
      Object.defineProperty(exports, "isNumber", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_number_1).default;
      } });
      var is_object_1 = require_is_object();
      Object.defineProperty(exports, "isObject", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_object_1).default;
      } });
      var is_object_like_1 = require_is_object_like();
      Object.defineProperty(exports, "isObjectLike", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_object_like_1).default;
      } });
      var is_plain_object_1 = require_is_plain_object();
      Object.defineProperty(exports, "isPlainObject", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_plain_object_1).default;
      } });
      var is_prototype_1 = require_is_prototype();
      Object.defineProperty(exports, "isPrototype", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_prototype_1).default;
      } });
      var is_reg_exp_1 = require_is_reg_exp();
      Object.defineProperty(exports, "isRegExp", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_reg_exp_1).default;
      } });
      var is_string_1 = require_is_string();
      Object.defineProperty(exports, "isString", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_string_1).default;
      } });
      var is_type_1 = require_is_type();
      Object.defineProperty(exports, "isType", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_type_1).default;
      } });
      var is_undefined_1 = require_is_undefined();
      Object.defineProperty(exports, "isUndefined", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_undefined_1).default;
      } });
      var is_element_1 = require_is_element();
      Object.defineProperty(exports, "isElement", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_element_1).default;
      } });
      var request_animation_frame_1 = require_request_animation_frame();
      Object.defineProperty(exports, "requestAnimationFrame", { enumerable: true, get: function() {
        return tslib_1.__importDefault(request_animation_frame_1).default;
      } });
      var clear_animation_frame_1 = require_clear_animation_frame();
      Object.defineProperty(exports, "clearAnimationFrame", { enumerable: true, get: function() {
        return tslib_1.__importDefault(clear_animation_frame_1).default;
      } });
      var augment_1 = require_augment();
      Object.defineProperty(exports, "augment", { enumerable: true, get: function() {
        return tslib_1.__importDefault(augment_1).default;
      } });
      var clone_1 = require_clone();
      Object.defineProperty(exports, "clone", { enumerable: true, get: function() {
        return tslib_1.__importDefault(clone_1).default;
      } });
      var debounce_1 = require_debounce();
      Object.defineProperty(exports, "debounce", { enumerable: true, get: function() {
        return tslib_1.__importDefault(debounce_1).default;
      } });
      var memoize_1 = require_memoize();
      Object.defineProperty(exports, "memoize", { enumerable: true, get: function() {
        return tslib_1.__importDefault(memoize_1).default;
      } });
      var deep_mix_1 = require_deep_mix();
      Object.defineProperty(exports, "deepMix", { enumerable: true, get: function() {
        return tslib_1.__importDefault(deep_mix_1).default;
      } });
      var each_1 = require_each();
      Object.defineProperty(exports, "each", { enumerable: true, get: function() {
        return tslib_1.__importDefault(each_1).default;
      } });
      var extend_1 = require_extend();
      Object.defineProperty(exports, "extend", { enumerable: true, get: function() {
        return tslib_1.__importDefault(extend_1).default;
      } });
      var index_of_1 = require_index_of();
      Object.defineProperty(exports, "indexOf", { enumerable: true, get: function() {
        return tslib_1.__importDefault(index_of_1).default;
      } });
      var is_empty_1 = require_is_empty();
      Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_empty_1).default;
      } });
      var is_equal_1 = require_is_equal();
      Object.defineProperty(exports, "isEqual", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_equal_1).default;
      } });
      var is_equal_with_1 = require_is_equal_with();
      Object.defineProperty(exports, "isEqualWith", { enumerable: true, get: function() {
        return tslib_1.__importDefault(is_equal_with_1).default;
      } });
      var map_1 = require_map();
      Object.defineProperty(exports, "map", { enumerable: true, get: function() {
        return tslib_1.__importDefault(map_1).default;
      } });
      var map_values_1 = require_map_values();
      Object.defineProperty(exports, "mapValues", { enumerable: true, get: function() {
        return tslib_1.__importDefault(map_values_1).default;
      } });
      var mix_1 = require_mix();
      Object.defineProperty(exports, "mix", { enumerable: true, get: function() {
        return tslib_1.__importDefault(mix_1).default;
      } });
      Object.defineProperty(exports, "assign", { enumerable: true, get: function() {
        return tslib_1.__importDefault(mix_1).default;
      } });
      var get_1 = require_get();
      Object.defineProperty(exports, "get", { enumerable: true, get: function() {
        return tslib_1.__importDefault(get_1).default;
      } });
      var set_1 = require_set();
      Object.defineProperty(exports, "set", { enumerable: true, get: function() {
        return tslib_1.__importDefault(set_1).default;
      } });
      var pick_1 = require_pick();
      Object.defineProperty(exports, "pick", { enumerable: true, get: function() {
        return tslib_1.__importDefault(pick_1).default;
      } });
      var omit_1 = require_omit();
      Object.defineProperty(exports, "omit", { enumerable: true, get: function() {
        return tslib_1.__importDefault(omit_1).default;
      } });
      var throttle_1 = require_throttle();
      Object.defineProperty(exports, "throttle", { enumerable: true, get: function() {
        return tslib_1.__importDefault(throttle_1).default;
      } });
      var to_array_1 = require_to_array();
      Object.defineProperty(exports, "toArray", { enumerable: true, get: function() {
        return tslib_1.__importDefault(to_array_1).default;
      } });
      var to_string_1 = require_to_string();
      Object.defineProperty(exports, "toString", { enumerable: true, get: function() {
        return tslib_1.__importDefault(to_string_1).default;
      } });
      var unique_id_1 = require_unique_id();
      Object.defineProperty(exports, "uniqueId", { enumerable: true, get: function() {
        return tslib_1.__importDefault(unique_id_1).default;
      } });
      var noop_1 = require_noop();
      Object.defineProperty(exports, "noop", { enumerable: true, get: function() {
        return tslib_1.__importDefault(noop_1).default;
      } });
      var identity_1 = require_identity();
      Object.defineProperty(exports, "identity", { enumerable: true, get: function() {
        return tslib_1.__importDefault(identity_1).default;
      } });
      var size_1 = require_size();
      Object.defineProperty(exports, "size", { enumerable: true, get: function() {
        return tslib_1.__importDefault(size_1).default;
      } });
      var cache_1 = require_cache();
      Object.defineProperty(exports, "Cache", { enumerable: true, get: function() {
        return tslib_1.__importDefault(cache_1).default;
      } });
    }
  });

  // node_modules/@antv/util/lib/color/torgb.js
  var require_torgb = __commonJS({
    "node_modules/@antv/util/lib/color/torgb.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toRGB = void 0;
      var lodash_1 = require_lodash();
      var arr2rgb_1 = require_arr2rgb();
      var RGB_REG = /rgba?\(([\s.,0-9]+)\)/;
      function getTmp() {
        var i = document.getElementById("antv-web-colour-picker");
        if (i) {
          return i;
        }
        i = document.createElement("i");
        i.id = "antv-web-colour-picker";
        i.title = "Web Colour Picker";
        i.style.display = "none";
        document.body.appendChild(i);
        return i;
      }
      function toRGBString(color2) {
        if (color2[0] === "#" && color2.length === 7) {
          return color2;
        }
        var iEl = getTmp();
        iEl.style.color = color2;
        var rst = document.defaultView.getComputedStyle(iEl, "").getPropertyValue("color");
        var matches = RGB_REG.exec(rst);
        var cArray = matches[1].split(/\s*,\s*/).map(function(s) {
          return Number(s);
        });
        rst = (0, arr2rgb_1.arr2rgb)(cArray);
        return rst;
      }
      exports.toRGB = (0, lodash_1.memoize)(toRGBString, function(color2) {
        return color2;
      }, 256);
    }
  });

  // node_modules/@antv/util/lib/color/gradient.js
  var require_gradient = __commonJS({
    "node_modules/@antv/util/lib/color/gradient.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.gradient = gradient;
      var rgb2arr_1 = require_rgb2arr();
      var arr2rgb_1 = require_arr2rgb();
      var torgb_1 = require_torgb();
      function getValue(start, end, percent, index2) {
        return start[index2] + (end[index2] - start[index2]) * percent;
      }
      function calColor(points, percent) {
        var fixedPercent = isNaN(Number(percent)) || percent < 0 ? 0 : percent > 1 ? 1 : Number(percent);
        var steps = points.length - 1;
        var step2 = Math.floor(steps * fixedPercent);
        var left = steps * fixedPercent - step2;
        var start = points[step2];
        var end = step2 === steps ? start : points[step2 + 1];
        return (0, arr2rgb_1.arr2rgb)([getValue(start, end, left, 0), getValue(start, end, left, 1), getValue(start, end, left, 2)]);
      }
      function gradient(colors) {
        var colorArray = typeof colors === "string" ? colors.split("-") : colors;
        var points = colorArray.map(function(color2) {
          return (0, rgb2arr_1.rgb2arr)(color2.indexOf("#") === -1 ? (0, torgb_1.toRGB)(color2) : color2);
        });
        return function(percent) {
          return calColor(points, percent);
        };
      }
    }
  });

  // node_modules/@antv/util/lib/color/tocssgradient.js
  var require_tocssgradient = __commonJS({
    "node_modules/@antv/util/lib/color/tocssgradient.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toCSSGradient = toCSSGradient;
      var regexLG2 = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
      var regexRG2 = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
      var regexColorStop2 = /[\d.]+:(#[^\s]+|[^)]+\))/gi;
      function isGradientColor(val) {
        return /^[r,R,L,l]{1}[\s]*\(/.test(val);
      }
      function toCSSGradient(gradientColor) {
        if (isGradientColor(gradientColor)) {
          var cssColor_1;
          var steps = void 0;
          if (gradientColor[0] === "l") {
            var arr = regexLG2.exec(gradientColor);
            var angle2 = +arr[1] + 90;
            steps = arr[2];
            cssColor_1 = "linear-gradient(".concat(angle2, "deg, ");
          } else if (gradientColor[0] === "r") {
            cssColor_1 = "radial-gradient(";
            var arr = regexRG2.exec(gradientColor);
            steps = arr[4];
          }
          var colorStops_1 = steps.match(regexColorStop2);
          colorStops_1.forEach(function(item, index2) {
            var itemArr = item.split(":");
            cssColor_1 += "".concat(itemArr[1], " ").concat(Number(itemArr[0]) * 100, "%");
            if (index2 !== colorStops_1.length - 1) {
              cssColor_1 += ", ";
            }
          });
          cssColor_1 += ")";
          return cssColor_1;
        }
        return gradientColor;
      }
    }
  });

  // node_modules/@antv/util/lib/color/index.js
  var require_color = __commonJS({
    "node_modules/@antv/util/lib/color/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toCSSGradient = exports.toRGB = exports.gradient = exports.rgb2arr = void 0;
      var rgb2arr_1 = require_rgb2arr();
      Object.defineProperty(exports, "rgb2arr", { enumerable: true, get: function() {
        return rgb2arr_1.rgb2arr;
      } });
      var gradient_1 = require_gradient();
      Object.defineProperty(exports, "gradient", { enumerable: true, get: function() {
        return gradient_1.gradient;
      } });
      var torgb_1 = require_torgb();
      Object.defineProperty(exports, "toRGB", { enumerable: true, get: function() {
        return torgb_1.toRGB;
      } });
      var tocssgradient_1 = require_tocssgradient();
      Object.defineProperty(exports, "toCSSGradient", { enumerable: true, get: function() {
        return tocssgradient_1.toCSSGradient;
      } });
    }
  });

  // node_modules/@antv/util/lib/matrix/transform.js
  var require_transform = __commonJS({
    "node_modules/@antv/util/lib/matrix/transform.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.transform = transform;
      var gl_matrix_1 = require_cjs();
      function leftTranslate(out, a2, v) {
        var transMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        gl_matrix_1.mat3.fromTranslation(transMat, v);
        return gl_matrix_1.mat3.multiply(out, transMat, a2);
      }
      function leftRotate(out, a2, rad2) {
        var rotateMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        gl_matrix_1.mat3.fromRotation(rotateMat, rad2);
        return gl_matrix_1.mat3.multiply(out, rotateMat, a2);
      }
      function leftScale(out, a2, v) {
        var scaleMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        gl_matrix_1.mat3.fromScaling(scaleMat, v);
        return gl_matrix_1.mat3.multiply(out, scaleMat, a2);
      }
      function leftMultiply(out, a2, a1) {
        return gl_matrix_1.mat3.multiply(out, a1, a2);
      }
      function transform(m2, actions) {
        var matrix3 = m2 ? [].concat(m2) : [1, 0, 0, 0, 1, 0, 0, 0, 1];
        for (var i = 0, len = actions.length; i < len; i++) {
          var action = actions[i];
          switch (action[0]) {
            case "t":
              leftTranslate(matrix3, matrix3, [action[1], action[2]]);
              break;
            case "s":
              leftScale(matrix3, matrix3, [action[1], action[2]]);
              break;
            case "r":
              leftRotate(matrix3, matrix3, action[1]);
              break;
            case "m":
              leftMultiply(matrix3, matrix3, action[1]);
              break;
            default:
              break;
          }
        }
        return matrix3;
      }
    }
  });

  // node_modules/@antv/util/lib/matrix/direction.js
  var require_direction = __commonJS({
    "node_modules/@antv/util/lib/matrix/direction.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.direction = direction2;
      function direction2(v1, v2) {
        return v1[0] * v2[1] - v2[0] * v1[1];
      }
    }
  });

  // node_modules/@antv/util/lib/matrix/angle-to.js
  var require_angle_to = __commonJS({
    "node_modules/@antv/util/lib/matrix/angle-to.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.angleTo = angleTo;
      var gl_matrix_1 = require_cjs();
      var direction_1 = require_direction();
      function angleTo(v1, v2, direct) {
        var ang = gl_matrix_1.vec2.angle(v1, v2);
        var angleLargeThanPI = (0, direction_1.direction)(v1, v2) >= 0;
        if (direct) {
          if (angleLargeThanPI) {
            return Math.PI * 2 - ang;
          }
          return ang;
        }
        if (angleLargeThanPI) {
          return ang;
        }
        return Math.PI * 2 - ang;
      }
    }
  });

  // node_modules/@antv/util/lib/matrix/vertical.js
  var require_vertical = __commonJS({
    "node_modules/@antv/util/lib/matrix/vertical.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.vertical = vertical2;
      function vertical2(out, v, flag) {
        if (flag) {
          out[0] = v[1];
          out[1] = -1 * v[0];
        } else {
          out[0] = -1 * v[1];
          out[1] = v[0];
        }
        return out;
      }
    }
  });

  // node_modules/@antv/util/lib/matrix/index.js
  var require_matrix = __commonJS({
    "node_modules/@antv/util/lib/matrix/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.vertical = exports.direction = exports.angleTo = exports.transform = void 0;
      var transform_1 = require_transform();
      Object.defineProperty(exports, "transform", { enumerable: true, get: function() {
        return transform_1.transform;
      } });
      var angle_to_1 = require_angle_to();
      Object.defineProperty(exports, "angleTo", { enumerable: true, get: function() {
        return angle_to_1.angleTo;
      } });
      var direction_1 = require_direction();
      Object.defineProperty(exports, "direction", { enumerable: true, get: function() {
        return direction_1.direction;
      } });
      var vertical_1 = require_vertical();
      Object.defineProperty(exports, "vertical", { enumerable: true, get: function() {
        return vertical_1.vertical;
      } });
    }
  });

  // node_modules/@antv/util/lib/path/process/round-path.js
  var require_round_path = __commonJS({
    "node_modules/@antv/util/lib/path/process/round-path.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.roundPath = roundPath;
      function roundPath(path, round3) {
        if (round3 === "off")
          return [].concat(path);
        var pow2 = typeof round3 === "number" && round3 >= 1 ? Math.pow(10, round3) : 1;
        return path.map(function(pi) {
          var values2 = pi.slice(1).map(Number).map(function(n) {
            return round3 ? Math.round(n * pow2) / pow2 : Math.round(n);
          });
          return [pi[0]].concat(values2);
        });
      }
    }
  });

  // node_modules/@antv/util/lib/path/convert/path-2-string.js
  var require_path_2_string = __commonJS({
    "node_modules/@antv/util/lib/path/convert/path-2-string.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.path2String = path2String;
      var round_path_1 = require_round_path();
      function path2String(path, round3) {
        if (round3 === void 0) {
          round3 = "off";
        }
        return (0, round_path_1.roundPath)(path, round3).map(function(x3) {
          return x3[0] + x3.slice(1).join(" ");
        }).join("");
      }
    }
  });

  // node_modules/@antv/util/lib/path/parser/params-parser.js
  var require_params_parser = __commonJS({
    "node_modules/@antv/util/lib/path/parser/params-parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.paramsParser = void 0;
      exports.paramsParser = {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        x: 0,
        y: 0,
        qx: null,
        qy: null
      };
    }
  });

  // node_modules/@antv/util/lib/path/process/fix-arc.js
  var require_fix_arc = __commonJS({
    "node_modules/@antv/util/lib/path/process/fix-arc.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fixArc = fixArc;
      function fixArc(pathArray, allPathCommands, i) {
        if (pathArray[i].length > 7) {
          pathArray[i].shift();
          var pi = pathArray[i];
          var ni = i;
          while (pi.length) {
            allPathCommands[i] = "A";
            pathArray.splice(ni += 1, 0, ["C"].concat(pi.splice(0, 6)));
          }
          pathArray.splice(i, 1);
        }
      }
    }
  });

  // node_modules/@antv/util/lib/path/parser/params-count.js
  var require_params_count = __commonJS({
    "node_modules/@antv/util/lib/path/parser/params-count.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.paramsCount = void 0;
      exports.paramsCount = {
        a: 7,
        c: 6,
        h: 1,
        l: 2,
        m: 2,
        r: 4,
        q: 4,
        s: 4,
        t: 2,
        v: 1,
        z: 0
      };
    }
  });

  // node_modules/@antv/util/lib/path/util/is-path-array.js
  var require_is_path_array = __commonJS({
    "node_modules/@antv/util/lib/path/util/is-path-array.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isPathArray = isPathArray;
      var params_count_1 = require_params_count();
      function isPathArray(path) {
        return Array.isArray(path) && path.every(function(seg) {
          var lk = seg[0].toLowerCase();
          return params_count_1.paramsCount[lk] === seg.length - 1 && "achlmqstvz".includes(lk);
        });
      }
    }
  });

  // node_modules/@antv/util/lib/path/util/is-absolute-array.js
  var require_is_absolute_array = __commonJS({
    "node_modules/@antv/util/lib/path/util/is-absolute-array.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isAbsoluteArray = isAbsoluteArray;
      var is_path_array_1 = require_is_path_array();
      function isAbsoluteArray(path) {
        return (0, is_path_array_1.isPathArray)(path) && // @ts-ignore -- `isPathArray` also checks if it's `Array`
        path.every(function(_a2) {
          var x3 = _a2[0];
          return x3 === x3.toUpperCase();
        });
      }
    }
  });

  // node_modules/@antv/util/lib/path/util/is-normalized-array.js
  var require_is_normalized_array = __commonJS({
    "node_modules/@antv/util/lib/path/util/is-normalized-array.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isNormalizedArray = isNormalizedArray;
      var is_absolute_array_1 = require_is_absolute_array();
      function isNormalizedArray(path) {
        return (0, is_absolute_array_1.isAbsoluteArray)(path) && path.every(function(_a2) {
          var pc = _a2[0];
          return "ACLMQZ".includes(pc);
        });
      }
    }
  });

  // node_modules/@antv/util/lib/path/parser/finalize-segment.js
  var require_finalize_segment = __commonJS({
    "node_modules/@antv/util/lib/path/parser/finalize-segment.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.finalizeSegment = finalizeSegment;
      var params_count_1 = require_params_count();
      function finalizeSegment(path) {
        var pathCommand = path.pathValue[path.segmentStart];
        var LK = pathCommand.toLowerCase();
        var data2 = path.data;
        while (data2.length >= params_count_1.paramsCount[LK]) {
          if (LK === "m" && data2.length > 2) {
            path.segments.push([pathCommand].concat(data2.splice(0, 2)));
            LK = "l";
            pathCommand = pathCommand === "m" ? "l" : "L";
          } else {
            path.segments.push([pathCommand].concat(data2.splice(0, params_count_1.paramsCount[LK])));
          }
          if (!params_count_1.paramsCount[LK]) {
            break;
          }
        }
      }
    }
  });

  // node_modules/@antv/util/lib/path/parser/scan-flag.js
  var require_scan_flag = __commonJS({
    "node_modules/@antv/util/lib/path/parser/scan-flag.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.scanFlag = scanFlag;
      function scanFlag(path) {
        var index2 = path.index, pathValue = path.pathValue;
        var code = pathValue.charCodeAt(index2);
        if (code === 48) {
          path.param = 0;
          path.index += 1;
          return;
        }
        if (code === 49) {
          path.param = 1;
          path.index += 1;
          return;
        }
        path.err = '[path-util]: invalid Arc flag "'.concat(pathValue[index2], '", expecting 0 or 1 at index ').concat(index2);
      }
    }
  });

  // node_modules/@antv/util/lib/path/parser/is-digit-start.js
  var require_is_digit_start = __commonJS({
    "node_modules/@antv/util/lib/path/parser/is-digit-start.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isDigitStart = isDigitStart;
      exports.isDigit = isDigit;
      function isDigitStart(code) {
        return code >= 48 && code <= 57 || code === 43 || code === 45 || code === 46;
      }
      function isDigit(code) {
        return code >= 48 && code <= 57;
      }
    }
  });

  // node_modules/@antv/util/lib/path/parser/scan-param.js
  var require_scan_param = __commonJS({
    "node_modules/@antv/util/lib/path/parser/scan-param.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.scanParam = scanParam;
      var is_digit_start_1 = require_is_digit_start();
      function scanParam(path) {
        var max4 = path.max, pathValue = path.pathValue, start = path.index;
        var index2 = start;
        var zeroFirst = false;
        var hasCeiling = false;
        var hasDecimal = false;
        var hasDot = false;
        var ch;
        if (index2 >= max4) {
          path.err = "[path-util]: Invalid path value at index ".concat(index2, ', "pathValue" is missing param');
          return;
        }
        ch = pathValue.charCodeAt(index2);
        if (ch === 43 || ch === 45) {
          index2 += 1;
          ch = pathValue.charCodeAt(index2);
        }
        if (!(0, is_digit_start_1.isDigit)(ch) && ch !== 46) {
          path.err = "[path-util]: Invalid path value at index ".concat(index2, ', "').concat(pathValue[index2], '" is not a number');
          return;
        }
        if (ch !== 46) {
          zeroFirst = ch === 48;
          index2 += 1;
          ch = pathValue.charCodeAt(index2);
          if (zeroFirst && index2 < max4) {
            if (ch && (0, is_digit_start_1.isDigit)(ch)) {
              path.err = "[path-util]: Invalid path value at index ".concat(start, ', "').concat(pathValue[start], '" illegal number');
              return;
            }
          }
          while (index2 < max4 && (0, is_digit_start_1.isDigit)(pathValue.charCodeAt(index2))) {
            index2 += 1;
            hasCeiling = true;
          }
          ch = pathValue.charCodeAt(index2);
        }
        if (ch === 46) {
          hasDot = true;
          index2 += 1;
          while ((0, is_digit_start_1.isDigit)(pathValue.charCodeAt(index2))) {
            index2 += 1;
            hasDecimal = true;
          }
          ch = pathValue.charCodeAt(index2);
        }
        if (ch === 101 || ch === 69) {
          if (hasDot && !hasCeiling && !hasDecimal) {
            path.err = "[path-util]: Invalid path value at index ".concat(index2, ', "').concat(pathValue[index2], '" invalid float exponent');
            return;
          }
          index2 += 1;
          ch = pathValue.charCodeAt(index2);
          if (ch === 43 || ch === 45) {
            index2 += 1;
          }
          if (index2 < max4 && (0, is_digit_start_1.isDigit)(pathValue.charCodeAt(index2))) {
            while (index2 < max4 && (0, is_digit_start_1.isDigit)(pathValue.charCodeAt(index2))) {
              index2 += 1;
            }
          } else {
            path.err = "[path-util]: Invalid path value at index ".concat(index2, ', "').concat(pathValue[index2], '" invalid integer exponent');
            return;
          }
        }
        path.index = index2;
        path.param = +path.pathValue.slice(start, index2);
      }
    }
  });

  // node_modules/@antv/util/lib/path/parser/is-space.js
  var require_is_space = __commonJS({
    "node_modules/@antv/util/lib/path/parser/is-space.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isSpace = isSpace;
      function isSpace(ch) {
        var specialSpaces = [
          5760,
          6158,
          8192,
          8193,
          8194,
          8195,
          8196,
          8197,
          8198,
          8199,
          8200,
          8201,
          8202,
          8239,
          8287,
          12288,
          65279
        ];
        return ch === 10 || ch === 13 || ch === 8232 || ch === 8233 || // Line terminators
        // White spaces
        ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch >= 5760 && specialSpaces.includes(ch);
      }
    }
  });

  // node_modules/@antv/util/lib/path/parser/skip-spaces.js
  var require_skip_spaces = __commonJS({
    "node_modules/@antv/util/lib/path/parser/skip-spaces.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.skipSpaces = skipSpaces;
      var is_space_1 = require_is_space();
      function skipSpaces(path) {
        var pathValue = path.pathValue, max4 = path.max;
        while (path.index < max4 && (0, is_space_1.isSpace)(pathValue.charCodeAt(path.index))) {
          path.index += 1;
        }
      }
    }
  });

  // node_modules/@antv/util/lib/path/parser/is-path-command.js
  var require_is_path_command = __commonJS({
    "node_modules/@antv/util/lib/path/parser/is-path-command.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isPathCommand = isPathCommand;
      function isPathCommand(code) {
        switch (code | 32) {
          case 109:
          case 122:
          case 108:
          case 104:
          case 118:
          case 99:
          case 115:
          case 113:
          case 116:
          case 97:
            return true;
          default:
            return false;
        }
      }
    }
  });

  // node_modules/@antv/util/lib/path/parser/is-arc-command.js
  var require_is_arc_command = __commonJS({
    "node_modules/@antv/util/lib/path/parser/is-arc-command.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isArcCommand = isArcCommand;
      function isArcCommand(code) {
        return (code | 32) === 97;
      }
    }
  });

  // node_modules/@antv/util/lib/path/parser/scan-segment.js
  var require_scan_segment = __commonJS({
    "node_modules/@antv/util/lib/path/parser/scan-segment.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.scanSegment = scanSegment;
      var finalize_segment_1 = require_finalize_segment();
      var params_count_1 = require_params_count();
      var scan_flag_1 = require_scan_flag();
      var scan_param_1 = require_scan_param();
      var skip_spaces_1 = require_skip_spaces();
      var is_path_command_1 = require_is_path_command();
      var is_digit_start_1 = require_is_digit_start();
      var is_arc_command_1 = require_is_arc_command();
      function scanSegment(path) {
        var max4 = path.max, pathValue = path.pathValue, index2 = path.index;
        var cmdCode = pathValue.charCodeAt(index2);
        var reqParams = params_count_1.paramsCount[pathValue[index2].toLowerCase()];
        path.segmentStart = index2;
        if (!(0, is_path_command_1.isPathCommand)(cmdCode)) {
          path.err = '[path-util]: Invalid path value "'.concat(pathValue[index2], '" is not a path command');
          return;
        }
        path.index += 1;
        (0, skip_spaces_1.skipSpaces)(path);
        path.data = [];
        if (!reqParams) {
          (0, finalize_segment_1.finalizeSegment)(path);
          return;
        }
        for (; ; ) {
          for (var i = reqParams; i > 0; i -= 1) {
            if ((0, is_arc_command_1.isArcCommand)(cmdCode) && (i === 3 || i === 4))
              (0, scan_flag_1.scanFlag)(path);
            else
              (0, scan_param_1.scanParam)(path);
            if (path.err.length) {
              return;
            }
            path.data.push(path.param);
            (0, skip_spaces_1.skipSpaces)(path);
            if (path.index < max4 && pathValue.charCodeAt(path.index) === 44) {
              path.index += 1;
              (0, skip_spaces_1.skipSpaces)(path);
            }
          }
          if (path.index >= path.max) {
            break;
          }
          if (!(0, is_digit_start_1.isDigitStart)(pathValue.charCodeAt(path.index))) {
            break;
          }
        }
        (0, finalize_segment_1.finalizeSegment)(path);
      }
    }
  });

  // node_modules/@antv/util/lib/path/parser/path-parser.js
  var require_path_parser = __commonJS({
    "node_modules/@antv/util/lib/path/parser/path-parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PathParser = void 0;
      var PathParser = (
        /** @class */
        /* @__PURE__ */ (function() {
          function PathParser2(pathString) {
            this.pathValue = pathString;
            this.segments = [];
            this.max = pathString.length;
            this.index = 0;
            this.param = 0;
            this.segmentStart = 0;
            this.data = [];
            this.err = "";
          }
          return PathParser2;
        })()
      );
      exports.PathParser = PathParser;
    }
  });

  // node_modules/@antv/util/lib/path/parser/parse-path-string.js
  var require_parse_path_string = __commonJS({
    "node_modules/@antv/util/lib/path/parser/parse-path-string.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parsePathString = parsePathString;
      var is_path_array_1 = require_is_path_array();
      var scan_segment_1 = require_scan_segment();
      var skip_spaces_1 = require_skip_spaces();
      var path_parser_1 = require_path_parser();
      function parsePathString(pathInput) {
        if ((0, is_path_array_1.isPathArray)(pathInput)) {
          return [].concat(pathInput);
        }
        var path = new path_parser_1.PathParser(pathInput);
        (0, skip_spaces_1.skipSpaces)(path);
        while (path.index < path.max && !path.err.length) {
          (0, scan_segment_1.scanSegment)(path);
        }
        return path.err ? path.err : path.segments;
      }
    }
  });

  // node_modules/@antv/util/lib/path/convert/path-2-absolute.js
  var require_path_2_absolute = __commonJS({
    "node_modules/@antv/util/lib/path/convert/path-2-absolute.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.path2Absolute = path2Absolute;
      var is_absolute_array_1 = require_is_absolute_array();
      var parse_path_string_1 = require_parse_path_string();
      function path2Absolute(pathInput) {
        if ((0, is_absolute_array_1.isAbsoluteArray)(pathInput)) {
          return [].concat(pathInput);
        }
        var path = (0, parse_path_string_1.parsePathString)(pathInput);
        var x3 = 0;
        var y3 = 0;
        var mx = 0;
        var my = 0;
        return path.map(function(segment) {
          var values2 = segment.slice(1).map(Number);
          var pathCommand = segment[0];
          var absCommand = pathCommand.toUpperCase();
          if (pathCommand === "M") {
            x3 = values2[0], y3 = values2[1];
            mx = x3;
            my = y3;
            return ["M", x3, y3];
          }
          var absoluteSegment;
          if (pathCommand !== absCommand) {
            switch (absCommand) {
              case "A":
                absoluteSegment = [
                  absCommand,
                  values2[0],
                  values2[1],
                  values2[2],
                  values2[3],
                  values2[4],
                  values2[5] + x3,
                  values2[6] + y3
                ];
                break;
              case "V":
                absoluteSegment = [absCommand, values2[0] + y3];
                break;
              case "H":
                absoluteSegment = [absCommand, values2[0] + x3];
                break;
              default: {
                var absValues = values2.map(function(n, j) {
                  return n + (j % 2 ? y3 : x3);
                });
                absoluteSegment = [absCommand].concat(absValues);
              }
            }
          } else {
            absoluteSegment = [absCommand].concat(values2);
          }
          var segLength = absoluteSegment.length;
          switch (absCommand) {
            case "Z":
              x3 = mx;
              y3 = my;
              break;
            case "H":
              x3 = absoluteSegment[1];
              break;
            case "V":
              y3 = absoluteSegment[1];
              break;
            default:
              x3 = absoluteSegment[segLength - 2];
              y3 = absoluteSegment[segLength - 1];
              if (absCommand === "M") {
                mx = x3;
                my = y3;
              }
          }
          return absoluteSegment;
        });
      }
    }
  });

  // node_modules/@antv/util/lib/path/process/normalize-segment.js
  var require_normalize_segment = __commonJS({
    "node_modules/@antv/util/lib/path/process/normalize-segment.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.normalizeSegment = normalizeSegment;
      function normalizeSegment(segment, params) {
        var pathCommand = segment[0];
        var px1 = params.x1, py1 = params.y1, px2 = params.x2, py2 = params.y2;
        var values2 = segment.slice(1).map(Number);
        var result = segment;
        if (!"TQ".includes(pathCommand)) {
          params.qx = null;
          params.qy = null;
        }
        if (pathCommand === "H") {
          result = ["L", segment[1], py1];
        } else if (pathCommand === "V") {
          result = ["L", px1, segment[1]];
        } else if (pathCommand === "S") {
          var x1 = px1 * 2 - px2;
          var y1 = py1 * 2 - py2;
          params.x1 = x1;
          params.y1 = y1;
          result = ["C", x1, y1].concat(values2);
        } else if (pathCommand === "T") {
          var qx = px1 * 2 - params.qx;
          var qy = py1 * 2 - params.qy;
          params.qx = qx;
          params.qy = qy;
          result = ["Q", qx, qy].concat(values2);
        } else if (pathCommand === "Q") {
          var nqx = values2[0], nqy = values2[1];
          params.qx = nqx;
          params.qy = nqy;
        }
        return result;
      }
    }
  });

  // node_modules/@antv/util/lib/path/process/normalize-path.js
  var require_normalize_path = __commonJS({
    "node_modules/@antv/util/lib/path/process/normalize-path.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.normalizePath = normalizePath2;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var is_normalized_array_1 = require_is_normalized_array();
      var params_parser_1 = require_params_parser();
      var path_2_absolute_1 = require_path_2_absolute();
      var normalize_segment_1 = require_normalize_segment();
      function normalizePath2(pathInput) {
        if ((0, is_normalized_array_1.isNormalizedArray)(pathInput)) {
          return [].concat(pathInput);
        }
        var path = (0, path_2_absolute_1.path2Absolute)(pathInput);
        var params = tslib_1.__assign({}, params_parser_1.paramsParser);
        for (var i = 0; i < path.length; i += 1) {
          path[i] = (0, normalize_segment_1.normalizeSegment)(path[i], params);
          var segment = path[i];
          var seglen = segment.length;
          params.x1 = +segment[seglen - 2];
          params.y1 = +segment[seglen - 1];
          params.x2 = +segment[seglen - 4] || params.x1;
          params.y2 = +segment[seglen - 3] || params.y1;
        }
        return path;
      }
    }
  });

  // node_modules/@antv/util/lib/path/util/is-curve-array.js
  var require_is_curve_array = __commonJS({
    "node_modules/@antv/util/lib/path/util/is-curve-array.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isCurveArray = isCurveArray;
      var is_normalized_array_1 = require_is_normalized_array();
      function isCurveArray(path) {
        return (0, is_normalized_array_1.isNormalizedArray)(path) && path.every(function(_a2) {
          var pc = _a2[0];
          return "MC".includes(pc);
        });
      }
    }
  });

  // node_modules/@antv/util/lib/path/util/rotate-vector.js
  var require_rotate_vector = __commonJS({
    "node_modules/@antv/util/lib/path/util/rotate-vector.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.rotateVector = rotateVector;
      function rotateVector(x3, y3, rad2) {
        var X = x3 * Math.cos(rad2) - y3 * Math.sin(rad2);
        var Y = x3 * Math.sin(rad2) + y3 * Math.cos(rad2);
        return { x: X, y: Y };
      }
    }
  });

  // node_modules/@antv/util/lib/path/process/arc-2-cubic.js
  var require_arc_2_cubic = __commonJS({
    "node_modules/@antv/util/lib/path/process/arc-2-cubic.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.arcToCubic = arcToCubic2;
      var rotate_vector_1 = require_rotate_vector();
      function arcToCubic2(X1, Y1, RX, RY, angle2, LAF, SF, X2, Y2, recursive) {
        var x1 = X1;
        var y1 = Y1;
        var rx = RX;
        var ry = RY;
        var x22 = X2;
        var y22 = Y2;
        var d120 = Math.PI * 120 / 180;
        var rad2 = Math.PI / 180 * (+angle2 || 0);
        var res = [];
        var xy;
        var f1;
        var f2;
        var cx;
        var cy;
        if (!recursive) {
          xy = (0, rotate_vector_1.rotateVector)(x1, y1, -rad2);
          x1 = xy.x;
          y1 = xy.y;
          xy = (0, rotate_vector_1.rotateVector)(x22, y22, -rad2);
          x22 = xy.x;
          y22 = xy.y;
          var x3 = (x1 - x22) / 2;
          var y3 = (y1 - y22) / 2;
          var h = x3 * x3 / (rx * rx) + y3 * y3 / (ry * ry);
          if (h > 1) {
            h = Math.sqrt(h);
            rx *= h;
            ry *= h;
          }
          var rx2 = rx * rx;
          var ry2 = ry * ry;
          var k = (LAF === SF ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y3 * y3 - ry2 * x3 * x3) / (rx2 * y3 * y3 + ry2 * x3 * x3)));
          cx = k * rx * y3 / ry + (x1 + x22) / 2;
          cy = k * -ry * x3 / rx + (y1 + y22) / 2;
          f1 = Math.asin(((y1 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
          f2 = Math.asin(((y22 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
          f1 = x1 < cx ? Math.PI - f1 : f1;
          f2 = x22 < cx ? Math.PI - f2 : f2;
          if (f1 < 0)
            f1 = Math.PI * 2 + f1;
          if (f2 < 0)
            f2 = Math.PI * 2 + f2;
          if (SF && f1 > f2) {
            f1 -= Math.PI * 2;
          }
          if (!SF && f2 > f1) {
            f2 -= Math.PI * 2;
          }
        } else {
          f1 = recursive[0], f2 = recursive[1], cx = recursive[2], cy = recursive[3];
        }
        var df = f2 - f1;
        if (Math.abs(df) > d120) {
          var f2old = f2;
          var x2old = x22;
          var y2old = y22;
          f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);
          x22 = cx + rx * Math.cos(f2);
          y22 = cy + ry * Math.sin(f2);
          res = arcToCubic2(x22, y22, rx, ry, angle2, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);
        }
        df = f2 - f1;
        var c1 = Math.cos(f1);
        var s1 = Math.sin(f1);
        var c2 = Math.cos(f2);
        var s2 = Math.sin(f2);
        var t = Math.tan(df / 4);
        var hx = 4 / 3 * rx * t;
        var hy = 4 / 3 * ry * t;
        var m1 = [x1, y1];
        var m2 = [x1 + hx * s1, y1 - hy * c1];
        var m3 = [x22 + hx * s2, y22 - hy * c2];
        var m4 = [x22, y22];
        m2[0] = 2 * m1[0] - m2[0];
        m2[1] = 2 * m1[1] - m2[1];
        if (recursive) {
          return m2.concat(m3, m4, res);
        }
        res = m2.concat(m3, m4, res);
        var newres = [];
        for (var i = 0, ii = res.length; i < ii; i += 1) {
          newres[i] = i % 2 ? (0, rotate_vector_1.rotateVector)(res[i - 1], res[i], rad2).y : (0, rotate_vector_1.rotateVector)(res[i], res[i + 1], rad2).x;
        }
        return newres;
      }
    }
  });

  // node_modules/@antv/util/lib/path/process/quad-2-cubic.js
  var require_quad_2_cubic = __commonJS({
    "node_modules/@antv/util/lib/path/process/quad-2-cubic.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.quadToCubic = quadToCubic;
      function quadToCubic(x1, y1, qx, qy, x22, y22) {
        var r13 = 1 / 3;
        var r23 = 2 / 3;
        return [
          r13 * x1 + r23 * qx,
          // cpx1
          r13 * y1 + r23 * qy,
          // cpy1
          r13 * x22 + r23 * qx,
          // cpx2
          r13 * y22 + r23 * qy,
          // cpy2
          x22,
          y22
          // x,y
        ];
      }
    }
  });

  // node_modules/@antv/util/lib/path/util/mid-point.js
  var require_mid_point = __commonJS({
    "node_modules/@antv/util/lib/path/util/mid-point.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.midPoint = midPoint;
      function midPoint(a2, b, t) {
        var ax = a2[0];
        var ay = a2[1];
        var bx = b[0];
        var by = b[1];
        return [ax + (bx - ax) * t, ay + (by - ay) * t];
      }
    }
  });

  // node_modules/@antv/util/lib/path/process/line-2-cubic.js
  var require_line_2_cubic = __commonJS({
    "node_modules/@antv/util/lib/path/process/line-2-cubic.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.lineToCubic = void 0;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var mid_point_1 = require_mid_point();
      var lineToCubic = function(x1, y1, x22, y22) {
        var t = 0.5;
        var mid = (0, mid_point_1.midPoint)([x1, y1], [x22, y22], t);
        return tslib_1.__spreadArray(tslib_1.__spreadArray([], mid, true), [x22, y22, x22, y22], false);
      };
      exports.lineToCubic = lineToCubic;
    }
  });

  // node_modules/@antv/util/lib/path/process/segment-2-cubic.js
  var require_segment_2_cubic = __commonJS({
    "node_modules/@antv/util/lib/path/process/segment-2-cubic.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.segmentToCubic = segmentToCubic;
      var arc_2_cubic_1 = require_arc_2_cubic();
      var quad_2_cubic_1 = require_quad_2_cubic();
      var line_2_cubic_1 = require_line_2_cubic();
      function segmentToCubic(segment, params) {
        var pathCommand = segment[0];
        var values2 = segment.slice(1).map(Number);
        var x3 = values2[0], y3 = values2[1];
        var args;
        var px1 = params.x1, py1 = params.y1, px = params.x, py = params.y;
        if (!"TQ".includes(pathCommand)) {
          params.qx = null;
          params.qy = null;
        }
        switch (pathCommand) {
          case "M":
            params.x = x3;
            params.y = y3;
            return segment;
          case "A":
            args = [px1, py1].concat(values2);
            return ["C"].concat((0, arc_2_cubic_1.arcToCubic)(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]));
          case "Q":
            params.qx = x3;
            params.qy = y3;
            args = [px1, py1].concat(values2);
            return ["C"].concat((0, quad_2_cubic_1.quadToCubic)(args[0], args[1], args[2], args[3], args[4], args[5]));
          case "L":
            return ["C"].concat((0, line_2_cubic_1.lineToCubic)(px1, py1, x3, y3));
          case "Z":
            if (px1 === px && py1 === py) {
              return ["C", px1, py1, px, py, px, py];
            }
            return ["C"].concat((0, line_2_cubic_1.lineToCubic)(px1, py1, px, py));
          default:
        }
        return segment;
      }
    }
  });

  // node_modules/@antv/util/lib/path/convert/path-2-curve.js
  var require_path_2_curve = __commonJS({
    "node_modules/@antv/util/lib/path/convert/path-2-curve.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.path2Curve = path2Curve2;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var params_parser_1 = require_params_parser();
      var fix_arc_1 = require_fix_arc();
      var normalize_path_1 = require_normalize_path();
      var is_curve_array_1 = require_is_curve_array();
      var segment_2_cubic_1 = require_segment_2_cubic();
      function path2Curve2(pathInput, needZCommandIndexes) {
        if (needZCommandIndexes === void 0) {
          needZCommandIndexes = false;
        }
        if ((0, is_curve_array_1.isCurveArray)(pathInput)) {
          var cloned = [].concat(pathInput);
          if (needZCommandIndexes) {
            return [cloned, []];
          } else {
            return cloned;
          }
        }
        var path = (0, normalize_path_1.normalizePath)(pathInput);
        var params = tslib_1.__assign({}, params_parser_1.paramsParser);
        var allPathCommands = [];
        var pathCommand = "";
        var ii = path.length;
        var segment;
        var seglen;
        var zCommandIndexes = [];
        for (var i = 0; i < ii; i += 1) {
          if (path[i])
            pathCommand = path[i][0];
          allPathCommands[i] = pathCommand;
          var curveSegment = (0, segment_2_cubic_1.segmentToCubic)(path[i], params);
          path[i] = curveSegment;
          (0, fix_arc_1.fixArc)(path, allPathCommands, i);
          ii = path.length;
          if (pathCommand === "Z") {
            zCommandIndexes.push(i);
          }
          segment = path[i];
          seglen = segment.length;
          params.x1 = +segment[seglen - 2];
          params.y1 = +segment[seglen - 1];
          params.x2 = +segment[seglen - 4] || params.x1;
          params.y2 = +segment[seglen - 3] || params.y1;
        }
        if (needZCommandIndexes) {
          return [path, zCommandIndexes];
        } else {
          return path;
        }
      }
    }
  });

  // node_modules/@antv/util/lib/path/convert/path-2-array.js
  var require_path_2_array = __commonJS({
    "node_modules/@antv/util/lib/path/convert/path-2-array.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.path2Array = path2Array;
      var parse_path_string_1 = require_parse_path_string();
      function path2Array(pathInput) {
        return (0, parse_path_string_1.parsePathString)(pathInput);
      }
    }
  });

  // node_modules/@antv/util/lib/path/process/clone-path.js
  var require_clone_path = __commonJS({
    "node_modules/@antv/util/lib/path/process/clone-path.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.clonePath = clonePath2;
      function clonePath2(path) {
        return path.map(function(x3) {
          return Array.isArray(x3) ? [].concat(x3) : x3;
        });
      }
    }
  });

  // node_modules/@antv/util/lib/path/process/reverse-curve.js
  var require_reverse_curve = __commonJS({
    "node_modules/@antv/util/lib/path/process/reverse-curve.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.reverseCurve = reverseCurve2;
      function reverseCurve2(pathArray) {
        var rotatedCurve = pathArray.slice(1).map(function(x3, i, curveOnly) {
          return !i ? pathArray[0].slice(1).concat(x3.slice(1)) : curveOnly[i - 1].slice(-2).concat(x3.slice(1));
        }).map(function(x3) {
          return x3.map(function(y3, i) {
            return x3[x3.length - i - 2 * (1 - i % 2)];
          });
        }).reverse();
        return [["M"].concat(rotatedCurve[0].slice(0, 2))].concat(rotatedCurve.map(function(x3) {
          return ["C"].concat(x3.slice(2));
        }));
      }
    }
  });

  // node_modules/@antv/util/lib/path/util/distance-square-root.js
  var require_distance_square_root = __commonJS({
    "node_modules/@antv/util/lib/path/util/distance-square-root.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.distanceSquareRoot = distanceSquareRoot3;
      function distanceSquareRoot3(a2, b) {
        return Math.sqrt((a2[0] - b[0]) * (a2[0] - b[0]) + (a2[1] - b[1]) * (a2[1] - b[1]));
      }
    }
  });

  // node_modules/@antv/util/lib/path/util/segment-line-factory.js
  var require_segment_line_factory = __commonJS({
    "node_modules/@antv/util/lib/path/util/segment-line-factory.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.segmentLineFactory = segmentLineFactory;
      var mid_point_1 = require_mid_point();
      var distance_square_root_1 = require_distance_square_root();
      function segmentLineFactory(x1, y1, x22, y22, distance6) {
        var length = (0, distance_square_root_1.distanceSquareRoot)([x1, y1], [x22, y22]);
        var point4 = { x: 0, y: 0 };
        if (typeof distance6 === "number") {
          if (distance6 <= 0) {
            point4 = { x: x1, y: y1 };
          } else if (distance6 >= length) {
            point4 = { x: x22, y: y22 };
          } else {
            var _a2 = (0, mid_point_1.midPoint)([x1, y1], [x22, y22], distance6 / length), x3 = _a2[0], y3 = _a2[1];
            point4 = { x: x3, y: y3 };
          }
        }
        return {
          length,
          point: point4,
          min: {
            x: Math.min(x1, x22),
            y: Math.min(y1, y22)
          },
          max: {
            x: Math.max(x1, x22),
            y: Math.max(y1, y22)
          }
        };
      }
    }
  });

  // node_modules/@antv/util/lib/path/util/segment-arc-factory.js
  var require_segment_arc_factory = __commonJS({
    "node_modules/@antv/util/lib/path/util/segment-arc-factory.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.segmentArcFactory = segmentArcFactory;
      var segment_line_factory_1 = require_segment_line_factory();
      var distance_square_root_1 = require_distance_square_root();
      function angleBetween3(v0, v1) {
        var v0x = v0.x, v0y = v0.y;
        var v1x = v1.x, v1y = v1.y;
        var p = v0x * v1x + v0y * v1y;
        var n = Math.sqrt((Math.pow(v0x, 2) + Math.pow(v0y, 2)) * (Math.pow(v1x, 2) + Math.pow(v1y, 2)));
        var sign = v0x * v1y - v0y * v1x < 0 ? -1 : 1;
        var angle2 = sign * Math.acos(p / n);
        return angle2;
      }
      function getPointAtArcSegmentLength(x1, y1, RX, RY, angle2, LAF, SF, x3, y3, t) {
        var abs = Math.abs, sin = Math.sin, cos = Math.cos, sqrt2 = Math.sqrt, PI = Math.PI;
        var rx = abs(RX);
        var ry = abs(RY);
        var xRot = (angle2 % 360 + 360) % 360;
        var xRotRad = xRot * (PI / 180);
        if (x1 === x3 && y1 === y3) {
          return { x: x1, y: y1 };
        }
        if (rx === 0 || ry === 0) {
          return (0, segment_line_factory_1.segmentLineFactory)(x1, y1, x3, y3, t).point;
        }
        var dx = (x1 - x3) / 2;
        var dy = (y1 - y3) / 2;
        var transformedPoint = {
          x: cos(xRotRad) * dx + sin(xRotRad) * dy,
          y: -sin(xRotRad) * dx + cos(xRotRad) * dy
        };
        var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
        if (radiiCheck > 1) {
          rx *= sqrt2(radiiCheck);
          ry *= sqrt2(radiiCheck);
        }
        var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
        var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
        var cRadicand = cSquareNumerator / cSquareRootDenom;
        cRadicand = cRadicand < 0 ? 0 : cRadicand;
        var cCoef = (LAF !== SF ? 1 : -1) * sqrt2(cRadicand);
        var transformedCenter = {
          x: cCoef * (rx * transformedPoint.y / ry),
          y: cCoef * (-(ry * transformedPoint.x) / rx)
        };
        var center = {
          x: cos(xRotRad) * transformedCenter.x - sin(xRotRad) * transformedCenter.y + (x1 + x3) / 2,
          y: sin(xRotRad) * transformedCenter.x + cos(xRotRad) * transformedCenter.y + (y1 + y3) / 2
        };
        var startVector = {
          x: (transformedPoint.x - transformedCenter.x) / rx,
          y: (transformedPoint.y - transformedCenter.y) / ry
        };
        var startAngle = angleBetween3({ x: 1, y: 0 }, startVector);
        var endVector = {
          x: (-transformedPoint.x - transformedCenter.x) / rx,
          y: (-transformedPoint.y - transformedCenter.y) / ry
        };
        var sweepAngle = angleBetween3(startVector, endVector);
        if (!SF && sweepAngle > 0) {
          sweepAngle -= 2 * PI;
        } else if (SF && sweepAngle < 0) {
          sweepAngle += 2 * PI;
        }
        sweepAngle %= 2 * PI;
        var alpha = startAngle + sweepAngle * t;
        var ellipseComponentX = rx * cos(alpha);
        var ellipseComponentY = ry * sin(alpha);
        var point4 = {
          x: cos(xRotRad) * ellipseComponentX - sin(xRotRad) * ellipseComponentY + center.x,
          y: sin(xRotRad) * ellipseComponentX + cos(xRotRad) * ellipseComponentY + center.y
        };
        return point4;
      }
      function segmentArcFactory(X1, Y1, RX, RY, angle2, LAF, SF, X2, Y2, distance6, options) {
        var _a2;
        var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 30 : _d;
        var distanceIsNumber = typeof distance6 === "number";
        var x3 = X1;
        var y3 = Y1;
        var LENGTH = 0;
        var prev = [x3, y3, LENGTH];
        var cur = [x3, y3];
        var t = 0;
        var POINT = { x: 0, y: 0 };
        var POINTS = [{ x: x3, y: y3 }];
        if (distanceIsNumber && distance6 <= 0) {
          POINT = { x: x3, y: y3 };
        }
        for (var j = 0; j <= sampleSize; j += 1) {
          t = j / sampleSize;
          _a2 = getPointAtArcSegmentLength(X1, Y1, RX, RY, angle2, LAF, SF, X2, Y2, t), x3 = _a2.x, y3 = _a2.y;
          if (bbox) {
            POINTS.push({ x: x3, y: y3 });
          }
          if (length) {
            LENGTH += (0, distance_square_root_1.distanceSquareRoot)(cur, [x3, y3]);
          }
          cur = [x3, y3];
          if (distanceIsNumber && LENGTH >= distance6 && distance6 > prev[2]) {
            var dv = (LENGTH - distance6) / (LENGTH - prev[2]);
            POINT = {
              x: cur[0] * (1 - dv) + prev[0] * dv,
              y: cur[1] * (1 - dv) + prev[1] * dv
            };
          }
          prev = [x3, y3, LENGTH];
        }
        if (distanceIsNumber && distance6 >= LENGTH) {
          POINT = { x: X2, y: Y2 };
        }
        return {
          length: LENGTH,
          point: POINT,
          min: {
            x: Math.min.apply(null, POINTS.map(function(n) {
              return n.x;
            })),
            y: Math.min.apply(null, POINTS.map(function(n) {
              return n.y;
            }))
          },
          max: {
            x: Math.max.apply(null, POINTS.map(function(n) {
              return n.x;
            })),
            y: Math.max.apply(null, POINTS.map(function(n) {
              return n.y;
            }))
          }
        };
      }
    }
  });

  // node_modules/@antv/util/lib/path/util/segment-cubic-factory.js
  var require_segment_cubic_factory = __commonJS({
    "node_modules/@antv/util/lib/path/util/segment-cubic-factory.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.segmentCubicFactory = segmentCubicFactory;
      var distance_square_root_1 = require_distance_square_root();
      function getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x22, y22, t) {
        var t1 = 1 - t;
        return {
          x: Math.pow(t1, 3) * x1 + 3 * Math.pow(t1, 2) * t * c1x + 3 * t1 * Math.pow(t, 2) * c2x + Math.pow(t, 3) * x22,
          y: Math.pow(t1, 3) * y1 + 3 * Math.pow(t1, 2) * t * c1y + 3 * t1 * Math.pow(t, 2) * c2y + Math.pow(t, 3) * y22
        };
      }
      function segmentCubicFactory(x1, y1, c1x, c1y, c2x, c2y, x22, y22, distance6, options) {
        var _a2;
        var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
        var distanceIsNumber = typeof distance6 === "number";
        var x3 = x1;
        var y3 = y1;
        var LENGTH = 0;
        var prev = [x3, y3, LENGTH];
        var cur = [x3, y3];
        var t = 0;
        var POINT = { x: 0, y: 0 };
        var POINTS = [{ x: x3, y: y3 }];
        if (distanceIsNumber && distance6 <= 0) {
          POINT = { x: x3, y: y3 };
        }
        for (var j = 0; j <= sampleSize; j += 1) {
          t = j / sampleSize;
          _a2 = getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x22, y22, t), x3 = _a2.x, y3 = _a2.y;
          if (bbox) {
            POINTS.push({ x: x3, y: y3 });
          }
          if (length) {
            LENGTH += (0, distance_square_root_1.distanceSquareRoot)(cur, [x3, y3]);
          }
          cur = [x3, y3];
          if (distanceIsNumber && LENGTH >= distance6 && distance6 > prev[2]) {
            var dv = (LENGTH - distance6) / (LENGTH - prev[2]);
            POINT = {
              x: cur[0] * (1 - dv) + prev[0] * dv,
              y: cur[1] * (1 - dv) + prev[1] * dv
            };
          }
          prev = [x3, y3, LENGTH];
        }
        if (distanceIsNumber && distance6 >= LENGTH) {
          POINT = { x: x22, y: y22 };
        }
        return {
          length: LENGTH,
          point: POINT,
          min: {
            x: Math.min.apply(null, POINTS.map(function(n) {
              return n.x;
            })),
            y: Math.min.apply(null, POINTS.map(function(n) {
              return n.y;
            }))
          },
          max: {
            x: Math.max.apply(null, POINTS.map(function(n) {
              return n.x;
            })),
            y: Math.max.apply(null, POINTS.map(function(n) {
              return n.y;
            }))
          }
        };
      }
    }
  });

  // node_modules/@antv/util/lib/path/util/segment-quad-factory.js
  var require_segment_quad_factory = __commonJS({
    "node_modules/@antv/util/lib/path/util/segment-quad-factory.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.segmentQuadFactory = segmentQuadFactory;
      var distance_square_root_1 = require_distance_square_root();
      function getPointAtQuadSegmentLength(x1, y1, cx, cy, x22, y22, t) {
        var t1 = 1 - t;
        return {
          x: Math.pow(t1, 2) * x1 + 2 * t1 * t * cx + Math.pow(t, 2) * x22,
          y: Math.pow(t1, 2) * y1 + 2 * t1 * t * cy + Math.pow(t, 2) * y22
        };
      }
      function segmentQuadFactory(x1, y1, qx, qy, x22, y22, distance6, options) {
        var _a2;
        var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
        var distanceIsNumber = typeof distance6 === "number";
        var x3 = x1;
        var y3 = y1;
        var LENGTH = 0;
        var prev = [x3, y3, LENGTH];
        var cur = [x3, y3];
        var t = 0;
        var POINT = { x: 0, y: 0 };
        var POINTS = [{ x: x3, y: y3 }];
        if (distanceIsNumber && distance6 <= 0) {
          POINT = { x: x3, y: y3 };
        }
        for (var j = 0; j <= sampleSize; j += 1) {
          t = j / sampleSize;
          _a2 = getPointAtQuadSegmentLength(x1, y1, qx, qy, x22, y22, t), x3 = _a2.x, y3 = _a2.y;
          if (bbox) {
            POINTS.push({ x: x3, y: y3 });
          }
          if (length) {
            LENGTH += (0, distance_square_root_1.distanceSquareRoot)(cur, [x3, y3]);
          }
          cur = [x3, y3];
          if (distanceIsNumber && LENGTH >= distance6 && distance6 > prev[2]) {
            var dv = (LENGTH - distance6) / (LENGTH - prev[2]);
            POINT = {
              x: cur[0] * (1 - dv) + prev[0] * dv,
              y: cur[1] * (1 - dv) + prev[1] * dv
            };
          }
          prev = [x3, y3, LENGTH];
        }
        if (distanceIsNumber && distance6 >= LENGTH) {
          POINT = { x: x22, y: y22 };
        }
        return {
          length: LENGTH,
          point: POINT,
          min: {
            x: Math.min.apply(null, POINTS.map(function(n) {
              return n.x;
            })),
            y: Math.min.apply(null, POINTS.map(function(n) {
              return n.y;
            }))
          },
          max: {
            x: Math.max.apply(null, POINTS.map(function(n) {
              return n.x;
            })),
            y: Math.max.apply(null, POINTS.map(function(n) {
              return n.y;
            }))
          }
        };
      }
    }
  });

  // node_modules/@antv/util/lib/path/util/path-length-factory.js
  var require_path_length_factory = __commonJS({
    "node_modules/@antv/util/lib/path/util/path-length-factory.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.pathLengthFactory = pathLengthFactory;
      var normalize_path_1 = require_normalize_path();
      var segment_line_factory_1 = require_segment_line_factory();
      var segment_arc_factory_1 = require_segment_arc_factory();
      var segment_cubic_factory_1 = require_segment_cubic_factory();
      var segment_quad_factory_1 = require_segment_quad_factory();
      function pathLengthFactory(pathInput, distance6, options) {
        var _a2, _b, _c, _d, _e, _f;
        var path = (0, normalize_path_1.normalizePath)(pathInput);
        var distanceIsNumber = typeof distance6 === "number";
        var isM;
        var data2 = [];
        var pathCommand;
        var x3 = 0;
        var y3 = 0;
        var mx = 0;
        var my = 0;
        var seg;
        var MIN = [];
        var MAX = [];
        var length = 0;
        var min4 = { x: 0, y: 0 };
        var max4 = min4;
        var point4 = min4;
        var POINT = min4;
        var LENGTH = 0;
        for (var i = 0, ll = path.length; i < ll; i += 1) {
          seg = path[i];
          pathCommand = seg[0];
          isM = pathCommand === "M";
          data2 = !isM ? [x3, y3].concat(seg.slice(1)) : data2;
          if (isM) {
            mx = seg[1], my = seg[2];
            min4 = { x: mx, y: my };
            max4 = min4;
            length = 0;
            if (distanceIsNumber && distance6 < 1e-3) {
              POINT = min4;
            }
          } else if (pathCommand === "L") {
            _a2 = (0, segment_line_factory_1.segmentLineFactory)(data2[0], data2[1], data2[2], data2[3], (distance6 || 0) - LENGTH), length = _a2.length, min4 = _a2.min, max4 = _a2.max, point4 = _a2.point;
          } else if (pathCommand === "A") {
            _b = (0, segment_arc_factory_1.segmentArcFactory)(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], data2[6], data2[7], data2[8], (distance6 || 0) - LENGTH, options || {}), length = _b.length, min4 = _b.min, max4 = _b.max, point4 = _b.point;
          } else if (pathCommand === "C") {
            _c = (0, segment_cubic_factory_1.segmentCubicFactory)(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], data2[6], data2[7], (distance6 || 0) - LENGTH, options || {}), length = _c.length, min4 = _c.min, max4 = _c.max, point4 = _c.point;
          } else if (pathCommand === "Q") {
            _d = (0, segment_quad_factory_1.segmentQuadFactory)(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], (distance6 || 0) - LENGTH, options || {}), length = _d.length, min4 = _d.min, max4 = _d.max, point4 = _d.point;
          } else if (pathCommand === "Z") {
            data2 = [x3, y3, mx, my];
            _e = (0, segment_line_factory_1.segmentLineFactory)(data2[0], data2[1], data2[2], data2[3], (distance6 || 0) - LENGTH), length = _e.length, min4 = _e.min, max4 = _e.max, point4 = _e.point;
          }
          if (distanceIsNumber && LENGTH < distance6 && LENGTH + length >= distance6) {
            POINT = point4;
          }
          MAX.push(max4);
          MIN.push(min4);
          LENGTH += length;
          _f = pathCommand !== "Z" ? seg.slice(-2) : [mx, my], x3 = _f[0], y3 = _f[1];
        }
        if (distanceIsNumber && distance6 >= LENGTH) {
          POINT = { x: x3, y: y3 };
        }
        return {
          length: LENGTH,
          point: POINT,
          min: {
            x: Math.min.apply(null, MIN.map(function(n) {
              return n.x;
            })),
            y: Math.min.apply(null, MIN.map(function(n) {
              return n.y;
            }))
          },
          max: {
            x: Math.max.apply(null, MAX.map(function(n) {
              return n.x;
            })),
            y: Math.max.apply(null, MAX.map(function(n) {
              return n.y;
            }))
          }
        };
      }
    }
  });

  // node_modules/@antv/util/lib/path/util/get-path-bbox.js
  var require_get_path_bbox = __commonJS({
    "node_modules/@antv/util/lib/path/util/get-path-bbox.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getPathBBox = getPathBBox2;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var path_length_factory_1 = require_path_length_factory();
      function getPathBBox2(path, options) {
        if (!path) {
          return {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            x2: 0,
            y2: 0,
            cx: 0,
            cy: 0,
            cz: 0
          };
        }
        var _a2 = (0, path_length_factory_1.pathLengthFactory)(path, void 0, tslib_1.__assign(tslib_1.__assign({}, options), { length: false })), _b = _a2.min, xMin = _b.x, yMin = _b.y, _c = _a2.max, xMax = _c.x, yMax = _c.y;
        var width2 = xMax - xMin;
        var height = yMax - yMin;
        return {
          width: width2,
          height,
          x: xMin,
          y: yMin,
          x2: xMax,
          y2: yMax,
          cx: xMin + width2 / 2,
          cy: yMin + height / 2,
          // an estimted guess
          cz: Math.max(width2, height) + Math.min(width2, height) / 2
        };
      }
    }
  });

  // node_modules/@antv/util/lib/path/util/get-total-length.js
  var require_get_total_length = __commonJS({
    "node_modules/@antv/util/lib/path/util/get-total-length.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getTotalLength = getTotalLength2;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var path_length_factory_1 = require_path_length_factory();
      function getTotalLength2(pathInput, options) {
        return (0, path_length_factory_1.pathLengthFactory)(pathInput, void 0, tslib_1.__assign(tslib_1.__assign({}, options), { bbox: false, length: true })).length;
      }
    }
  });

  // node_modules/@antv/util/lib/path/util/get-path-bbox-total-length.js
  var require_get_path_bbox_total_length = __commonJS({
    "node_modules/@antv/util/lib/path/util/get-path-bbox-total-length.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getPathBBoxTotalLength = getPathBBoxTotalLength;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var path_length_factory_1 = require_path_length_factory();
      function getPathBBoxTotalLength(path, options) {
        if (!path) {
          return {
            length: 0,
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            x2: 0,
            y2: 0,
            cx: 0,
            cy: 0,
            cz: 0
          };
        }
        var _a2 = (0, path_length_factory_1.pathLengthFactory)(path, void 0, tslib_1.__assign(tslib_1.__assign({}, options), { bbox: true, length: true })), length = _a2.length, _b = _a2.min, xMin = _b.x, yMin = _b.y, _c = _a2.max, xMax = _c.x, yMax = _c.y;
        var width2 = xMax - xMin;
        var height = yMax - yMin;
        return {
          length,
          width: width2,
          height,
          x: xMin,
          y: yMin,
          x2: xMax,
          y2: yMax,
          cx: xMin + width2 / 2,
          cy: yMin + height / 2,
          // an estimted guess
          cz: Math.max(width2, height) + Math.min(width2, height) / 2
        };
      }
    }
  });

  // node_modules/@antv/util/lib/path/util/get-rotated-curve.js
  var require_get_rotated_curve = __commonJS({
    "node_modules/@antv/util/lib/path/util/get-rotated-curve.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getRotatedCurve = getRotatedCurve2;
      var distance_square_root_1 = require_distance_square_root();
      function getRotations(a2) {
        var segCount = a2.length;
        var pointCount = segCount - 1;
        return a2.map(function(f, idx) {
          return a2.map(function(p, i) {
            var oldSegIdx = idx + i;
            var seg;
            if (i === 0 || a2[oldSegIdx] && a2[oldSegIdx][0] === "M") {
              seg = a2[oldSegIdx];
              return ["M"].concat(seg.slice(-2));
            }
            if (oldSegIdx >= segCount)
              oldSegIdx -= pointCount;
            return a2[oldSegIdx];
          });
        });
      }
      function getRotatedCurve2(a2, b) {
        var segCount = a2.length - 1;
        var lineLengths = [];
        var computedIndex = 0;
        var sumLensSqrd = 0;
        var rotations = getRotations(a2);
        rotations.forEach(function(r, i) {
          a2.slice(1).forEach(function(s, j) {
            sumLensSqrd += (0, distance_square_root_1.distanceSquareRoot)(a2[(i + j) % segCount].slice(-2), b[j % segCount].slice(-2));
          });
          lineLengths[i] = sumLensSqrd;
          sumLensSqrd = 0;
        });
        computedIndex = lineLengths.indexOf(Math.min.apply(null, lineLengths));
        return rotations[computedIndex];
      }
    }
  });

  // node_modules/@antv/util/lib/path/util/get-path-area.js
  var require_get_path_area = __commonJS({
    "node_modules/@antv/util/lib/path/util/get-path-area.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getPathArea = getPathArea;
      var path_2_curve_1 = require_path_2_curve();
      function getCubicSegArea(x1, y1, c1x, c1y, c2x, c2y, x22, y22) {
        return 3 * ((y22 - y1) * (c1x + c2x) - (x22 - x1) * (c1y + c2y) + c1y * (x1 - c2x) - c1x * (y1 - c2y) + y22 * (c2x + x1 / 3) - x22 * (c2y + y1 / 3)) / 20;
      }
      function getPathArea(path) {
        var x3 = 0;
        var y3 = 0;
        var len = 0;
        return (0, path_2_curve_1.path2Curve)(path).map(function(seg) {
          var _a2;
          switch (seg[0]) {
            case "M":
              x3 = seg[1], y3 = seg[2];
              return 0;
            default:
              var _b = seg.slice(1), c1x = _b[0], c1y = _b[1], c2x = _b[2], c2y = _b[3], x22 = _b[4], y22 = _b[5];
              len = getCubicSegArea(x3, y3, c1x, c1y, c2x, c2y, x22, y22);
              _a2 = seg.slice(-2), x3 = _a2[0], y3 = _a2[1];
              return len;
          }
        }).reduce(function(a2, b) {
          return a2 + b;
        }, 0);
      }
    }
  });

  // node_modules/@antv/util/lib/path/util/get-draw-direction.js
  var require_get_draw_direction = __commonJS({
    "node_modules/@antv/util/lib/path/util/get-draw-direction.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getDrawDirection = getDrawDirection2;
      var get_path_area_1 = require_get_path_area();
      function getDrawDirection2(pathArray) {
        return (0, get_path_area_1.getPathArea)(pathArray) >= 0;
      }
    }
  });

  // node_modules/@antv/util/lib/path/util/get-point-at-length.js
  var require_get_point_at_length = __commonJS({
    "node_modules/@antv/util/lib/path/util/get-point-at-length.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getPointAtLength = getPointAtLength2;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var path_length_factory_1 = require_path_length_factory();
      function getPointAtLength2(pathInput, distance6, options) {
        return (0, path_length_factory_1.pathLengthFactory)(pathInput, distance6, tslib_1.__assign(tslib_1.__assign({}, options), { bbox: false, length: true })).point;
      }
    }
  });

  // node_modules/@antv/util/lib/path/util/get-properties-at-length.js
  var require_get_properties_at_length = __commonJS({
    "node_modules/@antv/util/lib/path/util/get-properties-at-length.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getPropertiesAtLength = getPropertiesAtLength;
      var parse_path_string_1 = require_parse_path_string();
      var get_total_length_1 = require_get_total_length();
      function getPropertiesAtLength(pathInput, distance6) {
        var pathArray = (0, parse_path_string_1.parsePathString)(pathInput);
        if (typeof pathArray === "string") {
          throw TypeError(pathArray);
        }
        var pathTemp = pathArray.slice();
        var pathLength = (0, get_total_length_1.getTotalLength)(pathTemp);
        var index2 = pathTemp.length - 1;
        var lengthAtSegment = 0;
        var length = 0;
        var segment = pathArray[0];
        var _a2 = segment.slice(-2), x3 = _a2[0], y3 = _a2[1];
        var point4 = { x: x3, y: y3 };
        if (index2 <= 0 || !distance6 || !Number.isFinite(distance6)) {
          return {
            segment,
            index: 0,
            length,
            point: point4,
            lengthAtSegment
          };
        }
        if (distance6 >= pathLength) {
          pathTemp = pathArray.slice(0, -1);
          lengthAtSegment = (0, get_total_length_1.getTotalLength)(pathTemp);
          length = pathLength - lengthAtSegment;
          return {
            segment: pathArray[index2],
            index: index2,
            length,
            lengthAtSegment
          };
        }
        var segments = [];
        while (index2 > 0) {
          segment = pathTemp[index2];
          pathTemp = pathTemp.slice(0, -1);
          lengthAtSegment = (0, get_total_length_1.getTotalLength)(pathTemp);
          length = pathLength - lengthAtSegment;
          pathLength = lengthAtSegment;
          segments.push({
            segment,
            index: index2,
            length,
            lengthAtSegment
          });
          index2 -= 1;
        }
        return segments.find(function(_a3) {
          var l = _a3.lengthAtSegment;
          return l <= distance6;
        });
      }
    }
  });

  // node_modules/@antv/util/lib/path/util/get-properties-at-point.js
  var require_get_properties_at_point = __commonJS({
    "node_modules/@antv/util/lib/path/util/get-properties-at-point.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getPropertiesAtPoint = getPropertiesAtPoint;
      var parse_path_string_1 = require_parse_path_string();
      var normalize_path_1 = require_normalize_path();
      var get_point_at_length_1 = require_get_point_at_length();
      var get_properties_at_length_1 = require_get_properties_at_length();
      var get_total_length_1 = require_get_total_length();
      function getPropertiesAtPoint(pathInput, point4) {
        var path = (0, parse_path_string_1.parsePathString)(pathInput);
        var normalPath = (0, normalize_path_1.normalizePath)(path);
        var pathLength = (0, get_total_length_1.getTotalLength)(path);
        var distanceTo = function(p) {
          var dx = p.x - point4.x;
          var dy = p.y - point4.y;
          return dx * dx + dy * dy;
        };
        var precision = 8;
        var scan;
        var scanDistance = 0;
        var closest;
        var bestLength = 0;
        var bestDistance = Infinity;
        for (var scanLength = 0; scanLength <= pathLength; scanLength += precision) {
          scan = (0, get_point_at_length_1.getPointAtLength)(normalPath, scanLength);
          scanDistance = distanceTo(scan);
          if (scanDistance < bestDistance) {
            closest = scan;
            bestLength = scanLength;
            bestDistance = scanDistance;
          }
        }
        precision /= 2;
        var before;
        var after;
        var beforeLength = 0;
        var afterLength = 0;
        var beforeDistance = 0;
        var afterDistance = 0;
        while (precision > 0.5) {
          beforeLength = bestLength - precision;
          before = (0, get_point_at_length_1.getPointAtLength)(normalPath, beforeLength);
          beforeDistance = distanceTo(before);
          afterLength = bestLength + precision;
          after = (0, get_point_at_length_1.getPointAtLength)(normalPath, afterLength);
          afterDistance = distanceTo(after);
          if (beforeLength >= 0 && beforeDistance < bestDistance) {
            closest = before;
            bestLength = beforeLength;
            bestDistance = beforeDistance;
          } else if (afterLength <= pathLength && afterDistance < bestDistance) {
            closest = after;
            bestLength = afterLength;
            bestDistance = afterDistance;
          } else {
            precision /= 2;
          }
        }
        var segment = (0, get_properties_at_length_1.getPropertiesAtLength)(path, bestLength);
        var distance6 = Math.sqrt(bestDistance);
        return { closest, distance: distance6, segment };
      }
    }
  });

  // node_modules/@antv/util/lib/path/util/is-point-in-stroke.js
  var require_is_point_in_stroke = __commonJS({
    "node_modules/@antv/util/lib/path/util/is-point-in-stroke.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isPointInStroke = isPointInStroke2;
      var get_properties_at_point_1 = require_get_properties_at_point();
      function isPointInStroke2(pathInput, point4) {
        var distance6 = (0, get_properties_at_point_1.getPropertiesAtPoint)(pathInput, point4).distance;
        return Math.abs(distance6) < 1e-3;
      }
    }
  });

  // node_modules/@antv/util/lib/path/util/equalize-segments.js
  var require_equalize_segments = __commonJS({
    "node_modules/@antv/util/lib/path/util/equalize-segments.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.equalizeSegments = equalizeSegments2;
      var mid_point_1 = require_mid_point();
      var segment_cubic_factory_1 = require_segment_cubic_factory();
      var MAX_RECURSION_DEPTH = 50;
      function splitCubic(pts, t) {
        if (t === void 0) {
          t = 0.5;
        }
        var p0 = pts.slice(0, 2);
        var p1 = pts.slice(2, 4);
        var p2 = pts.slice(4, 6);
        var p3 = pts.slice(6, 8);
        var p4 = (0, mid_point_1.midPoint)(p0, p1, t);
        var p5 = (0, mid_point_1.midPoint)(p1, p2, t);
        var p6 = (0, mid_point_1.midPoint)(p2, p3, t);
        var p7 = (0, mid_point_1.midPoint)(p4, p5, t);
        var p8 = (0, mid_point_1.midPoint)(p5, p6, t);
        var p9 = (0, mid_point_1.midPoint)(p7, p8, t);
        return [
          // @ts-ignore
          ["C"].concat(p4, p7, p9),
          // @ts-ignore
          ["C"].concat(p8, p6, p3)
        ];
      }
      function getCurveArray(segments) {
        return segments.map(function(segment, i, pathArray) {
          var segmentData = i && pathArray[i - 1].slice(-2).concat(segment.slice(1));
          var curveLength = i ? (0, segment_cubic_factory_1.segmentCubicFactory)(segmentData[0], segmentData[1], segmentData[2], segmentData[3], segmentData[4], segmentData[5], segmentData[6], segmentData[7], segmentData[8], { bbox: false }).length : 0;
          var subsegs;
          if (i) {
            subsegs = curveLength ? splitCubic(segmentData) : [segment, segment];
          } else {
            subsegs = [segment];
          }
          return {
            s: segment,
            ss: subsegs,
            l: curveLength
          };
        });
      }
      function equalizeSegments2(path1, path2, TL, depth) {
        if (depth === void 0) {
          depth = 0;
        }
        if (depth > MAX_RECURSION_DEPTH) {
          console.warn("Maximum recursion depth reached in equalizeSegments");
          return [path1, path2];
        }
        var c1 = getCurveArray(path1);
        var c2 = getCurveArray(path2);
        var L1 = c1.length;
        var L2 = c2.length;
        var l1 = c1.filter(function(x3) {
          return x3.l;
        }).length;
        var l2 = c2.filter(function(x3) {
          return x3.l;
        }).length;
        var m1 = c1.filter(function(x3) {
          return x3.l;
        }).reduce(function(a2, _a2) {
          var l = _a2.l;
          return a2 + l;
        }, 0) / l1 || 0;
        var m2 = c2.filter(function(x3) {
          return x3.l;
        }).reduce(function(a2, _a2) {
          var l = _a2.l;
          return a2 + l;
        }, 0) / l2 || 0;
        var tl = TL || Math.max(L1, L2);
        var mm = [m1, m2];
        var dif = [tl - L1, tl - L2];
        var canSplit = 0;
        var result = [c1, c2].map(function(x3, i) {
          return x3.l === tl ? x3.map(function(y3) {
            return y3.s;
          }) : x3.map(function(y3, j) {
            canSplit = j && dif[i] && y3.l >= mm[i];
            dif[i] -= canSplit ? 1 : 0;
            return canSplit ? y3.ss : [y3.s];
          }).flat();
        });
        return result[0].length === result[1].length ? result : equalizeSegments2(result[0], result[1], tl, depth + 1);
      }
    }
  });

  // node_modules/@antv/util/lib/path/types.js
  var require_types = __commonJS({
    "node_modules/@antv/util/lib/path/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/@antv/util/lib/path/index.js
  var require_path = __commonJS({
    "node_modules/@antv/util/lib/path/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.equalizeSegments = exports.distanceSquareRoot = exports.isPointInStroke = exports.getPointAtLength = exports.getDrawDirection = exports.getPathArea = exports.getRotatedCurve = exports.getPathBBoxTotalLength = exports.getTotalLength = exports.getPathBBox = exports.arcToCubic = exports.reverseCurve = exports.normalizePath = exports.clonePath = exports.path2Array = exports.path2Absolute = exports.path2Curve = exports.path2String = void 0;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var path_2_string_1 = require_path_2_string();
      Object.defineProperty(exports, "path2String", { enumerable: true, get: function() {
        return path_2_string_1.path2String;
      } });
      var path_2_curve_1 = require_path_2_curve();
      Object.defineProperty(exports, "path2Curve", { enumerable: true, get: function() {
        return path_2_curve_1.path2Curve;
      } });
      var path_2_absolute_1 = require_path_2_absolute();
      Object.defineProperty(exports, "path2Absolute", { enumerable: true, get: function() {
        return path_2_absolute_1.path2Absolute;
      } });
      var path_2_array_1 = require_path_2_array();
      Object.defineProperty(exports, "path2Array", { enumerable: true, get: function() {
        return path_2_array_1.path2Array;
      } });
      var clone_path_1 = require_clone_path();
      Object.defineProperty(exports, "clonePath", { enumerable: true, get: function() {
        return clone_path_1.clonePath;
      } });
      var normalize_path_1 = require_normalize_path();
      Object.defineProperty(exports, "normalizePath", { enumerable: true, get: function() {
        return normalize_path_1.normalizePath;
      } });
      var reverse_curve_1 = require_reverse_curve();
      Object.defineProperty(exports, "reverseCurve", { enumerable: true, get: function() {
        return reverse_curve_1.reverseCurve;
      } });
      var arc_2_cubic_1 = require_arc_2_cubic();
      Object.defineProperty(exports, "arcToCubic", { enumerable: true, get: function() {
        return arc_2_cubic_1.arcToCubic;
      } });
      var get_path_bbox_1 = require_get_path_bbox();
      Object.defineProperty(exports, "getPathBBox", { enumerable: true, get: function() {
        return get_path_bbox_1.getPathBBox;
      } });
      var get_total_length_1 = require_get_total_length();
      Object.defineProperty(exports, "getTotalLength", { enumerable: true, get: function() {
        return get_total_length_1.getTotalLength;
      } });
      var get_path_bbox_total_length_1 = require_get_path_bbox_total_length();
      Object.defineProperty(exports, "getPathBBoxTotalLength", { enumerable: true, get: function() {
        return get_path_bbox_total_length_1.getPathBBoxTotalLength;
      } });
      var get_rotated_curve_1 = require_get_rotated_curve();
      Object.defineProperty(exports, "getRotatedCurve", { enumerable: true, get: function() {
        return get_rotated_curve_1.getRotatedCurve;
      } });
      var get_path_area_1 = require_get_path_area();
      Object.defineProperty(exports, "getPathArea", { enumerable: true, get: function() {
        return get_path_area_1.getPathArea;
      } });
      var get_draw_direction_1 = require_get_draw_direction();
      Object.defineProperty(exports, "getDrawDirection", { enumerable: true, get: function() {
        return get_draw_direction_1.getDrawDirection;
      } });
      var get_point_at_length_1 = require_get_point_at_length();
      Object.defineProperty(exports, "getPointAtLength", { enumerable: true, get: function() {
        return get_point_at_length_1.getPointAtLength;
      } });
      var is_point_in_stroke_1 = require_is_point_in_stroke();
      Object.defineProperty(exports, "isPointInStroke", { enumerable: true, get: function() {
        return is_point_in_stroke_1.isPointInStroke;
      } });
      var distance_square_root_1 = require_distance_square_root();
      Object.defineProperty(exports, "distanceSquareRoot", { enumerable: true, get: function() {
        return distance_square_root_1.distanceSquareRoot;
      } });
      var equalize_segments_1 = require_equalize_segments();
      Object.defineProperty(exports, "equalizeSegments", { enumerable: true, get: function() {
        return equalize_segments_1.equalizeSegments;
      } });
      tslib_1.__exportStar(require_types(), exports);
    }
  });

  // node_modules/@antv/util/lib/math/is-point-in-polygon.js
  var require_is_point_in_polygon = __commonJS({
    "node_modules/@antv/util/lib/math/is-point-in-polygon.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isPointInPolygon = isPointInPolygon2;
      var tolerance2 = 1e-6;
      function dcmp2(x3) {
        if (Math.abs(x3) < tolerance2) {
          return 0;
        }
        return x3 < 0 ? -1 : 1;
      }
      function onSegment2(p1, p2, q) {
        if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
          return true;
        }
        return false;
      }
      function isPointInPolygon2(points, x3, y3) {
        var isHit = false;
        var n = points.length;
        if (n <= 2) {
          return false;
        }
        for (var i = 0; i < n; i++) {
          var p1 = points[i];
          var p2 = points[(i + 1) % n];
          if (onSegment2(p1, p2, [x3, y3])) {
            return true;
          }
          if (dcmp2(p1[1] - y3) > 0 !== dcmp2(p2[1] - y3) > 0 && dcmp2(x3 - (y3 - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
            isHit = !isHit;
          }
        }
        return isHit;
      }
    }
  });

  // node_modules/@antv/util/lib/math/is-polygons-intersect.js
  var require_is_polygons_intersect = __commonJS({
    "node_modules/@antv/util/lib/math/is-polygons-intersect.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isPolygonsIntersect = isPolygonsIntersect;
      var is_point_in_polygon_1 = require_is_point_in_polygon();
      var isBetween2 = function(value, min4, max4) {
        return value >= min4 && value <= max4;
      };
      function getLineIntersect(p0, p1, p2, p3) {
        var tolerance2 = 1e-3;
        var E2 = {
          x: p2.x - p0.x,
          y: p2.y - p0.y
        };
        var D0 = {
          x: p1.x - p0.x,
          y: p1.y - p0.y
        };
        var D1 = {
          x: p3.x - p2.x,
          y: p3.y - p2.y
        };
        var kross = D0.x * D1.y - D0.y * D1.x;
        var sqrKross = kross * kross;
        var sqrLen0 = D0.x * D0.x + D0.y * D0.y;
        var sqrLen1 = D1.x * D1.x + D1.y * D1.y;
        var point4 = null;
        if (sqrKross > tolerance2 * sqrLen0 * sqrLen1) {
          var s = (E2.x * D1.y - E2.y * D1.x) / kross;
          var t = (E2.x * D0.y - E2.y * D0.x) / kross;
          if (isBetween2(s, 0, 1) && isBetween2(t, 0, 1)) {
            point4 = {
              x: p0.x + s * D0.x,
              y: p0.y + s * D0.y
            };
          }
        }
        return point4;
      }
      function parseToLines(points) {
        var lines = [];
        var count = points.length;
        for (var i = 0; i < count - 1; i++) {
          var point4 = points[i];
          var next = points[i + 1];
          lines.push({
            from: {
              x: point4[0],
              y: point4[1]
            },
            to: {
              x: next[0],
              y: next[1]
            }
          });
        }
        if (lines.length > 1) {
          var first = points[0];
          var last2 = points[count - 1];
          lines.push({
            from: {
              x: last2[0],
              y: last2[1]
            },
            to: {
              x: first[0],
              y: first[1]
            }
          });
        }
        return lines;
      }
      function lineIntersectPolygon(lines, line2) {
        var isIntersect2 = false;
        lines.forEach(function(l) {
          if (getLineIntersect(l.from, l.to, line2.from, line2.to)) {
            isIntersect2 = true;
            return false;
          }
        });
        return isIntersect2;
      }
      function getBBox2(points) {
        var xArr = points.map(function(p) {
          return p[0];
        });
        var yArr = points.map(function(p) {
          return p[1];
        });
        return {
          minX: Math.min.apply(null, xArr),
          maxX: Math.max.apply(null, xArr),
          minY: Math.min.apply(null, yArr),
          maxY: Math.max.apply(null, yArr)
        };
      }
      function intersectBBox(box1, box2) {
        return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
      }
      function isPolygonsIntersect(points1, points2) {
        if (points1.length < 2 || points2.length < 2) {
          return false;
        }
        var bbox1 = getBBox2(points1);
        var bbox2 = getBBox2(points2);
        if (!intersectBBox(bbox1, bbox2)) {
          return false;
        }
        var isIn = false;
        points2.forEach(function(point4) {
          if ((0, is_point_in_polygon_1.isPointInPolygon)(points1, point4[0], point4[1])) {
            isIn = true;
            return false;
          }
        });
        if (isIn) {
          return true;
        }
        points1.forEach(function(point4) {
          if ((0, is_point_in_polygon_1.isPointInPolygon)(points2, point4[0], point4[1])) {
            isIn = true;
            return false;
          }
        });
        if (isIn) {
          return true;
        }
        var lines1 = parseToLines(points1);
        var lines2 = parseToLines(points2);
        var isIntersect2 = false;
        lines2.forEach(function(line2) {
          if (lineIntersectPolygon(lines1, line2)) {
            isIntersect2 = true;
            return false;
          }
        });
        return isIntersect2;
      }
    }
  });

  // node_modules/@antv/util/lib/math/index.js
  var require_math = __commonJS({
    "node_modules/@antv/util/lib/math/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isPolygonsIntersect = exports.isPointInPolygon = void 0;
      var is_point_in_polygon_1 = require_is_point_in_polygon();
      Object.defineProperty(exports, "isPointInPolygon", { enumerable: true, get: function() {
        return is_point_in_polygon_1.isPointInPolygon;
      } });
      var is_polygons_intersect_1 = require_is_polygons_intersect();
      Object.defineProperty(exports, "isPolygonsIntersect", { enumerable: true, get: function() {
        return is_polygons_intersect_1.isPolygonsIntersect;
      } });
    }
  });

  // node_modules/@antv/util/lib/dom/create-dom.js
  var require_create_dom = __commonJS({
    "node_modules/@antv/util/lib/dom/create-dom.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createDOM = createDOM3;
      function createDOM3(str) {
        var container = document.createElement("div");
        container.innerHTML = str;
        var dom = container.childNodes[0];
        if (dom && container.contains(dom)) {
          container.removeChild(dom);
        }
        return dom;
      }
    }
  });

  // node_modules/@antv/util/lib/dom/modify-css.js
  var require_modify_css = __commonJS({
    "node_modules/@antv/util/lib/dom/modify-css.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.modifyCSS = modifyCSS;
      function modifyCSS(dom, css) {
        if (!dom)
          return;
        Object.keys(css).forEach(function(key) {
          dom.style[key] = css[key];
        });
        return dom;
      }
    }
  });

  // node_modules/@antv/util/lib/dom/index.js
  var require_dom = __commonJS({
    "node_modules/@antv/util/lib/dom/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.modifyCSS = exports.createDOM = void 0;
      var create_dom_1 = require_create_dom();
      Object.defineProperty(exports, "createDOM", { enumerable: true, get: function() {
        return create_dom_1.createDOM;
      } });
      var modify_css_1 = require_modify_css();
      Object.defineProperty(exports, "modifyCSS", { enumerable: true, get: function() {
        return modify_css_1.modifyCSS;
      } });
    }
  });

  // node_modules/@antv/util/lib/index.js
  var require_lib = __commonJS({
    "node_modules/@antv/util/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      tslib_1.__exportStar(require_color(), exports);
      tslib_1.__exportStar(require_matrix(), exports);
      tslib_1.__exportStar(require_path(), exports);
      tslib_1.__exportStar(require_lodash(), exports);
      tslib_1.__exportStar(require_math(), exports);
      tslib_1.__exportStar(require_dom(), exports);
    }
  });

  // node_modules/@antv/hierarchy/build/hierarchy.js
  var require_hierarchy = __commonJS({
    "node_modules/@antv/hierarchy/build/hierarchy.js"(exports, module) {
      (function webpackUniversalModuleDefinition(root2, factory) {
        if (typeof exports === "object" && typeof module === "object")
          module.exports = factory();
        else if (typeof define === "function" && define.amd)
          define([], factory);
        else if (typeof exports === "object")
          exports["Hierarchy"] = factory();
        else
          root2["Hierarchy"] = factory();
      })(typeof self !== "undefined" ? self : exports, function() {
        return (
          /******/
          (function(modules) {
            var installedModules = {};
            function __webpack_require__(moduleId) {
              if (installedModules[moduleId]) {
                return installedModules[moduleId].exports;
              }
              var module2 = installedModules[moduleId] = {
                /******/
                i: moduleId,
                /******/
                l: false,
                /******/
                exports: {}
                /******/
              };
              modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
              module2.l = true;
              return module2.exports;
            }
            __webpack_require__.m = modules;
            __webpack_require__.c = installedModules;
            __webpack_require__.d = function(exports2, name, getter) {
              if (!__webpack_require__.o(exports2, name)) {
                Object.defineProperty(exports2, name, {
                  /******/
                  configurable: false,
                  /******/
                  enumerable: true,
                  /******/
                  get: getter
                  /******/
                });
              }
            };
            __webpack_require__.n = function(module2) {
              var getter = module2 && module2.__esModule ? (
                /******/
                function getDefault() {
                  return module2["default"];
                }
              ) : (
                /******/
                function getModuleExports() {
                  return module2;
                }
              );
              __webpack_require__.d(getter, "a", getter);
              return getter;
            };
            __webpack_require__.o = function(object, property) {
              return Object.prototype.hasOwnProperty.call(object, property);
            };
            __webpack_require__.p = "";
            return __webpack_require__(__webpack_require__.s = 5);
          })([
            /* 0 */
            /***/
            (function(module2, exports2) {
              function getHeight2(preNode, node, align, heightField) {
                if (heightField === void 0) {
                  heightField = "height";
                }
                return align === "center" ? (preNode[heightField] + node[heightField]) / 2 : preNode.height;
              }
              module2.exports = {
                assign: Object.assign,
                getHeight: getHeight2
              };
            }),
            /* 1 */
            /***/
            (function(module2, exports2, __webpack_require__) {
              var hierarchy = __webpack_require__(3);
              var Layout = /* @__PURE__ */ (function() {
                function Layout2(root2, options) {
                  if (options === void 0) {
                    options = {};
                  }
                  var me = this;
                  me.options = options;
                  me.rootNode = hierarchy(root2, options);
                }
                var _proto = Layout2.prototype;
                _proto.execute = function execute() {
                  throw new Error("please override this method");
                };
                return Layout2;
              })();
              module2.exports = Layout;
            }),
            /* 2 */
            /***/
            (function(module2, exports2, __webpack_require__) {
              var separateTree = __webpack_require__(4);
              var VALID_DIRECTIONS = [
                "LR",
                // left to right
                "RL",
                // right to left
                "TB",
                // top to bottom
                "BT",
                // bottom to top
                "H",
                // horizontal
                "V"
                // vertical
              ];
              var HORIZONTAL_DIRECTIONS = ["LR", "RL", "H"];
              var isHorizontal3 = function isHorizontal4(direction2) {
                return HORIZONTAL_DIRECTIONS.indexOf(direction2) > -1;
              };
              var DEFAULT_DIRECTION = VALID_DIRECTIONS[0];
              module2.exports = function(root2, options, layoutAlgrithm) {
                var direction2 = options.direction || DEFAULT_DIRECTION;
                options.isHorizontal = isHorizontal3(direction2);
                if (direction2 && VALID_DIRECTIONS.indexOf(direction2) === -1) {
                  throw new TypeError("Invalid direction: " + direction2);
                }
                if (direction2 === VALID_DIRECTIONS[0]) {
                  layoutAlgrithm(root2, options);
                } else if (direction2 === VALID_DIRECTIONS[1]) {
                  layoutAlgrithm(root2, options);
                  root2.right2left();
                } else if (direction2 === VALID_DIRECTIONS[2]) {
                  layoutAlgrithm(root2, options);
                } else if (direction2 === VALID_DIRECTIONS[3]) {
                  layoutAlgrithm(root2, options);
                  root2.bottom2top();
                } else if (direction2 === VALID_DIRECTIONS[4] || direction2 === VALID_DIRECTIONS[5]) {
                  var _separateTree = separateTree(root2, options), left = _separateTree.left, right = _separateTree.right;
                  layoutAlgrithm(left, options);
                  layoutAlgrithm(right, options);
                  options.isHorizontal ? left.right2left() : left.bottom2top();
                  right.translate(left.x - right.x, left.y - right.y);
                  root2.x = left.x;
                  root2.y = right.y;
                  var bb = root2.getBoundingBox();
                  if (options.isHorizontal) {
                    if (bb.top < 0) {
                      root2.translate(0, -bb.top);
                    }
                  } else {
                    if (bb.left < 0) {
                      root2.translate(-bb.left, 0);
                    }
                  }
                }
                var fixedRoot = options.fixedRoot;
                if (fixedRoot === void 0) fixedRoot = true;
                if (fixedRoot) {
                  root2.translate(-(root2.x + root2.width / 2 + root2.hgap), -(root2.y + root2.height / 2 + root2.vgap));
                }
                reassignXYIfRadial(root2, options);
                return root2;
              };
              function reassignXYIfRadial(root2, options) {
                if (options.radial) {
                  var _ref = options.isHorizontal ? ["x", "y"] : ["y", "x"], rScale = _ref[0], radScale = _ref[1];
                  var min4 = {
                    x: Infinity,
                    y: Infinity
                  };
                  var max4 = {
                    x: -Infinity,
                    y: -Infinity
                  };
                  var count = 0;
                  root2.DFTraverse(function(node) {
                    count++;
                    var x3 = node.x, y3 = node.y;
                    min4.x = Math.min(min4.x, x3);
                    min4.y = Math.min(min4.y, y3);
                    max4.x = Math.max(max4.x, x3);
                    max4.y = Math.max(max4.y, y3);
                  });
                  var radDiff = max4[radScale] - min4[radScale];
                  if (radDiff === 0) return;
                  var avgRad = Math.PI * 2 / count;
                  root2.DFTraverse(function(node) {
                    var rad2 = (node[radScale] - min4[radScale]) / radDiff * (Math.PI * 2 - avgRad) + avgRad;
                    var r = node[rScale] - root2[rScale];
                    node.x = Math.cos(rad2) * r;
                    node.y = Math.sin(rad2) * r;
                  });
                }
              }
            }),
            /* 3 */
            /***/
            (function(module2, exports2, __webpack_require__) {
              var util = __webpack_require__(0);
              var PEM = 18;
              var DEFAULT_HEIGHT = PEM * 2;
              var DEFAULT_GAP = PEM;
              var DEFAULT_OPTIONS = {
                getId: function getId(d2) {
                  return d2.id || d2.name;
                },
                getPreH: function getPreH(d2) {
                  return d2.preH || 0;
                },
                getPreV: function getPreV(d2) {
                  return d2.preV || 0;
                },
                getHGap: function getHGap(d2) {
                  return d2.hgap || DEFAULT_GAP;
                },
                getVGap: function getVGap(d2) {
                  return d2.vgap || DEFAULT_GAP;
                },
                getChildren: function getChildren(d2) {
                  return d2.children;
                },
                getHeight: function getHeight2(d2) {
                  return d2.height || DEFAULT_HEIGHT;
                },
                getWidth: function getWidth2(d2) {
                  var label = d2.label || " ";
                  return d2.width || label.split("").length * PEM;
                }
              };
              function Node3(data2, options) {
                var me = this;
                me.vgap = me.hgap = 0;
                if (data2 instanceof Node3) return data2;
                me.data = data2;
                var hgap = options.getHGap(data2);
                var vgap = options.getVGap(data2);
                me.preH = options.getPreH(data2);
                me.preV = options.getPreV(data2);
                me.width = options.getWidth(data2);
                me.height = options.getHeight(data2);
                me.width += me.preH;
                me.height += me.preV;
                me.id = options.getId(data2);
                me.x = me.y = 0;
                me.depth = 0;
                if (!me.children) {
                  me.children = [];
                }
                me.addGap(hgap, vgap);
                return me;
              }
              util.assign(Node3.prototype, {
                isRoot: function isRoot2() {
                  return this.depth === 0;
                },
                isLeaf: function isLeaf() {
                  return this.children.length === 0;
                },
                addGap: function addGap(hgap, vgap) {
                  var me = this;
                  me.hgap += hgap;
                  me.vgap += vgap;
                  me.width += 2 * hgap;
                  me.height += 2 * vgap;
                },
                eachNode: function eachNode(callback) {
                  var me = this;
                  var nodes = [me];
                  var current2;
                  while (current2 = nodes.shift()) {
                    callback(current2);
                    nodes = current2.children.concat(nodes);
                  }
                },
                DFTraverse: function DFTraverse(callback) {
                  this.eachNode(callback);
                },
                BFTraverse: function BFTraverse(callback) {
                  var me = this;
                  var nodes = [me];
                  var current2;
                  while (current2 = nodes.shift()) {
                    callback(current2);
                    nodes = nodes.concat(current2.children);
                  }
                },
                getBoundingBox: function getBoundingBox() {
                  var bb = {
                    left: Number.MAX_VALUE,
                    top: Number.MAX_VALUE,
                    width: 0,
                    height: 0
                  };
                  this.eachNode(function(node) {
                    bb.left = Math.min(bb.left, node.x);
                    bb.top = Math.min(bb.top, node.y);
                    bb.width = Math.max(bb.width, node.x + node.width);
                    bb.height = Math.max(bb.height, node.y + node.height);
                  });
                  return bb;
                },
                // translate
                translate: function translate3(tx, ty) {
                  if (tx === void 0) {
                    tx = 0;
                  }
                  if (ty === void 0) {
                    ty = 0;
                  }
                  this.eachNode(function(node) {
                    node.x += tx;
                    node.y += ty;
                    node.x += node.preH;
                    node.y += node.preV;
                  });
                },
                right2left: function right2left() {
                  var me = this;
                  var bb = me.getBoundingBox();
                  me.eachNode(function(node) {
                    node.x = node.x - (node.x - bb.left) * 2 - node.width;
                  });
                  me.translate(bb.width, 0);
                },
                bottom2top: function bottom2top() {
                  var me = this;
                  var bb = me.getBoundingBox();
                  me.eachNode(function(node) {
                    node.y = node.y - (node.y - bb.top) * 2 - node.height;
                  });
                  me.translate(0, bb.height);
                }
              });
              function hierarchy(data2, options, isolated) {
                if (options === void 0) {
                  options = {};
                }
                options = util.assign({}, DEFAULT_OPTIONS, options);
                var root2 = new Node3(data2, options);
                var nodes = [root2];
                var node;
                if (!isolated && !data2.collapsed) {
                  while (node = nodes.shift()) {
                    if (!node.data.collapsed) {
                      var children = options.getChildren(node.data);
                      var length = children ? children.length : 0;
                      node.children = new Array(length);
                      if (children && length) {
                        for (var i = 0; i < length; i++) {
                          var child = new Node3(children[i], options);
                          node.children[i] = child;
                          nodes.push(child);
                          child.parent = node;
                          child.depth = node.depth + 1;
                        }
                      }
                    }
                  }
                }
                return root2;
              }
              module2.exports = hierarchy;
            }),
            /* 4 */
            /***/
            (function(module2, exports2, __webpack_require__) {
              var hierarchy = __webpack_require__(3);
              module2.exports = function(root2, options) {
                var left = hierarchy(root2.data, options, true);
                var right = hierarchy(root2.data, options, true);
                var treeSize = root2.children.length;
                var rightTreeSize = Math.round(treeSize / 2);
                var getSide = options.getSide || function(child2, index2) {
                  if (index2 < rightTreeSize) {
                    return "right";
                  }
                  return "left";
                };
                for (var i = 0; i < treeSize; i++) {
                  var child = root2.children[i];
                  var side = getSide(child, i);
                  if (side === "right") {
                    right.children.push(child);
                  } else {
                    left.children.push(child);
                  }
                }
                left.eachNode(function(node) {
                  if (!node.isRoot()) {
                    node.side = "left";
                  }
                });
                right.eachNode(function(node) {
                  if (!node.isRoot()) {
                    node.side = "right";
                  }
                });
                return {
                  left,
                  right
                };
              };
            }),
            /* 5 */
            /***/
            (function(module2, exports2, __webpack_require__) {
              var hierarchy = {
                compactBox: __webpack_require__(6),
                dendrogram: __webpack_require__(8),
                indented: __webpack_require__(10),
                mindmap: __webpack_require__(12)
              };
              module2.exports = hierarchy;
            }),
            /* 6 */
            /***/
            (function(module2, exports2, __webpack_require__) {
              function _inheritsLoose(t, o) {
                t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf2(t, o);
              }
              function _setPrototypeOf2(t, e) {
                return _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e3) {
                  return t2.__proto__ = e3, t2;
                }, _setPrototypeOf2(t, e);
              }
              var TreeLayout = __webpack_require__(1);
              var nonLayeredTidyTree = __webpack_require__(7);
              var doTreeLayout = __webpack_require__(2);
              var util = __webpack_require__(0);
              var CompactBoxTreeLayout = /* @__PURE__ */ (function(_TreeLayout) {
                function CompactBoxTreeLayout2() {
                  return _TreeLayout.apply(this, arguments) || this;
                }
                _inheritsLoose(CompactBoxTreeLayout2, _TreeLayout);
                var _proto = CompactBoxTreeLayout2.prototype;
                _proto.execute = function execute() {
                  var me = this;
                  return doTreeLayout(me.rootNode, me.options, nonLayeredTidyTree);
                };
                return CompactBoxTreeLayout2;
              })(TreeLayout);
              var DEFAULT_OPTIONS = {};
              function compactBoxLayout(root2, options) {
                options = util.assign({}, DEFAULT_OPTIONS, options);
                return new CompactBoxTreeLayout(root2, options).execute();
              }
              module2.exports = compactBoxLayout;
            }),
            /* 7 */
            /***/
            (function(module2, exports2) {
              function WrappedTree(w, h, y3, c2) {
                if (c2 === void 0) {
                  c2 = [];
                }
                var me = this;
                me.w = w || 0;
                me.h = h || 0;
                me.y = y3 || 0;
                me.x = 0;
                me.c = c2 || [];
                me.cs = c2.length;
                me.prelim = 0;
                me.mod = 0;
                me.shift = 0;
                me.change = 0;
                me.tl = null;
                me.tr = null;
                me.el = null;
                me.er = null;
                me.msel = 0;
                me.mser = 0;
              }
              WrappedTree.fromNode = function(root2, isHorizontal3) {
                if (!root2) return null;
                var children = [];
                root2.children.forEach(function(child) {
                  children.push(WrappedTree.fromNode(child, isHorizontal3));
                });
                if (isHorizontal3) return new WrappedTree(root2.height, root2.width, root2.x, children);
                return new WrappedTree(root2.width, root2.height, root2.y, children);
              };
              function moveRight(node, move, isHorizontal3) {
                if (isHorizontal3) {
                  node.y += move;
                } else {
                  node.x += move;
                }
                node.children.forEach(function(child) {
                  moveRight(child, move, isHorizontal3);
                });
              }
              function getMin(node, isHorizontal3) {
                var res = isHorizontal3 ? node.y : node.x;
                node.children.forEach(function(child) {
                  res = Math.min(getMin(child, isHorizontal3), res);
                });
                return res;
              }
              function normalize5(node, isHorizontal3) {
                var min4 = getMin(node, isHorizontal3);
                moveRight(node, -min4, isHorizontal3);
              }
              function convertBack(converted, root2, isHorizontal3) {
                if (isHorizontal3) {
                  root2.y = converted.x;
                } else {
                  root2.x = converted.x;
                }
                converted.c.forEach(function(child, i) {
                  convertBack(child, root2.children[i], isHorizontal3);
                });
              }
              function layer(node, isHorizontal3, d2) {
                if (d2 === void 0) {
                  d2 = 0;
                }
                if (isHorizontal3) {
                  node.x = d2;
                  d2 += node.width;
                } else {
                  node.y = d2;
                  d2 += node.height;
                }
                node.children.forEach(function(child) {
                  layer(child, isHorizontal3, d2);
                });
              }
              module2.exports = function(root2, options) {
                if (options === void 0) {
                  options = {};
                }
                var isHorizontal3 = options.isHorizontal;
                function firstWalk(t) {
                  if (t.cs === 0) {
                    setExtremes(t);
                    return;
                  }
                  firstWalk(t.c[0]);
                  var ih = updateIYL(bottom(t.c[0].el), 0, null);
                  for (var i = 1; i < t.cs; ++i) {
                    firstWalk(t.c[i]);
                    var min4 = bottom(t.c[i].er);
                    separate(t, i, ih);
                    ih = updateIYL(min4, i, ih);
                  }
                  positionRoot(t);
                  setExtremes(t);
                }
                function setExtremes(t) {
                  if (t.cs === 0) {
                    t.el = t;
                    t.er = t;
                    t.msel = t.mser = 0;
                  } else {
                    t.el = t.c[0].el;
                    t.msel = t.c[0].msel;
                    t.er = t.c[t.cs - 1].er;
                    t.mser = t.c[t.cs - 1].mser;
                  }
                }
                function separate(t, i, ih) {
                  var sr = t.c[i - 1];
                  var mssr = sr.mod;
                  var cl = t.c[i];
                  var mscl = cl.mod;
                  while (sr !== null && cl !== null) {
                    if (bottom(sr) > ih.low) ih = ih.nxt;
                    var dist = mssr + sr.prelim + sr.w - (mscl + cl.prelim);
                    if (dist > 0) {
                      mscl += dist;
                      moveSubtree(t, i, ih.index, dist);
                    }
                    var sy = bottom(sr);
                    var cy = bottom(cl);
                    if (sy <= cy) {
                      sr = nextRightContour(sr);
                      if (sr !== null) mssr += sr.mod;
                    }
                    if (sy >= cy) {
                      cl = nextLeftContour(cl);
                      if (cl !== null) mscl += cl.mod;
                    }
                  }
                  if (!sr && !!cl) {
                    setLeftThread(t, i, cl, mscl);
                  } else if (!!sr && !cl) {
                    setRightThread(t, i, sr, mssr);
                  }
                }
                function moveSubtree(t, i, si, dist) {
                  t.c[i].mod += dist;
                  t.c[i].msel += dist;
                  t.c[i].mser += dist;
                  distributeExtra(t, i, si, dist);
                }
                function nextLeftContour(t) {
                  return t.cs === 0 ? t.tl : t.c[0];
                }
                function nextRightContour(t) {
                  return t.cs === 0 ? t.tr : t.c[t.cs - 1];
                }
                function bottom(t) {
                  return t.y + t.h;
                }
                function setLeftThread(t, i, cl, modsumcl) {
                  var li = t.c[0].el;
                  li.tl = cl;
                  var diff = modsumcl - cl.mod - t.c[0].msel;
                  li.mod += diff;
                  li.prelim -= diff;
                  t.c[0].el = t.c[i].el;
                  t.c[0].msel = t.c[i].msel;
                }
                function setRightThread(t, i, sr, modsumsr) {
                  var ri = t.c[i].er;
                  ri.tr = sr;
                  var diff = modsumsr - sr.mod - t.c[i].mser;
                  ri.mod += diff;
                  ri.prelim -= diff;
                  t.c[i].er = t.c[i - 1].er;
                  t.c[i].mser = t.c[i - 1].mser;
                }
                function positionRoot(t) {
                  t.prelim = (t.c[0].prelim + t.c[0].mod + t.c[t.cs - 1].mod + t.c[t.cs - 1].prelim + t.c[t.cs - 1].w) / 2 - t.w / 2;
                }
                function secondWalk(t, modsum) {
                  modsum += t.mod;
                  t.x = t.prelim + modsum;
                  addChildSpacing(t);
                  for (var i = 0; i < t.cs; i++) {
                    secondWalk(t.c[i], modsum);
                  }
                }
                function distributeExtra(t, i, si, dist) {
                  if (si !== i - 1) {
                    var nr = i - si;
                    t.c[si + 1].shift += dist / nr;
                    t.c[i].shift -= dist / nr;
                    t.c[i].change -= dist - dist / nr;
                  }
                }
                function addChildSpacing(t) {
                  var d2 = 0;
                  var modsumdelta = 0;
                  for (var i = 0; i < t.cs; i++) {
                    d2 += t.c[i].shift;
                    modsumdelta += d2 + t.c[i].change;
                    t.c[i].mod += modsumdelta;
                  }
                }
                function updateIYL(low, index2, ih) {
                  while (ih !== null && low >= ih.low) {
                    ih = ih.nxt;
                  }
                  return {
                    low,
                    index: index2,
                    nxt: ih
                  };
                }
                layer(root2, isHorizontal3);
                var wt = WrappedTree.fromNode(root2, isHorizontal3);
                firstWalk(wt);
                secondWalk(wt, 0);
                convertBack(wt, root2, isHorizontal3);
                normalize5(root2, isHorizontal3);
                return root2;
              };
            }),
            /* 8 */
            /***/
            (function(module2, exports2, __webpack_require__) {
              function _inheritsLoose(t, o) {
                t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf2(t, o);
              }
              function _setPrototypeOf2(t, e) {
                return _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e3) {
                  return t2.__proto__ = e3, t2;
                }, _setPrototypeOf2(t, e);
              }
              var TreeLayout = __webpack_require__(1);
              var dendrogram2 = __webpack_require__(9);
              var doTreeLayout = __webpack_require__(2);
              var util = __webpack_require__(0);
              var DendrogramLayout = /* @__PURE__ */ (function(_TreeLayout) {
                function DendrogramLayout2() {
                  return _TreeLayout.apply(this, arguments) || this;
                }
                _inheritsLoose(DendrogramLayout2, _TreeLayout);
                var _proto = DendrogramLayout2.prototype;
                _proto.execute = function execute() {
                  var me = this;
                  me.rootNode.width = 0;
                  return doTreeLayout(me.rootNode, me.options, dendrogram2);
                };
                return DendrogramLayout2;
              })(TreeLayout);
              var DEFAULT_OPTIONS = {};
              function dendrogramLayout(root2, options) {
                options = util.assign({}, DEFAULT_OPTIONS, options);
                return new DendrogramLayout(root2, options).execute();
              }
              module2.exports = dendrogramLayout;
            }),
            /* 9 */
            /***/
            (function(module2, exports2, __webpack_require__) {
              var util = __webpack_require__(0);
              function WrappedTree(height, children) {
                if (height === void 0) {
                  height = 0;
                }
                if (children === void 0) {
                  children = [];
                }
                var me = this;
                me.x = me.y = 0;
                me.leftChild = me.rightChild = null;
                me.height = 0;
                me.children = children;
              }
              var DEFAULT_OPTIONS = {
                isHorizontal: true,
                nodeSep: 20,
                nodeSize: 20,
                rankSep: 200,
                subTreeSep: 10
              };
              function convertBack(converted, root2, isHorizontal3) {
                if (isHorizontal3) {
                  root2.x = converted.x;
                  root2.y = converted.y;
                } else {
                  root2.x = converted.y;
                  root2.y = converted.x;
                }
                converted.children.forEach(function(child, i) {
                  convertBack(child, root2.children[i], isHorizontal3);
                });
              }
              module2.exports = function(root2, options) {
                if (options === void 0) {
                  options = {};
                }
                options = util.assign({}, DEFAULT_OPTIONS, options);
                var maxDepth = 0;
                function wrappedTreeFromNode(n) {
                  if (!n) return null;
                  n.width = 0;
                  if (n.depth && n.depth > maxDepth) {
                    maxDepth = n.depth;
                  }
                  var children = n.children;
                  var childrenCount = children.length;
                  var t = new WrappedTree(n.height, []);
                  children.forEach(function(child, i) {
                    var childWT = wrappedTreeFromNode(child);
                    t.children.push(childWT);
                    if (i === 0) {
                      t.leftChild = childWT;
                    }
                    if (i === childrenCount - 1) {
                      t.rightChild = childWT;
                    }
                  });
                  t.originNode = n;
                  t.isLeaf = n.isLeaf();
                  return t;
                }
                function getDrawingDepth(t) {
                  if (t.isLeaf || t.children.length === 0) {
                    t.drawingDepth = maxDepth;
                  } else {
                    var depths = t.children.map(function(child) {
                      return getDrawingDepth(child);
                    });
                    var minChildDepth = Math.min.apply(null, depths);
                    t.drawingDepth = minChildDepth - 1;
                  }
                  return t.drawingDepth;
                }
                var prevLeaf;
                function position2(t) {
                  t.x = t.drawingDepth * options.rankSep;
                  if (t.isLeaf) {
                    t.y = 0;
                    if (prevLeaf) {
                      t.y = prevLeaf.y + prevLeaf.height + options.nodeSep;
                      if (t.originNode.parent !== prevLeaf.originNode.parent) {
                        t.y += options.subTreeSep;
                      }
                    }
                    prevLeaf = t;
                  } else {
                    t.children.forEach(function(child) {
                      position2(child);
                    });
                    t.y = (t.leftChild.y + t.rightChild.y) / 2;
                  }
                }
                var wt = wrappedTreeFromNode(root2);
                getDrawingDepth(wt);
                position2(wt);
                convertBack(wt, root2, options.isHorizontal);
                return root2;
              };
            }),
            /* 10 */
            /***/
            (function(module2, exports2, __webpack_require__) {
              function _inheritsLoose(t, o) {
                t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf2(t, o);
              }
              function _setPrototypeOf2(t, e) {
                return _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e3) {
                  return t2.__proto__ = e3, t2;
                }, _setPrototypeOf2(t, e);
              }
              var TreeLayout = __webpack_require__(1);
              var indentedTree = __webpack_require__(11);
              var separateTree = __webpack_require__(4);
              var util = __webpack_require__(0);
              var VALID_DIRECTIONS = [
                "LR",
                // left to right
                "RL",
                // right to left
                "H"
                // horizontal
              ];
              var DEFAULT_DIRECTION = VALID_DIRECTIONS[0];
              var IndentedLayout = /* @__PURE__ */ (function(_TreeLayout) {
                function IndentedLayout2() {
                  return _TreeLayout.apply(this, arguments) || this;
                }
                _inheritsLoose(IndentedLayout2, _TreeLayout);
                var _proto = IndentedLayout2.prototype;
                _proto.execute = function execute() {
                  var me = this;
                  var options = me.options;
                  var root2 = me.rootNode;
                  options.isHorizontal = true;
                  var _options$indent = options.indent, indent = _options$indent === void 0 ? 20 : _options$indent, _options$dropCap = options.dropCap, dropCap = _options$dropCap === void 0 ? true : _options$dropCap, _options$direction = options.direction, direction2 = _options$direction === void 0 ? DEFAULT_DIRECTION : _options$direction, align = options.align;
                  if (direction2 && VALID_DIRECTIONS.indexOf(direction2) === -1) {
                    throw new TypeError("Invalid direction: " + direction2);
                  }
                  if (direction2 === VALID_DIRECTIONS[0]) {
                    indentedTree(root2, indent, dropCap, align);
                  } else if (direction2 === VALID_DIRECTIONS[1]) {
                    indentedTree(root2, indent, dropCap, align);
                    root2.right2left();
                  } else if (direction2 === VALID_DIRECTIONS[2]) {
                    var _separateTree = separateTree(root2, options), left = _separateTree.left, right = _separateTree.right;
                    indentedTree(left, indent, dropCap, align);
                    left.right2left();
                    indentedTree(right, indent, dropCap, align);
                    var bbox = left.getBoundingBox();
                    right.translate(bbox.width, 0);
                    root2.x = right.x - root2.width / 2;
                  }
                  return root2;
                };
                return IndentedLayout2;
              })(TreeLayout);
              var DEFAULT_OPTIONS = {};
              function indentedLayout(root2, options) {
                options = util.assign({}, DEFAULT_OPTIONS, options);
                return new IndentedLayout(root2, options).execute();
              }
              module2.exports = indentedLayout;
            }),
            /* 11 */
            /***/
            (function(module2, exports2, __webpack_require__) {
              var util = __webpack_require__(0);
              function positionNode(node, previousNode, indent, dropCap, align) {
                var displacementX = (typeof indent === "function" ? indent(node) : indent) * node.depth;
                if (!dropCap) {
                  try {
                    if (node.id === node.parent.children[0].id) {
                      node.x += displacementX;
                      node.y = previousNode ? previousNode.y : 0;
                      return;
                    }
                  } catch (e) {
                  }
                }
                node.x += displacementX;
                if (previousNode) {
                  node.y = previousNode.y + util.getHeight(previousNode, node, align);
                  if (previousNode.parent && node.parent.id !== previousNode.parent.id) {
                    var prevParent = previousNode.parent;
                    var preY = prevParent.y + util.getHeight(prevParent, node, align);
                    node.y = preY > node.y ? preY : node.y;
                  }
                } else {
                  node.y = 0;
                }
                return;
              }
              module2.exports = function(root2, indent, dropCap, align) {
                var previousNode = null;
                root2.eachNode(function(node) {
                  positionNode(node, previousNode, indent, dropCap, align);
                  previousNode = node;
                });
              };
            }),
            /* 12 */
            /***/
            (function(module2, exports2, __webpack_require__) {
              function _inheritsLoose(t, o) {
                t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf2(t, o);
              }
              function _setPrototypeOf2(t, e) {
                return _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e3) {
                  return t2.__proto__ = e3, t2;
                }, _setPrototypeOf2(t, e);
              }
              var TreeLayout = __webpack_require__(1);
              var mindmap2 = __webpack_require__(13);
              var doTreeLayout = __webpack_require__(2);
              var util = __webpack_require__(0);
              var MindmapLayout = /* @__PURE__ */ (function(_TreeLayout) {
                function MindmapLayout2() {
                  return _TreeLayout.apply(this, arguments) || this;
                }
                _inheritsLoose(MindmapLayout2, _TreeLayout);
                var _proto = MindmapLayout2.prototype;
                _proto.execute = function execute() {
                  var me = this;
                  return doTreeLayout(me.rootNode, me.options, mindmap2);
                };
                return MindmapLayout2;
              })(TreeLayout);
              var DEFAULT_OPTIONS = {};
              function mindmapLayout(root2, options) {
                options = util.assign({}, DEFAULT_OPTIONS, options);
                return new MindmapLayout(root2, options).execute();
              }
              module2.exports = mindmapLayout;
            }),
            /* 13 */
            /***/
            (function(module2, exports2, __webpack_require__) {
              var util = __webpack_require__(0);
              function secondWalk(node, options) {
                var totalHeight = 0;
                if (!node.children.length) {
                  totalHeight = node.height;
                } else {
                  node.children.forEach(function(c2) {
                    totalHeight += secondWalk(c2, options);
                  });
                }
                node._subTreeSep = options.getSubTreeSep(node.data);
                node.totalHeight = Math.max(node.height, totalHeight) + 2 * node._subTreeSep;
                return node.totalHeight;
              }
              function thirdWalk(node) {
                var children = node.children;
                var len = children.length;
                if (len) {
                  children.forEach(function(c2) {
                    thirdWalk(c2);
                  });
                  var first = children[0];
                  var last2 = children[len - 1];
                  var childrenHeight = last2.y - first.y + last2.height;
                  var childrenTotalHeight = 0;
                  children.forEach(function(child) {
                    childrenTotalHeight += child.totalHeight;
                  });
                  if (childrenHeight > node.height) {
                    node.y = first.y + childrenHeight / 2 - node.height / 2;
                  } else if (children.length !== 1 || node.height > childrenTotalHeight) {
                    var offset = node.y + (node.height - childrenHeight) / 2 - first.y;
                    children.forEach(function(c2) {
                      c2.translate(0, offset);
                    });
                  } else {
                    node.y = (first.y + first.height / 2 + last2.y + last2.height / 2) / 2 - node.height / 2;
                  }
                }
              }
              var DEFAULT_OPTIONS = {
                getSubTreeSep: function getSubTreeSep() {
                  return 0;
                }
              };
              module2.exports = function(root2, options) {
                if (options === void 0) {
                  options = {};
                }
                options = util.assign({}, DEFAULT_OPTIONS, options);
                root2.parent = {
                  x: 0,
                  width: 0,
                  height: 0,
                  y: 0
                };
                root2.BFTraverse(function(node) {
                  node.x = node.parent.x + node.parent.width;
                });
                root2.parent = null;
                secondWalk(root2, options);
                root2.startY = 0;
                root2.y = root2.totalHeight / 2 - root2.height / 2;
                root2.eachNode(function(node) {
                  var children = node.children;
                  var len = children.length;
                  if (len) {
                    var first = children[0];
                    first.startY = node.startY + node._subTreeSep;
                    if (len === 1) {
                      first.y = node.y + node.height / 2 - first.height / 2;
                    } else {
                      first.y = first.startY + first.totalHeight / 2 - first.height / 2;
                      for (var i = 1; i < len; i++) {
                        var c2 = children[i];
                        c2.startY = children[i - 1].startY + children[i - 1].totalHeight;
                        c2.y = c2.startY + c2.totalHeight / 2 - c2.height / 2;
                      }
                    }
                  }
                });
                thirdWalk(root2);
              };
            })
            /******/
          ])
        );
      });
    }
  });

  // node_modules/is-any-array/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/is-any-array/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isAnyArray = void 0;
      var toString3 = Object.prototype.toString;
      function isAnyArray(value) {
        const tag = toString3.call(value);
        return tag.endsWith("Array]") && !tag.includes("Big");
      }
      exports.isAnyArray = isAnyArray;
    }
  });

  // node_modules/ml-array-max/lib/index.js
  var require_lib3 = __commonJS({
    "node_modules/ml-array-max/lib/index.js"(exports, module) {
      "use strict";
      var isAnyArray = require_lib2();
      function max4(input, options = {}) {
        if (!isAnyArray.isAnyArray(input)) {
          throw new TypeError("input must be an array");
        }
        if (input.length === 0) {
          throw new TypeError("input must not be empty");
        }
        const { fromIndex = 0, toIndex = input.length } = options;
        if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
          throw new Error("fromIndex must be a positive integer smaller than length");
        }
        if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
          throw new Error(
            "toIndex must be an integer greater than fromIndex and at most equal to length"
          );
        }
        let maxValue = input[fromIndex];
        for (let i = fromIndex + 1; i < toIndex; i++) {
          if (input[i] > maxValue) maxValue = input[i];
        }
        return maxValue;
      }
      module.exports = max4;
    }
  });

  // node_modules/ml-array-min/lib/index.js
  var require_lib4 = __commonJS({
    "node_modules/ml-array-min/lib/index.js"(exports, module) {
      "use strict";
      var isAnyArray = require_lib2();
      function min4(input, options = {}) {
        if (!isAnyArray.isAnyArray(input)) {
          throw new TypeError("input must be an array");
        }
        if (input.length === 0) {
          throw new TypeError("input must not be empty");
        }
        const { fromIndex = 0, toIndex = input.length } = options;
        if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
          throw new Error("fromIndex must be a positive integer smaller than length");
        }
        if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
          throw new Error(
            "toIndex must be an integer greater than fromIndex and at most equal to length"
          );
        }
        let minValue = input[fromIndex];
        for (let i = fromIndex + 1; i < toIndex; i++) {
          if (input[i] < minValue) minValue = input[i];
        }
        return minValue;
      }
      module.exports = min4;
    }
  });

  // node_modules/ml-array-rescale/lib/index.js
  var require_lib5 = __commonJS({
    "node_modules/ml-array-rescale/lib/index.js"(exports, module) {
      "use strict";
      var isAnyArray = require_lib2();
      var max4 = require_lib3();
      var min4 = require_lib4();
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e : { "default": e };
      }
      var max__default = /* @__PURE__ */ _interopDefaultLegacy(max4);
      var min__default = /* @__PURE__ */ _interopDefaultLegacy(min4);
      function rescale(input, options = {}) {
        if (!isAnyArray.isAnyArray(input)) {
          throw new TypeError("input must be an array");
        } else if (input.length === 0) {
          throw new TypeError("input must not be empty");
        }
        let output;
        if (options.output !== void 0) {
          if (!isAnyArray.isAnyArray(options.output)) {
            throw new TypeError("output option must be an array if specified");
          }
          output = options.output;
        } else {
          output = new Array(input.length);
        }
        const currentMin = min__default["default"](input);
        const currentMax = max__default["default"](input);
        if (currentMin === currentMax) {
          throw new RangeError(
            "minimum and maximum input values are equal. Cannot rescale a constant array"
          );
        }
        const {
          min: minValue = options.autoMinMax ? currentMin : 0,
          max: maxValue = options.autoMinMax ? currentMax : 1
        } = options;
        if (minValue >= maxValue) {
          throw new RangeError("min option must be smaller than max option");
        }
        const factor = (maxValue - minValue) / (currentMax - currentMin);
        for (let i = 0; i < input.length; i++) {
          output[i] = (input[i] - currentMin) * factor + minValue;
        }
        return output;
      }
      module.exports = rescale;
    }
  });

  // node_modules/ml-matrix/matrix.js
  var require_matrix2 = __commonJS({
    "node_modules/ml-matrix/matrix.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var isAnyArray = require_lib2();
      var rescale = require_lib5();
      var indent = " ".repeat(2);
      var indentData = " ".repeat(4);
      function inspectMatrix() {
        return inspectMatrixWithOptions(this);
      }
      function inspectMatrixWithOptions(matrix3, options = {}) {
        const {
          maxRows = 15,
          maxColumns = 10,
          maxNumSize = 8,
          padMinus = "auto"
        } = options;
        return `${matrix3.constructor.name} {
${indent}[
${indentData}${inspectData(matrix3, maxRows, maxColumns, maxNumSize, padMinus)}
${indent}]
${indent}rows: ${matrix3.rows}
${indent}columns: ${matrix3.columns}
}`;
      }
      function inspectData(matrix3, maxRows, maxColumns, maxNumSize, padMinus) {
        const { rows, columns } = matrix3;
        const maxI = Math.min(rows, maxRows);
        const maxJ = Math.min(columns, maxColumns);
        const result = [];
        if (padMinus === "auto") {
          padMinus = false;
          loop: for (let i = 0; i < maxI; i++) {
            for (let j = 0; j < maxJ; j++) {
              if (matrix3.get(i, j) < 0) {
                padMinus = true;
                break loop;
              }
            }
          }
        }
        for (let i = 0; i < maxI; i++) {
          let line2 = [];
          for (let j = 0; j < maxJ; j++) {
            line2.push(formatNumber(matrix3.get(i, j), maxNumSize, padMinus));
          }
          result.push(`${line2.join(" ")}`);
        }
        if (maxJ !== columns) {
          result[result.length - 1] += ` ... ${columns - maxColumns} more columns`;
        }
        if (maxI !== rows) {
          result.push(`... ${rows - maxRows} more rows`);
        }
        return result.join(`
${indentData}`);
      }
      function formatNumber(num, maxNumSize, padMinus) {
        return (num >= 0 && padMinus ? ` ${formatNumber2(num, maxNumSize - 1)}` : formatNumber2(num, maxNumSize)).padEnd(maxNumSize);
      }
      function formatNumber2(num, len) {
        let str = num.toString();
        if (str.length <= len) return str;
        let fix = num.toFixed(len);
        if (fix.length > len) {
          fix = num.toFixed(Math.max(0, len - (fix.length - len)));
        }
        if (fix.length <= len && !fix.startsWith("0.000") && !fix.startsWith("-0.000")) {
          return fix;
        }
        let exp = num.toExponential(len);
        if (exp.length > len) {
          exp = num.toExponential(Math.max(0, len - (exp.length - len)));
        }
        return exp.slice(0);
      }
      function installMathOperations(AbstractMatrix3, Matrix4) {
        AbstractMatrix3.prototype.add = function add5(value) {
          if (typeof value === "number") return this.addS(value);
          return this.addM(value);
        };
        AbstractMatrix3.prototype.addS = function addS(value) {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) + value);
            }
          }
          return this;
        };
        AbstractMatrix3.prototype.addM = function addM(matrix3) {
          matrix3 = Matrix4.checkMatrix(matrix3);
          if (this.rows !== matrix3.rows || this.columns !== matrix3.columns) {
            throw new RangeError("Matrices dimensions must be equal");
          }
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) + matrix3.get(i, j));
            }
          }
          return this;
        };
        AbstractMatrix3.add = function add5(matrix3, value) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.add(value);
        };
        AbstractMatrix3.prototype.sub = function sub2(value) {
          if (typeof value === "number") return this.subS(value);
          return this.subM(value);
        };
        AbstractMatrix3.prototype.subS = function subS(value) {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) - value);
            }
          }
          return this;
        };
        AbstractMatrix3.prototype.subM = function subM(matrix3) {
          matrix3 = Matrix4.checkMatrix(matrix3);
          if (this.rows !== matrix3.rows || this.columns !== matrix3.columns) {
            throw new RangeError("Matrices dimensions must be equal");
          }
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) - matrix3.get(i, j));
            }
          }
          return this;
        };
        AbstractMatrix3.sub = function sub2(matrix3, value) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.sub(value);
        };
        AbstractMatrix3.prototype.subtract = AbstractMatrix3.prototype.sub;
        AbstractMatrix3.prototype.subtractS = AbstractMatrix3.prototype.subS;
        AbstractMatrix3.prototype.subtractM = AbstractMatrix3.prototype.subM;
        AbstractMatrix3.subtract = AbstractMatrix3.sub;
        AbstractMatrix3.prototype.mul = function mul(value) {
          if (typeof value === "number") return this.mulS(value);
          return this.mulM(value);
        };
        AbstractMatrix3.prototype.mulS = function mulS(value) {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) * value);
            }
          }
          return this;
        };
        AbstractMatrix3.prototype.mulM = function mulM(matrix3) {
          matrix3 = Matrix4.checkMatrix(matrix3);
          if (this.rows !== matrix3.rows || this.columns !== matrix3.columns) {
            throw new RangeError("Matrices dimensions must be equal");
          }
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) * matrix3.get(i, j));
            }
          }
          return this;
        };
        AbstractMatrix3.mul = function mul(matrix3, value) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.mul(value);
        };
        AbstractMatrix3.prototype.multiply = AbstractMatrix3.prototype.mul;
        AbstractMatrix3.prototype.multiplyS = AbstractMatrix3.prototype.mulS;
        AbstractMatrix3.prototype.multiplyM = AbstractMatrix3.prototype.mulM;
        AbstractMatrix3.multiply = AbstractMatrix3.mul;
        AbstractMatrix3.prototype.div = function div(value) {
          if (typeof value === "number") return this.divS(value);
          return this.divM(value);
        };
        AbstractMatrix3.prototype.divS = function divS(value) {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) / value);
            }
          }
          return this;
        };
        AbstractMatrix3.prototype.divM = function divM(matrix3) {
          matrix3 = Matrix4.checkMatrix(matrix3);
          if (this.rows !== matrix3.rows || this.columns !== matrix3.columns) {
            throw new RangeError("Matrices dimensions must be equal");
          }
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) / matrix3.get(i, j));
            }
          }
          return this;
        };
        AbstractMatrix3.div = function div(matrix3, value) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.div(value);
        };
        AbstractMatrix3.prototype.divide = AbstractMatrix3.prototype.div;
        AbstractMatrix3.prototype.divideS = AbstractMatrix3.prototype.divS;
        AbstractMatrix3.prototype.divideM = AbstractMatrix3.prototype.divM;
        AbstractMatrix3.divide = AbstractMatrix3.div;
        AbstractMatrix3.prototype.mod = function mod3(value) {
          if (typeof value === "number") return this.modS(value);
          return this.modM(value);
        };
        AbstractMatrix3.prototype.modS = function modS(value) {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) % value);
            }
          }
          return this;
        };
        AbstractMatrix3.prototype.modM = function modM(matrix3) {
          matrix3 = Matrix4.checkMatrix(matrix3);
          if (this.rows !== matrix3.rows || this.columns !== matrix3.columns) {
            throw new RangeError("Matrices dimensions must be equal");
          }
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) % matrix3.get(i, j));
            }
          }
          return this;
        };
        AbstractMatrix3.mod = function mod3(matrix3, value) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.mod(value);
        };
        AbstractMatrix3.prototype.modulus = AbstractMatrix3.prototype.mod;
        AbstractMatrix3.prototype.modulusS = AbstractMatrix3.prototype.modS;
        AbstractMatrix3.prototype.modulusM = AbstractMatrix3.prototype.modM;
        AbstractMatrix3.modulus = AbstractMatrix3.mod;
        AbstractMatrix3.prototype.and = function and(value) {
          if (typeof value === "number") return this.andS(value);
          return this.andM(value);
        };
        AbstractMatrix3.prototype.andS = function andS(value) {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) & value);
            }
          }
          return this;
        };
        AbstractMatrix3.prototype.andM = function andM(matrix3) {
          matrix3 = Matrix4.checkMatrix(matrix3);
          if (this.rows !== matrix3.rows || this.columns !== matrix3.columns) {
            throw new RangeError("Matrices dimensions must be equal");
          }
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) & matrix3.get(i, j));
            }
          }
          return this;
        };
        AbstractMatrix3.and = function and(matrix3, value) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.and(value);
        };
        AbstractMatrix3.prototype.or = function or(value) {
          if (typeof value === "number") return this.orS(value);
          return this.orM(value);
        };
        AbstractMatrix3.prototype.orS = function orS(value) {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) | value);
            }
          }
          return this;
        };
        AbstractMatrix3.prototype.orM = function orM(matrix3) {
          matrix3 = Matrix4.checkMatrix(matrix3);
          if (this.rows !== matrix3.rows || this.columns !== matrix3.columns) {
            throw new RangeError("Matrices dimensions must be equal");
          }
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) | matrix3.get(i, j));
            }
          }
          return this;
        };
        AbstractMatrix3.or = function or(matrix3, value) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.or(value);
        };
        AbstractMatrix3.prototype.xor = function xor(value) {
          if (typeof value === "number") return this.xorS(value);
          return this.xorM(value);
        };
        AbstractMatrix3.prototype.xorS = function xorS(value) {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) ^ value);
            }
          }
          return this;
        };
        AbstractMatrix3.prototype.xorM = function xorM(matrix3) {
          matrix3 = Matrix4.checkMatrix(matrix3);
          if (this.rows !== matrix3.rows || this.columns !== matrix3.columns) {
            throw new RangeError("Matrices dimensions must be equal");
          }
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) ^ matrix3.get(i, j));
            }
          }
          return this;
        };
        AbstractMatrix3.xor = function xor(matrix3, value) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.xor(value);
        };
        AbstractMatrix3.prototype.leftShift = function leftShift(value) {
          if (typeof value === "number") return this.leftShiftS(value);
          return this.leftShiftM(value);
        };
        AbstractMatrix3.prototype.leftShiftS = function leftShiftS(value) {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) << value);
            }
          }
          return this;
        };
        AbstractMatrix3.prototype.leftShiftM = function leftShiftM(matrix3) {
          matrix3 = Matrix4.checkMatrix(matrix3);
          if (this.rows !== matrix3.rows || this.columns !== matrix3.columns) {
            throw new RangeError("Matrices dimensions must be equal");
          }
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) << matrix3.get(i, j));
            }
          }
          return this;
        };
        AbstractMatrix3.leftShift = function leftShift(matrix3, value) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.leftShift(value);
        };
        AbstractMatrix3.prototype.signPropagatingRightShift = function signPropagatingRightShift(value) {
          if (typeof value === "number") return this.signPropagatingRightShiftS(value);
          return this.signPropagatingRightShiftM(value);
        };
        AbstractMatrix3.prototype.signPropagatingRightShiftS = function signPropagatingRightShiftS(value) {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) >> value);
            }
          }
          return this;
        };
        AbstractMatrix3.prototype.signPropagatingRightShiftM = function signPropagatingRightShiftM(matrix3) {
          matrix3 = Matrix4.checkMatrix(matrix3);
          if (this.rows !== matrix3.rows || this.columns !== matrix3.columns) {
            throw new RangeError("Matrices dimensions must be equal");
          }
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) >> matrix3.get(i, j));
            }
          }
          return this;
        };
        AbstractMatrix3.signPropagatingRightShift = function signPropagatingRightShift(matrix3, value) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.signPropagatingRightShift(value);
        };
        AbstractMatrix3.prototype.rightShift = function rightShift(value) {
          if (typeof value === "number") return this.rightShiftS(value);
          return this.rightShiftM(value);
        };
        AbstractMatrix3.prototype.rightShiftS = function rightShiftS(value) {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) >>> value);
            }
          }
          return this;
        };
        AbstractMatrix3.prototype.rightShiftM = function rightShiftM(matrix3) {
          matrix3 = Matrix4.checkMatrix(matrix3);
          if (this.rows !== matrix3.rows || this.columns !== matrix3.columns) {
            throw new RangeError("Matrices dimensions must be equal");
          }
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) >>> matrix3.get(i, j));
            }
          }
          return this;
        };
        AbstractMatrix3.rightShift = function rightShift(matrix3, value) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.rightShift(value);
        };
        AbstractMatrix3.prototype.zeroFillRightShift = AbstractMatrix3.prototype.rightShift;
        AbstractMatrix3.prototype.zeroFillRightShiftS = AbstractMatrix3.prototype.rightShiftS;
        AbstractMatrix3.prototype.zeroFillRightShiftM = AbstractMatrix3.prototype.rightShiftM;
        AbstractMatrix3.zeroFillRightShift = AbstractMatrix3.rightShift;
        AbstractMatrix3.prototype.not = function not() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, ~this.get(i, j));
            }
          }
          return this;
        };
        AbstractMatrix3.not = function not(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.not();
        };
        AbstractMatrix3.prototype.abs = function abs() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.abs(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.abs = function abs(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.abs();
        };
        AbstractMatrix3.prototype.acos = function acos() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.acos(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.acos = function acos(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.acos();
        };
        AbstractMatrix3.prototype.acosh = function acosh() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.acosh(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.acosh = function acosh(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.acosh();
        };
        AbstractMatrix3.prototype.asin = function asin() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.asin(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.asin = function asin(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.asin();
        };
        AbstractMatrix3.prototype.asinh = function asinh() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.asinh(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.asinh = function asinh(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.asinh();
        };
        AbstractMatrix3.prototype.atan = function atan() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.atan(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.atan = function atan(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.atan();
        };
        AbstractMatrix3.prototype.atanh = function atanh() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.atanh(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.atanh = function atanh(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.atanh();
        };
        AbstractMatrix3.prototype.cbrt = function cbrt() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.cbrt(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.cbrt = function cbrt(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.cbrt();
        };
        AbstractMatrix3.prototype.ceil = function ceil() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.ceil(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.ceil = function ceil(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.ceil();
        };
        AbstractMatrix3.prototype.clz32 = function clz32() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.clz32(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.clz32 = function clz32(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.clz32();
        };
        AbstractMatrix3.prototype.cos = function cos() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.cos(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.cos = function cos(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.cos();
        };
        AbstractMatrix3.prototype.cosh = function cosh() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.cosh(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.cosh = function cosh(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.cosh();
        };
        AbstractMatrix3.prototype.exp = function exp() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.exp(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.exp = function exp(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.exp();
        };
        AbstractMatrix3.prototype.expm1 = function expm1() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.expm1(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.expm1 = function expm1(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.expm1();
        };
        AbstractMatrix3.prototype.floor = function floor() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.floor(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.floor = function floor(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.floor();
        };
        AbstractMatrix3.prototype.fround = function fround() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.fround(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.fround = function fround(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.fround();
        };
        AbstractMatrix3.prototype.log = function log2() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.log(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.log = function log2(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.log();
        };
        AbstractMatrix3.prototype.log1p = function log1p() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.log1p(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.log1p = function log1p(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.log1p();
        };
        AbstractMatrix3.prototype.log10 = function log10() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.log10(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.log10 = function log10(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.log10();
        };
        AbstractMatrix3.prototype.log2 = function log2() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.log2(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.log2 = function log2(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.log2();
        };
        AbstractMatrix3.prototype.round = function round3() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.round(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.round = function round3(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.round();
        };
        AbstractMatrix3.prototype.sign = function sign() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.sign(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.sign = function sign(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.sign();
        };
        AbstractMatrix3.prototype.sin = function sin() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.sin(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.sin = function sin(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.sin();
        };
        AbstractMatrix3.prototype.sinh = function sinh() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.sinh(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.sinh = function sinh(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.sinh();
        };
        AbstractMatrix3.prototype.sqrt = function sqrt2() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.sqrt(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.sqrt = function sqrt2(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.sqrt();
        };
        AbstractMatrix3.prototype.tan = function tan() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.tan(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.tan = function tan(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.tan();
        };
        AbstractMatrix3.prototype.tanh = function tanh() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.tanh(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.tanh = function tanh(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.tanh();
        };
        AbstractMatrix3.prototype.trunc = function trunc() {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, Math.trunc(this.get(i, j)));
            }
          }
          return this;
        };
        AbstractMatrix3.trunc = function trunc(matrix3) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.trunc();
        };
        AbstractMatrix3.pow = function pow2(matrix3, arg0) {
          const newMatrix = new Matrix4(matrix3);
          return newMatrix.pow(arg0);
        };
        AbstractMatrix3.prototype.pow = function pow2(value) {
          if (typeof value === "number") return this.powS(value);
          return this.powM(value);
        };
        AbstractMatrix3.prototype.powS = function powS(value) {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) ** value);
            }
          }
          return this;
        };
        AbstractMatrix3.prototype.powM = function powM(matrix3) {
          matrix3 = Matrix4.checkMatrix(matrix3);
          if (this.rows !== matrix3.rows || this.columns !== matrix3.columns) {
            throw new RangeError("Matrices dimensions must be equal");
          }
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) ** matrix3.get(i, j));
            }
          }
          return this;
        };
      }
      function checkRowIndex(matrix3, index2, outer) {
        let max4 = outer ? matrix3.rows : matrix3.rows - 1;
        if (index2 < 0 || index2 > max4) {
          throw new RangeError("Row index out of range");
        }
      }
      function checkColumnIndex(matrix3, index2, outer) {
        let max4 = outer ? matrix3.columns : matrix3.columns - 1;
        if (index2 < 0 || index2 > max4) {
          throw new RangeError("Column index out of range");
        }
      }
      function checkRowVector(matrix3, vector) {
        if (vector.to1DArray) {
          vector = vector.to1DArray();
        }
        if (vector.length !== matrix3.columns) {
          throw new RangeError(
            "vector size must be the same as the number of columns"
          );
        }
        return vector;
      }
      function checkColumnVector(matrix3, vector) {
        if (vector.to1DArray) {
          vector = vector.to1DArray();
        }
        if (vector.length !== matrix3.rows) {
          throw new RangeError("vector size must be the same as the number of rows");
        }
        return vector;
      }
      function checkRowIndices(matrix3, rowIndices) {
        if (!isAnyArray.isAnyArray(rowIndices)) {
          throw new TypeError("row indices must be an array");
        }
        for (let i = 0; i < rowIndices.length; i++) {
          if (rowIndices[i] < 0 || rowIndices[i] >= matrix3.rows) {
            throw new RangeError("row indices are out of range");
          }
        }
      }
      function checkColumnIndices(matrix3, columnIndices) {
        if (!isAnyArray.isAnyArray(columnIndices)) {
          throw new TypeError("column indices must be an array");
        }
        for (let i = 0; i < columnIndices.length; i++) {
          if (columnIndices[i] < 0 || columnIndices[i] >= matrix3.columns) {
            throw new RangeError("column indices are out of range");
          }
        }
      }
      function checkRange(matrix3, startRow, endRow, startColumn, endColumn) {
        if (arguments.length !== 5) {
          throw new RangeError("expected 4 arguments");
        }
        checkNumber("startRow", startRow);
        checkNumber("endRow", endRow);
        checkNumber("startColumn", startColumn);
        checkNumber("endColumn", endColumn);
        if (startRow > endRow || startColumn > endColumn || startRow < 0 || startRow >= matrix3.rows || endRow < 0 || endRow >= matrix3.rows || startColumn < 0 || startColumn >= matrix3.columns || endColumn < 0 || endColumn >= matrix3.columns) {
          throw new RangeError("Submatrix indices are out of range");
        }
      }
      function newArray(length, value = 0) {
        let array = [];
        for (let i = 0; i < length; i++) {
          array.push(value);
        }
        return array;
      }
      function checkNumber(name, value) {
        if (typeof value !== "number") {
          throw new TypeError(`${name} must be a number`);
        }
      }
      function checkNonEmpty(matrix3) {
        if (matrix3.isEmpty()) {
          throw new Error("Empty matrix has no elements to index");
        }
      }
      function sumByRow(matrix3) {
        let sum = newArray(matrix3.rows);
        for (let i = 0; i < matrix3.rows; ++i) {
          for (let j = 0; j < matrix3.columns; ++j) {
            sum[i] += matrix3.get(i, j);
          }
        }
        return sum;
      }
      function sumByColumn(matrix3) {
        let sum = newArray(matrix3.columns);
        for (let i = 0; i < matrix3.rows; ++i) {
          for (let j = 0; j < matrix3.columns; ++j) {
            sum[j] += matrix3.get(i, j);
          }
        }
        return sum;
      }
      function sumAll(matrix3) {
        let v = 0;
        for (let i = 0; i < matrix3.rows; i++) {
          for (let j = 0; j < matrix3.columns; j++) {
            v += matrix3.get(i, j);
          }
        }
        return v;
      }
      function productByRow(matrix3) {
        let sum = newArray(matrix3.rows, 1);
        for (let i = 0; i < matrix3.rows; ++i) {
          for (let j = 0; j < matrix3.columns; ++j) {
            sum[i] *= matrix3.get(i, j);
          }
        }
        return sum;
      }
      function productByColumn(matrix3) {
        let sum = newArray(matrix3.columns, 1);
        for (let i = 0; i < matrix3.rows; ++i) {
          for (let j = 0; j < matrix3.columns; ++j) {
            sum[j] *= matrix3.get(i, j);
          }
        }
        return sum;
      }
      function productAll(matrix3) {
        let v = 1;
        for (let i = 0; i < matrix3.rows; i++) {
          for (let j = 0; j < matrix3.columns; j++) {
            v *= matrix3.get(i, j);
          }
        }
        return v;
      }
      function varianceByRow(matrix3, unbiased, mean) {
        const rows = matrix3.rows;
        const cols = matrix3.columns;
        const variance = [];
        for (let i = 0; i < rows; i++) {
          let sum1 = 0;
          let sum2 = 0;
          let x3 = 0;
          for (let j = 0; j < cols; j++) {
            x3 = matrix3.get(i, j) - mean[i];
            sum1 += x3;
            sum2 += x3 * x3;
          }
          if (unbiased) {
            variance.push((sum2 - sum1 * sum1 / cols) / (cols - 1));
          } else {
            variance.push((sum2 - sum1 * sum1 / cols) / cols);
          }
        }
        return variance;
      }
      function varianceByColumn(matrix3, unbiased, mean) {
        const rows = matrix3.rows;
        const cols = matrix3.columns;
        const variance = [];
        for (let j = 0; j < cols; j++) {
          let sum1 = 0;
          let sum2 = 0;
          let x3 = 0;
          for (let i = 0; i < rows; i++) {
            x3 = matrix3.get(i, j) - mean[j];
            sum1 += x3;
            sum2 += x3 * x3;
          }
          if (unbiased) {
            variance.push((sum2 - sum1 * sum1 / rows) / (rows - 1));
          } else {
            variance.push((sum2 - sum1 * sum1 / rows) / rows);
          }
        }
        return variance;
      }
      function varianceAll(matrix3, unbiased, mean) {
        const rows = matrix3.rows;
        const cols = matrix3.columns;
        const size2 = rows * cols;
        let sum1 = 0;
        let sum2 = 0;
        let x3 = 0;
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            x3 = matrix3.get(i, j) - mean;
            sum1 += x3;
            sum2 += x3 * x3;
          }
        }
        if (unbiased) {
          return (sum2 - sum1 * sum1 / size2) / (size2 - 1);
        } else {
          return (sum2 - sum1 * sum1 / size2) / size2;
        }
      }
      function centerByRow(matrix3, mean) {
        for (let i = 0; i < matrix3.rows; i++) {
          for (let j = 0; j < matrix3.columns; j++) {
            matrix3.set(i, j, matrix3.get(i, j) - mean[i]);
          }
        }
      }
      function centerByColumn(matrix3, mean) {
        for (let i = 0; i < matrix3.rows; i++) {
          for (let j = 0; j < matrix3.columns; j++) {
            matrix3.set(i, j, matrix3.get(i, j) - mean[j]);
          }
        }
      }
      function centerAll(matrix3, mean) {
        for (let i = 0; i < matrix3.rows; i++) {
          for (let j = 0; j < matrix3.columns; j++) {
            matrix3.set(i, j, matrix3.get(i, j) - mean);
          }
        }
      }
      function getScaleByRow(matrix3) {
        const scale4 = [];
        for (let i = 0; i < matrix3.rows; i++) {
          let sum = 0;
          for (let j = 0; j < matrix3.columns; j++) {
            sum += matrix3.get(i, j) ** 2 / (matrix3.columns - 1);
          }
          scale4.push(Math.sqrt(sum));
        }
        return scale4;
      }
      function scaleByRow(matrix3, scale4) {
        for (let i = 0; i < matrix3.rows; i++) {
          for (let j = 0; j < matrix3.columns; j++) {
            matrix3.set(i, j, matrix3.get(i, j) / scale4[i]);
          }
        }
      }
      function getScaleByColumn(matrix3) {
        const scale4 = [];
        for (let j = 0; j < matrix3.columns; j++) {
          let sum = 0;
          for (let i = 0; i < matrix3.rows; i++) {
            sum += matrix3.get(i, j) ** 2 / (matrix3.rows - 1);
          }
          scale4.push(Math.sqrt(sum));
        }
        return scale4;
      }
      function scaleByColumn(matrix3, scale4) {
        for (let i = 0; i < matrix3.rows; i++) {
          for (let j = 0; j < matrix3.columns; j++) {
            matrix3.set(i, j, matrix3.get(i, j) / scale4[j]);
          }
        }
      }
      function getScaleAll(matrix3) {
        const divider = matrix3.size - 1;
        let sum = 0;
        for (let j = 0; j < matrix3.columns; j++) {
          for (let i = 0; i < matrix3.rows; i++) {
            sum += matrix3.get(i, j) ** 2 / divider;
          }
        }
        return Math.sqrt(sum);
      }
      function scaleAll(matrix3, scale4) {
        for (let i = 0; i < matrix3.rows; i++) {
          for (let j = 0; j < matrix3.columns; j++) {
            matrix3.set(i, j, matrix3.get(i, j) / scale4);
          }
        }
      }
      var AbstractMatrix2 = class _AbstractMatrix {
        static from1DArray(newRows, newColumns, newData) {
          let length = newRows * newColumns;
          if (length !== newData.length) {
            throw new RangeError("data length does not match given dimensions");
          }
          let newMatrix = new Matrix3(newRows, newColumns);
          for (let row2 = 0; row2 < newRows; row2++) {
            for (let column = 0; column < newColumns; column++) {
              newMatrix.set(row2, column, newData[row2 * newColumns + column]);
            }
          }
          return newMatrix;
        }
        static rowVector(newData) {
          let vector = new Matrix3(1, newData.length);
          for (let i = 0; i < newData.length; i++) {
            vector.set(0, i, newData[i]);
          }
          return vector;
        }
        static columnVector(newData) {
          let vector = new Matrix3(newData.length, 1);
          for (let i = 0; i < newData.length; i++) {
            vector.set(i, 0, newData[i]);
          }
          return vector;
        }
        static zeros(rows, columns) {
          return new Matrix3(rows, columns);
        }
        static ones(rows, columns) {
          return new Matrix3(rows, columns).fill(1);
        }
        static rand(rows, columns, options = {}) {
          if (typeof options !== "object") {
            throw new TypeError("options must be an object");
          }
          const { random = Math.random } = options;
          let matrix3 = new Matrix3(rows, columns);
          for (let i = 0; i < rows; i++) {
            for (let j = 0; j < columns; j++) {
              matrix3.set(i, j, random());
            }
          }
          return matrix3;
        }
        static randInt(rows, columns, options = {}) {
          if (typeof options !== "object") {
            throw new TypeError("options must be an object");
          }
          const { min: min4 = 0, max: max4 = 1e3, random = Math.random } = options;
          if (!Number.isInteger(min4)) throw new TypeError("min must be an integer");
          if (!Number.isInteger(max4)) throw new TypeError("max must be an integer");
          if (min4 >= max4) throw new RangeError("min must be smaller than max");
          let interval2 = max4 - min4;
          let matrix3 = new Matrix3(rows, columns);
          for (let i = 0; i < rows; i++) {
            for (let j = 0; j < columns; j++) {
              let value = min4 + Math.round(random() * interval2);
              matrix3.set(i, j, value);
            }
          }
          return matrix3;
        }
        static eye(rows, columns, value) {
          if (columns === void 0) columns = rows;
          if (value === void 0) value = 1;
          let min4 = Math.min(rows, columns);
          let matrix3 = this.zeros(rows, columns);
          for (let i = 0; i < min4; i++) {
            matrix3.set(i, i, value);
          }
          return matrix3;
        }
        static diag(data2, rows, columns) {
          let l = data2.length;
          if (rows === void 0) rows = l;
          if (columns === void 0) columns = rows;
          let min4 = Math.min(l, rows, columns);
          let matrix3 = this.zeros(rows, columns);
          for (let i = 0; i < min4; i++) {
            matrix3.set(i, i, data2[i]);
          }
          return matrix3;
        }
        static min(matrix1, matrix22) {
          matrix1 = this.checkMatrix(matrix1);
          matrix22 = this.checkMatrix(matrix22);
          let rows = matrix1.rows;
          let columns = matrix1.columns;
          let result = new Matrix3(rows, columns);
          for (let i = 0; i < rows; i++) {
            for (let j = 0; j < columns; j++) {
              result.set(i, j, Math.min(matrix1.get(i, j), matrix22.get(i, j)));
            }
          }
          return result;
        }
        static max(matrix1, matrix22) {
          matrix1 = this.checkMatrix(matrix1);
          matrix22 = this.checkMatrix(matrix22);
          let rows = matrix1.rows;
          let columns = matrix1.columns;
          let result = new this(rows, columns);
          for (let i = 0; i < rows; i++) {
            for (let j = 0; j < columns; j++) {
              result.set(i, j, Math.max(matrix1.get(i, j), matrix22.get(i, j)));
            }
          }
          return result;
        }
        static checkMatrix(value) {
          return _AbstractMatrix.isMatrix(value) ? value : new Matrix3(value);
        }
        static isMatrix(value) {
          return value != null && value.klass === "Matrix";
        }
        get size() {
          return this.rows * this.columns;
        }
        apply(callback) {
          if (typeof callback !== "function") {
            throw new TypeError("callback must be a function");
          }
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              callback.call(this, i, j);
            }
          }
          return this;
        }
        to1DArray() {
          let array = [];
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              array.push(this.get(i, j));
            }
          }
          return array;
        }
        to2DArray() {
          let copy = [];
          for (let i = 0; i < this.rows; i++) {
            copy.push([]);
            for (let j = 0; j < this.columns; j++) {
              copy[i].push(this.get(i, j));
            }
          }
          return copy;
        }
        toJSON() {
          return this.to2DArray();
        }
        isRowVector() {
          return this.rows === 1;
        }
        isColumnVector() {
          return this.columns === 1;
        }
        isVector() {
          return this.rows === 1 || this.columns === 1;
        }
        isSquare() {
          return this.rows === this.columns;
        }
        isEmpty() {
          return this.rows === 0 || this.columns === 0;
        }
        isSymmetric() {
          if (this.isSquare()) {
            for (let i = 0; i < this.rows; i++) {
              for (let j = 0; j <= i; j++) {
                if (this.get(i, j) !== this.get(j, i)) {
                  return false;
                }
              }
            }
            return true;
          }
          return false;
        }
        isDistance() {
          if (!this.isSymmetric()) return false;
          for (let i = 0; i < this.rows; i++) {
            if (this.get(i, i) !== 0) return false;
          }
          return true;
        }
        isEchelonForm() {
          let i = 0;
          let j = 0;
          let previousColumn = -1;
          let isEchelonForm = true;
          let checked = false;
          while (i < this.rows && isEchelonForm) {
            j = 0;
            checked = false;
            while (j < this.columns && checked === false) {
              if (this.get(i, j) === 0) {
                j++;
              } else if (this.get(i, j) === 1 && j > previousColumn) {
                checked = true;
                previousColumn = j;
              } else {
                isEchelonForm = false;
                checked = true;
              }
            }
            i++;
          }
          return isEchelonForm;
        }
        isReducedEchelonForm() {
          let i = 0;
          let j = 0;
          let previousColumn = -1;
          let isReducedEchelonForm = true;
          let checked = false;
          while (i < this.rows && isReducedEchelonForm) {
            j = 0;
            checked = false;
            while (j < this.columns && checked === false) {
              if (this.get(i, j) === 0) {
                j++;
              } else if (this.get(i, j) === 1 && j > previousColumn) {
                checked = true;
                previousColumn = j;
              } else {
                isReducedEchelonForm = false;
                checked = true;
              }
            }
            for (let k = j + 1; k < this.rows; k++) {
              if (this.get(i, k) !== 0) {
                isReducedEchelonForm = false;
              }
            }
            i++;
          }
          return isReducedEchelonForm;
        }
        echelonForm() {
          let result = this.clone();
          let h = 0;
          let k = 0;
          while (h < result.rows && k < result.columns) {
            let iMax = h;
            for (let i = h; i < result.rows; i++) {
              if (result.get(i, k) > result.get(iMax, k)) {
                iMax = i;
              }
            }
            if (result.get(iMax, k) === 0) {
              k++;
            } else {
              result.swapRows(h, iMax);
              let tmp2 = result.get(h, k);
              for (let j = k; j < result.columns; j++) {
                result.set(h, j, result.get(h, j) / tmp2);
              }
              for (let i = h + 1; i < result.rows; i++) {
                let factor = result.get(i, k) / result.get(h, k);
                result.set(i, k, 0);
                for (let j = k + 1; j < result.columns; j++) {
                  result.set(i, j, result.get(i, j) - result.get(h, j) * factor);
                }
              }
              h++;
              k++;
            }
          }
          return result;
        }
        reducedEchelonForm() {
          let result = this.echelonForm();
          let m2 = result.columns;
          let n = result.rows;
          let h = n - 1;
          while (h >= 0) {
            if (result.maxRow(h) === 0) {
              h--;
            } else {
              let p = 0;
              let pivot = false;
              while (p < n && pivot === false) {
                if (result.get(h, p) === 1) {
                  pivot = true;
                } else {
                  p++;
                }
              }
              for (let i = 0; i < h; i++) {
                let factor = result.get(i, p);
                for (let j = p; j < m2; j++) {
                  let tmp2 = result.get(i, j) - factor * result.get(h, j);
                  result.set(i, j, tmp2);
                }
              }
              h--;
            }
          }
          return result;
        }
        set() {
          throw new Error("set method is unimplemented");
        }
        get() {
          throw new Error("get method is unimplemented");
        }
        repeat(options = {}) {
          if (typeof options !== "object") {
            throw new TypeError("options must be an object");
          }
          const { rows = 1, columns = 1 } = options;
          if (!Number.isInteger(rows) || rows <= 0) {
            throw new TypeError("rows must be a positive integer");
          }
          if (!Number.isInteger(columns) || columns <= 0) {
            throw new TypeError("columns must be a positive integer");
          }
          let matrix3 = new Matrix3(this.rows * rows, this.columns * columns);
          for (let i = 0; i < rows; i++) {
            for (let j = 0; j < columns; j++) {
              matrix3.setSubMatrix(this, this.rows * i, this.columns * j);
            }
          }
          return matrix3;
        }
        fill(value) {
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, value);
            }
          }
          return this;
        }
        neg() {
          return this.mulS(-1);
        }
        getRow(index2) {
          checkRowIndex(this, index2);
          let row2 = [];
          for (let i = 0; i < this.columns; i++) {
            row2.push(this.get(index2, i));
          }
          return row2;
        }
        getRowVector(index2) {
          return Matrix3.rowVector(this.getRow(index2));
        }
        setRow(index2, array) {
          checkRowIndex(this, index2);
          array = checkRowVector(this, array);
          for (let i = 0; i < this.columns; i++) {
            this.set(index2, i, array[i]);
          }
          return this;
        }
        swapRows(row1, row2) {
          checkRowIndex(this, row1);
          checkRowIndex(this, row2);
          for (let i = 0; i < this.columns; i++) {
            let temp = this.get(row1, i);
            this.set(row1, i, this.get(row2, i));
            this.set(row2, i, temp);
          }
          return this;
        }
        getColumn(index2) {
          checkColumnIndex(this, index2);
          let column = [];
          for (let i = 0; i < this.rows; i++) {
            column.push(this.get(i, index2));
          }
          return column;
        }
        getColumnVector(index2) {
          return Matrix3.columnVector(this.getColumn(index2));
        }
        setColumn(index2, array) {
          checkColumnIndex(this, index2);
          array = checkColumnVector(this, array);
          for (let i = 0; i < this.rows; i++) {
            this.set(i, index2, array[i]);
          }
          return this;
        }
        swapColumns(column1, column2) {
          checkColumnIndex(this, column1);
          checkColumnIndex(this, column2);
          for (let i = 0; i < this.rows; i++) {
            let temp = this.get(i, column1);
            this.set(i, column1, this.get(i, column2));
            this.set(i, column2, temp);
          }
          return this;
        }
        addRowVector(vector) {
          vector = checkRowVector(this, vector);
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) + vector[j]);
            }
          }
          return this;
        }
        subRowVector(vector) {
          vector = checkRowVector(this, vector);
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) - vector[j]);
            }
          }
          return this;
        }
        mulRowVector(vector) {
          vector = checkRowVector(this, vector);
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) * vector[j]);
            }
          }
          return this;
        }
        divRowVector(vector) {
          vector = checkRowVector(this, vector);
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) / vector[j]);
            }
          }
          return this;
        }
        addColumnVector(vector) {
          vector = checkColumnVector(this, vector);
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) + vector[i]);
            }
          }
          return this;
        }
        subColumnVector(vector) {
          vector = checkColumnVector(this, vector);
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) - vector[i]);
            }
          }
          return this;
        }
        mulColumnVector(vector) {
          vector = checkColumnVector(this, vector);
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) * vector[i]);
            }
          }
          return this;
        }
        divColumnVector(vector) {
          vector = checkColumnVector(this, vector);
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              this.set(i, j, this.get(i, j) / vector[i]);
            }
          }
          return this;
        }
        mulRow(index2, value) {
          checkRowIndex(this, index2);
          for (let i = 0; i < this.columns; i++) {
            this.set(index2, i, this.get(index2, i) * value);
          }
          return this;
        }
        mulColumn(index2, value) {
          checkColumnIndex(this, index2);
          for (let i = 0; i < this.rows; i++) {
            this.set(i, index2, this.get(i, index2) * value);
          }
          return this;
        }
        max(by) {
          if (this.isEmpty()) {
            return NaN;
          }
          switch (by) {
            case "row": {
              const max4 = new Array(this.rows).fill(Number.NEGATIVE_INFINITY);
              for (let row2 = 0; row2 < this.rows; row2++) {
                for (let column = 0; column < this.columns; column++) {
                  if (this.get(row2, column) > max4[row2]) {
                    max4[row2] = this.get(row2, column);
                  }
                }
              }
              return max4;
            }
            case "column": {
              const max4 = new Array(this.columns).fill(Number.NEGATIVE_INFINITY);
              for (let row2 = 0; row2 < this.rows; row2++) {
                for (let column = 0; column < this.columns; column++) {
                  if (this.get(row2, column) > max4[column]) {
                    max4[column] = this.get(row2, column);
                  }
                }
              }
              return max4;
            }
            case void 0: {
              let max4 = this.get(0, 0);
              for (let row2 = 0; row2 < this.rows; row2++) {
                for (let column = 0; column < this.columns; column++) {
                  if (this.get(row2, column) > max4) {
                    max4 = this.get(row2, column);
                  }
                }
              }
              return max4;
            }
            default:
              throw new Error(`invalid option: ${by}`);
          }
        }
        maxIndex() {
          checkNonEmpty(this);
          let v = this.get(0, 0);
          let idx = [0, 0];
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              if (this.get(i, j) > v) {
                v = this.get(i, j);
                idx[0] = i;
                idx[1] = j;
              }
            }
          }
          return idx;
        }
        min(by) {
          if (this.isEmpty()) {
            return NaN;
          }
          switch (by) {
            case "row": {
              const min4 = new Array(this.rows).fill(Number.POSITIVE_INFINITY);
              for (let row2 = 0; row2 < this.rows; row2++) {
                for (let column = 0; column < this.columns; column++) {
                  if (this.get(row2, column) < min4[row2]) {
                    min4[row2] = this.get(row2, column);
                  }
                }
              }
              return min4;
            }
            case "column": {
              const min4 = new Array(this.columns).fill(Number.POSITIVE_INFINITY);
              for (let row2 = 0; row2 < this.rows; row2++) {
                for (let column = 0; column < this.columns; column++) {
                  if (this.get(row2, column) < min4[column]) {
                    min4[column] = this.get(row2, column);
                  }
                }
              }
              return min4;
            }
            case void 0: {
              let min4 = this.get(0, 0);
              for (let row2 = 0; row2 < this.rows; row2++) {
                for (let column = 0; column < this.columns; column++) {
                  if (this.get(row2, column) < min4) {
                    min4 = this.get(row2, column);
                  }
                }
              }
              return min4;
            }
            default:
              throw new Error(`invalid option: ${by}`);
          }
        }
        minIndex() {
          checkNonEmpty(this);
          let v = this.get(0, 0);
          let idx = [0, 0];
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              if (this.get(i, j) < v) {
                v = this.get(i, j);
                idx[0] = i;
                idx[1] = j;
              }
            }
          }
          return idx;
        }
        maxRow(row2) {
          checkRowIndex(this, row2);
          if (this.isEmpty()) {
            return NaN;
          }
          let v = this.get(row2, 0);
          for (let i = 1; i < this.columns; i++) {
            if (this.get(row2, i) > v) {
              v = this.get(row2, i);
            }
          }
          return v;
        }
        maxRowIndex(row2) {
          checkRowIndex(this, row2);
          checkNonEmpty(this);
          let v = this.get(row2, 0);
          let idx = [row2, 0];
          for (let i = 1; i < this.columns; i++) {
            if (this.get(row2, i) > v) {
              v = this.get(row2, i);
              idx[1] = i;
            }
          }
          return idx;
        }
        minRow(row2) {
          checkRowIndex(this, row2);
          if (this.isEmpty()) {
            return NaN;
          }
          let v = this.get(row2, 0);
          for (let i = 1; i < this.columns; i++) {
            if (this.get(row2, i) < v) {
              v = this.get(row2, i);
            }
          }
          return v;
        }
        minRowIndex(row2) {
          checkRowIndex(this, row2);
          checkNonEmpty(this);
          let v = this.get(row2, 0);
          let idx = [row2, 0];
          for (let i = 1; i < this.columns; i++) {
            if (this.get(row2, i) < v) {
              v = this.get(row2, i);
              idx[1] = i;
            }
          }
          return idx;
        }
        maxColumn(column) {
          checkColumnIndex(this, column);
          if (this.isEmpty()) {
            return NaN;
          }
          let v = this.get(0, column);
          for (let i = 1; i < this.rows; i++) {
            if (this.get(i, column) > v) {
              v = this.get(i, column);
            }
          }
          return v;
        }
        maxColumnIndex(column) {
          checkColumnIndex(this, column);
          checkNonEmpty(this);
          let v = this.get(0, column);
          let idx = [0, column];
          for (let i = 1; i < this.rows; i++) {
            if (this.get(i, column) > v) {
              v = this.get(i, column);
              idx[0] = i;
            }
          }
          return idx;
        }
        minColumn(column) {
          checkColumnIndex(this, column);
          if (this.isEmpty()) {
            return NaN;
          }
          let v = this.get(0, column);
          for (let i = 1; i < this.rows; i++) {
            if (this.get(i, column) < v) {
              v = this.get(i, column);
            }
          }
          return v;
        }
        minColumnIndex(column) {
          checkColumnIndex(this, column);
          checkNonEmpty(this);
          let v = this.get(0, column);
          let idx = [0, column];
          for (let i = 1; i < this.rows; i++) {
            if (this.get(i, column) < v) {
              v = this.get(i, column);
              idx[0] = i;
            }
          }
          return idx;
        }
        diag() {
          let min4 = Math.min(this.rows, this.columns);
          let diag = [];
          for (let i = 0; i < min4; i++) {
            diag.push(this.get(i, i));
          }
          return diag;
        }
        norm(type = "frobenius") {
          switch (type) {
            case "max":
              return this.max();
            case "frobenius":
              return Math.sqrt(this.dot(this));
            default:
              throw new RangeError(`unknown norm type: ${type}`);
          }
        }
        cumulativeSum() {
          let sum = 0;
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              sum += this.get(i, j);
              this.set(i, j, sum);
            }
          }
          return this;
        }
        dot(vector2) {
          if (_AbstractMatrix.isMatrix(vector2)) vector2 = vector2.to1DArray();
          let vector1 = this.to1DArray();
          if (vector1.length !== vector2.length) {
            throw new RangeError("vectors do not have the same size");
          }
          let dot4 = 0;
          for (let i = 0; i < vector1.length; i++) {
            dot4 += vector1[i] * vector2[i];
          }
          return dot4;
        }
        mmul(other) {
          other = Matrix3.checkMatrix(other);
          let m2 = this.rows;
          let n = this.columns;
          let p = other.columns;
          let result = new Matrix3(m2, p);
          let Bcolj = new Float64Array(n);
          for (let j = 0; j < p; j++) {
            for (let k = 0; k < n; k++) {
              Bcolj[k] = other.get(k, j);
            }
            for (let i = 0; i < m2; i++) {
              let s = 0;
              for (let k = 0; k < n; k++) {
                s += this.get(i, k) * Bcolj[k];
              }
              result.set(i, j, s);
            }
          }
          return result;
        }
        mpow(scalar) {
          if (!this.isSquare()) {
            throw new RangeError("Matrix must be square");
          }
          if (!Number.isInteger(scalar) || scalar < 0) {
            throw new RangeError("Exponent must be a non-negative integer");
          }
          let result = Matrix3.eye(this.rows);
          let bb = this;
          for (let e = scalar; e >= 1; e /= 2) {
            if ((e & 1) !== 0) {
              result = result.mmul(bb);
            }
            bb = bb.mmul(bb);
          }
          return result;
        }
        strassen2x2(other) {
          other = Matrix3.checkMatrix(other);
          let result = new Matrix3(2, 2);
          const a11 = this.get(0, 0);
          const b11 = other.get(0, 0);
          const a12 = this.get(0, 1);
          const b12 = other.get(0, 1);
          const a21 = this.get(1, 0);
          const b21 = other.get(1, 0);
          const a22 = this.get(1, 1);
          const b22 = other.get(1, 1);
          const m1 = (a11 + a22) * (b11 + b22);
          const m2 = (a21 + a22) * b11;
          const m3 = a11 * (b12 - b22);
          const m4 = a22 * (b21 - b11);
          const m5 = (a11 + a12) * b22;
          const m6 = (a21 - a11) * (b11 + b12);
          const m7 = (a12 - a22) * (b21 + b22);
          const c00 = m1 + m4 - m5 + m7;
          const c01 = m3 + m5;
          const c10 = m2 + m4;
          const c11 = m1 - m2 + m3 + m6;
          result.set(0, 0, c00);
          result.set(0, 1, c01);
          result.set(1, 0, c10);
          result.set(1, 1, c11);
          return result;
        }
        strassen3x3(other) {
          other = Matrix3.checkMatrix(other);
          let result = new Matrix3(3, 3);
          const a00 = this.get(0, 0);
          const a01 = this.get(0, 1);
          const a02 = this.get(0, 2);
          const a10 = this.get(1, 0);
          const a11 = this.get(1, 1);
          const a12 = this.get(1, 2);
          const a20 = this.get(2, 0);
          const a21 = this.get(2, 1);
          const a22 = this.get(2, 2);
          const b00 = other.get(0, 0);
          const b01 = other.get(0, 1);
          const b02 = other.get(0, 2);
          const b10 = other.get(1, 0);
          const b11 = other.get(1, 1);
          const b12 = other.get(1, 2);
          const b20 = other.get(2, 0);
          const b21 = other.get(2, 1);
          const b22 = other.get(2, 2);
          const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;
          const m2 = (a00 - a10) * (-b01 + b11);
          const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);
          const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);
          const m5 = (a10 + a11) * (-b00 + b01);
          const m6 = a00 * b00;
          const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);
          const m8 = (-a00 + a20) * (b02 - b12);
          const m9 = (a20 + a21) * (-b00 + b02);
          const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;
          const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);
          const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);
          const m13 = (a02 - a22) * (b11 - b21);
          const m14 = a02 * b20;
          const m15 = (a21 + a22) * (-b20 + b21);
          const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);
          const m17 = (a02 - a12) * (b12 - b22);
          const m18 = (a11 + a12) * (-b20 + b22);
          const m19 = a01 * b10;
          const m20 = a12 * b21;
          const m21 = a10 * b02;
          const m22 = a20 * b01;
          const m23 = a22 * b22;
          const c00 = m6 + m14 + m19;
          const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;
          const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;
          const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;
          const c11 = m2 + m4 + m5 + m6 + m20;
          const c12 = m14 + m16 + m17 + m18 + m21;
          const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;
          const c21 = m12 + m13 + m14 + m15 + m22;
          const c22 = m6 + m7 + m8 + m9 + m23;
          result.set(0, 0, c00);
          result.set(0, 1, c01);
          result.set(0, 2, c02);
          result.set(1, 0, c10);
          result.set(1, 1, c11);
          result.set(1, 2, c12);
          result.set(2, 0, c20);
          result.set(2, 1, c21);
          result.set(2, 2, c22);
          return result;
        }
        mmulStrassen(y3) {
          y3 = Matrix3.checkMatrix(y3);
          let x3 = this.clone();
          let r1 = x3.rows;
          let c1 = x3.columns;
          let r2 = y3.rows;
          let c2 = y3.columns;
          if (c1 !== r2) {
            console.warn(
              `Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`
            );
          }
          function embed(mat, rows, cols) {
            let r3 = mat.rows;
            let c4 = mat.columns;
            if (r3 === rows && c4 === cols) {
              return mat;
            } else {
              let resultat = _AbstractMatrix.zeros(rows, cols);
              resultat = resultat.setSubMatrix(mat, 0, 0);
              return resultat;
            }
          }
          let r = Math.max(r1, r2);
          let c3 = Math.max(c1, c2);
          x3 = embed(x3, r, c3);
          y3 = embed(y3, r, c3);
          function blockMult(a2, b, rows, cols) {
            if (rows <= 512 || cols <= 512) {
              return a2.mmul(b);
            }
            if (rows % 2 === 1 && cols % 2 === 1) {
              a2 = embed(a2, rows + 1, cols + 1);
              b = embed(b, rows + 1, cols + 1);
            } else if (rows % 2 === 1) {
              a2 = embed(a2, rows + 1, cols);
              b = embed(b, rows + 1, cols);
            } else if (cols % 2 === 1) {
              a2 = embed(a2, rows, cols + 1);
              b = embed(b, rows, cols + 1);
            }
            let halfRows = parseInt(a2.rows / 2, 10);
            let halfCols = parseInt(a2.columns / 2, 10);
            let a11 = a2.subMatrix(0, halfRows - 1, 0, halfCols - 1);
            let b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);
            let a12 = a2.subMatrix(0, halfRows - 1, halfCols, a2.columns - 1);
            let b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);
            let a21 = a2.subMatrix(halfRows, a2.rows - 1, 0, halfCols - 1);
            let b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);
            let a22 = a2.subMatrix(halfRows, a2.rows - 1, halfCols, a2.columns - 1);
            let b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);
            let m1 = blockMult(
              _AbstractMatrix.add(a11, a22),
              _AbstractMatrix.add(b11, b22),
              halfRows,
              halfCols
            );
            let m2 = blockMult(_AbstractMatrix.add(a21, a22), b11, halfRows, halfCols);
            let m3 = blockMult(a11, _AbstractMatrix.sub(b12, b22), halfRows, halfCols);
            let m4 = blockMult(a22, _AbstractMatrix.sub(b21, b11), halfRows, halfCols);
            let m5 = blockMult(_AbstractMatrix.add(a11, a12), b22, halfRows, halfCols);
            let m6 = blockMult(
              _AbstractMatrix.sub(a21, a11),
              _AbstractMatrix.add(b11, b12),
              halfRows,
              halfCols
            );
            let m7 = blockMult(
              _AbstractMatrix.sub(a12, a22),
              _AbstractMatrix.add(b21, b22),
              halfRows,
              halfCols
            );
            let c11 = _AbstractMatrix.add(m1, m4);
            c11.sub(m5);
            c11.add(m7);
            let c12 = _AbstractMatrix.add(m3, m5);
            let c21 = _AbstractMatrix.add(m2, m4);
            let c22 = _AbstractMatrix.sub(m1, m2);
            c22.add(m3);
            c22.add(m6);
            let result = _AbstractMatrix.zeros(2 * c11.rows, 2 * c11.columns);
            result = result.setSubMatrix(c11, 0, 0);
            result = result.setSubMatrix(c12, c11.rows, 0);
            result = result.setSubMatrix(c21, 0, c11.columns);
            result = result.setSubMatrix(c22, c11.rows, c11.columns);
            return result.subMatrix(0, rows - 1, 0, cols - 1);
          }
          return blockMult(x3, y3, r, c3);
        }
        scaleRows(options = {}) {
          if (typeof options !== "object") {
            throw new TypeError("options must be an object");
          }
          const { min: min4 = 0, max: max4 = 1 } = options;
          if (!Number.isFinite(min4)) throw new TypeError("min must be a number");
          if (!Number.isFinite(max4)) throw new TypeError("max must be a number");
          if (min4 >= max4) throw new RangeError("min must be smaller than max");
          let newMatrix = new Matrix3(this.rows, this.columns);
          for (let i = 0; i < this.rows; i++) {
            const row2 = this.getRow(i);
            if (row2.length > 0) {
              rescale(row2, { min: min4, max: max4, output: row2 });
            }
            newMatrix.setRow(i, row2);
          }
          return newMatrix;
        }
        scaleColumns(options = {}) {
          if (typeof options !== "object") {
            throw new TypeError("options must be an object");
          }
          const { min: min4 = 0, max: max4 = 1 } = options;
          if (!Number.isFinite(min4)) throw new TypeError("min must be a number");
          if (!Number.isFinite(max4)) throw new TypeError("max must be a number");
          if (min4 >= max4) throw new RangeError("min must be smaller than max");
          let newMatrix = new Matrix3(this.rows, this.columns);
          for (let i = 0; i < this.columns; i++) {
            const column = this.getColumn(i);
            if (column.length) {
              rescale(column, {
                min: min4,
                max: max4,
                output: column
              });
            }
            newMatrix.setColumn(i, column);
          }
          return newMatrix;
        }
        flipRows() {
          const middle = Math.ceil(this.columns / 2);
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < middle; j++) {
              let first = this.get(i, j);
              let last2 = this.get(i, this.columns - 1 - j);
              this.set(i, j, last2);
              this.set(i, this.columns - 1 - j, first);
            }
          }
          return this;
        }
        flipColumns() {
          const middle = Math.ceil(this.rows / 2);
          for (let j = 0; j < this.columns; j++) {
            for (let i = 0; i < middle; i++) {
              let first = this.get(i, j);
              let last2 = this.get(this.rows - 1 - i, j);
              this.set(i, j, last2);
              this.set(this.rows - 1 - i, j, first);
            }
          }
          return this;
        }
        kroneckerProduct(other) {
          other = Matrix3.checkMatrix(other);
          let m2 = this.rows;
          let n = this.columns;
          let p = other.rows;
          let q = other.columns;
          let result = new Matrix3(m2 * p, n * q);
          for (let i = 0; i < m2; i++) {
            for (let j = 0; j < n; j++) {
              for (let k = 0; k < p; k++) {
                for (let l = 0; l < q; l++) {
                  result.set(p * i + k, q * j + l, this.get(i, j) * other.get(k, l));
                }
              }
            }
          }
          return result;
        }
        kroneckerSum(other) {
          other = Matrix3.checkMatrix(other);
          if (!this.isSquare() || !other.isSquare()) {
            throw new Error("Kronecker Sum needs two Square Matrices");
          }
          let m2 = this.rows;
          let n = other.rows;
          let AxI = this.kroneckerProduct(Matrix3.eye(n, n));
          let IxB = Matrix3.eye(m2, m2).kroneckerProduct(other);
          return AxI.add(IxB);
        }
        transpose() {
          let result = new Matrix3(this.columns, this.rows);
          for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.columns; j++) {
              result.set(j, i, this.get(i, j));
            }
          }
          return result;
        }
        sortRows(compareFunction = compareNumbers) {
          for (let i = 0; i < this.rows; i++) {
            this.setRow(i, this.getRow(i).sort(compareFunction));
          }
          return this;
        }
        sortColumns(compareFunction = compareNumbers) {
          for (let i = 0; i < this.columns; i++) {
            this.setColumn(i, this.getColumn(i).sort(compareFunction));
          }
          return this;
        }
        subMatrix(startRow, endRow, startColumn, endColumn) {
          checkRange(this, startRow, endRow, startColumn, endColumn);
          let newMatrix = new Matrix3(
            endRow - startRow + 1,
            endColumn - startColumn + 1
          );
          for (let i = startRow; i <= endRow; i++) {
            for (let j = startColumn; j <= endColumn; j++) {
              newMatrix.set(i - startRow, j - startColumn, this.get(i, j));
            }
          }
          return newMatrix;
        }
        subMatrixRow(indices, startColumn, endColumn) {
          if (startColumn === void 0) startColumn = 0;
          if (endColumn === void 0) endColumn = this.columns - 1;
          if (startColumn > endColumn || startColumn < 0 || startColumn >= this.columns || endColumn < 0 || endColumn >= this.columns) {
            throw new RangeError("Argument out of range");
          }
          let newMatrix = new Matrix3(indices.length, endColumn - startColumn + 1);
          for (let i = 0; i < indices.length; i++) {
            for (let j = startColumn; j <= endColumn; j++) {
              if (indices[i] < 0 || indices[i] >= this.rows) {
                throw new RangeError(`Row index out of range: ${indices[i]}`);
              }
              newMatrix.set(i, j - startColumn, this.get(indices[i], j));
            }
          }
          return newMatrix;
        }
        subMatrixColumn(indices, startRow, endRow) {
          if (startRow === void 0) startRow = 0;
          if (endRow === void 0) endRow = this.rows - 1;
          if (startRow > endRow || startRow < 0 || startRow >= this.rows || endRow < 0 || endRow >= this.rows) {
            throw new RangeError("Argument out of range");
          }
          let newMatrix = new Matrix3(endRow - startRow + 1, indices.length);
          for (let i = 0; i < indices.length; i++) {
            for (let j = startRow; j <= endRow; j++) {
              if (indices[i] < 0 || indices[i] >= this.columns) {
                throw new RangeError(`Column index out of range: ${indices[i]}`);
              }
              newMatrix.set(j - startRow, i, this.get(j, indices[i]));
            }
          }
          return newMatrix;
        }
        setSubMatrix(matrix3, startRow, startColumn) {
          matrix3 = Matrix3.checkMatrix(matrix3);
          if (matrix3.isEmpty()) {
            return this;
          }
          let endRow = startRow + matrix3.rows - 1;
          let endColumn = startColumn + matrix3.columns - 1;
          checkRange(this, startRow, endRow, startColumn, endColumn);
          for (let i = 0; i < matrix3.rows; i++) {
            for (let j = 0; j < matrix3.columns; j++) {
              this.set(startRow + i, startColumn + j, matrix3.get(i, j));
            }
          }
          return this;
        }
        selection(rowIndices, columnIndices) {
          checkRowIndices(this, rowIndices);
          checkColumnIndices(this, columnIndices);
          let newMatrix = new Matrix3(rowIndices.length, columnIndices.length);
          for (let i = 0; i < rowIndices.length; i++) {
            let rowIndex = rowIndices[i];
            for (let j = 0; j < columnIndices.length; j++) {
              let columnIndex = columnIndices[j];
              newMatrix.set(i, j, this.get(rowIndex, columnIndex));
            }
          }
          return newMatrix;
        }
        trace() {
          let min4 = Math.min(this.rows, this.columns);
          let trace = 0;
          for (let i = 0; i < min4; i++) {
            trace += this.get(i, i);
          }
          return trace;
        }
        clone() {
          return this.constructor.copy(this, new Matrix3(this.rows, this.columns));
        }
        /**
         * @template {AbstractMatrix} M
         * @param {AbstractMatrix} from
         * @param {M} to
         * @return {M}
         */
        static copy(from, to) {
          for (const [row2, column, value] of from.entries()) {
            to.set(row2, column, value);
          }
          return to;
        }
        sum(by) {
          switch (by) {
            case "row":
              return sumByRow(this);
            case "column":
              return sumByColumn(this);
            case void 0:
              return sumAll(this);
            default:
              throw new Error(`invalid option: ${by}`);
          }
        }
        product(by) {
          switch (by) {
            case "row":
              return productByRow(this);
            case "column":
              return productByColumn(this);
            case void 0:
              return productAll(this);
            default:
              throw new Error(`invalid option: ${by}`);
          }
        }
        mean(by) {
          const sum = this.sum(by);
          switch (by) {
            case "row": {
              for (let i = 0; i < this.rows; i++) {
                sum[i] /= this.columns;
              }
              return sum;
            }
            case "column": {
              for (let i = 0; i < this.columns; i++) {
                sum[i] /= this.rows;
              }
              return sum;
            }
            case void 0:
              return sum / this.size;
            default:
              throw new Error(`invalid option: ${by}`);
          }
        }
        variance(by, options = {}) {
          if (typeof by === "object") {
            options = by;
            by = void 0;
          }
          if (typeof options !== "object") {
            throw new TypeError("options must be an object");
          }
          const { unbiased = true, mean = this.mean(by) } = options;
          if (typeof unbiased !== "boolean") {
            throw new TypeError("unbiased must be a boolean");
          }
          switch (by) {
            case "row": {
              if (!isAnyArray.isAnyArray(mean)) {
                throw new TypeError("mean must be an array");
              }
              return varianceByRow(this, unbiased, mean);
            }
            case "column": {
              if (!isAnyArray.isAnyArray(mean)) {
                throw new TypeError("mean must be an array");
              }
              return varianceByColumn(this, unbiased, mean);
            }
            case void 0: {
              if (typeof mean !== "number") {
                throw new TypeError("mean must be a number");
              }
              return varianceAll(this, unbiased, mean);
            }
            default:
              throw new Error(`invalid option: ${by}`);
          }
        }
        standardDeviation(by, options) {
          if (typeof by === "object") {
            options = by;
            by = void 0;
          }
          const variance = this.variance(by, options);
          if (by === void 0) {
            return Math.sqrt(variance);
          } else {
            for (let i = 0; i < variance.length; i++) {
              variance[i] = Math.sqrt(variance[i]);
            }
            return variance;
          }
        }
        center(by, options = {}) {
          if (typeof by === "object") {
            options = by;
            by = void 0;
          }
          if (typeof options !== "object") {
            throw new TypeError("options must be an object");
          }
          const { center = this.mean(by) } = options;
          switch (by) {
            case "row": {
              if (!isAnyArray.isAnyArray(center)) {
                throw new TypeError("center must be an array");
              }
              centerByRow(this, center);
              return this;
            }
            case "column": {
              if (!isAnyArray.isAnyArray(center)) {
                throw new TypeError("center must be an array");
              }
              centerByColumn(this, center);
              return this;
            }
            case void 0: {
              if (typeof center !== "number") {
                throw new TypeError("center must be a number");
              }
              centerAll(this, center);
              return this;
            }
            default:
              throw new Error(`invalid option: ${by}`);
          }
        }
        scale(by, options = {}) {
          if (typeof by === "object") {
            options = by;
            by = void 0;
          }
          if (typeof options !== "object") {
            throw new TypeError("options must be an object");
          }
          let scale4 = options.scale;
          switch (by) {
            case "row": {
              if (scale4 === void 0) {
                scale4 = getScaleByRow(this);
              } else if (!isAnyArray.isAnyArray(scale4)) {
                throw new TypeError("scale must be an array");
              }
              scaleByRow(this, scale4);
              return this;
            }
            case "column": {
              if (scale4 === void 0) {
                scale4 = getScaleByColumn(this);
              } else if (!isAnyArray.isAnyArray(scale4)) {
                throw new TypeError("scale must be an array");
              }
              scaleByColumn(this, scale4);
              return this;
            }
            case void 0: {
              if (scale4 === void 0) {
                scale4 = getScaleAll(this);
              } else if (typeof scale4 !== "number") {
                throw new TypeError("scale must be a number");
              }
              scaleAll(this, scale4);
              return this;
            }
            default:
              throw new Error(`invalid option: ${by}`);
          }
        }
        toString(options) {
          return inspectMatrixWithOptions(this, options);
        }
        [Symbol.iterator]() {
          return this.entries();
        }
        /**
         * iterator from left to right, from top to bottom
         * yield [row, column, value]
         * @returns {Generator<[number, number, number], void, void>}
         */
        *entries() {
          for (let row2 = 0; row2 < this.rows; row2++) {
            for (let col = 0; col < this.columns; col++) {
              yield [row2, col, this.get(row2, col)];
            }
          }
        }
        /**
         * iterator from left to right, from top to bottom
         * yield value
         * @returns {Generator<number, void, void>}
         */
        *values() {
          for (let row2 = 0; row2 < this.rows; row2++) {
            for (let col = 0; col < this.columns; col++) {
              yield this.get(row2, col);
            }
          }
        }
      };
      AbstractMatrix2.prototype.klass = "Matrix";
      if (typeof Symbol !== "undefined") {
        AbstractMatrix2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspectMatrix;
      }
      function compareNumbers(a2, b) {
        return a2 - b;
      }
      function isArrayOfNumbers(array) {
        return array.every((element) => {
          return typeof element === "number";
        });
      }
      AbstractMatrix2.random = AbstractMatrix2.rand;
      AbstractMatrix2.randomInt = AbstractMatrix2.randInt;
      AbstractMatrix2.diagonal = AbstractMatrix2.diag;
      AbstractMatrix2.prototype.diagonal = AbstractMatrix2.prototype.diag;
      AbstractMatrix2.identity = AbstractMatrix2.eye;
      AbstractMatrix2.prototype.negate = AbstractMatrix2.prototype.neg;
      AbstractMatrix2.prototype.tensorProduct = AbstractMatrix2.prototype.kroneckerProduct;
      var Matrix3 = class _Matrix extends AbstractMatrix2 {
        /**
         * @type {Float64Array[]}
         */
        data;
        /**
         * Init an empty matrix
         * @param {number} nRows
         * @param {number} nColumns
         */
        #initData(nRows, nColumns) {
          this.data = [];
          if (Number.isInteger(nColumns) && nColumns >= 0) {
            for (let i = 0; i < nRows; i++) {
              this.data.push(new Float64Array(nColumns));
            }
          } else {
            throw new TypeError("nColumns must be a positive integer");
          }
          this.rows = nRows;
          this.columns = nColumns;
        }
        constructor(nRows, nColumns) {
          super();
          if (_Matrix.isMatrix(nRows)) {
            this.#initData(nRows.rows, nRows.columns);
            _Matrix.copy(nRows, this);
          } else if (Number.isInteger(nRows) && nRows >= 0) {
            this.#initData(nRows, nColumns);
          } else if (isAnyArray.isAnyArray(nRows)) {
            const arrayData = nRows;
            nRows = arrayData.length;
            nColumns = nRows ? arrayData[0].length : 0;
            if (typeof nColumns !== "number") {
              throw new TypeError(
                "Data must be a 2D array with at least one element"
              );
            }
            this.data = [];
            for (let i = 0; i < nRows; i++) {
              if (arrayData[i].length !== nColumns) {
                throw new RangeError("Inconsistent array dimensions");
              }
              if (!isArrayOfNumbers(arrayData[i])) {
                throw new TypeError("Input data contains non-numeric values");
              }
              this.data.push(Float64Array.from(arrayData[i]));
            }
            this.rows = nRows;
            this.columns = nColumns;
          } else {
            throw new TypeError(
              "First argument must be a positive number or an array"
            );
          }
        }
        set(rowIndex, columnIndex, value) {
          this.data[rowIndex][columnIndex] = value;
          return this;
        }
        get(rowIndex, columnIndex) {
          return this.data[rowIndex][columnIndex];
        }
        removeRow(index2) {
          checkRowIndex(this, index2);
          this.data.splice(index2, 1);
          this.rows -= 1;
          return this;
        }
        addRow(index2, array) {
          if (array === void 0) {
            array = index2;
            index2 = this.rows;
          }
          checkRowIndex(this, index2, true);
          array = Float64Array.from(checkRowVector(this, array));
          this.data.splice(index2, 0, array);
          this.rows += 1;
          return this;
        }
        removeColumn(index2) {
          checkColumnIndex(this, index2);
          for (let i = 0; i < this.rows; i++) {
            const newRow = new Float64Array(this.columns - 1);
            for (let j = 0; j < index2; j++) {
              newRow[j] = this.data[i][j];
            }
            for (let j = index2 + 1; j < this.columns; j++) {
              newRow[j - 1] = this.data[i][j];
            }
            this.data[i] = newRow;
          }
          this.columns -= 1;
          return this;
        }
        addColumn(index2, array) {
          if (typeof array === "undefined") {
            array = index2;
            index2 = this.columns;
          }
          checkColumnIndex(this, index2, true);
          array = checkColumnVector(this, array);
          for (let i = 0; i < this.rows; i++) {
            const newRow = new Float64Array(this.columns + 1);
            let j = 0;
            for (; j < index2; j++) {
              newRow[j] = this.data[i][j];
            }
            newRow[j++] = array[i];
            for (; j < this.columns + 1; j++) {
              newRow[j] = this.data[i][j - 1];
            }
            this.data[i] = newRow;
          }
          this.columns += 1;
          return this;
        }
      };
      installMathOperations(AbstractMatrix2, Matrix3);
      var SymmetricMatrix2 = class _SymmetricMatrix extends AbstractMatrix2 {
        /** @type {Matrix} */
        #matrix;
        get size() {
          return this.#matrix.size;
        }
        get rows() {
          return this.#matrix.rows;
        }
        get columns() {
          return this.#matrix.columns;
        }
        get diagonalSize() {
          return this.rows;
        }
        /**
         * not the same as matrix.isSymmetric()
         * Here is to check if it's instanceof SymmetricMatrix without bundling issues
         *
         * @param value
         * @returns {boolean}
         */
        static isSymmetricMatrix(value) {
          return Matrix3.isMatrix(value) && value.klassType === "SymmetricMatrix";
        }
        /**
         * @param diagonalSize
         * @return {SymmetricMatrix}
         */
        static zeros(diagonalSize) {
          return new this(diagonalSize);
        }
        /**
         * @param diagonalSize
         * @return {SymmetricMatrix}
         */
        static ones(diagonalSize) {
          return new this(diagonalSize).fill(1);
        }
        /**
         * @param {number | AbstractMatrix | ArrayLike<ArrayLike<number>>} diagonalSize
         * @return {this}
         */
        constructor(diagonalSize) {
          super();
          if (Matrix3.isMatrix(diagonalSize)) {
            if (!diagonalSize.isSymmetric()) {
              throw new TypeError("not symmetric data");
            }
            this.#matrix = Matrix3.copy(
              diagonalSize,
              new Matrix3(diagonalSize.rows, diagonalSize.rows)
            );
          } else if (Number.isInteger(diagonalSize) && diagonalSize >= 0) {
            this.#matrix = new Matrix3(diagonalSize, diagonalSize);
          } else {
            this.#matrix = new Matrix3(diagonalSize);
            if (!this.isSymmetric()) {
              throw new TypeError("not symmetric data");
            }
          }
        }
        clone() {
          const matrix3 = new _SymmetricMatrix(this.diagonalSize);
          for (const [row2, col, value] of this.upperRightEntries()) {
            matrix3.set(row2, col, value);
          }
          return matrix3;
        }
        toMatrix() {
          return new Matrix3(this);
        }
        get(rowIndex, columnIndex) {
          return this.#matrix.get(rowIndex, columnIndex);
        }
        set(rowIndex, columnIndex, value) {
          this.#matrix.set(rowIndex, columnIndex, value);
          this.#matrix.set(columnIndex, rowIndex, value);
          return this;
        }
        removeCross(index2) {
          this.#matrix.removeRow(index2);
          this.#matrix.removeColumn(index2);
          return this;
        }
        addCross(index2, array) {
          if (array === void 0) {
            array = index2;
            index2 = this.diagonalSize;
          }
          const row2 = array.slice();
          row2.splice(index2, 1);
          this.#matrix.addRow(index2, row2);
          this.#matrix.addColumn(index2, array);
          return this;
        }
        /**
         * @param {Mask[]} mask
         */
        applyMask(mask) {
          if (mask.length !== this.diagonalSize) {
            throw new RangeError("Mask size do not match with matrix size");
          }
          const sidesToRemove = [];
          for (const [index2, passthroughs] of mask.entries()) {
            if (passthroughs) continue;
            sidesToRemove.push(index2);
          }
          sidesToRemove.reverse();
          for (const sideIndex of sidesToRemove) {
            this.removeCross(sideIndex);
          }
          return this;
        }
        /**
         * Compact format upper-right corner of matrix
         * iterate from left to right, from top to bottom.
         *
         * ```
         *   A B C D
         * A 1 2 3 4
         * B 2 5 6 7
         * C 3 6 8 9
         * D 4 7 9 10
         * ```
         *
         * will return compact 1D array `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`
         *
         * length is S(i=0, n=sideSize) => 10 for a 4 sideSized matrix
         *
         * @returns {number[]}
         */
        toCompact() {
          const { diagonalSize } = this;
          const compact = new Array(diagonalSize * (diagonalSize + 1) / 2);
          for (let col = 0, row2 = 0, index2 = 0; index2 < compact.length; index2++) {
            compact[index2] = this.get(row2, col);
            if (++col >= diagonalSize) col = ++row2;
          }
          return compact;
        }
        /**
         * @param {number[]} compact
         * @return {SymmetricMatrix}
         */
        static fromCompact(compact) {
          const compactSize = compact.length;
          const diagonalSize = (Math.sqrt(8 * compactSize + 1) - 1) / 2;
          if (!Number.isInteger(diagonalSize)) {
            throw new TypeError(
              `This array is not a compact representation of a Symmetric Matrix, ${JSON.stringify(
                compact
              )}`
            );
          }
          const matrix3 = new _SymmetricMatrix(diagonalSize);
          for (let col = 0, row2 = 0, index2 = 0; index2 < compactSize; index2++) {
            matrix3.set(col, row2, compact[index2]);
            if (++col >= diagonalSize) col = ++row2;
          }
          return matrix3;
        }
        /**
         * half iterator upper-right-corner from left to right, from top to bottom
         * yield [row, column, value]
         *
         * @returns {Generator<[number, number, number], void, void>}
         */
        *upperRightEntries() {
          for (let row2 = 0, col = 0; row2 < this.diagonalSize; void 0) {
            const value = this.get(row2, col);
            yield [row2, col, value];
            if (++col >= this.diagonalSize) col = ++row2;
          }
        }
        /**
         * half iterator upper-right-corner from left to right, from top to bottom
         * yield value
         *
         * @returns {Generator<[number, number, number], void, void>}
         */
        *upperRightValues() {
          for (let row2 = 0, col = 0; row2 < this.diagonalSize; void 0) {
            const value = this.get(row2, col);
            yield value;
            if (++col >= this.diagonalSize) col = ++row2;
          }
        }
      };
      SymmetricMatrix2.prototype.klassType = "SymmetricMatrix";
      var DistanceMatrix2 = class _DistanceMatrix extends SymmetricMatrix2 {
        /**
         * not the same as matrix.isSymmetric()
         * Here is to check if it's instanceof SymmetricMatrix without bundling issues
         *
         * @param value
         * @returns {boolean}
         */
        static isDistanceMatrix(value) {
          return SymmetricMatrix2.isSymmetricMatrix(value) && value.klassSubType === "DistanceMatrix";
        }
        constructor(sideSize) {
          super(sideSize);
          if (!this.isDistance()) {
            throw new TypeError("Provided arguments do no produce a distance matrix");
          }
        }
        set(rowIndex, columnIndex, value) {
          if (rowIndex === columnIndex) value = 0;
          return super.set(rowIndex, columnIndex, value);
        }
        addCross(index2, array) {
          if (array === void 0) {
            array = index2;
            index2 = this.diagonalSize;
          }
          array = array.slice();
          array[index2] = 0;
          return super.addCross(index2, array);
        }
        toSymmetricMatrix() {
          return new SymmetricMatrix2(this);
        }
        clone() {
          const matrix3 = new _DistanceMatrix(this.diagonalSize);
          for (const [row2, col, value] of this.upperRightEntries()) {
            if (row2 === col) continue;
            matrix3.set(row2, col, value);
          }
          return matrix3;
        }
        /**
         * Compact format upper-right corner of matrix
         * no diagonal (only zeros)
         * iterable from left to right, from top to bottom.
         *
         * ```
         *   A B C D
         * A 0 1 2 3
         * B 1 0 4 5
         * C 2 4 0 6
         * D 3 5 6 0
         * ```
         *
         * will return compact 1D array `[1, 2, 3, 4, 5, 6]`
         *
         * length is S(i=0, n=sideSize-1) => 6 for a 4 side sized matrix
         *
         * @returns {number[]}
         */
        toCompact() {
          const { diagonalSize } = this;
          const compactLength = (diagonalSize - 1) * diagonalSize / 2;
          const compact = new Array(compactLength);
          for (let col = 1, row2 = 0, index2 = 0; index2 < compact.length; index2++) {
            compact[index2] = this.get(row2, col);
            if (++col >= diagonalSize) col = ++row2 + 1;
          }
          return compact;
        }
        /**
         * @param {number[]} compact
         */
        static fromCompact(compact) {
          const compactSize = compact.length;
          if (compactSize === 0) {
            return new this(0);
          }
          const diagonalSize = (Math.sqrt(8 * compactSize + 1) + 1) / 2;
          if (!Number.isInteger(diagonalSize)) {
            throw new TypeError(
              `This array is not a compact representation of a DistanceMatrix, ${JSON.stringify(
                compact
              )}`
            );
          }
          const matrix3 = new this(diagonalSize);
          for (let col = 1, row2 = 0, index2 = 0; index2 < compactSize; index2++) {
            matrix3.set(col, row2, compact[index2]);
            if (++col >= diagonalSize) col = ++row2 + 1;
          }
          return matrix3;
        }
      };
      DistanceMatrix2.prototype.klassSubType = "DistanceMatrix";
      var BaseView = class extends AbstractMatrix2 {
        constructor(matrix3, rows, columns) {
          super();
          this.matrix = matrix3;
          this.rows = rows;
          this.columns = columns;
        }
      };
      var MatrixColumnView2 = class extends BaseView {
        constructor(matrix3, column) {
          checkColumnIndex(matrix3, column);
          super(matrix3, matrix3.rows, 1);
          this.column = column;
        }
        set(rowIndex, columnIndex, value) {
          this.matrix.set(rowIndex, this.column, value);
          return this;
        }
        get(rowIndex) {
          return this.matrix.get(rowIndex, this.column);
        }
      };
      var MatrixColumnSelectionView2 = class extends BaseView {
        constructor(matrix3, columnIndices) {
          checkColumnIndices(matrix3, columnIndices);
          super(matrix3, matrix3.rows, columnIndices.length);
          this.columnIndices = columnIndices;
        }
        set(rowIndex, columnIndex, value) {
          this.matrix.set(rowIndex, this.columnIndices[columnIndex], value);
          return this;
        }
        get(rowIndex, columnIndex) {
          return this.matrix.get(rowIndex, this.columnIndices[columnIndex]);
        }
      };
      var MatrixFlipColumnView2 = class extends BaseView {
        constructor(matrix3) {
          super(matrix3, matrix3.rows, matrix3.columns);
        }
        set(rowIndex, columnIndex, value) {
          this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);
          return this;
        }
        get(rowIndex, columnIndex) {
          return this.matrix.get(rowIndex, this.columns - columnIndex - 1);
        }
      };
      var MatrixFlipRowView2 = class extends BaseView {
        constructor(matrix3) {
          super(matrix3, matrix3.rows, matrix3.columns);
        }
        set(rowIndex, columnIndex, value) {
          this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);
          return this;
        }
        get(rowIndex, columnIndex) {
          return this.matrix.get(this.rows - rowIndex - 1, columnIndex);
        }
      };
      var MatrixRowView2 = class extends BaseView {
        constructor(matrix3, row2) {
          checkRowIndex(matrix3, row2);
          super(matrix3, 1, matrix3.columns);
          this.row = row2;
        }
        set(rowIndex, columnIndex, value) {
          this.matrix.set(this.row, columnIndex, value);
          return this;
        }
        get(rowIndex, columnIndex) {
          return this.matrix.get(this.row, columnIndex);
        }
      };
      var MatrixRowSelectionView2 = class extends BaseView {
        constructor(matrix3, rowIndices) {
          checkRowIndices(matrix3, rowIndices);
          super(matrix3, rowIndices.length, matrix3.columns);
          this.rowIndices = rowIndices;
        }
        set(rowIndex, columnIndex, value) {
          this.matrix.set(this.rowIndices[rowIndex], columnIndex, value);
          return this;
        }
        get(rowIndex, columnIndex) {
          return this.matrix.get(this.rowIndices[rowIndex], columnIndex);
        }
      };
      var MatrixSelectionView2 = class extends BaseView {
        constructor(matrix3, rowIndices, columnIndices) {
          checkRowIndices(matrix3, rowIndices);
          checkColumnIndices(matrix3, columnIndices);
          super(matrix3, rowIndices.length, columnIndices.length);
          this.rowIndices = rowIndices;
          this.columnIndices = columnIndices;
        }
        set(rowIndex, columnIndex, value) {
          this.matrix.set(
            this.rowIndices[rowIndex],
            this.columnIndices[columnIndex],
            value
          );
          return this;
        }
        get(rowIndex, columnIndex) {
          return this.matrix.get(
            this.rowIndices[rowIndex],
            this.columnIndices[columnIndex]
          );
        }
      };
      var MatrixSubView2 = class extends BaseView {
        constructor(matrix3, startRow, endRow, startColumn, endColumn) {
          checkRange(matrix3, startRow, endRow, startColumn, endColumn);
          super(matrix3, endRow - startRow + 1, endColumn - startColumn + 1);
          this.startRow = startRow;
          this.startColumn = startColumn;
        }
        set(rowIndex, columnIndex, value) {
          this.matrix.set(
            this.startRow + rowIndex,
            this.startColumn + columnIndex,
            value
          );
          return this;
        }
        get(rowIndex, columnIndex) {
          return this.matrix.get(
            this.startRow + rowIndex,
            this.startColumn + columnIndex
          );
        }
      };
      var MatrixTransposeView2 = class extends BaseView {
        constructor(matrix3) {
          super(matrix3, matrix3.columns, matrix3.rows);
        }
        set(rowIndex, columnIndex, value) {
          this.matrix.set(columnIndex, rowIndex, value);
          return this;
        }
        get(rowIndex, columnIndex) {
          return this.matrix.get(columnIndex, rowIndex);
        }
      };
      var WrapperMatrix1D2 = class extends AbstractMatrix2 {
        constructor(data2, options = {}) {
          const { rows = 1 } = options;
          if (data2.length % rows !== 0) {
            throw new Error("the data length is not divisible by the number of rows");
          }
          super();
          this.rows = rows;
          this.columns = data2.length / rows;
          this.data = data2;
        }
        set(rowIndex, columnIndex, value) {
          let index2 = this._calculateIndex(rowIndex, columnIndex);
          this.data[index2] = value;
          return this;
        }
        get(rowIndex, columnIndex) {
          let index2 = this._calculateIndex(rowIndex, columnIndex);
          return this.data[index2];
        }
        _calculateIndex(row2, column) {
          return row2 * this.columns + column;
        }
      };
      var WrapperMatrix2D2 = class extends AbstractMatrix2 {
        constructor(data2) {
          super();
          this.data = data2;
          this.rows = data2.length;
          this.columns = data2[0].length;
        }
        set(rowIndex, columnIndex, value) {
          this.data[rowIndex][columnIndex] = value;
          return this;
        }
        get(rowIndex, columnIndex) {
          return this.data[rowIndex][columnIndex];
        }
      };
      function wrap3(array, options) {
        if (isAnyArray.isAnyArray(array)) {
          if (array[0] && isAnyArray.isAnyArray(array[0])) {
            return new WrapperMatrix2D2(array);
          } else {
            return new WrapperMatrix1D2(array, options);
          }
        } else {
          throw new Error("the argument is not an array");
        }
      }
      var LuDecomposition2 = class {
        constructor(matrix3) {
          matrix3 = WrapperMatrix2D2.checkMatrix(matrix3);
          let lu = matrix3.clone();
          let rows = lu.rows;
          let columns = lu.columns;
          let pivotVector = new Float64Array(rows);
          let pivotSign = 1;
          let i, j, k, p, s, t, v;
          let LUcolj, kmax;
          for (i = 0; i < rows; i++) {
            pivotVector[i] = i;
          }
          LUcolj = new Float64Array(rows);
          for (j = 0; j < columns; j++) {
            for (i = 0; i < rows; i++) {
              LUcolj[i] = lu.get(i, j);
            }
            for (i = 0; i < rows; i++) {
              kmax = Math.min(i, j);
              s = 0;
              for (k = 0; k < kmax; k++) {
                s += lu.get(i, k) * LUcolj[k];
              }
              LUcolj[i] -= s;
              lu.set(i, j, LUcolj[i]);
            }
            p = j;
            for (i = j + 1; i < rows; i++) {
              if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {
                p = i;
              }
            }
            if (p !== j) {
              for (k = 0; k < columns; k++) {
                t = lu.get(p, k);
                lu.set(p, k, lu.get(j, k));
                lu.set(j, k, t);
              }
              v = pivotVector[p];
              pivotVector[p] = pivotVector[j];
              pivotVector[j] = v;
              pivotSign = -pivotSign;
            }
            if (j < rows && lu.get(j, j) !== 0) {
              for (i = j + 1; i < rows; i++) {
                lu.set(i, j, lu.get(i, j) / lu.get(j, j));
              }
            }
          }
          this.LU = lu;
          this.pivotVector = pivotVector;
          this.pivotSign = pivotSign;
        }
        isSingular() {
          let data2 = this.LU;
          let col = data2.columns;
          for (let j = 0; j < col; j++) {
            if (data2.get(j, j) === 0) {
              return true;
            }
          }
          return false;
        }
        solve(value) {
          value = Matrix3.checkMatrix(value);
          let lu = this.LU;
          let rows = lu.rows;
          if (rows !== value.rows) {
            throw new Error("Invalid matrix dimensions");
          }
          if (this.isSingular()) {
            throw new Error("LU matrix is singular");
          }
          let count = value.columns;
          let X = value.subMatrixRow(this.pivotVector, 0, count - 1);
          let columns = lu.columns;
          let i, j, k;
          for (k = 0; k < columns; k++) {
            for (i = k + 1; i < columns; i++) {
              for (j = 0; j < count; j++) {
                X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));
              }
            }
          }
          for (k = columns - 1; k >= 0; k--) {
            for (j = 0; j < count; j++) {
              X.set(k, j, X.get(k, j) / lu.get(k, k));
            }
            for (i = 0; i < k; i++) {
              for (j = 0; j < count; j++) {
                X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));
              }
            }
          }
          return X;
        }
        get determinant() {
          let data2 = this.LU;
          if (!data2.isSquare()) {
            throw new Error("Matrix must be square");
          }
          let determinant3 = this.pivotSign;
          let col = data2.columns;
          for (let j = 0; j < col; j++) {
            determinant3 *= data2.get(j, j);
          }
          return determinant3;
        }
        get lowerTriangularMatrix() {
          let data2 = this.LU;
          let rows = data2.rows;
          let columns = data2.columns;
          let X = new Matrix3(rows, columns);
          for (let i = 0; i < rows; i++) {
            for (let j = 0; j < columns; j++) {
              if (i > j) {
                X.set(i, j, data2.get(i, j));
              } else if (i === j) {
                X.set(i, j, 1);
              } else {
                X.set(i, j, 0);
              }
            }
          }
          return X;
        }
        get upperTriangularMatrix() {
          let data2 = this.LU;
          let rows = data2.rows;
          let columns = data2.columns;
          let X = new Matrix3(rows, columns);
          for (let i = 0; i < rows; i++) {
            for (let j = 0; j < columns; j++) {
              if (i <= j) {
                X.set(i, j, data2.get(i, j));
              } else {
                X.set(i, j, 0);
              }
            }
          }
          return X;
        }
        get pivotPermutationVector() {
          return Array.from(this.pivotVector);
        }
      };
      function hypotenuse(a2, b) {
        let r = 0;
        if (Math.abs(a2) > Math.abs(b)) {
          r = b / a2;
          return Math.abs(a2) * Math.sqrt(1 + r * r);
        }
        if (b !== 0) {
          r = a2 / b;
          return Math.abs(b) * Math.sqrt(1 + r * r);
        }
        return 0;
      }
      var QrDecomposition2 = class {
        constructor(value) {
          value = WrapperMatrix2D2.checkMatrix(value);
          let qr = value.clone();
          let m2 = value.rows;
          let n = value.columns;
          let rdiag = new Float64Array(n);
          let i, j, k, s;
          for (k = 0; k < n; k++) {
            let nrm = 0;
            for (i = k; i < m2; i++) {
              nrm = hypotenuse(nrm, qr.get(i, k));
            }
            if (nrm !== 0) {
              if (qr.get(k, k) < 0) {
                nrm = -nrm;
              }
              for (i = k; i < m2; i++) {
                qr.set(i, k, qr.get(i, k) / nrm);
              }
              qr.set(k, k, qr.get(k, k) + 1);
              for (j = k + 1; j < n; j++) {
                s = 0;
                for (i = k; i < m2; i++) {
                  s += qr.get(i, k) * qr.get(i, j);
                }
                s = -s / qr.get(k, k);
                for (i = k; i < m2; i++) {
                  qr.set(i, j, qr.get(i, j) + s * qr.get(i, k));
                }
              }
            }
            rdiag[k] = -nrm;
          }
          this.QR = qr;
          this.Rdiag = rdiag;
        }
        solve(value) {
          value = Matrix3.checkMatrix(value);
          let qr = this.QR;
          let m2 = qr.rows;
          if (value.rows !== m2) {
            throw new Error("Matrix row dimensions must agree");
          }
          if (!this.isFullRank()) {
            throw new Error("Matrix is rank deficient");
          }
          let count = value.columns;
          let X = value.clone();
          let n = qr.columns;
          let i, j, k, s;
          for (k = 0; k < n; k++) {
            for (j = 0; j < count; j++) {
              s = 0;
              for (i = k; i < m2; i++) {
                s += qr.get(i, k) * X.get(i, j);
              }
              s = -s / qr.get(k, k);
              for (i = k; i < m2; i++) {
                X.set(i, j, X.get(i, j) + s * qr.get(i, k));
              }
            }
          }
          for (k = n - 1; k >= 0; k--) {
            for (j = 0; j < count; j++) {
              X.set(k, j, X.get(k, j) / this.Rdiag[k]);
            }
            for (i = 0; i < k; i++) {
              for (j = 0; j < count; j++) {
                X.set(i, j, X.get(i, j) - X.get(k, j) * qr.get(i, k));
              }
            }
          }
          return X.subMatrix(0, n - 1, 0, count - 1);
        }
        isFullRank() {
          let columns = this.QR.columns;
          for (let i = 0; i < columns; i++) {
            if (this.Rdiag[i] === 0) {
              return false;
            }
          }
          return true;
        }
        get upperTriangularMatrix() {
          let qr = this.QR;
          let n = qr.columns;
          let X = new Matrix3(n, n);
          let i, j;
          for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
              if (i < j) {
                X.set(i, j, qr.get(i, j));
              } else if (i === j) {
                X.set(i, j, this.Rdiag[i]);
              } else {
                X.set(i, j, 0);
              }
            }
          }
          return X;
        }
        get orthogonalMatrix() {
          let qr = this.QR;
          let rows = qr.rows;
          let columns = qr.columns;
          let X = new Matrix3(rows, columns);
          let i, j, k, s;
          for (k = columns - 1; k >= 0; k--) {
            for (i = 0; i < rows; i++) {
              X.set(i, k, 0);
            }
            X.set(k, k, 1);
            for (j = k; j < columns; j++) {
              if (qr.get(k, k) !== 0) {
                s = 0;
                for (i = k; i < rows; i++) {
                  s += qr.get(i, k) * X.get(i, j);
                }
                s = -s / qr.get(k, k);
                for (i = k; i < rows; i++) {
                  X.set(i, j, X.get(i, j) + s * qr.get(i, k));
                }
              }
            }
          }
          return X;
        }
      };
      var SingularValueDecomposition3 = class {
        constructor(value, options = {}) {
          value = WrapperMatrix2D2.checkMatrix(value);
          if (value.isEmpty()) {
            throw new Error("Matrix must be non-empty");
          }
          let m2 = value.rows;
          let n = value.columns;
          const {
            computeLeftSingularVectors = true,
            computeRightSingularVectors = true,
            autoTranspose = false
          } = options;
          let wantu = Boolean(computeLeftSingularVectors);
          let wantv = Boolean(computeRightSingularVectors);
          let swapped = false;
          let a2;
          if (m2 < n) {
            if (!autoTranspose) {
              a2 = value.clone();
              console.warn(
                "Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose"
              );
            } else {
              a2 = value.transpose();
              m2 = a2.rows;
              n = a2.columns;
              swapped = true;
              let aux = wantu;
              wantu = wantv;
              wantv = aux;
            }
          } else {
            a2 = value.clone();
          }
          let nu = Math.min(m2, n);
          let ni = Math.min(m2 + 1, n);
          let s = new Float64Array(ni);
          let U = new Matrix3(m2, nu);
          let V = new Matrix3(n, n);
          let e = new Float64Array(n);
          let work = new Float64Array(m2);
          let si = new Float64Array(ni);
          for (let i = 0; i < ni; i++) si[i] = i;
          let nct = Math.min(m2 - 1, n);
          let nrt = Math.max(0, Math.min(n - 2, m2));
          let mrc = Math.max(nct, nrt);
          for (let k = 0; k < mrc; k++) {
            if (k < nct) {
              s[k] = 0;
              for (let i = k; i < m2; i++) {
                s[k] = hypotenuse(s[k], a2.get(i, k));
              }
              if (s[k] !== 0) {
                if (a2.get(k, k) < 0) {
                  s[k] = -s[k];
                }
                for (let i = k; i < m2; i++) {
                  a2.set(i, k, a2.get(i, k) / s[k]);
                }
                a2.set(k, k, a2.get(k, k) + 1);
              }
              s[k] = -s[k];
            }
            for (let j = k + 1; j < n; j++) {
              if (k < nct && s[k] !== 0) {
                let t = 0;
                for (let i = k; i < m2; i++) {
                  t += a2.get(i, k) * a2.get(i, j);
                }
                t = -t / a2.get(k, k);
                for (let i = k; i < m2; i++) {
                  a2.set(i, j, a2.get(i, j) + t * a2.get(i, k));
                }
              }
              e[j] = a2.get(k, j);
            }
            if (wantu && k < nct) {
              for (let i = k; i < m2; i++) {
                U.set(i, k, a2.get(i, k));
              }
            }
            if (k < nrt) {
              e[k] = 0;
              for (let i = k + 1; i < n; i++) {
                e[k] = hypotenuse(e[k], e[i]);
              }
              if (e[k] !== 0) {
                if (e[k + 1] < 0) {
                  e[k] = 0 - e[k];
                }
                for (let i = k + 1; i < n; i++) {
                  e[i] /= e[k];
                }
                e[k + 1] += 1;
              }
              e[k] = -e[k];
              if (k + 1 < m2 && e[k] !== 0) {
                for (let i = k + 1; i < m2; i++) {
                  work[i] = 0;
                }
                for (let i = k + 1; i < m2; i++) {
                  for (let j = k + 1; j < n; j++) {
                    work[i] += e[j] * a2.get(i, j);
                  }
                }
                for (let j = k + 1; j < n; j++) {
                  let t = -e[j] / e[k + 1];
                  for (let i = k + 1; i < m2; i++) {
                    a2.set(i, j, a2.get(i, j) + t * work[i]);
                  }
                }
              }
              if (wantv) {
                for (let i = k + 1; i < n; i++) {
                  V.set(i, k, e[i]);
                }
              }
            }
          }
          let p = Math.min(n, m2 + 1);
          if (nct < n) {
            s[nct] = a2.get(nct, nct);
          }
          if (m2 < p) {
            s[p - 1] = 0;
          }
          if (nrt + 1 < p) {
            e[nrt] = a2.get(nrt, p - 1);
          }
          e[p - 1] = 0;
          if (wantu) {
            for (let j = nct; j < nu; j++) {
              for (let i = 0; i < m2; i++) {
                U.set(i, j, 0);
              }
              U.set(j, j, 1);
            }
            for (let k = nct - 1; k >= 0; k--) {
              if (s[k] !== 0) {
                for (let j = k + 1; j < nu; j++) {
                  let t = 0;
                  for (let i = k; i < m2; i++) {
                    t += U.get(i, k) * U.get(i, j);
                  }
                  t = -t / U.get(k, k);
                  for (let i = k; i < m2; i++) {
                    U.set(i, j, U.get(i, j) + t * U.get(i, k));
                  }
                }
                for (let i = k; i < m2; i++) {
                  U.set(i, k, -U.get(i, k));
                }
                U.set(k, k, 1 + U.get(k, k));
                for (let i = 0; i < k - 1; i++) {
                  U.set(i, k, 0);
                }
              } else {
                for (let i = 0; i < m2; i++) {
                  U.set(i, k, 0);
                }
                U.set(k, k, 1);
              }
            }
          }
          if (wantv) {
            for (let k = n - 1; k >= 0; k--) {
              if (k < nrt && e[k] !== 0) {
                for (let j = k + 1; j < n; j++) {
                  let t = 0;
                  for (let i = k + 1; i < n; i++) {
                    t += V.get(i, k) * V.get(i, j);
                  }
                  t = -t / V.get(k + 1, k);
                  for (let i = k + 1; i < n; i++) {
                    V.set(i, j, V.get(i, j) + t * V.get(i, k));
                  }
                }
              }
              for (let i = 0; i < n; i++) {
                V.set(i, k, 0);
              }
              V.set(k, k, 1);
            }
          }
          let pp = p - 1;
          let eps = Number.EPSILON;
          while (p > 0) {
            let k, kase;
            for (k = p - 2; k >= -1; k--) {
              if (k === -1) {
                break;
              }
              const alpha = Number.MIN_VALUE + eps * Math.abs(s[k] + Math.abs(s[k + 1]));
              if (Math.abs(e[k]) <= alpha || Number.isNaN(e[k])) {
                e[k] = 0;
                break;
              }
            }
            if (k === p - 2) {
              kase = 4;
            } else {
              let ks;
              for (ks = p - 1; ks >= k; ks--) {
                if (ks === k) {
                  break;
                }
                let t = (ks !== p ? Math.abs(e[ks]) : 0) + (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);
                if (Math.abs(s[ks]) <= eps * t) {
                  s[ks] = 0;
                  break;
                }
              }
              if (ks === k) {
                kase = 3;
              } else if (ks === p - 1) {
                kase = 1;
              } else {
                kase = 2;
                k = ks;
              }
            }
            k++;
            switch (kase) {
              case 1: {
                let f = e[p - 2];
                e[p - 2] = 0;
                for (let j = p - 2; j >= k; j--) {
                  let t = hypotenuse(s[j], f);
                  let cs = s[j] / t;
                  let sn = f / t;
                  s[j] = t;
                  if (j !== k) {
                    f = -sn * e[j - 1];
                    e[j - 1] = cs * e[j - 1];
                  }
                  if (wantv) {
                    for (let i = 0; i < n; i++) {
                      t = cs * V.get(i, j) + sn * V.get(i, p - 1);
                      V.set(i, p - 1, -sn * V.get(i, j) + cs * V.get(i, p - 1));
                      V.set(i, j, t);
                    }
                  }
                }
                break;
              }
              case 2: {
                let f = e[k - 1];
                e[k - 1] = 0;
                for (let j = k; j < p; j++) {
                  let t = hypotenuse(s[j], f);
                  let cs = s[j] / t;
                  let sn = f / t;
                  s[j] = t;
                  f = -sn * e[j];
                  e[j] = cs * e[j];
                  if (wantu) {
                    for (let i = 0; i < m2; i++) {
                      t = cs * U.get(i, j) + sn * U.get(i, k - 1);
                      U.set(i, k - 1, -sn * U.get(i, j) + cs * U.get(i, k - 1));
                      U.set(i, j, t);
                    }
                  }
                }
                break;
              }
              case 3: {
                const scale4 = Math.max(
                  Math.abs(s[p - 1]),
                  Math.abs(s[p - 2]),
                  Math.abs(e[p - 2]),
                  Math.abs(s[k]),
                  Math.abs(e[k])
                );
                const sp = s[p - 1] / scale4;
                const spm1 = s[p - 2] / scale4;
                const epm1 = e[p - 2] / scale4;
                const sk = s[k] / scale4;
                const ek = e[k] / scale4;
                const b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
                const c2 = sp * epm1 * (sp * epm1);
                let shift = 0;
                if (b !== 0 || c2 !== 0) {
                  if (b < 0) {
                    shift = 0 - Math.sqrt(b * b + c2);
                  } else {
                    shift = Math.sqrt(b * b + c2);
                  }
                  shift = c2 / (b + shift);
                }
                let f = (sk + sp) * (sk - sp) + shift;
                let g = sk * ek;
                for (let j = k; j < p - 1; j++) {
                  let t = hypotenuse(f, g);
                  if (t === 0) t = Number.MIN_VALUE;
                  let cs = f / t;
                  let sn = g / t;
                  if (j !== k) {
                    e[j - 1] = t;
                  }
                  f = cs * s[j] + sn * e[j];
                  e[j] = cs * e[j] - sn * s[j];
                  g = sn * s[j + 1];
                  s[j + 1] = cs * s[j + 1];
                  if (wantv) {
                    for (let i = 0; i < n; i++) {
                      t = cs * V.get(i, j) + sn * V.get(i, j + 1);
                      V.set(i, j + 1, -sn * V.get(i, j) + cs * V.get(i, j + 1));
                      V.set(i, j, t);
                    }
                  }
                  t = hypotenuse(f, g);
                  if (t === 0) t = Number.MIN_VALUE;
                  cs = f / t;
                  sn = g / t;
                  s[j] = t;
                  f = cs * e[j] + sn * s[j + 1];
                  s[j + 1] = -sn * e[j] + cs * s[j + 1];
                  g = sn * e[j + 1];
                  e[j + 1] = cs * e[j + 1];
                  if (wantu && j < m2 - 1) {
                    for (let i = 0; i < m2; i++) {
                      t = cs * U.get(i, j) + sn * U.get(i, j + 1);
                      U.set(i, j + 1, -sn * U.get(i, j) + cs * U.get(i, j + 1));
                      U.set(i, j, t);
                    }
                  }
                }
                e[p - 2] = f;
                break;
              }
              case 4: {
                if (s[k] <= 0) {
                  s[k] = s[k] < 0 ? -s[k] : 0;
                  if (wantv) {
                    for (let i = 0; i <= pp; i++) {
                      V.set(i, k, -V.get(i, k));
                    }
                  }
                }
                while (k < pp) {
                  if (s[k] >= s[k + 1]) {
                    break;
                  }
                  let t = s[k];
                  s[k] = s[k + 1];
                  s[k + 1] = t;
                  if (wantv && k < n - 1) {
                    for (let i = 0; i < n; i++) {
                      t = V.get(i, k + 1);
                      V.set(i, k + 1, V.get(i, k));
                      V.set(i, k, t);
                    }
                  }
                  if (wantu && k < m2 - 1) {
                    for (let i = 0; i < m2; i++) {
                      t = U.get(i, k + 1);
                      U.set(i, k + 1, U.get(i, k));
                      U.set(i, k, t);
                    }
                  }
                  k++;
                }
                p--;
                break;
              }
            }
          }
          if (swapped) {
            let tmp2 = V;
            V = U;
            U = tmp2;
          }
          this.m = m2;
          this.n = n;
          this.s = s;
          this.U = U;
          this.V = V;
        }
        solve(value) {
          let Y = value;
          let e = this.threshold;
          let scols = this.s.length;
          let Ls = Matrix3.zeros(scols, scols);
          for (let i = 0; i < scols; i++) {
            if (Math.abs(this.s[i]) <= e) {
              Ls.set(i, i, 0);
            } else {
              Ls.set(i, i, 1 / this.s[i]);
            }
          }
          let U = this.U;
          let V = this.rightSingularVectors;
          let VL = V.mmul(Ls);
          let vrows = V.rows;
          let urows = U.rows;
          let VLU = Matrix3.zeros(vrows, urows);
          for (let i = 0; i < vrows; i++) {
            for (let j = 0; j < urows; j++) {
              let sum = 0;
              for (let k = 0; k < scols; k++) {
                sum += VL.get(i, k) * U.get(j, k);
              }
              VLU.set(i, j, sum);
            }
          }
          return VLU.mmul(Y);
        }
        solveForDiagonal(value) {
          return this.solve(Matrix3.diag(value));
        }
        inverse() {
          let V = this.V;
          let e = this.threshold;
          let vrows = V.rows;
          let vcols = V.columns;
          let X = new Matrix3(vrows, this.s.length);
          for (let i = 0; i < vrows; i++) {
            for (let j = 0; j < vcols; j++) {
              if (Math.abs(this.s[j]) > e) {
                X.set(i, j, V.get(i, j) / this.s[j]);
              }
            }
          }
          let U = this.U;
          let urows = U.rows;
          let ucols = U.columns;
          let Y = new Matrix3(vrows, urows);
          for (let i = 0; i < vrows; i++) {
            for (let j = 0; j < urows; j++) {
              let sum = 0;
              for (let k = 0; k < ucols; k++) {
                sum += X.get(i, k) * U.get(j, k);
              }
              Y.set(i, j, sum);
            }
          }
          return Y;
        }
        get condition() {
          return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
        }
        get norm2() {
          return this.s[0];
        }
        get rank() {
          let tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;
          let r = 0;
          let s = this.s;
          for (let i = 0, ii = s.length; i < ii; i++) {
            if (s[i] > tol) {
              r++;
            }
          }
          return r;
        }
        get diagonal() {
          return Array.from(this.s);
        }
        get threshold() {
          return Number.EPSILON / 2 * Math.max(this.m, this.n) * this.s[0];
        }
        get leftSingularVectors() {
          return this.U;
        }
        get rightSingularVectors() {
          return this.V;
        }
        get diagonalMatrix() {
          return Matrix3.diag(this.s);
        }
      };
      function inverse2(matrix3, useSVD = false) {
        matrix3 = WrapperMatrix2D2.checkMatrix(matrix3);
        if (useSVD) {
          return new SingularValueDecomposition3(matrix3).inverse();
        } else {
          return solve2(matrix3, Matrix3.eye(matrix3.rows));
        }
      }
      function solve2(leftHandSide, rightHandSide, useSVD = false) {
        leftHandSide = WrapperMatrix2D2.checkMatrix(leftHandSide);
        rightHandSide = WrapperMatrix2D2.checkMatrix(rightHandSide);
        if (useSVD) {
          return new SingularValueDecomposition3(leftHandSide).solve(rightHandSide);
        } else {
          return leftHandSide.isSquare() ? new LuDecomposition2(leftHandSide).solve(rightHandSide) : new QrDecomposition2(leftHandSide).solve(rightHandSide);
        }
      }
      function determinant2(matrix3) {
        matrix3 = Matrix3.checkMatrix(matrix3);
        if (matrix3.isSquare()) {
          if (matrix3.columns === 0) {
            return 1;
          }
          let a2, b, c2, d2;
          if (matrix3.columns === 2) {
            a2 = matrix3.get(0, 0);
            b = matrix3.get(0, 1);
            c2 = matrix3.get(1, 0);
            d2 = matrix3.get(1, 1);
            return a2 * d2 - b * c2;
          } else if (matrix3.columns === 3) {
            let subMatrix0, subMatrix1, subMatrix2;
            subMatrix0 = new MatrixSelectionView2(matrix3, [1, 2], [1, 2]);
            subMatrix1 = new MatrixSelectionView2(matrix3, [1, 2], [0, 2]);
            subMatrix2 = new MatrixSelectionView2(matrix3, [1, 2], [0, 1]);
            a2 = matrix3.get(0, 0);
            b = matrix3.get(0, 1);
            c2 = matrix3.get(0, 2);
            return a2 * determinant2(subMatrix0) - b * determinant2(subMatrix1) + c2 * determinant2(subMatrix2);
          } else {
            return new LuDecomposition2(matrix3).determinant;
          }
        } else {
          throw Error("determinant can only be calculated for a square matrix");
        }
      }
      function xrange(n, exception) {
        let range = [];
        for (let i = 0; i < n; i++) {
          if (i !== exception) {
            range.push(i);
          }
        }
        return range;
      }
      function dependenciesOneRow(error2, matrix3, index2, thresholdValue = 1e-9, thresholdError = 1e-9) {
        if (error2 > thresholdError) {
          return new Array(matrix3.rows + 1).fill(0);
        } else {
          let returnArray = matrix3.addRow(index2, [0]);
          for (let i = 0; i < returnArray.rows; i++) {
            if (Math.abs(returnArray.get(i, 0)) < thresholdValue) {
              returnArray.set(i, 0, 0);
            }
          }
          return returnArray.to1DArray();
        }
      }
      function linearDependencies2(matrix3, options = {}) {
        const { thresholdValue = 1e-9, thresholdError = 1e-9 } = options;
        matrix3 = Matrix3.checkMatrix(matrix3);
        let n = matrix3.rows;
        let results = new Matrix3(n, n);
        for (let i = 0; i < n; i++) {
          let b = Matrix3.columnVector(matrix3.getRow(i));
          let Abis = matrix3.subMatrixRow(xrange(n, i)).transpose();
          let svd = new SingularValueDecomposition3(Abis);
          let x3 = svd.solve(b);
          let error2 = Matrix3.sub(b, Abis.mmul(x3)).abs().max();
          results.setRow(
            i,
            dependenciesOneRow(error2, x3, i, thresholdValue, thresholdError)
          );
        }
        return results;
      }
      function pseudoInverse2(matrix3, threshold = Number.EPSILON) {
        matrix3 = Matrix3.checkMatrix(matrix3);
        if (matrix3.isEmpty()) {
          return matrix3.transpose();
        }
        let svdSolution = new SingularValueDecomposition3(matrix3, { autoTranspose: true });
        let U = svdSolution.leftSingularVectors;
        let V = svdSolution.rightSingularVectors;
        let s = svdSolution.diagonal;
        for (let i = 0; i < s.length; i++) {
          if (Math.abs(s[i]) > threshold) {
            s[i] = 1 / s[i];
          } else {
            s[i] = 0;
          }
        }
        return V.mmul(Matrix3.diag(s).mmul(U.transpose()));
      }
      function covariance2(xMatrix, yMatrix = xMatrix, options = {}) {
        xMatrix = new Matrix3(xMatrix);
        let yIsSame = false;
        if (typeof yMatrix === "object" && !Matrix3.isMatrix(yMatrix) && !isAnyArray.isAnyArray(yMatrix)) {
          options = yMatrix;
          yMatrix = xMatrix;
          yIsSame = true;
        } else {
          yMatrix = new Matrix3(yMatrix);
        }
        if (xMatrix.rows !== yMatrix.rows) {
          throw new TypeError("Both matrices must have the same number of rows");
        }
        const { center = true } = options;
        if (center) {
          xMatrix = xMatrix.center("column");
          if (!yIsSame) {
            yMatrix = yMatrix.center("column");
          }
        }
        const cov = xMatrix.transpose().mmul(yMatrix);
        for (let i = 0; i < cov.rows; i++) {
          for (let j = 0; j < cov.columns; j++) {
            cov.set(i, j, cov.get(i, j) * (1 / (xMatrix.rows - 1)));
          }
        }
        return cov;
      }
      function correlation2(xMatrix, yMatrix = xMatrix, options = {}) {
        xMatrix = new Matrix3(xMatrix);
        let yIsSame = false;
        if (typeof yMatrix === "object" && !Matrix3.isMatrix(yMatrix) && !isAnyArray.isAnyArray(yMatrix)) {
          options = yMatrix;
          yMatrix = xMatrix;
          yIsSame = true;
        } else {
          yMatrix = new Matrix3(yMatrix);
        }
        if (xMatrix.rows !== yMatrix.rows) {
          throw new TypeError("Both matrices must have the same number of rows");
        }
        const { center = true, scale: scale4 = true } = options;
        if (center) {
          xMatrix.center("column");
          if (!yIsSame) {
            yMatrix.center("column");
          }
        }
        if (scale4) {
          xMatrix.scale("column");
          if (!yIsSame) {
            yMatrix.scale("column");
          }
        }
        const sdx = xMatrix.standardDeviation("column", { unbiased: true });
        const sdy = yIsSame ? sdx : yMatrix.standardDeviation("column", { unbiased: true });
        const corr = xMatrix.transpose().mmul(yMatrix);
        for (let i = 0; i < corr.rows; i++) {
          for (let j = 0; j < corr.columns; j++) {
            corr.set(
              i,
              j,
              corr.get(i, j) * (1 / (sdx[i] * sdy[j])) * (1 / (xMatrix.rows - 1))
            );
          }
        }
        return corr;
      }
      var EigenvalueDecomposition2 = class {
        constructor(matrix3, options = {}) {
          const { assumeSymmetric = false } = options;
          matrix3 = WrapperMatrix2D2.checkMatrix(matrix3);
          if (!matrix3.isSquare()) {
            throw new Error("Matrix is not a square matrix");
          }
          if (matrix3.isEmpty()) {
            throw new Error("Matrix must be non-empty");
          }
          let n = matrix3.columns;
          let V = new Matrix3(n, n);
          let d2 = new Float64Array(n);
          let e = new Float64Array(n);
          let value = matrix3;
          let i, j;
          let isSymmetric = false;
          if (assumeSymmetric) {
            isSymmetric = true;
          } else {
            isSymmetric = matrix3.isSymmetric();
          }
          if (isSymmetric) {
            for (i = 0; i < n; i++) {
              for (j = 0; j < n; j++) {
                V.set(i, j, value.get(i, j));
              }
            }
            tred2(n, e, d2, V);
            tql2(n, e, d2, V);
          } else {
            let H = new Matrix3(n, n);
            let ort = new Float64Array(n);
            for (j = 0; j < n; j++) {
              for (i = 0; i < n; i++) {
                H.set(i, j, value.get(i, j));
              }
            }
            orthes(n, H, ort, V);
            hqr2(n, e, d2, V, H);
          }
          this.n = n;
          this.e = e;
          this.d = d2;
          this.V = V;
        }
        get realEigenvalues() {
          return Array.from(this.d);
        }
        get imaginaryEigenvalues() {
          return Array.from(this.e);
        }
        get eigenvectorMatrix() {
          return this.V;
        }
        get diagonalMatrix() {
          let n = this.n;
          let e = this.e;
          let d2 = this.d;
          let X = new Matrix3(n, n);
          let i, j;
          for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
              X.set(i, j, 0);
            }
            X.set(i, i, d2[i]);
            if (e[i] > 0) {
              X.set(i, i + 1, e[i]);
            } else if (e[i] < 0) {
              X.set(i, i - 1, e[i]);
            }
          }
          return X;
        }
      };
      function tred2(n, e, d2, V) {
        let f, g, h, i, j, k, hh, scale4;
        for (j = 0; j < n; j++) {
          d2[j] = V.get(n - 1, j);
        }
        for (i = n - 1; i > 0; i--) {
          scale4 = 0;
          h = 0;
          for (k = 0; k < i; k++) {
            scale4 = scale4 + Math.abs(d2[k]);
          }
          if (scale4 === 0) {
            e[i] = d2[i - 1];
            for (j = 0; j < i; j++) {
              d2[j] = V.get(i - 1, j);
              V.set(i, j, 0);
              V.set(j, i, 0);
            }
          } else {
            for (k = 0; k < i; k++) {
              d2[k] /= scale4;
              h += d2[k] * d2[k];
            }
            f = d2[i - 1];
            g = Math.sqrt(h);
            if (f > 0) {
              g = -g;
            }
            e[i] = scale4 * g;
            h = h - f * g;
            d2[i - 1] = f - g;
            for (j = 0; j < i; j++) {
              e[j] = 0;
            }
            for (j = 0; j < i; j++) {
              f = d2[j];
              V.set(j, i, f);
              g = e[j] + V.get(j, j) * f;
              for (k = j + 1; k <= i - 1; k++) {
                g += V.get(k, j) * d2[k];
                e[k] += V.get(k, j) * f;
              }
              e[j] = g;
            }
            f = 0;
            for (j = 0; j < i; j++) {
              e[j] /= h;
              f += e[j] * d2[j];
            }
            hh = f / (h + h);
            for (j = 0; j < i; j++) {
              e[j] -= hh * d2[j];
            }
            for (j = 0; j < i; j++) {
              f = d2[j];
              g = e[j];
              for (k = j; k <= i - 1; k++) {
                V.set(k, j, V.get(k, j) - (f * e[k] + g * d2[k]));
              }
              d2[j] = V.get(i - 1, j);
              V.set(i, j, 0);
            }
          }
          d2[i] = h;
        }
        for (i = 0; i < n - 1; i++) {
          V.set(n - 1, i, V.get(i, i));
          V.set(i, i, 1);
          h = d2[i + 1];
          if (h !== 0) {
            for (k = 0; k <= i; k++) {
              d2[k] = V.get(k, i + 1) / h;
            }
            for (j = 0; j <= i; j++) {
              g = 0;
              for (k = 0; k <= i; k++) {
                g += V.get(k, i + 1) * V.get(k, j);
              }
              for (k = 0; k <= i; k++) {
                V.set(k, j, V.get(k, j) - g * d2[k]);
              }
            }
          }
          for (k = 0; k <= i; k++) {
            V.set(k, i + 1, 0);
          }
        }
        for (j = 0; j < n; j++) {
          d2[j] = V.get(n - 1, j);
          V.set(n - 1, j, 0);
        }
        V.set(n - 1, n - 1, 1);
        e[0] = 0;
      }
      function tql2(n, e, d2, V) {
        let g, h, i, j, k, l, m2, p, r, dl1, c2, c22, c3, el1, s, s2;
        for (i = 1; i < n; i++) {
          e[i - 1] = e[i];
        }
        e[n - 1] = 0;
        let f = 0;
        let tst1 = 0;
        let eps = Number.EPSILON;
        for (l = 0; l < n; l++) {
          tst1 = Math.max(tst1, Math.abs(d2[l]) + Math.abs(e[l]));
          m2 = l;
          while (m2 < n) {
            if (Math.abs(e[m2]) <= eps * tst1) {
              break;
            }
            m2++;
          }
          if (m2 > l) {
            do {
              g = d2[l];
              p = (d2[l + 1] - g) / (2 * e[l]);
              r = hypotenuse(p, 1);
              if (p < 0) {
                r = -r;
              }
              d2[l] = e[l] / (p + r);
              d2[l + 1] = e[l] * (p + r);
              dl1 = d2[l + 1];
              h = g - d2[l];
              for (i = l + 2; i < n; i++) {
                d2[i] -= h;
              }
              f = f + h;
              p = d2[m2];
              c2 = 1;
              c22 = c2;
              c3 = c2;
              el1 = e[l + 1];
              s = 0;
              s2 = 0;
              for (i = m2 - 1; i >= l; i--) {
                c3 = c22;
                c22 = c2;
                s2 = s;
                g = c2 * e[i];
                h = c2 * p;
                r = hypotenuse(p, e[i]);
                e[i + 1] = s * r;
                s = e[i] / r;
                c2 = p / r;
                p = c2 * d2[i] - s * g;
                d2[i + 1] = h + s * (c2 * g + s * d2[i]);
                for (k = 0; k < n; k++) {
                  h = V.get(k, i + 1);
                  V.set(k, i + 1, s * V.get(k, i) + c2 * h);
                  V.set(k, i, c2 * V.get(k, i) - s * h);
                }
              }
              p = -s * s2 * c3 * el1 * e[l] / dl1;
              e[l] = s * p;
              d2[l] = c2 * p;
            } while (Math.abs(e[l]) > eps * tst1);
          }
          d2[l] = d2[l] + f;
          e[l] = 0;
        }
        for (i = 0; i < n - 1; i++) {
          k = i;
          p = d2[i];
          for (j = i + 1; j < n; j++) {
            if (d2[j] < p) {
              k = j;
              p = d2[j];
            }
          }
          if (k !== i) {
            d2[k] = d2[i];
            d2[i] = p;
            for (j = 0; j < n; j++) {
              p = V.get(j, i);
              V.set(j, i, V.get(j, k));
              V.set(j, k, p);
            }
          }
        }
      }
      function orthes(n, H, ort, V) {
        let low = 0;
        let high = n - 1;
        let f, g, h, i, j, m2;
        let scale4;
        for (m2 = low + 1; m2 <= high - 1; m2++) {
          scale4 = 0;
          for (i = m2; i <= high; i++) {
            scale4 = scale4 + Math.abs(H.get(i, m2 - 1));
          }
          if (scale4 !== 0) {
            h = 0;
            for (i = high; i >= m2; i--) {
              ort[i] = H.get(i, m2 - 1) / scale4;
              h += ort[i] * ort[i];
            }
            g = Math.sqrt(h);
            if (ort[m2] > 0) {
              g = -g;
            }
            h = h - ort[m2] * g;
            ort[m2] = ort[m2] - g;
            for (j = m2; j < n; j++) {
              f = 0;
              for (i = high; i >= m2; i--) {
                f += ort[i] * H.get(i, j);
              }
              f = f / h;
              for (i = m2; i <= high; i++) {
                H.set(i, j, H.get(i, j) - f * ort[i]);
              }
            }
            for (i = 0; i <= high; i++) {
              f = 0;
              for (j = high; j >= m2; j--) {
                f += ort[j] * H.get(i, j);
              }
              f = f / h;
              for (j = m2; j <= high; j++) {
                H.set(i, j, H.get(i, j) - f * ort[j]);
              }
            }
            ort[m2] = scale4 * ort[m2];
            H.set(m2, m2 - 1, scale4 * g);
          }
        }
        for (i = 0; i < n; i++) {
          for (j = 0; j < n; j++) {
            V.set(i, j, i === j ? 1 : 0);
          }
        }
        for (m2 = high - 1; m2 >= low + 1; m2--) {
          if (H.get(m2, m2 - 1) !== 0) {
            for (i = m2 + 1; i <= high; i++) {
              ort[i] = H.get(i, m2 - 1);
            }
            for (j = m2; j <= high; j++) {
              g = 0;
              for (i = m2; i <= high; i++) {
                g += ort[i] * V.get(i, j);
              }
              g = g / ort[m2] / H.get(m2, m2 - 1);
              for (i = m2; i <= high; i++) {
                V.set(i, j, V.get(i, j) + g * ort[i]);
              }
            }
          }
        }
      }
      function hqr2(nn, e, d2, V, H) {
        let n = nn - 1;
        let low = 0;
        let high = nn - 1;
        let eps = Number.EPSILON;
        let exshift = 0;
        let norm = 0;
        let p = 0;
        let q = 0;
        let r = 0;
        let s = 0;
        let z = 0;
        let iter = 0;
        let i, j, k, l, m2, t, w, x3, y3;
        let ra, sa, vr, vi;
        let notlast, cdivres;
        for (i = 0; i < nn; i++) {
          if (i < low || i > high) {
            d2[i] = H.get(i, i);
            e[i] = 0;
          }
          for (j = Math.max(i - 1, 0); j < nn; j++) {
            norm = norm + Math.abs(H.get(i, j));
          }
        }
        while (n >= low) {
          l = n;
          while (l > low) {
            s = Math.abs(H.get(l - 1, l - 1)) + Math.abs(H.get(l, l));
            if (s === 0) {
              s = norm;
            }
            if (Math.abs(H.get(l, l - 1)) < eps * s) {
              break;
            }
            l--;
          }
          if (l === n) {
            H.set(n, n, H.get(n, n) + exshift);
            d2[n] = H.get(n, n);
            e[n] = 0;
            n--;
            iter = 0;
          } else if (l === n - 1) {
            w = H.get(n, n - 1) * H.get(n - 1, n);
            p = (H.get(n - 1, n - 1) - H.get(n, n)) / 2;
            q = p * p + w;
            z = Math.sqrt(Math.abs(q));
            H.set(n, n, H.get(n, n) + exshift);
            H.set(n - 1, n - 1, H.get(n - 1, n - 1) + exshift);
            x3 = H.get(n, n);
            if (q >= 0) {
              z = p >= 0 ? p + z : p - z;
              d2[n - 1] = x3 + z;
              d2[n] = d2[n - 1];
              if (z !== 0) {
                d2[n] = x3 - w / z;
              }
              e[n - 1] = 0;
              e[n] = 0;
              x3 = H.get(n, n - 1);
              s = Math.abs(x3) + Math.abs(z);
              p = x3 / s;
              q = z / s;
              r = Math.sqrt(p * p + q * q);
              p = p / r;
              q = q / r;
              for (j = n - 1; j < nn; j++) {
                z = H.get(n - 1, j);
                H.set(n - 1, j, q * z + p * H.get(n, j));
                H.set(n, j, q * H.get(n, j) - p * z);
              }
              for (i = 0; i <= n; i++) {
                z = H.get(i, n - 1);
                H.set(i, n - 1, q * z + p * H.get(i, n));
                H.set(i, n, q * H.get(i, n) - p * z);
              }
              for (i = low; i <= high; i++) {
                z = V.get(i, n - 1);
                V.set(i, n - 1, q * z + p * V.get(i, n));
                V.set(i, n, q * V.get(i, n) - p * z);
              }
            } else {
              d2[n - 1] = x3 + p;
              d2[n] = x3 + p;
              e[n - 1] = z;
              e[n] = -z;
            }
            n = n - 2;
            iter = 0;
          } else {
            x3 = H.get(n, n);
            y3 = 0;
            w = 0;
            if (l < n) {
              y3 = H.get(n - 1, n - 1);
              w = H.get(n, n - 1) * H.get(n - 1, n);
            }
            if (iter === 10) {
              exshift += x3;
              for (i = low; i <= n; i++) {
                H.set(i, i, H.get(i, i) - x3);
              }
              s = Math.abs(H.get(n, n - 1)) + Math.abs(H.get(n - 1, n - 2));
              x3 = y3 = 0.75 * s;
              w = -0.4375 * s * s;
            }
            if (iter === 30) {
              s = (y3 - x3) / 2;
              s = s * s + w;
              if (s > 0) {
                s = Math.sqrt(s);
                if (y3 < x3) {
                  s = -s;
                }
                s = x3 - w / ((y3 - x3) / 2 + s);
                for (i = low; i <= n; i++) {
                  H.set(i, i, H.get(i, i) - s);
                }
                exshift += s;
                x3 = y3 = w = 0.964;
              }
            }
            iter = iter + 1;
            m2 = n - 2;
            while (m2 >= l) {
              z = H.get(m2, m2);
              r = x3 - z;
              s = y3 - z;
              p = (r * s - w) / H.get(m2 + 1, m2) + H.get(m2, m2 + 1);
              q = H.get(m2 + 1, m2 + 1) - z - r - s;
              r = H.get(m2 + 2, m2 + 1);
              s = Math.abs(p) + Math.abs(q) + Math.abs(r);
              p = p / s;
              q = q / s;
              r = r / s;
              if (m2 === l) {
                break;
              }
              if (Math.abs(H.get(m2, m2 - 1)) * (Math.abs(q) + Math.abs(r)) < eps * (Math.abs(p) * (Math.abs(H.get(m2 - 1, m2 - 1)) + Math.abs(z) + Math.abs(H.get(m2 + 1, m2 + 1))))) {
                break;
              }
              m2--;
            }
            for (i = m2 + 2; i <= n; i++) {
              H.set(i, i - 2, 0);
              if (i > m2 + 2) {
                H.set(i, i - 3, 0);
              }
            }
            for (k = m2; k <= n - 1; k++) {
              notlast = k !== n - 1;
              if (k !== m2) {
                p = H.get(k, k - 1);
                q = H.get(k + 1, k - 1);
                r = notlast ? H.get(k + 2, k - 1) : 0;
                x3 = Math.abs(p) + Math.abs(q) + Math.abs(r);
                if (x3 !== 0) {
                  p = p / x3;
                  q = q / x3;
                  r = r / x3;
                }
              }
              if (x3 === 0) {
                break;
              }
              s = Math.sqrt(p * p + q * q + r * r);
              if (p < 0) {
                s = -s;
              }
              if (s !== 0) {
                if (k !== m2) {
                  H.set(k, k - 1, -s * x3);
                } else if (l !== m2) {
                  H.set(k, k - 1, -H.get(k, k - 1));
                }
                p = p + s;
                x3 = p / s;
                y3 = q / s;
                z = r / s;
                q = q / p;
                r = r / p;
                for (j = k; j < nn; j++) {
                  p = H.get(k, j) + q * H.get(k + 1, j);
                  if (notlast) {
                    p = p + r * H.get(k + 2, j);
                    H.set(k + 2, j, H.get(k + 2, j) - p * z);
                  }
                  H.set(k, j, H.get(k, j) - p * x3);
                  H.set(k + 1, j, H.get(k + 1, j) - p * y3);
                }
                for (i = 0; i <= Math.min(n, k + 3); i++) {
                  p = x3 * H.get(i, k) + y3 * H.get(i, k + 1);
                  if (notlast) {
                    p = p + z * H.get(i, k + 2);
                    H.set(i, k + 2, H.get(i, k + 2) - p * r);
                  }
                  H.set(i, k, H.get(i, k) - p);
                  H.set(i, k + 1, H.get(i, k + 1) - p * q);
                }
                for (i = low; i <= high; i++) {
                  p = x3 * V.get(i, k) + y3 * V.get(i, k + 1);
                  if (notlast) {
                    p = p + z * V.get(i, k + 2);
                    V.set(i, k + 2, V.get(i, k + 2) - p * r);
                  }
                  V.set(i, k, V.get(i, k) - p);
                  V.set(i, k + 1, V.get(i, k + 1) - p * q);
                }
              }
            }
          }
        }
        if (norm === 0) {
          return;
        }
        for (n = nn - 1; n >= 0; n--) {
          p = d2[n];
          q = e[n];
          if (q === 0) {
            l = n;
            H.set(n, n, 1);
            for (i = n - 1; i >= 0; i--) {
              w = H.get(i, i) - p;
              r = 0;
              for (j = l; j <= n; j++) {
                r = r + H.get(i, j) * H.get(j, n);
              }
              if (e[i] < 0) {
                z = w;
                s = r;
              } else {
                l = i;
                if (e[i] === 0) {
                  H.set(i, n, w !== 0 ? -r / w : -r / (eps * norm));
                } else {
                  x3 = H.get(i, i + 1);
                  y3 = H.get(i + 1, i);
                  q = (d2[i] - p) * (d2[i] - p) + e[i] * e[i];
                  t = (x3 * s - z * r) / q;
                  H.set(i, n, t);
                  H.set(
                    i + 1,
                    n,
                    Math.abs(x3) > Math.abs(z) ? (-r - w * t) / x3 : (-s - y3 * t) / z
                  );
                }
                t = Math.abs(H.get(i, n));
                if (eps * t * t > 1) {
                  for (j = i; j <= n; j++) {
                    H.set(j, n, H.get(j, n) / t);
                  }
                }
              }
            }
          } else if (q < 0) {
            l = n - 1;
            if (Math.abs(H.get(n, n - 1)) > Math.abs(H.get(n - 1, n))) {
              H.set(n - 1, n - 1, q / H.get(n, n - 1));
              H.set(n - 1, n, -(H.get(n, n) - p) / H.get(n, n - 1));
            } else {
              cdivres = cdiv(0, -H.get(n - 1, n), H.get(n - 1, n - 1) - p, q);
              H.set(n - 1, n - 1, cdivres[0]);
              H.set(n - 1, n, cdivres[1]);
            }
            H.set(n, n - 1, 0);
            H.set(n, n, 1);
            for (i = n - 2; i >= 0; i--) {
              ra = 0;
              sa = 0;
              for (j = l; j <= n; j++) {
                ra = ra + H.get(i, j) * H.get(j, n - 1);
                sa = sa + H.get(i, j) * H.get(j, n);
              }
              w = H.get(i, i) - p;
              if (e[i] < 0) {
                z = w;
                r = ra;
                s = sa;
              } else {
                l = i;
                if (e[i] === 0) {
                  cdivres = cdiv(-ra, -sa, w, q);
                  H.set(i, n - 1, cdivres[0]);
                  H.set(i, n, cdivres[1]);
                } else {
                  x3 = H.get(i, i + 1);
                  y3 = H.get(i + 1, i);
                  vr = (d2[i] - p) * (d2[i] - p) + e[i] * e[i] - q * q;
                  vi = (d2[i] - p) * 2 * q;
                  if (vr === 0 && vi === 0) {
                    vr = eps * norm * (Math.abs(w) + Math.abs(q) + Math.abs(x3) + Math.abs(y3) + Math.abs(z));
                  }
                  cdivres = cdiv(
                    x3 * r - z * ra + q * sa,
                    x3 * s - z * sa - q * ra,
                    vr,
                    vi
                  );
                  H.set(i, n - 1, cdivres[0]);
                  H.set(i, n, cdivres[1]);
                  if (Math.abs(x3) > Math.abs(z) + Math.abs(q)) {
                    H.set(
                      i + 1,
                      n - 1,
                      (-ra - w * H.get(i, n - 1) + q * H.get(i, n)) / x3
                    );
                    H.set(
                      i + 1,
                      n,
                      (-sa - w * H.get(i, n) - q * H.get(i, n - 1)) / x3
                    );
                  } else {
                    cdivres = cdiv(
                      -r - y3 * H.get(i, n - 1),
                      -s - y3 * H.get(i, n),
                      z,
                      q
                    );
                    H.set(i + 1, n - 1, cdivres[0]);
                    H.set(i + 1, n, cdivres[1]);
                  }
                }
                t = Math.max(Math.abs(H.get(i, n - 1)), Math.abs(H.get(i, n)));
                if (eps * t * t > 1) {
                  for (j = i; j <= n; j++) {
                    H.set(j, n - 1, H.get(j, n - 1) / t);
                    H.set(j, n, H.get(j, n) / t);
                  }
                }
              }
            }
          }
        }
        for (i = 0; i < nn; i++) {
          if (i < low || i > high) {
            for (j = i; j < nn; j++) {
              V.set(i, j, H.get(i, j));
            }
          }
        }
        for (j = nn - 1; j >= low; j--) {
          for (i = low; i <= high; i++) {
            z = 0;
            for (k = low; k <= Math.min(j, high); k++) {
              z = z + V.get(i, k) * H.get(k, j);
            }
            V.set(i, j, z);
          }
        }
      }
      function cdiv(xr, xi, yr, yi) {
        let r, d2;
        if (Math.abs(yr) > Math.abs(yi)) {
          r = yi / yr;
          d2 = yr + r * yi;
          return [(xr + r * xi) / d2, (xi - r * xr) / d2];
        } else {
          r = yr / yi;
          d2 = yi + r * yr;
          return [(r * xr + xi) / d2, (r * xi - xr) / d2];
        }
      }
      var CholeskyDecomposition2 = class {
        constructor(value) {
          value = WrapperMatrix2D2.checkMatrix(value);
          if (!value.isSymmetric()) {
            throw new Error("Matrix is not symmetric");
          }
          let a2 = value;
          let dimension = a2.rows;
          let l = new Matrix3(dimension, dimension);
          let positiveDefinite = true;
          let i, j, k;
          for (j = 0; j < dimension; j++) {
            let d2 = 0;
            for (k = 0; k < j; k++) {
              let s = 0;
              for (i = 0; i < k; i++) {
                s += l.get(k, i) * l.get(j, i);
              }
              s = (a2.get(j, k) - s) / l.get(k, k);
              l.set(j, k, s);
              d2 = d2 + s * s;
            }
            d2 = a2.get(j, j) - d2;
            positiveDefinite &&= d2 > 0;
            l.set(j, j, Math.sqrt(Math.max(d2, 0)));
            for (k = j + 1; k < dimension; k++) {
              l.set(j, k, 0);
            }
          }
          this.L = l;
          this.positiveDefinite = positiveDefinite;
        }
        isPositiveDefinite() {
          return this.positiveDefinite;
        }
        solve(value) {
          value = WrapperMatrix2D2.checkMatrix(value);
          let l = this.L;
          let dimension = l.rows;
          if (value.rows !== dimension) {
            throw new Error("Matrix dimensions do not match");
          }
          if (this.isPositiveDefinite() === false) {
            throw new Error("Matrix is not positive definite");
          }
          let count = value.columns;
          let B3 = value.clone();
          let i, j, k;
          for (k = 0; k < dimension; k++) {
            for (j = 0; j < count; j++) {
              for (i = 0; i < k; i++) {
                B3.set(k, j, B3.get(k, j) - B3.get(i, j) * l.get(k, i));
              }
              B3.set(k, j, B3.get(k, j) / l.get(k, k));
            }
          }
          for (k = dimension - 1; k >= 0; k--) {
            for (j = 0; j < count; j++) {
              for (i = k + 1; i < dimension; i++) {
                B3.set(k, j, B3.get(k, j) - B3.get(i, j) * l.get(i, k));
              }
              B3.set(k, j, B3.get(k, j) / l.get(k, k));
            }
          }
          return B3;
        }
        get lowerTriangularMatrix() {
          return this.L;
        }
      };
      var nipals = class {
        constructor(X, options = {}) {
          X = WrapperMatrix2D2.checkMatrix(X);
          let { Y } = options;
          const {
            scaleScores = false,
            maxIterations = 1e3,
            terminationCriteria = 1e-10
          } = options;
          let u;
          if (Y) {
            if (isAnyArray.isAnyArray(Y) && typeof Y[0] === "number") {
              Y = Matrix3.columnVector(Y);
            } else {
              Y = WrapperMatrix2D2.checkMatrix(Y);
            }
            if (Y.rows !== X.rows) {
              throw new Error("Y should have the same number of rows as X");
            }
            u = Y.getColumnVector(0);
          } else {
            u = X.getColumnVector(0);
          }
          let diff = 1;
          let t, q, w, tOld;
          for (let counter = 0; counter < maxIterations && diff > terminationCriteria; counter++) {
            w = X.transpose().mmul(u).div(u.transpose().mmul(u).get(0, 0));
            w = w.div(w.norm());
            t = X.mmul(w).div(w.transpose().mmul(w).get(0, 0));
            if (counter > 0) {
              diff = t.clone().sub(tOld).pow(2).sum();
            }
            tOld = t.clone();
            if (Y) {
              q = Y.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));
              q = q.div(q.norm());
              u = Y.mmul(q).div(q.transpose().mmul(q).get(0, 0));
            } else {
              u = t;
            }
          }
          if (Y) {
            let p = X.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));
            p = p.div(p.norm());
            let xResidual = X.clone().sub(t.clone().mmul(p.transpose()));
            let residual = u.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));
            let yResidual = Y.clone().sub(
              t.clone().mulS(residual.get(0, 0)).mmul(q.transpose())
            );
            this.t = t;
            this.p = p.transpose();
            this.w = w.transpose();
            this.q = q;
            this.u = u;
            this.s = t.transpose().mmul(t);
            this.xResidual = xResidual;
            this.yResidual = yResidual;
            this.betas = residual;
          } else {
            this.w = w.transpose();
            this.s = t.transpose().mmul(t).sqrt();
            if (scaleScores) {
              this.t = t.clone().div(this.s.get(0, 0));
            } else {
              this.t = t;
            }
            this.xResidual = X.sub(t.mmul(w.transpose()));
          }
        }
      };
      exports.AbstractMatrix = AbstractMatrix2;
      exports.CHO = CholeskyDecomposition2;
      exports.CholeskyDecomposition = CholeskyDecomposition2;
      exports.DistanceMatrix = DistanceMatrix2;
      exports.EVD = EigenvalueDecomposition2;
      exports.EigenvalueDecomposition = EigenvalueDecomposition2;
      exports.LU = LuDecomposition2;
      exports.LuDecomposition = LuDecomposition2;
      exports.Matrix = Matrix3;
      exports.MatrixColumnSelectionView = MatrixColumnSelectionView2;
      exports.MatrixColumnView = MatrixColumnView2;
      exports.MatrixFlipColumnView = MatrixFlipColumnView2;
      exports.MatrixFlipRowView = MatrixFlipRowView2;
      exports.MatrixRowSelectionView = MatrixRowSelectionView2;
      exports.MatrixRowView = MatrixRowView2;
      exports.MatrixSelectionView = MatrixSelectionView2;
      exports.MatrixSubView = MatrixSubView2;
      exports.MatrixTransposeView = MatrixTransposeView2;
      exports.NIPALS = nipals;
      exports.Nipals = nipals;
      exports.QR = QrDecomposition2;
      exports.QrDecomposition = QrDecomposition2;
      exports.SVD = SingularValueDecomposition3;
      exports.SingularValueDecomposition = SingularValueDecomposition3;
      exports.SymmetricMatrix = SymmetricMatrix2;
      exports.WrapperMatrix1D = WrapperMatrix1D2;
      exports.WrapperMatrix2D = WrapperMatrix2D2;
      exports.correlation = correlation2;
      exports.covariance = covariance2;
      exports.default = Matrix3;
      exports.determinant = determinant2;
      exports.inverse = inverse2;
      exports.linearDependencies = linearDependencies2;
      exports.pseudoInverse = pseudoInverse2;
      exports.solve = solve2;
      exports.wrap = wrap3;
    }
  });

  // node_modules/lodash/_listCacheClear.js
  var require_listCacheClear = __commonJS({
    "node_modules/lodash/_listCacheClear.js"(exports, module) {
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      module.exports = listCacheClear;
    }
  });

  // node_modules/lodash/eq.js
  var require_eq = __commonJS({
    "node_modules/lodash/eq.js"(exports, module) {
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      module.exports = eq;
    }
  });

  // node_modules/lodash/_assocIndexOf.js
  var require_assocIndexOf = __commonJS({
    "node_modules/lodash/_assocIndexOf.js"(exports, module) {
      var eq = require_eq();
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      module.exports = assocIndexOf;
    }
  });

  // node_modules/lodash/_listCacheDelete.js
  var require_listCacheDelete = __commonJS({
    "node_modules/lodash/_listCacheDelete.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      var arrayProto = Array.prototype;
      var splice4 = arrayProto.splice;
      function listCacheDelete(key) {
        var data2 = this.__data__, index2 = assocIndexOf(data2, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data2.length - 1;
        if (index2 == lastIndex) {
          data2.pop();
        } else {
          splice4.call(data2, index2, 1);
        }
        --this.size;
        return true;
      }
      module.exports = listCacheDelete;
    }
  });

  // node_modules/lodash/_listCacheGet.js
  var require_listCacheGet = __commonJS({
    "node_modules/lodash/_listCacheGet.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheGet(key) {
        var data2 = this.__data__, index2 = assocIndexOf(data2, key);
        return index2 < 0 ? void 0 : data2[index2][1];
      }
      module.exports = listCacheGet;
    }
  });

  // node_modules/lodash/_listCacheHas.js
  var require_listCacheHas = __commonJS({
    "node_modules/lodash/_listCacheHas.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      module.exports = listCacheHas;
    }
  });

  // node_modules/lodash/_listCacheSet.js
  var require_listCacheSet = __commonJS({
    "node_modules/lodash/_listCacheSet.js"(exports, module) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheSet(key, value) {
        var data2 = this.__data__, index2 = assocIndexOf(data2, key);
        if (index2 < 0) {
          ++this.size;
          data2.push([key, value]);
        } else {
          data2[index2][1] = value;
        }
        return this;
      }
      module.exports = listCacheSet;
    }
  });

  // node_modules/lodash/_ListCache.js
  var require_ListCache = __commonJS({
    "node_modules/lodash/_ListCache.js"(exports, module) {
      var listCacheClear = require_listCacheClear();
      var listCacheDelete = require_listCacheDelete();
      var listCacheGet = require_listCacheGet();
      var listCacheHas = require_listCacheHas();
      var listCacheSet = require_listCacheSet();
      function ListCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      module.exports = ListCache;
    }
  });

  // node_modules/lodash/_stackClear.js
  var require_stackClear = __commonJS({
    "node_modules/lodash/_stackClear.js"(exports, module) {
      var ListCache = require_ListCache();
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      module.exports = stackClear;
    }
  });

  // node_modules/lodash/_stackDelete.js
  var require_stackDelete = __commonJS({
    "node_modules/lodash/_stackDelete.js"(exports, module) {
      function stackDelete(key) {
        var data2 = this.__data__, result = data2["delete"](key);
        this.size = data2.size;
        return result;
      }
      module.exports = stackDelete;
    }
  });

  // node_modules/lodash/_stackGet.js
  var require_stackGet = __commonJS({
    "node_modules/lodash/_stackGet.js"(exports, module) {
      function stackGet(key) {
        return this.__data__.get(key);
      }
      module.exports = stackGet;
    }
  });

  // node_modules/lodash/_stackHas.js
  var require_stackHas = __commonJS({
    "node_modules/lodash/_stackHas.js"(exports, module) {
      function stackHas(key) {
        return this.__data__.has(key);
      }
      module.exports = stackHas;
    }
  });

  // node_modules/lodash/_freeGlobal.js
  var require_freeGlobal = __commonJS({
    "node_modules/lodash/_freeGlobal.js"(exports, module) {
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      module.exports = freeGlobal;
    }
  });

  // node_modules/lodash/_root.js
  var require_root = __commonJS({
    "node_modules/lodash/_root.js"(exports, module) {
      var freeGlobal = require_freeGlobal();
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root2 = freeGlobal || freeSelf || Function("return this")();
      module.exports = root2;
    }
  });

  // node_modules/lodash/_Symbol.js
  var require_Symbol = __commonJS({
    "node_modules/lodash/_Symbol.js"(exports, module) {
      var root2 = require_root();
      var Symbol2 = root2.Symbol;
      module.exports = Symbol2;
    }
  });

  // node_modules/lodash/_getRawTag.js
  var require_getRawTag = __commonJS({
    "node_modules/lodash/_getRawTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var objectProto2 = Object.prototype;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      var nativeObjectToString = objectProto2.toString;
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      module.exports = getRawTag;
    }
  });

  // node_modules/lodash/_objectToString.js
  var require_objectToString = __commonJS({
    "node_modules/lodash/_objectToString.js"(exports, module) {
      var objectProto2 = Object.prototype;
      var nativeObjectToString = objectProto2.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      module.exports = objectToString;
    }
  });

  // node_modules/lodash/_baseGetTag.js
  var require_baseGetTag = __commonJS({
    "node_modules/lodash/_baseGetTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var getRawTag = require_getRawTag();
      var objectToString = require_objectToString();
      var nullTag = "[object Null]";
      var undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      module.exports = baseGetTag;
    }
  });

  // node_modules/lodash/isObject.js
  var require_isObject = __commonJS({
    "node_modules/lodash/isObject.js"(exports, module) {
      function isObject12(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      module.exports = isObject12;
    }
  });

  // node_modules/lodash/isFunction.js
  var require_isFunction = __commonJS({
    "node_modules/lodash/isFunction.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isObject12 = require_isObject();
      var asyncTag = "[object AsyncFunction]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var proxyTag = "[object Proxy]";
      function isFunction35(value) {
        if (!isObject12(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      module.exports = isFunction35;
    }
  });

  // node_modules/lodash/_coreJsData.js
  var require_coreJsData = __commonJS({
    "node_modules/lodash/_coreJsData.js"(exports, module) {
      var root2 = require_root();
      var coreJsData = root2["__core-js_shared__"];
      module.exports = coreJsData;
    }
  });

  // node_modules/lodash/_isMasked.js
  var require_isMasked = __commonJS({
    "node_modules/lodash/_isMasked.js"(exports, module) {
      var coreJsData = require_coreJsData();
      var maskSrcKey = (function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      })();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      module.exports = isMasked;
    }
  });

  // node_modules/lodash/_toSource.js
  var require_toSource = __commonJS({
    "node_modules/lodash/_toSource.js"(exports, module) {
      var funcProto = Function.prototype;
      var funcToString = funcProto.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      module.exports = toSource;
    }
  });

  // node_modules/lodash/_baseIsNative.js
  var require_baseIsNative = __commonJS({
    "node_modules/lodash/_baseIsNative.js"(exports, module) {
      var isFunction35 = require_isFunction();
      var isMasked = require_isMasked();
      var isObject12 = require_isObject();
      var toSource = require_toSource();
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto = Function.prototype;
      var objectProto2 = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject12(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction35(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      module.exports = baseIsNative;
    }
  });

  // node_modules/lodash/_getValue.js
  var require_getValue = __commonJS({
    "node_modules/lodash/_getValue.js"(exports, module) {
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      module.exports = getValue;
    }
  });

  // node_modules/lodash/_getNative.js
  var require_getNative = __commonJS({
    "node_modules/lodash/_getNative.js"(exports, module) {
      var baseIsNative = require_baseIsNative();
      var getValue = require_getValue();
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      module.exports = getNative;
    }
  });

  // node_modules/lodash/_Map.js
  var require_Map = __commonJS({
    "node_modules/lodash/_Map.js"(exports, module) {
      var getNative = require_getNative();
      var root2 = require_root();
      var Map2 = getNative(root2, "Map");
      module.exports = Map2;
    }
  });

  // node_modules/lodash/_nativeCreate.js
  var require_nativeCreate = __commonJS({
    "node_modules/lodash/_nativeCreate.js"(exports, module) {
      var getNative = require_getNative();
      var nativeCreate = getNative(Object, "create");
      module.exports = nativeCreate;
    }
  });

  // node_modules/lodash/_hashClear.js
  var require_hashClear = __commonJS({
    "node_modules/lodash/_hashClear.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      module.exports = hashClear;
    }
  });

  // node_modules/lodash/_hashDelete.js
  var require_hashDelete = __commonJS({
    "node_modules/lodash/_hashDelete.js"(exports, module) {
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      module.exports = hashDelete;
    }
  });

  // node_modules/lodash/_hashGet.js
  var require_hashGet = __commonJS({
    "node_modules/lodash/_hashGet.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var objectProto2 = Object.prototype;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      function hashGet(key) {
        var data2 = this.__data__;
        if (nativeCreate) {
          var result = data2[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty.call(data2, key) ? data2[key] : void 0;
      }
      module.exports = hashGet;
    }
  });

  // node_modules/lodash/_hashHas.js
  var require_hashHas = __commonJS({
    "node_modules/lodash/_hashHas.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      var objectProto2 = Object.prototype;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      function hashHas(key) {
        var data2 = this.__data__;
        return nativeCreate ? data2[key] !== void 0 : hasOwnProperty.call(data2, key);
      }
      module.exports = hashHas;
    }
  });

  // node_modules/lodash/_hashSet.js
  var require_hashSet = __commonJS({
    "node_modules/lodash/_hashSet.js"(exports, module) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data2 = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      module.exports = hashSet;
    }
  });

  // node_modules/lodash/_Hash.js
  var require_Hash = __commonJS({
    "node_modules/lodash/_Hash.js"(exports, module) {
      var hashClear = require_hashClear();
      var hashDelete = require_hashDelete();
      var hashGet = require_hashGet();
      var hashHas = require_hashHas();
      var hashSet = require_hashSet();
      function Hash(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      module.exports = Hash;
    }
  });

  // node_modules/lodash/_mapCacheClear.js
  var require_mapCacheClear = __commonJS({
    "node_modules/lodash/_mapCacheClear.js"(exports, module) {
      var Hash = require_Hash();
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      module.exports = mapCacheClear;
    }
  });

  // node_modules/lodash/_isKeyable.js
  var require_isKeyable = __commonJS({
    "node_modules/lodash/_isKeyable.js"(exports, module) {
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      module.exports = isKeyable;
    }
  });

  // node_modules/lodash/_getMapData.js
  var require_getMapData = __commonJS({
    "node_modules/lodash/_getMapData.js"(exports, module) {
      var isKeyable = require_isKeyable();
      function getMapData(map, key) {
        var data2 = map.__data__;
        return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
      }
      module.exports = getMapData;
    }
  });

  // node_modules/lodash/_mapCacheDelete.js
  var require_mapCacheDelete = __commonJS({
    "node_modules/lodash/_mapCacheDelete.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      module.exports = mapCacheDelete;
    }
  });

  // node_modules/lodash/_mapCacheGet.js
  var require_mapCacheGet = __commonJS({
    "node_modules/lodash/_mapCacheGet.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      module.exports = mapCacheGet;
    }
  });

  // node_modules/lodash/_mapCacheHas.js
  var require_mapCacheHas = __commonJS({
    "node_modules/lodash/_mapCacheHas.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      module.exports = mapCacheHas;
    }
  });

  // node_modules/lodash/_mapCacheSet.js
  var require_mapCacheSet = __commonJS({
    "node_modules/lodash/_mapCacheSet.js"(exports, module) {
      var getMapData = require_getMapData();
      function mapCacheSet(key, value) {
        var data2 = getMapData(this, key), size2 = data2.size;
        data2.set(key, value);
        this.size += data2.size == size2 ? 0 : 1;
        return this;
      }
      module.exports = mapCacheSet;
    }
  });

  // node_modules/lodash/_MapCache.js
  var require_MapCache = __commonJS({
    "node_modules/lodash/_MapCache.js"(exports, module) {
      var mapCacheClear = require_mapCacheClear();
      var mapCacheDelete = require_mapCacheDelete();
      var mapCacheGet = require_mapCacheGet();
      var mapCacheHas = require_mapCacheHas();
      var mapCacheSet = require_mapCacheSet();
      function MapCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      module.exports = MapCache;
    }
  });

  // node_modules/lodash/_stackSet.js
  var require_stackSet = __commonJS({
    "node_modules/lodash/_stackSet.js"(exports, module) {
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      var MapCache = require_MapCache();
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data2 = this.__data__;
        if (data2 instanceof ListCache) {
          var pairs = data2.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data2.size;
            return this;
          }
          data2 = this.__data__ = new MapCache(pairs);
        }
        data2.set(key, value);
        this.size = data2.size;
        return this;
      }
      module.exports = stackSet;
    }
  });

  // node_modules/lodash/_Stack.js
  var require_Stack = __commonJS({
    "node_modules/lodash/_Stack.js"(exports, module) {
      var ListCache = require_ListCache();
      var stackClear = require_stackClear();
      var stackDelete = require_stackDelete();
      var stackGet = require_stackGet();
      var stackHas = require_stackHas();
      var stackSet = require_stackSet();
      function Stack2(entries) {
        var data2 = this.__data__ = new ListCache(entries);
        this.size = data2.size;
      }
      Stack2.prototype.clear = stackClear;
      Stack2.prototype["delete"] = stackDelete;
      Stack2.prototype.get = stackGet;
      Stack2.prototype.has = stackHas;
      Stack2.prototype.set = stackSet;
      module.exports = Stack2;
    }
  });

  // node_modules/lodash/_arrayEach.js
  var require_arrayEach = __commonJS({
    "node_modules/lodash/_arrayEach.js"(exports, module) {
      function arrayEach(array, iteratee) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (iteratee(array[index2], index2, array) === false) {
            break;
          }
        }
        return array;
      }
      module.exports = arrayEach;
    }
  });

  // node_modules/lodash/_defineProperty.js
  var require_defineProperty = __commonJS({
    "node_modules/lodash/_defineProperty.js"(exports, module) {
      var getNative = require_getNative();
      var defineProperty = (function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      })();
      module.exports = defineProperty;
    }
  });

  // node_modules/lodash/_baseAssignValue.js
  var require_baseAssignValue = __commonJS({
    "node_modules/lodash/_baseAssignValue.js"(exports, module) {
      var defineProperty = require_defineProperty();
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      module.exports = baseAssignValue;
    }
  });

  // node_modules/lodash/_assignValue.js
  var require_assignValue = __commonJS({
    "node_modules/lodash/_assignValue.js"(exports, module) {
      var baseAssignValue = require_baseAssignValue();
      var eq = require_eq();
      var objectProto2 = Object.prototype;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      module.exports = assignValue;
    }
  });

  // node_modules/lodash/_copyObject.js
  var require_copyObject = __commonJS({
    "node_modules/lodash/_copyObject.js"(exports, module) {
      var assignValue = require_assignValue();
      var baseAssignValue = require_baseAssignValue();
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index2 = -1, length = props.length;
        while (++index2 < length) {
          var key = props[index2];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      module.exports = copyObject;
    }
  });

  // node_modules/lodash/_baseTimes.js
  var require_baseTimes = __commonJS({
    "node_modules/lodash/_baseTimes.js"(exports, module) {
      function baseTimes(n, iteratee) {
        var index2 = -1, result = Array(n);
        while (++index2 < n) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      module.exports = baseTimes;
    }
  });

  // node_modules/lodash/isObjectLike.js
  var require_isObjectLike = __commonJS({
    "node_modules/lodash/isObjectLike.js"(exports, module) {
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      module.exports = isObjectLike;
    }
  });

  // node_modules/lodash/_baseIsArguments.js
  var require_baseIsArguments = __commonJS({
    "node_modules/lodash/_baseIsArguments.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var argsTag = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      module.exports = baseIsArguments;
    }
  });

  // node_modules/lodash/isArguments.js
  var require_isArguments = __commonJS({
    "node_modules/lodash/isArguments.js"(exports, module) {
      var baseIsArguments = require_baseIsArguments();
      var isObjectLike = require_isObjectLike();
      var objectProto2 = Object.prototype;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      var propertyIsEnumerable = objectProto2.propertyIsEnumerable;
      var isArguments = baseIsArguments(/* @__PURE__ */ (function() {
        return arguments;
      })()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      module.exports = isArguments;
    }
  });

  // node_modules/lodash/isArray.js
  var require_isArray = __commonJS({
    "node_modules/lodash/isArray.js"(exports, module) {
      var isArray7 = Array.isArray;
      module.exports = isArray7;
    }
  });

  // node_modules/lodash/stubFalse.js
  var require_stubFalse = __commonJS({
    "node_modules/lodash/stubFalse.js"(exports, module) {
      function stubFalse() {
        return false;
      }
      module.exports = stubFalse;
    }
  });

  // node_modules/lodash/isBuffer.js
  var require_isBuffer = __commonJS({
    "node_modules/lodash/isBuffer.js"(exports, module) {
      var root2 = require_root();
      var stubFalse = require_stubFalse();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root2.Buffer : void 0;
      var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      module.exports = isBuffer;
    }
  });

  // node_modules/lodash/_isIndex.js
  var require_isIndex = __commonJS({
    "node_modules/lodash/_isIndex.js"(exports, module) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      module.exports = isIndex;
    }
  });

  // node_modules/lodash/isLength.js
  var require_isLength = __commonJS({
    "node_modules/lodash/isLength.js"(exports, module) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      module.exports = isLength;
    }
  });

  // node_modules/lodash/_baseIsTypedArray.js
  var require_baseIsTypedArray = __commonJS({
    "node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isLength = require_isLength();
      var isObjectLike = require_isObjectLike();
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var objectTag = "[object Object]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      module.exports = baseIsTypedArray;
    }
  });

  // node_modules/lodash/_baseUnary.js
  var require_baseUnary = __commonJS({
    "node_modules/lodash/_baseUnary.js"(exports, module) {
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      module.exports = baseUnary;
    }
  });

  // node_modules/lodash/_nodeUtil.js
  var require_nodeUtil = __commonJS({
    "node_modules/lodash/_nodeUtil.js"(exports, module) {
      var freeGlobal = require_freeGlobal();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = (function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      })();
      module.exports = nodeUtil;
    }
  });

  // node_modules/lodash/isTypedArray.js
  var require_isTypedArray = __commonJS({
    "node_modules/lodash/isTypedArray.js"(exports, module) {
      var baseIsTypedArray = require_baseIsTypedArray();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      module.exports = isTypedArray;
    }
  });

  // node_modules/lodash/_arrayLikeKeys.js
  var require_arrayLikeKeys = __commonJS({
    "node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
      var baseTimes = require_baseTimes();
      var isArguments = require_isArguments();
      var isArray7 = require_isArray();
      var isBuffer = require_isBuffer();
      var isIndex = require_isIndex();
      var isTypedArray = require_isTypedArray();
      var objectProto2 = Object.prototype;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray7(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = arrayLikeKeys;
    }
  });

  // node_modules/lodash/_isPrototype.js
  var require_isPrototype = __commonJS({
    "node_modules/lodash/_isPrototype.js"(exports, module) {
      var objectProto2 = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
        return value === proto;
      }
      module.exports = isPrototype;
    }
  });

  // node_modules/lodash/_overArg.js
  var require_overArg = __commonJS({
    "node_modules/lodash/_overArg.js"(exports, module) {
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      module.exports = overArg;
    }
  });

  // node_modules/lodash/_nativeKeys.js
  var require_nativeKeys = __commonJS({
    "node_modules/lodash/_nativeKeys.js"(exports, module) {
      var overArg = require_overArg();
      var nativeKeys = overArg(Object.keys, Object);
      module.exports = nativeKeys;
    }
  });

  // node_modules/lodash/_baseKeys.js
  var require_baseKeys = __commonJS({
    "node_modules/lodash/_baseKeys.js"(exports, module) {
      var isPrototype = require_isPrototype();
      var nativeKeys = require_nativeKeys();
      var objectProto2 = Object.prototype;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = baseKeys;
    }
  });

  // node_modules/lodash/isArrayLike.js
  var require_isArrayLike = __commonJS({
    "node_modules/lodash/isArrayLike.js"(exports, module) {
      var isFunction35 = require_isFunction();
      var isLength = require_isLength();
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction35(value);
      }
      module.exports = isArrayLike;
    }
  });

  // node_modules/lodash/keys.js
  var require_keys2 = __commonJS({
    "node_modules/lodash/keys.js"(exports, module) {
      var arrayLikeKeys = require_arrayLikeKeys();
      var baseKeys = require_baseKeys();
      var isArrayLike = require_isArrayLike();
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      module.exports = keys;
    }
  });

  // node_modules/lodash/_baseAssign.js
  var require_baseAssign = __commonJS({
    "node_modules/lodash/_baseAssign.js"(exports, module) {
      var copyObject = require_copyObject();
      var keys = require_keys2();
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      module.exports = baseAssign;
    }
  });

  // node_modules/lodash/_nativeKeysIn.js
  var require_nativeKeysIn = __commonJS({
    "node_modules/lodash/_nativeKeysIn.js"(exports, module) {
      function nativeKeysIn(object) {
        var result = [];
        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = nativeKeysIn;
    }
  });

  // node_modules/lodash/_baseKeysIn.js
  var require_baseKeysIn = __commonJS({
    "node_modules/lodash/_baseKeysIn.js"(exports, module) {
      var isObject12 = require_isObject();
      var isPrototype = require_isPrototype();
      var nativeKeysIn = require_nativeKeysIn();
      var objectProto2 = Object.prototype;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      function baseKeysIn(object) {
        if (!isObject12(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      module.exports = baseKeysIn;
    }
  });

  // node_modules/lodash/keysIn.js
  var require_keysIn = __commonJS({
    "node_modules/lodash/keysIn.js"(exports, module) {
      var arrayLikeKeys = require_arrayLikeKeys();
      var baseKeysIn = require_baseKeysIn();
      var isArrayLike = require_isArrayLike();
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      module.exports = keysIn;
    }
  });

  // node_modules/lodash/_baseAssignIn.js
  var require_baseAssignIn = __commonJS({
    "node_modules/lodash/_baseAssignIn.js"(exports, module) {
      var copyObject = require_copyObject();
      var keysIn = require_keysIn();
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      module.exports = baseAssignIn;
    }
  });

  // node_modules/lodash/_cloneBuffer.js
  var require_cloneBuffer = __commonJS({
    "node_modules/lodash/_cloneBuffer.js"(exports, module) {
      var root2 = require_root();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root2.Buffer : void 0;
      var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result);
        return result;
      }
      module.exports = cloneBuffer;
    }
  });

  // node_modules/lodash/_copyArray.js
  var require_copyArray = __commonJS({
    "node_modules/lodash/_copyArray.js"(exports, module) {
      function copyArray(source, array) {
        var index2 = -1, length = source.length;
        array || (array = Array(length));
        while (++index2 < length) {
          array[index2] = source[index2];
        }
        return array;
      }
      module.exports = copyArray;
    }
  });

  // node_modules/lodash/_arrayFilter.js
  var require_arrayFilter = __commonJS({
    "node_modules/lodash/_arrayFilter.js"(exports, module) {
      function arrayFilter(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index2 < length) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      module.exports = arrayFilter;
    }
  });

  // node_modules/lodash/stubArray.js
  var require_stubArray = __commonJS({
    "node_modules/lodash/stubArray.js"(exports, module) {
      function stubArray() {
        return [];
      }
      module.exports = stubArray;
    }
  });

  // node_modules/lodash/_getSymbols.js
  var require_getSymbols = __commonJS({
    "node_modules/lodash/_getSymbols.js"(exports, module) {
      var arrayFilter = require_arrayFilter();
      var stubArray = require_stubArray();
      var objectProto2 = Object.prototype;
      var propertyIsEnumerable = objectProto2.propertyIsEnumerable;
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      module.exports = getSymbols;
    }
  });

  // node_modules/lodash/_copySymbols.js
  var require_copySymbols = __commonJS({
    "node_modules/lodash/_copySymbols.js"(exports, module) {
      var copyObject = require_copyObject();
      var getSymbols = require_getSymbols();
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      module.exports = copySymbols;
    }
  });

  // node_modules/lodash/_arrayPush.js
  var require_arrayPush = __commonJS({
    "node_modules/lodash/_arrayPush.js"(exports, module) {
      function arrayPush(array, values2) {
        var index2 = -1, length = values2.length, offset = array.length;
        while (++index2 < length) {
          array[offset + index2] = values2[index2];
        }
        return array;
      }
      module.exports = arrayPush;
    }
  });

  // node_modules/lodash/_getPrototype.js
  var require_getPrototype = __commonJS({
    "node_modules/lodash/_getPrototype.js"(exports, module) {
      var overArg = require_overArg();
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      module.exports = getPrototype;
    }
  });

  // node_modules/lodash/_getSymbolsIn.js
  var require_getSymbolsIn = __commonJS({
    "node_modules/lodash/_getSymbolsIn.js"(exports, module) {
      var arrayPush = require_arrayPush();
      var getPrototype = require_getPrototype();
      var getSymbols = require_getSymbols();
      var stubArray = require_stubArray();
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result = [];
        while (object) {
          arrayPush(result, getSymbols(object));
          object = getPrototype(object);
        }
        return result;
      };
      module.exports = getSymbolsIn;
    }
  });

  // node_modules/lodash/_copySymbolsIn.js
  var require_copySymbolsIn = __commonJS({
    "node_modules/lodash/_copySymbolsIn.js"(exports, module) {
      var copyObject = require_copyObject();
      var getSymbolsIn = require_getSymbolsIn();
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      module.exports = copySymbolsIn;
    }
  });

  // node_modules/lodash/_baseGetAllKeys.js
  var require_baseGetAllKeys = __commonJS({
    "node_modules/lodash/_baseGetAllKeys.js"(exports, module) {
      var arrayPush = require_arrayPush();
      var isArray7 = require_isArray();
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray7(object) ? result : arrayPush(result, symbolsFunc(object));
      }
      module.exports = baseGetAllKeys;
    }
  });

  // node_modules/lodash/_getAllKeys.js
  var require_getAllKeys = __commonJS({
    "node_modules/lodash/_getAllKeys.js"(exports, module) {
      var baseGetAllKeys = require_baseGetAllKeys();
      var getSymbols = require_getSymbols();
      var keys = require_keys2();
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      module.exports = getAllKeys;
    }
  });

  // node_modules/lodash/_getAllKeysIn.js
  var require_getAllKeysIn = __commonJS({
    "node_modules/lodash/_getAllKeysIn.js"(exports, module) {
      var baseGetAllKeys = require_baseGetAllKeys();
      var getSymbolsIn = require_getSymbolsIn();
      var keysIn = require_keysIn();
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      module.exports = getAllKeysIn;
    }
  });

  // node_modules/lodash/_DataView.js
  var require_DataView = __commonJS({
    "node_modules/lodash/_DataView.js"(exports, module) {
      var getNative = require_getNative();
      var root2 = require_root();
      var DataView = getNative(root2, "DataView");
      module.exports = DataView;
    }
  });

  // node_modules/lodash/_Promise.js
  var require_Promise = __commonJS({
    "node_modules/lodash/_Promise.js"(exports, module) {
      var getNative = require_getNative();
      var root2 = require_root();
      var Promise2 = getNative(root2, "Promise");
      module.exports = Promise2;
    }
  });

  // node_modules/lodash/_Set.js
  var require_Set = __commonJS({
    "node_modules/lodash/_Set.js"(exports, module) {
      var getNative = require_getNative();
      var root2 = require_root();
      var Set2 = getNative(root2, "Set");
      module.exports = Set2;
    }
  });

  // node_modules/lodash/_WeakMap.js
  var require_WeakMap = __commonJS({
    "node_modules/lodash/_WeakMap.js"(exports, module) {
      var getNative = require_getNative();
      var root2 = require_root();
      var WeakMap2 = getNative(root2, "WeakMap");
      module.exports = WeakMap2;
    }
  });

  // node_modules/lodash/_getTag.js
  var require_getTag = __commonJS({
    "node_modules/lodash/_getTag.js"(exports, module) {
      var DataView = require_DataView();
      var Map2 = require_Map();
      var Promise2 = require_Promise();
      var Set2 = require_Set();
      var WeakMap2 = require_WeakMap();
      var baseGetTag = require_baseGetTag();
      var toSource = require_toSource();
      var mapTag = "[object Map]";
      var objectTag = "[object Object]";
      var promiseTag = "[object Promise]";
      var setTag = "[object Set]";
      var weakMapTag = "[object WeakMap]";
      var dataViewTag = "[object DataView]";
      var dataViewCtorString = toSource(DataView);
      var mapCtorString = toSource(Map2);
      var promiseCtorString = toSource(Promise2);
      var setCtorString = toSource(Set2);
      var weakMapCtorString = toSource(WeakMap2);
      var getTag = baseGetTag;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      module.exports = getTag;
    }
  });

  // node_modules/lodash/_initCloneArray.js
  var require_initCloneArray = __commonJS({
    "node_modules/lodash/_initCloneArray.js"(exports, module) {
      var objectProto2 = Object.prototype;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      function initCloneArray(array) {
        var length = array.length, result = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
          result.index = array.index;
          result.input = array.input;
        }
        return result;
      }
      module.exports = initCloneArray;
    }
  });

  // node_modules/lodash/_Uint8Array.js
  var require_Uint8Array = __commonJS({
    "node_modules/lodash/_Uint8Array.js"(exports, module) {
      var root2 = require_root();
      var Uint8Array2 = root2.Uint8Array;
      module.exports = Uint8Array2;
    }
  });

  // node_modules/lodash/_cloneArrayBuffer.js
  var require_cloneArrayBuffer = __commonJS({
    "node_modules/lodash/_cloneArrayBuffer.js"(exports, module) {
      var Uint8Array2 = require_Uint8Array();
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
        return result;
      }
      module.exports = cloneArrayBuffer;
    }
  });

  // node_modules/lodash/_cloneDataView.js
  var require_cloneDataView = __commonJS({
    "node_modules/lodash/_cloneDataView.js"(exports, module) {
      var cloneArrayBuffer = require_cloneArrayBuffer();
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      module.exports = cloneDataView;
    }
  });

  // node_modules/lodash/_cloneRegExp.js
  var require_cloneRegExp = __commonJS({
    "node_modules/lodash/_cloneRegExp.js"(exports, module) {
      var reFlags = /\w*$/;
      function cloneRegExp(regexp) {
        var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result.lastIndex = regexp.lastIndex;
        return result;
      }
      module.exports = cloneRegExp;
    }
  });

  // node_modules/lodash/_cloneSymbol.js
  var require_cloneSymbol = __commonJS({
    "node_modules/lodash/_cloneSymbol.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
      }
      module.exports = cloneSymbol;
    }
  });

  // node_modules/lodash/_cloneTypedArray.js
  var require_cloneTypedArray = __commonJS({
    "node_modules/lodash/_cloneTypedArray.js"(exports, module) {
      var cloneArrayBuffer = require_cloneArrayBuffer();
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      module.exports = cloneTypedArray;
    }
  });

  // node_modules/lodash/_initCloneByTag.js
  var require_initCloneByTag = __commonJS({
    "node_modules/lodash/_initCloneByTag.js"(exports, module) {
      var cloneArrayBuffer = require_cloneArrayBuffer();
      var cloneDataView = require_cloneDataView();
      var cloneRegExp = require_cloneRegExp();
      var cloneSymbol = require_cloneSymbol();
      var cloneTypedArray = require_cloneTypedArray();
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      module.exports = initCloneByTag;
    }
  });

  // node_modules/lodash/_baseCreate.js
  var require_baseCreate = __commonJS({
    "node_modules/lodash/_baseCreate.js"(exports, module) {
      var isObject12 = require_isObject();
      var objectCreate = Object.create;
      var baseCreate = /* @__PURE__ */ (function() {
        function object() {
        }
        return function(proto) {
          if (!isObject12(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result = new object();
          object.prototype = void 0;
          return result;
        };
      })();
      module.exports = baseCreate;
    }
  });

  // node_modules/lodash/_initCloneObject.js
  var require_initCloneObject = __commonJS({
    "node_modules/lodash/_initCloneObject.js"(exports, module) {
      var baseCreate = require_baseCreate();
      var getPrototype = require_getPrototype();
      var isPrototype = require_isPrototype();
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      module.exports = initCloneObject;
    }
  });

  // node_modules/lodash/_baseIsMap.js
  var require_baseIsMap = __commonJS({
    "node_modules/lodash/_baseIsMap.js"(exports, module) {
      var getTag = require_getTag();
      var isObjectLike = require_isObjectLike();
      var mapTag = "[object Map]";
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      module.exports = baseIsMap;
    }
  });

  // node_modules/lodash/isMap.js
  var require_isMap = __commonJS({
    "node_modules/lodash/isMap.js"(exports, module) {
      var baseIsMap = require_baseIsMap();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsMap = nodeUtil && nodeUtil.isMap;
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      module.exports = isMap;
    }
  });

  // node_modules/lodash/_baseIsSet.js
  var require_baseIsSet = __commonJS({
    "node_modules/lodash/_baseIsSet.js"(exports, module) {
      var getTag = require_getTag();
      var isObjectLike = require_isObjectLike();
      var setTag = "[object Set]";
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      module.exports = baseIsSet;
    }
  });

  // node_modules/lodash/isSet.js
  var require_isSet = __commonJS({
    "node_modules/lodash/isSet.js"(exports, module) {
      var baseIsSet = require_baseIsSet();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsSet = nodeUtil && nodeUtil.isSet;
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      module.exports = isSet;
    }
  });

  // node_modules/lodash/_baseClone.js
  var require_baseClone = __commonJS({
    "node_modules/lodash/_baseClone.js"(exports, module) {
      var Stack2 = require_Stack();
      var arrayEach = require_arrayEach();
      var assignValue = require_assignValue();
      var baseAssign = require_baseAssign();
      var baseAssignIn = require_baseAssignIn();
      var cloneBuffer = require_cloneBuffer();
      var copyArray = require_copyArray();
      var copySymbols = require_copySymbols();
      var copySymbolsIn = require_copySymbolsIn();
      var getAllKeys = require_getAllKeys();
      var getAllKeysIn = require_getAllKeysIn();
      var getTag = require_getTag();
      var initCloneArray = require_initCloneArray();
      var initCloneByTag = require_initCloneByTag();
      var initCloneObject = require_initCloneObject();
      var isArray7 = require_isArray();
      var isBuffer = require_isBuffer();
      var isMap = require_isMap();
      var isObject12 = require_isObject();
      var isSet = require_isSet();
      var keys = require_keys2();
      var keysIn = require_keysIn();
      var CLONE_DEEP_FLAG = 1;
      var CLONE_FLAT_FLAG = 2;
      var CLONE_SYMBOLS_FLAG = 4;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var objectTag = "[object Object]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result !== void 0) {
          return result;
        }
        if (!isObject12(value)) {
          return value;
        }
        var isArr = isArray7(value);
        if (isArr) {
          result = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack2());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? void 0 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result;
      }
      module.exports = baseClone;
    }
  });

  // node_modules/lodash/clone.js
  var require_clone2 = __commonJS({
    "node_modules/lodash/clone.js"(exports, module) {
      var baseClone = require_baseClone();
      var CLONE_SYMBOLS_FLAG = 4;
      function clone8(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      module.exports = clone8;
    }
  });

  // node_modules/lodash/constant.js
  var require_constant = __commonJS({
    "node_modules/lodash/constant.js"(exports, module) {
      function constant(value) {
        return function() {
          return value;
        };
      }
      module.exports = constant;
    }
  });

  // node_modules/lodash/_createBaseFor.js
  var require_createBaseFor = __commonJS({
    "node_modules/lodash/_createBaseFor.js"(exports, module) {
      function createBaseFor(fromRight) {
        return function(object, iteratee, keysFunc) {
          var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index2];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      module.exports = createBaseFor;
    }
  });

  // node_modules/lodash/_baseFor.js
  var require_baseFor = __commonJS({
    "node_modules/lodash/_baseFor.js"(exports, module) {
      var createBaseFor = require_createBaseFor();
      var baseFor = createBaseFor();
      module.exports = baseFor;
    }
  });

  // node_modules/lodash/_baseForOwn.js
  var require_baseForOwn = __commonJS({
    "node_modules/lodash/_baseForOwn.js"(exports, module) {
      var baseFor = require_baseFor();
      var keys = require_keys2();
      function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys);
      }
      module.exports = baseForOwn;
    }
  });

  // node_modules/lodash/_createBaseEach.js
  var require_createBaseEach = __commonJS({
    "node_modules/lodash/_createBaseEach.js"(exports, module) {
      var isArrayLike = require_isArrayLike();
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
          }
          var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
          while (fromRight ? index2-- : ++index2 < length) {
            if (iteratee(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      module.exports = createBaseEach;
    }
  });

  // node_modules/lodash/_baseEach.js
  var require_baseEach = __commonJS({
    "node_modules/lodash/_baseEach.js"(exports, module) {
      var baseForOwn = require_baseForOwn();
      var createBaseEach = require_createBaseEach();
      var baseEach = createBaseEach(baseForOwn);
      module.exports = baseEach;
    }
  });

  // node_modules/lodash/identity.js
  var require_identity2 = __commonJS({
    "node_modules/lodash/identity.js"(exports, module) {
      function identity3(value) {
        return value;
      }
      module.exports = identity3;
    }
  });

  // node_modules/lodash/_castFunction.js
  var require_castFunction = __commonJS({
    "node_modules/lodash/_castFunction.js"(exports, module) {
      var identity3 = require_identity2();
      function castFunction(value) {
        return typeof value == "function" ? value : identity3;
      }
      module.exports = castFunction;
    }
  });

  // node_modules/lodash/forEach.js
  var require_forEach = __commonJS({
    "node_modules/lodash/forEach.js"(exports, module) {
      var arrayEach = require_arrayEach();
      var baseEach = require_baseEach();
      var castFunction = require_castFunction();
      var isArray7 = require_isArray();
      function forEach(collection, iteratee) {
        var func = isArray7(collection) ? arrayEach : baseEach;
        return func(collection, castFunction(iteratee));
      }
      module.exports = forEach;
    }
  });

  // node_modules/lodash/each.js
  var require_each2 = __commonJS({
    "node_modules/lodash/each.js"(exports, module) {
      module.exports = require_forEach();
    }
  });

  // node_modules/lodash/_baseFilter.js
  var require_baseFilter = __commonJS({
    "node_modules/lodash/_baseFilter.js"(exports, module) {
      var baseEach = require_baseEach();
      function baseFilter(collection, predicate) {
        var result = [];
        baseEach(collection, function(value, index2, collection2) {
          if (predicate(value, index2, collection2)) {
            result.push(value);
          }
        });
        return result;
      }
      module.exports = baseFilter;
    }
  });

  // node_modules/lodash/_setCacheAdd.js
  var require_setCacheAdd = __commonJS({
    "node_modules/lodash/_setCacheAdd.js"(exports, module) {
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      module.exports = setCacheAdd;
    }
  });

  // node_modules/lodash/_setCacheHas.js
  var require_setCacheHas = __commonJS({
    "node_modules/lodash/_setCacheHas.js"(exports, module) {
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      module.exports = setCacheHas;
    }
  });

  // node_modules/lodash/_SetCache.js
  var require_SetCache = __commonJS({
    "node_modules/lodash/_SetCache.js"(exports, module) {
      var MapCache = require_MapCache();
      var setCacheAdd = require_setCacheAdd();
      var setCacheHas = require_setCacheHas();
      function SetCache(values2) {
        var index2 = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index2 < length) {
          this.add(values2[index2]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      module.exports = SetCache;
    }
  });

  // node_modules/lodash/_arraySome.js
  var require_arraySome = __commonJS({
    "node_modules/lodash/_arraySome.js"(exports, module) {
      function arraySome(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (predicate(array[index2], index2, array)) {
            return true;
          }
        }
        return false;
      }
      module.exports = arraySome;
    }
  });

  // node_modules/lodash/_cacheHas.js
  var require_cacheHas = __commonJS({
    "node_modules/lodash/_cacheHas.js"(exports, module) {
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      module.exports = cacheHas;
    }
  });

  // node_modules/lodash/_equalArrays.js
  var require_equalArrays = __commonJS({
    "node_modules/lodash/_equalArrays.js"(exports, module) {
      var SetCache = require_SetCache();
      var arraySome = require_arraySome();
      var cacheHas = require_cacheHas();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
        stack.set(array, other);
        stack.set(other, array);
        while (++index2 < arrLength) {
          var arrValue = array[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result;
      }
      module.exports = equalArrays;
    }
  });

  // node_modules/lodash/_mapToArray.js
  var require_mapToArray = __commonJS({
    "node_modules/lodash/_mapToArray.js"(exports, module) {
      function mapToArray(map) {
        var index2 = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index2] = [key, value];
        });
        return result;
      }
      module.exports = mapToArray;
    }
  });

  // node_modules/lodash/_setToArray.js
  var require_setToArray = __commonJS({
    "node_modules/lodash/_setToArray.js"(exports, module) {
      function setToArray(set6) {
        var index2 = -1, result = Array(set6.size);
        set6.forEach(function(value) {
          result[++index2] = value;
        });
        return result;
      }
      module.exports = setToArray;
    }
  });

  // node_modules/lodash/_equalByTag.js
  var require_equalByTag = __commonJS({
    "node_modules/lodash/_equalByTag.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var Uint8Array2 = require_Uint8Array();
      var eq = require_eq();
      var equalArrays = require_equalArrays();
      var mapToArray = require_mapToArray();
      var setToArray = require_setToArray();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      module.exports = equalByTag;
    }
  });

  // node_modules/lodash/_equalObjects.js
  var require_equalObjects = __commonJS({
    "node_modules/lodash/_equalObjects.js"(exports, module) {
      var getAllKeys = require_getAllKeys();
      var COMPARE_PARTIAL_FLAG = 1;
      var objectProto2 = Object.prototype;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result;
      }
      module.exports = equalObjects;
    }
  });

  // node_modules/lodash/_baseIsEqualDeep.js
  var require_baseIsEqualDeep = __commonJS({
    "node_modules/lodash/_baseIsEqualDeep.js"(exports, module) {
      var Stack2 = require_Stack();
      var equalArrays = require_equalArrays();
      var equalByTag = require_equalByTag();
      var equalObjects = require_equalObjects();
      var getTag = require_getTag();
      var isArray7 = require_isArray();
      var isBuffer = require_isBuffer();
      var isTypedArray = require_isTypedArray();
      var COMPARE_PARTIAL_FLAG = 1;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var objectTag = "[object Object]";
      var objectProto2 = Object.prototype;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray7(object), othIsArr = isArray7(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack2());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack2());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack2());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      module.exports = baseIsEqualDeep;
    }
  });

  // node_modules/lodash/_baseIsEqual.js
  var require_baseIsEqual = __commonJS({
    "node_modules/lodash/_baseIsEqual.js"(exports, module) {
      var baseIsEqualDeep = require_baseIsEqualDeep();
      var isObjectLike = require_isObjectLike();
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      module.exports = baseIsEqual;
    }
  });

  // node_modules/lodash/_baseIsMatch.js
  var require_baseIsMatch = __commonJS({
    "node_modules/lodash/_baseIsMatch.js"(exports, module) {
      var Stack2 = require_Stack();
      var baseIsEqual = require_baseIsEqual();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function baseIsMatch(object, source, matchData, customizer) {
        var index2 = matchData.length, length = index2, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object(object);
        while (index2--) {
          var data2 = matchData[index2];
          if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
            return false;
          }
        }
        while (++index2 < length) {
          data2 = matchData[index2];
          var key = data2[0], objValue = object[key], srcValue = data2[1];
          if (noCustomizer && data2[2]) {
            if (objValue === void 0 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack2();
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      module.exports = baseIsMatch;
    }
  });

  // node_modules/lodash/_isStrictComparable.js
  var require_isStrictComparable = __commonJS({
    "node_modules/lodash/_isStrictComparable.js"(exports, module) {
      var isObject12 = require_isObject();
      function isStrictComparable(value) {
        return value === value && !isObject12(value);
      }
      module.exports = isStrictComparable;
    }
  });

  // node_modules/lodash/_getMatchData.js
  var require_getMatchData = __commonJS({
    "node_modules/lodash/_getMatchData.js"(exports, module) {
      var isStrictComparable = require_isStrictComparable();
      var keys = require_keys2();
      function getMatchData(object) {
        var result = keys(object), length = result.length;
        while (length--) {
          var key = result[length], value = object[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      module.exports = getMatchData;
    }
  });

  // node_modules/lodash/_matchesStrictComparable.js
  var require_matchesStrictComparable = __commonJS({
    "node_modules/lodash/_matchesStrictComparable.js"(exports, module) {
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
        };
      }
      module.exports = matchesStrictComparable;
    }
  });

  // node_modules/lodash/_baseMatches.js
  var require_baseMatches = __commonJS({
    "node_modules/lodash/_baseMatches.js"(exports, module) {
      var baseIsMatch = require_baseIsMatch();
      var getMatchData = require_getMatchData();
      var matchesStrictComparable = require_matchesStrictComparable();
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      module.exports = baseMatches;
    }
  });

  // node_modules/lodash/isSymbol.js
  var require_isSymbol = __commonJS({
    "node_modules/lodash/isSymbol.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var symbolTag = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      module.exports = isSymbol;
    }
  });

  // node_modules/lodash/_isKey.js
  var require_isKey = __commonJS({
    "node_modules/lodash/_isKey.js"(exports, module) {
      var isArray7 = require_isArray();
      var isSymbol = require_isSymbol();
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
      var reIsPlainProp = /^\w*$/;
      function isKey(value, object) {
        if (isArray7(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }
      module.exports = isKey;
    }
  });

  // node_modules/lodash/memoize.js
  var require_memoize2 = __commonJS({
    "node_modules/lodash/memoize.js"(exports, module) {
      var MapCache = require_MapCache();
      var FUNC_ERROR_TEXT = "Expected a function";
      function memoize4(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result) || cache;
          return result;
        };
        memoized.cache = new (memoize4.Cache || MapCache)();
        return memoized;
      }
      memoize4.Cache = MapCache;
      module.exports = memoize4;
    }
  });

  // node_modules/lodash/_memoizeCapped.js
  var require_memoizeCapped = __commonJS({
    "node_modules/lodash/_memoizeCapped.js"(exports, module) {
      var memoize4 = require_memoize2();
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result = memoize4(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result.cache;
        return result;
      }
      module.exports = memoizeCapped;
    }
  });

  // node_modules/lodash/_stringToPath.js
  var require_stringToPath = __commonJS({
    "node_modules/lodash/_stringToPath.js"(exports, module) {
      var memoizeCapped = require_memoizeCapped();
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = memoizeCapped(function(string) {
        var result = [];
        if (string.charCodeAt(0) === 46) {
          result.push("");
        }
        string.replace(rePropName, function(match2, number, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
        });
        return result;
      });
      module.exports = stringToPath;
    }
  });

  // node_modules/lodash/_arrayMap.js
  var require_arrayMap = __commonJS({
    "node_modules/lodash/_arrayMap.js"(exports, module) {
      function arrayMap(array, iteratee) {
        var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index2 < length) {
          result[index2] = iteratee(array[index2], index2, array);
        }
        return result;
      }
      module.exports = arrayMap;
    }
  });

  // node_modules/lodash/_baseToString.js
  var require_baseToString = __commonJS({
    "node_modules/lodash/_baseToString.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var arrayMap = require_arrayMap();
      var isArray7 = require_isArray();
      var isSymbol = require_isSymbol();
      var INFINITY = 1 / 0;
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolToString = symbolProto ? symbolProto.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray7(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      module.exports = baseToString;
    }
  });

  // node_modules/lodash/toString.js
  var require_toString = __commonJS({
    "node_modules/lodash/toString.js"(exports, module) {
      var baseToString = require_baseToString();
      function toString3(value) {
        return value == null ? "" : baseToString(value);
      }
      module.exports = toString3;
    }
  });

  // node_modules/lodash/_castPath.js
  var require_castPath = __commonJS({
    "node_modules/lodash/_castPath.js"(exports, module) {
      var isArray7 = require_isArray();
      var isKey = require_isKey();
      var stringToPath = require_stringToPath();
      var toString3 = require_toString();
      function castPath(value, object) {
        if (isArray7(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString3(value));
      }
      module.exports = castPath;
    }
  });

  // node_modules/lodash/_toKey.js
  var require_toKey = __commonJS({
    "node_modules/lodash/_toKey.js"(exports, module) {
      var isSymbol = require_isSymbol();
      var INFINITY = 1 / 0;
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      module.exports = toKey;
    }
  });

  // node_modules/lodash/_baseGet.js
  var require_baseGet = __commonJS({
    "node_modules/lodash/_baseGet.js"(exports, module) {
      var castPath = require_castPath();
      var toKey = require_toKey();
      function baseGet(object, path) {
        path = castPath(path, object);
        var index2 = 0, length = path.length;
        while (object != null && index2 < length) {
          object = object[toKey(path[index2++])];
        }
        return index2 && index2 == length ? object : void 0;
      }
      module.exports = baseGet;
    }
  });

  // node_modules/lodash/get.js
  var require_get2 = __commonJS({
    "node_modules/lodash/get.js"(exports, module) {
      var baseGet = require_baseGet();
      function get9(object, path, defaultValue) {
        var result = object == null ? void 0 : baseGet(object, path);
        return result === void 0 ? defaultValue : result;
      }
      module.exports = get9;
    }
  });

  // node_modules/lodash/_baseHasIn.js
  var require_baseHasIn = __commonJS({
    "node_modules/lodash/_baseHasIn.js"(exports, module) {
      function baseHasIn(object, key) {
        return object != null && key in Object(object);
      }
      module.exports = baseHasIn;
    }
  });

  // node_modules/lodash/_hasPath.js
  var require_hasPath = __commonJS({
    "node_modules/lodash/_hasPath.js"(exports, module) {
      var castPath = require_castPath();
      var isArguments = require_isArguments();
      var isArray7 = require_isArray();
      var isIndex = require_isIndex();
      var isLength = require_isLength();
      var toKey = require_toKey();
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index2 = -1, length = path.length, result = false;
        while (++index2 < length) {
          var key = toKey(path[index2]);
          if (!(result = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result || ++index2 != length) {
          return result;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray7(object) || isArguments(object));
      }
      module.exports = hasPath;
    }
  });

  // node_modules/lodash/hasIn.js
  var require_hasIn = __commonJS({
    "node_modules/lodash/hasIn.js"(exports, module) {
      var baseHasIn = require_baseHasIn();
      var hasPath = require_hasPath();
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      module.exports = hasIn;
    }
  });

  // node_modules/lodash/_baseMatchesProperty.js
  var require_baseMatchesProperty = __commonJS({
    "node_modules/lodash/_baseMatchesProperty.js"(exports, module) {
      var baseIsEqual = require_baseIsEqual();
      var get9 = require_get2();
      var hasIn = require_hasIn();
      var isKey = require_isKey();
      var isStrictComparable = require_isStrictComparable();
      var matchesStrictComparable = require_matchesStrictComparable();
      var toKey = require_toKey();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get9(object, path);
          return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      module.exports = baseMatchesProperty;
    }
  });

  // node_modules/lodash/_baseProperty.js
  var require_baseProperty = __commonJS({
    "node_modules/lodash/_baseProperty.js"(exports, module) {
      function baseProperty(key) {
        return function(object) {
          return object == null ? void 0 : object[key];
        };
      }
      module.exports = baseProperty;
    }
  });

  // node_modules/lodash/_basePropertyDeep.js
  var require_basePropertyDeep = __commonJS({
    "node_modules/lodash/_basePropertyDeep.js"(exports, module) {
      var baseGet = require_baseGet();
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      module.exports = basePropertyDeep;
    }
  });

  // node_modules/lodash/property.js
  var require_property = __commonJS({
    "node_modules/lodash/property.js"(exports, module) {
      var baseProperty = require_baseProperty();
      var basePropertyDeep = require_basePropertyDeep();
      var isKey = require_isKey();
      var toKey = require_toKey();
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      module.exports = property;
    }
  });

  // node_modules/lodash/_baseIteratee.js
  var require_baseIteratee = __commonJS({
    "node_modules/lodash/_baseIteratee.js"(exports, module) {
      var baseMatches = require_baseMatches();
      var baseMatchesProperty = require_baseMatchesProperty();
      var identity3 = require_identity2();
      var isArray7 = require_isArray();
      var property = require_property();
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity3;
        }
        if (typeof value == "object") {
          return isArray7(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      module.exports = baseIteratee;
    }
  });

  // node_modules/lodash/filter.js
  var require_filter2 = __commonJS({
    "node_modules/lodash/filter.js"(exports, module) {
      var arrayFilter = require_arrayFilter();
      var baseFilter = require_baseFilter();
      var baseIteratee = require_baseIteratee();
      var isArray7 = require_isArray();
      function filter(collection, predicate) {
        var func = isArray7(collection) ? arrayFilter : baseFilter;
        return func(collection, baseIteratee(predicate, 3));
      }
      module.exports = filter;
    }
  });

  // node_modules/lodash/_baseHas.js
  var require_baseHas = __commonJS({
    "node_modules/lodash/_baseHas.js"(exports, module) {
      var objectProto2 = Object.prototype;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      function baseHas(object, key) {
        return object != null && hasOwnProperty.call(object, key);
      }
      module.exports = baseHas;
    }
  });

  // node_modules/lodash/has.js
  var require_has2 = __commonJS({
    "node_modules/lodash/has.js"(exports, module) {
      var baseHas = require_baseHas();
      var hasPath = require_hasPath();
      function has(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      module.exports = has;
    }
  });

  // node_modules/lodash/isEmpty.js
  var require_isEmpty = __commonJS({
    "node_modules/lodash/isEmpty.js"(exports, module) {
      var baseKeys = require_baseKeys();
      var getTag = require_getTag();
      var isArguments = require_isArguments();
      var isArray7 = require_isArray();
      var isArrayLike = require_isArrayLike();
      var isBuffer = require_isBuffer();
      var isPrototype = require_isPrototype();
      var isTypedArray = require_isTypedArray();
      var mapTag = "[object Map]";
      var setTag = "[object Set]";
      var objectProto2 = Object.prototype;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      function isEmpty7(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray7(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      module.exports = isEmpty7;
    }
  });

  // node_modules/lodash/isUndefined.js
  var require_isUndefined = __commonJS({
    "node_modules/lodash/isUndefined.js"(exports, module) {
      function isUndefined5(value) {
        return value === void 0;
      }
      module.exports = isUndefined5;
    }
  });

  // node_modules/lodash/_baseMap.js
  var require_baseMap = __commonJS({
    "node_modules/lodash/_baseMap.js"(exports, module) {
      var baseEach = require_baseEach();
      var isArrayLike = require_isArrayLike();
      function baseMap(collection, iteratee) {
        var index2 = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result[++index2] = iteratee(value, key, collection2);
        });
        return result;
      }
      module.exports = baseMap;
    }
  });

  // node_modules/lodash/map.js
  var require_map2 = __commonJS({
    "node_modules/lodash/map.js"(exports, module) {
      var arrayMap = require_arrayMap();
      var baseIteratee = require_baseIteratee();
      var baseMap = require_baseMap();
      var isArray7 = require_isArray();
      function map(collection, iteratee) {
        var func = isArray7(collection) ? arrayMap : baseMap;
        return func(collection, baseIteratee(iteratee, 3));
      }
      module.exports = map;
    }
  });

  // node_modules/lodash/_arrayReduce.js
  var require_arrayReduce = __commonJS({
    "node_modules/lodash/_arrayReduce.js"(exports, module) {
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index2 = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index2];
        }
        while (++index2 < length) {
          accumulator = iteratee(accumulator, array[index2], index2, array);
        }
        return accumulator;
      }
      module.exports = arrayReduce;
    }
  });

  // node_modules/lodash/_baseReduce.js
  var require_baseReduce = __commonJS({
    "node_modules/lodash/_baseReduce.js"(exports, module) {
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index2, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
        });
        return accumulator;
      }
      module.exports = baseReduce;
    }
  });

  // node_modules/lodash/reduce.js
  var require_reduce2 = __commonJS({
    "node_modules/lodash/reduce.js"(exports, module) {
      var arrayReduce = require_arrayReduce();
      var baseEach = require_baseEach();
      var baseIteratee = require_baseIteratee();
      var baseReduce = require_baseReduce();
      var isArray7 = require_isArray();
      function reduce(collection, iteratee, accumulator) {
        var func = isArray7(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
      }
      module.exports = reduce;
    }
  });

  // node_modules/lodash/isString.js
  var require_isString = __commonJS({
    "node_modules/lodash/isString.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var isArray7 = require_isArray();
      var isObjectLike = require_isObjectLike();
      var stringTag = "[object String]";
      function isString16(value) {
        return typeof value == "string" || !isArray7(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      module.exports = isString16;
    }
  });

  // node_modules/lodash/_asciiSize.js
  var require_asciiSize = __commonJS({
    "node_modules/lodash/_asciiSize.js"(exports, module) {
      var baseProperty = require_baseProperty();
      var asciiSize = baseProperty("length");
      module.exports = asciiSize;
    }
  });

  // node_modules/lodash/_hasUnicode.js
  var require_hasUnicode = __commonJS({
    "node_modules/lodash/_hasUnicode.js"(exports, module) {
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsZWJ = "\\u200d";
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      module.exports = hasUnicode;
    }
  });

  // node_modules/lodash/_unicodeSize.js
  var require_unicodeSize = __commonJS({
    "node_modules/lodash/_unicodeSize.js"(exports, module) {
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsAstral = "[" + rsAstralRange + "]";
      var rsCombo = "[" + rsComboRange + "]";
      var rsFitz = "\\ud83c[\\udffb-\\udfff]";
      var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
      var rsNonAstral = "[^" + rsAstralRange + "]";
      var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
      var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
      var rsZWJ = "\\u200d";
      var reOptMod = rsModifier + "?";
      var rsOptVar = "[" + rsVarRange + "]?";
      var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
      var rsSeq = rsOptVar + reOptMod + rsOptJoin;
      var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      module.exports = unicodeSize;
    }
  });

  // node_modules/lodash/_stringSize.js
  var require_stringSize = __commonJS({
    "node_modules/lodash/_stringSize.js"(exports, module) {
      var asciiSize = require_asciiSize();
      var hasUnicode = require_hasUnicode();
      var unicodeSize = require_unicodeSize();
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      module.exports = stringSize;
    }
  });

  // node_modules/lodash/size.js
  var require_size2 = __commonJS({
    "node_modules/lodash/size.js"(exports, module) {
      var baseKeys = require_baseKeys();
      var getTag = require_getTag();
      var isArrayLike = require_isArrayLike();
      var isString16 = require_isString();
      var stringSize = require_stringSize();
      var mapTag = "[object Map]";
      var setTag = "[object Set]";
      function size2(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString16(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      module.exports = size2;
    }
  });

  // node_modules/lodash/transform.js
  var require_transform2 = __commonJS({
    "node_modules/lodash/transform.js"(exports, module) {
      var arrayEach = require_arrayEach();
      var baseCreate = require_baseCreate();
      var baseForOwn = require_baseForOwn();
      var baseIteratee = require_baseIteratee();
      var getPrototype = require_getPrototype();
      var isArray7 = require_isArray();
      var isBuffer = require_isBuffer();
      var isFunction35 = require_isFunction();
      var isObject12 = require_isObject();
      var isTypedArray = require_isTypedArray();
      function transform(object, iteratee, accumulator) {
        var isArr = isArray7(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
        iteratee = baseIteratee(iteratee, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject12(object)) {
            accumulator = isFunction35(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
          return iteratee(accumulator, value, index2, object2);
        });
        return accumulator;
      }
      module.exports = transform;
    }
  });

  // node_modules/lodash/_isFlattenable.js
  var require_isFlattenable = __commonJS({
    "node_modules/lodash/_isFlattenable.js"(exports, module) {
      var Symbol2 = require_Symbol();
      var isArguments = require_isArguments();
      var isArray7 = require_isArray();
      var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
      function isFlattenable(value) {
        return isArray7(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      module.exports = isFlattenable;
    }
  });

  // node_modules/lodash/_baseFlatten.js
  var require_baseFlatten = __commonJS({
    "node_modules/lodash/_baseFlatten.js"(exports, module) {
      var arrayPush = require_arrayPush();
      var isFlattenable = require_isFlattenable();
      function baseFlatten(array, depth, predicate, isStrict, result) {
        var index2 = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result || (result = []);
        while (++index2 < length) {
          var value = array[index2];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
              arrayPush(result, value);
            }
          } else if (!isStrict) {
            result[result.length] = value;
          }
        }
        return result;
      }
      module.exports = baseFlatten;
    }
  });

  // node_modules/lodash/_apply.js
  var require_apply = __commonJS({
    "node_modules/lodash/_apply.js"(exports, module) {
      function apply3(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      module.exports = apply3;
    }
  });

  // node_modules/lodash/_overRest.js
  var require_overRest = __commonJS({
    "node_modules/lodash/_overRest.js"(exports, module) {
      var apply3 = require_apply();
      var nativeMax = Math.max;
      function overRest(func, start, transform) {
        start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array(length);
          while (++index2 < length) {
            array[index2] = args[start + index2];
          }
          index2 = -1;
          var otherArgs = Array(start + 1);
          while (++index2 < start) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start] = transform(array);
          return apply3(func, this, otherArgs);
        };
      }
      module.exports = overRest;
    }
  });

  // node_modules/lodash/_baseSetToString.js
  var require_baseSetToString = __commonJS({
    "node_modules/lodash/_baseSetToString.js"(exports, module) {
      var constant = require_constant();
      var defineProperty = require_defineProperty();
      var identity3 = require_identity2();
      var baseSetToString = !defineProperty ? identity3 : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      module.exports = baseSetToString;
    }
  });

  // node_modules/lodash/_shortOut.js
  var require_shortOut = __commonJS({
    "node_modules/lodash/_shortOut.js"(exports, module) {
      var HOT_COUNT = 800;
      var HOT_SPAN = 16;
      var nativeNow = Date.now;
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      module.exports = shortOut;
    }
  });

  // node_modules/lodash/_setToString.js
  var require_setToString = __commonJS({
    "node_modules/lodash/_setToString.js"(exports, module) {
      var baseSetToString = require_baseSetToString();
      var shortOut = require_shortOut();
      var setToString = shortOut(baseSetToString);
      module.exports = setToString;
    }
  });

  // node_modules/lodash/_baseRest.js
  var require_baseRest = __commonJS({
    "node_modules/lodash/_baseRest.js"(exports, module) {
      var identity3 = require_identity2();
      var overRest = require_overRest();
      var setToString = require_setToString();
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity3), func + "");
      }
      module.exports = baseRest;
    }
  });

  // node_modules/lodash/_baseFindIndex.js
  var require_baseFindIndex = __commonJS({
    "node_modules/lodash/_baseFindIndex.js"(exports, module) {
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index2-- : ++index2 < length) {
          if (predicate(array[index2], index2, array)) {
            return index2;
          }
        }
        return -1;
      }
      module.exports = baseFindIndex;
    }
  });

  // node_modules/lodash/_baseIsNaN.js
  var require_baseIsNaN = __commonJS({
    "node_modules/lodash/_baseIsNaN.js"(exports, module) {
      function baseIsNaN(value) {
        return value !== value;
      }
      module.exports = baseIsNaN;
    }
  });

  // node_modules/lodash/_strictIndexOf.js
  var require_strictIndexOf = __commonJS({
    "node_modules/lodash/_strictIndexOf.js"(exports, module) {
      function strictIndexOf(array, value, fromIndex) {
        var index2 = fromIndex - 1, length = array.length;
        while (++index2 < length) {
          if (array[index2] === value) {
            return index2;
          }
        }
        return -1;
      }
      module.exports = strictIndexOf;
    }
  });

  // node_modules/lodash/_baseIndexOf.js
  var require_baseIndexOf = __commonJS({
    "node_modules/lodash/_baseIndexOf.js"(exports, module) {
      var baseFindIndex = require_baseFindIndex();
      var baseIsNaN = require_baseIsNaN();
      var strictIndexOf = require_strictIndexOf();
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      module.exports = baseIndexOf;
    }
  });

  // node_modules/lodash/_arrayIncludes.js
  var require_arrayIncludes = __commonJS({
    "node_modules/lodash/_arrayIncludes.js"(exports, module) {
      var baseIndexOf = require_baseIndexOf();
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      module.exports = arrayIncludes;
    }
  });

  // node_modules/lodash/_arrayIncludesWith.js
  var require_arrayIncludesWith = __commonJS({
    "node_modules/lodash/_arrayIncludesWith.js"(exports, module) {
      function arrayIncludesWith(array, value, comparator) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (comparator(value, array[index2])) {
            return true;
          }
        }
        return false;
      }
      module.exports = arrayIncludesWith;
    }
  });

  // node_modules/lodash/noop.js
  var require_noop2 = __commonJS({
    "node_modules/lodash/noop.js"(exports, module) {
      function noop3() {
      }
      module.exports = noop3;
    }
  });

  // node_modules/lodash/_createSet.js
  var require_createSet = __commonJS({
    "node_modules/lodash/_createSet.js"(exports, module) {
      var Set2 = require_Set();
      var noop3 = require_noop2();
      var setToArray = require_setToArray();
      var INFINITY = 1 / 0;
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop3 : function(values2) {
        return new Set2(values2);
      };
      module.exports = createSet;
    }
  });

  // node_modules/lodash/_baseUniq.js
  var require_baseUniq = __commonJS({
    "node_modules/lodash/_baseUniq.js"(exports, module) {
      var SetCache = require_SetCache();
      var arrayIncludes = require_arrayIncludes();
      var arrayIncludesWith = require_arrayIncludesWith();
      var cacheHas = require_cacheHas();
      var createSet = require_createSet();
      var setToArray = require_setToArray();
      var LARGE_ARRAY_SIZE = 200;
      function baseUniq(array, iteratee, comparator) {
        var index2 = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
        if (comparator) {
          isCommon = false;
          includes = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set6 = iteratee ? null : createSet(array);
          if (set6) {
            return setToArray(set6);
          }
          isCommon = false;
          includes = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee ? [] : result;
        }
        outer:
          while (++index2 < length) {
            var value = array[index2], computed = iteratee ? iteratee(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            } else if (!includes(seen, computed, comparator)) {
              if (seen !== result) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
        return result;
      }
      module.exports = baseUniq;
    }
  });

  // node_modules/lodash/isArrayLikeObject.js
  var require_isArrayLikeObject = __commonJS({
    "node_modules/lodash/isArrayLikeObject.js"(exports, module) {
      var isArrayLike = require_isArrayLike();
      var isObjectLike = require_isObjectLike();
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      module.exports = isArrayLikeObject;
    }
  });

  // node_modules/lodash/union.js
  var require_union2 = __commonJS({
    "node_modules/lodash/union.js"(exports, module) {
      var baseFlatten = require_baseFlatten();
      var baseRest = require_baseRest();
      var baseUniq = require_baseUniq();
      var isArrayLikeObject = require_isArrayLikeObject();
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      module.exports = union;
    }
  });

  // node_modules/lodash/_baseValues.js
  var require_baseValues = __commonJS({
    "node_modules/lodash/_baseValues.js"(exports, module) {
      var arrayMap = require_arrayMap();
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      module.exports = baseValues;
    }
  });

  // node_modules/lodash/values.js
  var require_values2 = __commonJS({
    "node_modules/lodash/values.js"(exports, module) {
      var baseValues = require_baseValues();
      var keys = require_keys2();
      function values2(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      module.exports = values2;
    }
  });

  // node_modules/graphlib/lib/lodash.js
  var require_lodash2 = __commonJS({
    "node_modules/graphlib/lib/lodash.js"(exports, module) {
      var lodash;
      if (typeof __require === "function") {
        try {
          lodash = {
            clone: require_clone2(),
            constant: require_constant(),
            each: require_each2(),
            filter: require_filter2(),
            has: require_has2(),
            isArray: require_isArray(),
            isEmpty: require_isEmpty(),
            isFunction: require_isFunction(),
            isUndefined: require_isUndefined(),
            keys: require_keys2(),
            map: require_map2(),
            reduce: require_reduce2(),
            size: require_size2(),
            transform: require_transform2(),
            union: require_union2(),
            values: require_values2()
          };
        } catch (e) {
        }
      }
      if (!lodash) {
        lodash = window._;
      }
      module.exports = lodash;
    }
  });

  // node_modules/graphlib/lib/graph.js
  var require_graph = __commonJS({
    "node_modules/graphlib/lib/graph.js"(exports, module) {
      "use strict";
      var _2 = require_lodash2();
      module.exports = Graph4;
      var DEFAULT_EDGE_NAME = "\0";
      var GRAPH_NODE = "\0";
      var EDGE_KEY_DELIM = "";
      function Graph4(opts) {
        this._isDirected = _2.has(opts, "directed") ? opts.directed : true;
        this._isMultigraph = _2.has(opts, "multigraph") ? opts.multigraph : false;
        this._isCompound = _2.has(opts, "compound") ? opts.compound : false;
        this._label = void 0;
        this._defaultNodeLabelFn = _2.constant(void 0);
        this._defaultEdgeLabelFn = _2.constant(void 0);
        this._nodes = {};
        if (this._isCompound) {
          this._parent = {};
          this._children = {};
          this._children[GRAPH_NODE] = {};
        }
        this._in = {};
        this._preds = {};
        this._out = {};
        this._sucs = {};
        this._edgeObjs = {};
        this._edgeLabels = {};
      }
      Graph4.prototype._nodeCount = 0;
      Graph4.prototype._edgeCount = 0;
      Graph4.prototype.isDirected = function() {
        return this._isDirected;
      };
      Graph4.prototype.isMultigraph = function() {
        return this._isMultigraph;
      };
      Graph4.prototype.isCompound = function() {
        return this._isCompound;
      };
      Graph4.prototype.setGraph = function(label) {
        this._label = label;
        return this;
      };
      Graph4.prototype.graph = function() {
        return this._label;
      };
      Graph4.prototype.setDefaultNodeLabel = function(newDefault) {
        if (!_2.isFunction(newDefault)) {
          newDefault = _2.constant(newDefault);
        }
        this._defaultNodeLabelFn = newDefault;
        return this;
      };
      Graph4.prototype.nodeCount = function() {
        return this._nodeCount;
      };
      Graph4.prototype.nodes = function() {
        return _2.keys(this._nodes);
      };
      Graph4.prototype.sources = function() {
        var self2 = this;
        return _2.filter(this.nodes(), function(v) {
          return _2.isEmpty(self2._in[v]);
        });
      };
      Graph4.prototype.sinks = function() {
        var self2 = this;
        return _2.filter(this.nodes(), function(v) {
          return _2.isEmpty(self2._out[v]);
        });
      };
      Graph4.prototype.setNodes = function(vs, value) {
        var args = arguments;
        var self2 = this;
        _2.each(vs, function(v) {
          if (args.length > 1) {
            self2.setNode(v, value);
          } else {
            self2.setNode(v);
          }
        });
        return this;
      };
      Graph4.prototype.setNode = function(v, value) {
        if (_2.has(this._nodes, v)) {
          if (arguments.length > 1) {
            this._nodes[v] = value;
          }
          return this;
        }
        this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);
        if (this._isCompound) {
          this._parent[v] = GRAPH_NODE;
          this._children[v] = {};
          this._children[GRAPH_NODE][v] = true;
        }
        this._in[v] = {};
        this._preds[v] = {};
        this._out[v] = {};
        this._sucs[v] = {};
        ++this._nodeCount;
        return this;
      };
      Graph4.prototype.node = function(v) {
        return this._nodes[v];
      };
      Graph4.prototype.hasNode = function(v) {
        return _2.has(this._nodes, v);
      };
      Graph4.prototype.removeNode = function(v) {
        var self2 = this;
        if (_2.has(this._nodes, v)) {
          var removeEdge = function(e) {
            self2.removeEdge(self2._edgeObjs[e]);
          };
          delete this._nodes[v];
          if (this._isCompound) {
            this._removeFromParentsChildList(v);
            delete this._parent[v];
            _2.each(this.children(v), function(child) {
              self2.setParent(child);
            });
            delete this._children[v];
          }
          _2.each(_2.keys(this._in[v]), removeEdge);
          delete this._in[v];
          delete this._preds[v];
          _2.each(_2.keys(this._out[v]), removeEdge);
          delete this._out[v];
          delete this._sucs[v];
          --this._nodeCount;
        }
        return this;
      };
      Graph4.prototype.setParent = function(v, parent) {
        if (!this._isCompound) {
          throw new Error("Cannot set parent in a non-compound graph");
        }
        if (_2.isUndefined(parent)) {
          parent = GRAPH_NODE;
        } else {
          parent += "";
          for (var ancestor = parent; !_2.isUndefined(ancestor); ancestor = this.parent(ancestor)) {
            if (ancestor === v) {
              throw new Error("Setting " + parent + " as parent of " + v + " would create a cycle");
            }
          }
          this.setNode(parent);
        }
        this.setNode(v);
        this._removeFromParentsChildList(v);
        this._parent[v] = parent;
        this._children[parent][v] = true;
        return this;
      };
      Graph4.prototype._removeFromParentsChildList = function(v) {
        delete this._children[this._parent[v]][v];
      };
      Graph4.prototype.parent = function(v) {
        if (this._isCompound) {
          var parent = this._parent[v];
          if (parent !== GRAPH_NODE) {
            return parent;
          }
        }
      };
      Graph4.prototype.children = function(v) {
        if (_2.isUndefined(v)) {
          v = GRAPH_NODE;
        }
        if (this._isCompound) {
          var children = this._children[v];
          if (children) {
            return _2.keys(children);
          }
        } else if (v === GRAPH_NODE) {
          return this.nodes();
        } else if (this.hasNode(v)) {
          return [];
        }
      };
      Graph4.prototype.predecessors = function(v) {
        var predsV = this._preds[v];
        if (predsV) {
          return _2.keys(predsV);
        }
      };
      Graph4.prototype.successors = function(v) {
        var sucsV = this._sucs[v];
        if (sucsV) {
          return _2.keys(sucsV);
        }
      };
      Graph4.prototype.neighbors = function(v) {
        var preds = this.predecessors(v);
        if (preds) {
          return _2.union(preds, this.successors(v));
        }
      };
      Graph4.prototype.isLeaf = function(v) {
        var neighbors;
        if (this.isDirected()) {
          neighbors = this.successors(v);
        } else {
          neighbors = this.neighbors(v);
        }
        return neighbors.length === 0;
      };
      Graph4.prototype.filterNodes = function(filter) {
        var copy = new this.constructor({
          directed: this._isDirected,
          multigraph: this._isMultigraph,
          compound: this._isCompound
        });
        copy.setGraph(this.graph());
        var self2 = this;
        _2.each(this._nodes, function(value, v) {
          if (filter(v)) {
            copy.setNode(v, value);
          }
        });
        _2.each(this._edgeObjs, function(e) {
          if (copy.hasNode(e.v) && copy.hasNode(e.w)) {
            copy.setEdge(e, self2.edge(e));
          }
        });
        var parents = {};
        function findParent(v) {
          var parent = self2.parent(v);
          if (parent === void 0 || copy.hasNode(parent)) {
            parents[v] = parent;
            return parent;
          } else if (parent in parents) {
            return parents[parent];
          } else {
            return findParent(parent);
          }
        }
        if (this._isCompound) {
          _2.each(copy.nodes(), function(v) {
            copy.setParent(v, findParent(v));
          });
        }
        return copy;
      };
      Graph4.prototype.setDefaultEdgeLabel = function(newDefault) {
        if (!_2.isFunction(newDefault)) {
          newDefault = _2.constant(newDefault);
        }
        this._defaultEdgeLabelFn = newDefault;
        return this;
      };
      Graph4.prototype.edgeCount = function() {
        return this._edgeCount;
      };
      Graph4.prototype.edges = function() {
        return _2.values(this._edgeObjs);
      };
      Graph4.prototype.setPath = function(vs, value) {
        var self2 = this;
        var args = arguments;
        _2.reduce(vs, function(v, w) {
          if (args.length > 1) {
            self2.setEdge(v, w, value);
          } else {
            self2.setEdge(v, w);
          }
          return w;
        });
        return this;
      };
      Graph4.prototype.setEdge = function() {
        var v, w, name, value;
        var valueSpecified = false;
        var arg0 = arguments[0];
        if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
          v = arg0.v;
          w = arg0.w;
          name = arg0.name;
          if (arguments.length === 2) {
            value = arguments[1];
            valueSpecified = true;
          }
        } else {
          v = arg0;
          w = arguments[1];
          name = arguments[3];
          if (arguments.length > 2) {
            value = arguments[2];
            valueSpecified = true;
          }
        }
        v = "" + v;
        w = "" + w;
        if (!_2.isUndefined(name)) {
          name = "" + name;
        }
        var e = edgeArgsToId(this._isDirected, v, w, name);
        if (_2.has(this._edgeLabels, e)) {
          if (valueSpecified) {
            this._edgeLabels[e] = value;
          }
          return this;
        }
        if (!_2.isUndefined(name) && !this._isMultigraph) {
          throw new Error("Cannot set a named edge when isMultigraph = false");
        }
        this.setNode(v);
        this.setNode(w);
        this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);
        var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);
        v = edgeObj.v;
        w = edgeObj.w;
        Object.freeze(edgeObj);
        this._edgeObjs[e] = edgeObj;
        incrementOrInitEntry(this._preds[w], v);
        incrementOrInitEntry(this._sucs[v], w);
        this._in[w][e] = edgeObj;
        this._out[v][e] = edgeObj;
        this._edgeCount++;
        return this;
      };
      Graph4.prototype.edge = function(v, w, name) {
        var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
        return this._edgeLabels[e];
      };
      Graph4.prototype.hasEdge = function(v, w, name) {
        var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
        return _2.has(this._edgeLabels, e);
      };
      Graph4.prototype.removeEdge = function(v, w, name) {
        var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
        var edge = this._edgeObjs[e];
        if (edge) {
          v = edge.v;
          w = edge.w;
          delete this._edgeLabels[e];
          delete this._edgeObjs[e];
          decrementOrRemoveEntry(this._preds[w], v);
          decrementOrRemoveEntry(this._sucs[v], w);
          delete this._in[w][e];
          delete this._out[v][e];
          this._edgeCount--;
        }
        return this;
      };
      Graph4.prototype.inEdges = function(v, u) {
        var inV = this._in[v];
        if (inV) {
          var edges = _2.values(inV);
          if (!u) {
            return edges;
          }
          return _2.filter(edges, function(edge) {
            return edge.v === u;
          });
        }
      };
      Graph4.prototype.outEdges = function(v, w) {
        var outV = this._out[v];
        if (outV) {
          var edges = _2.values(outV);
          if (!w) {
            return edges;
          }
          return _2.filter(edges, function(edge) {
            return edge.w === w;
          });
        }
      };
      Graph4.prototype.nodeEdges = function(v, w) {
        var inEdges = this.inEdges(v, w);
        if (inEdges) {
          return inEdges.concat(this.outEdges(v, w));
        }
      };
      function incrementOrInitEntry(map, k) {
        if (map[k]) {
          map[k]++;
        } else {
          map[k] = 1;
        }
      }
      function decrementOrRemoveEntry(map, k) {
        if (!--map[k]) {
          delete map[k];
        }
      }
      function edgeArgsToId(isDirected, v_, w_, name) {
        var v = "" + v_;
        var w = "" + w_;
        if (!isDirected && v > w) {
          var tmp2 = v;
          v = w;
          w = tmp2;
        }
        return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM + (_2.isUndefined(name) ? DEFAULT_EDGE_NAME : name);
      }
      function edgeArgsToObj(isDirected, v_, w_, name) {
        var v = "" + v_;
        var w = "" + w_;
        if (!isDirected && v > w) {
          var tmp2 = v;
          v = w;
          w = tmp2;
        }
        var edgeObj = { v, w };
        if (name) {
          edgeObj.name = name;
        }
        return edgeObj;
      }
      function edgeObjToId(isDirected, edgeObj) {
        return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
      }
    }
  });

  // node_modules/graphlib/lib/version.js
  var require_version = __commonJS({
    "node_modules/graphlib/lib/version.js"(exports, module) {
      module.exports = "2.1.8";
    }
  });

  // node_modules/graphlib/lib/index.js
  var require_lib6 = __commonJS({
    "node_modules/graphlib/lib/index.js"(exports, module) {
      module.exports = {
        Graph: require_graph(),
        version: require_version()
      };
    }
  });

  // node_modules/graphlib/lib/json.js
  var require_json = __commonJS({
    "node_modules/graphlib/lib/json.js"(exports, module) {
      var _2 = require_lodash2();
      var Graph4 = require_graph();
      module.exports = {
        write,
        read
      };
      function write(g) {
        var json = {
          options: {
            directed: g.isDirected(),
            multigraph: g.isMultigraph(),
            compound: g.isCompound()
          },
          nodes: writeNodes(g),
          edges: writeEdges(g)
        };
        if (!_2.isUndefined(g.graph())) {
          json.value = _2.clone(g.graph());
        }
        return json;
      }
      function writeNodes(g) {
        return _2.map(g.nodes(), function(v) {
          var nodeValue = g.node(v);
          var parent = g.parent(v);
          var node = { v };
          if (!_2.isUndefined(nodeValue)) {
            node.value = nodeValue;
          }
          if (!_2.isUndefined(parent)) {
            node.parent = parent;
          }
          return node;
        });
      }
      function writeEdges(g) {
        return _2.map(g.edges(), function(e) {
          var edgeValue = g.edge(e);
          var edge = { v: e.v, w: e.w };
          if (!_2.isUndefined(e.name)) {
            edge.name = e.name;
          }
          if (!_2.isUndefined(edgeValue)) {
            edge.value = edgeValue;
          }
          return edge;
        });
      }
      function read(json) {
        var g = new Graph4(json.options).setGraph(json.value);
        _2.each(json.nodes, function(entry) {
          g.setNode(entry.v, entry.value);
          if (entry.parent) {
            g.setParent(entry.v, entry.parent);
          }
        });
        _2.each(json.edges, function(entry) {
          g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
        });
        return g;
      }
    }
  });

  // node_modules/graphlib/lib/alg/components.js
  var require_components = __commonJS({
    "node_modules/graphlib/lib/alg/components.js"(exports, module) {
      var _2 = require_lodash2();
      module.exports = components;
      function components(g) {
        var visited = {};
        var cmpts = [];
        var cmpt;
        function dfs4(v) {
          if (_2.has(visited, v)) return;
          visited[v] = true;
          cmpt.push(v);
          _2.each(g.successors(v), dfs4);
          _2.each(g.predecessors(v), dfs4);
        }
        _2.each(g.nodes(), function(v) {
          cmpt = [];
          dfs4(v);
          if (cmpt.length) {
            cmpts.push(cmpt);
          }
        });
        return cmpts;
      }
    }
  });

  // node_modules/graphlib/lib/data/priority-queue.js
  var require_priority_queue = __commonJS({
    "node_modules/graphlib/lib/data/priority-queue.js"(exports, module) {
      var _2 = require_lodash2();
      module.exports = PriorityQueue;
      function PriorityQueue() {
        this._arr = [];
        this._keyIndices = {};
      }
      PriorityQueue.prototype.size = function() {
        return this._arr.length;
      };
      PriorityQueue.prototype.keys = function() {
        return this._arr.map(function(x3) {
          return x3.key;
        });
      };
      PriorityQueue.prototype.has = function(key) {
        return _2.has(this._keyIndices, key);
      };
      PriorityQueue.prototype.priority = function(key) {
        var index2 = this._keyIndices[key];
        if (index2 !== void 0) {
          return this._arr[index2].priority;
        }
      };
      PriorityQueue.prototype.min = function() {
        if (this.size() === 0) {
          throw new Error("Queue underflow");
        }
        return this._arr[0].key;
      };
      PriorityQueue.prototype.add = function(key, priority) {
        var keyIndices = this._keyIndices;
        key = String(key);
        if (!_2.has(keyIndices, key)) {
          var arr = this._arr;
          var index2 = arr.length;
          keyIndices[key] = index2;
          arr.push({ key, priority });
          this._decrease(index2);
          return true;
        }
        return false;
      };
      PriorityQueue.prototype.removeMin = function() {
        this._swap(0, this._arr.length - 1);
        var min4 = this._arr.pop();
        delete this._keyIndices[min4.key];
        this._heapify(0);
        return min4.key;
      };
      PriorityQueue.prototype.decrease = function(key, priority) {
        var index2 = this._keyIndices[key];
        if (priority > this._arr[index2].priority) {
          throw new Error("New priority is greater than current priority. Key: " + key + " Old: " + this._arr[index2].priority + " New: " + priority);
        }
        this._arr[index2].priority = priority;
        this._decrease(index2);
      };
      PriorityQueue.prototype._heapify = function(i) {
        var arr = this._arr;
        var l = 2 * i;
        var r = l + 1;
        var largest = i;
        if (l < arr.length) {
          largest = arr[l].priority < arr[largest].priority ? l : largest;
          if (r < arr.length) {
            largest = arr[r].priority < arr[largest].priority ? r : largest;
          }
          if (largest !== i) {
            this._swap(i, largest);
            this._heapify(largest);
          }
        }
      };
      PriorityQueue.prototype._decrease = function(index2) {
        var arr = this._arr;
        var priority = arr[index2].priority;
        var parent;
        while (index2 !== 0) {
          parent = index2 >> 1;
          if (arr[parent].priority < priority) {
            break;
          }
          this._swap(index2, parent);
          index2 = parent;
        }
      };
      PriorityQueue.prototype._swap = function(i, j) {
        var arr = this._arr;
        var keyIndices = this._keyIndices;
        var origArrI = arr[i];
        var origArrJ = arr[j];
        arr[i] = origArrJ;
        arr[j] = origArrI;
        keyIndices[origArrJ.key] = i;
        keyIndices[origArrI.key] = j;
      };
    }
  });

  // node_modules/graphlib/lib/alg/dijkstra.js
  var require_dijkstra = __commonJS({
    "node_modules/graphlib/lib/alg/dijkstra.js"(exports, module) {
      var _2 = require_lodash2();
      var PriorityQueue = require_priority_queue();
      module.exports = dijkstra3;
      var DEFAULT_WEIGHT_FUNC = _2.constant(1);
      function dijkstra3(g, source, weightFn, edgeFn) {
        return runDijkstra(
          g,
          String(source),
          weightFn || DEFAULT_WEIGHT_FUNC,
          edgeFn || function(v) {
            return g.outEdges(v);
          }
        );
      }
      function runDijkstra(g, source, weightFn, edgeFn) {
        var results = {};
        var pq = new PriorityQueue();
        var v, vEntry;
        var updateNeighbors = function(edge) {
          var w = edge.v !== v ? edge.v : edge.w;
          var wEntry = results[w];
          var weight = weightFn(edge);
          var distance6 = vEntry.distance + weight;
          if (weight < 0) {
            throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
          }
          if (distance6 < wEntry.distance) {
            wEntry.distance = distance6;
            wEntry.predecessor = v;
            pq.decrease(w, distance6);
          }
        };
        g.nodes().forEach(function(v2) {
          var distance6 = v2 === source ? 0 : Number.POSITIVE_INFINITY;
          results[v2] = { distance: distance6 };
          pq.add(v2, distance6);
        });
        while (pq.size() > 0) {
          v = pq.removeMin();
          vEntry = results[v];
          if (vEntry.distance === Number.POSITIVE_INFINITY) {
            break;
          }
          edgeFn(v).forEach(updateNeighbors);
        }
        return results;
      }
    }
  });

  // node_modules/graphlib/lib/alg/dijkstra-all.js
  var require_dijkstra_all = __commonJS({
    "node_modules/graphlib/lib/alg/dijkstra-all.js"(exports, module) {
      var dijkstra3 = require_dijkstra();
      var _2 = require_lodash2();
      module.exports = dijkstraAll;
      function dijkstraAll(g, weightFunc, edgeFunc) {
        return _2.transform(g.nodes(), function(acc, v) {
          acc[v] = dijkstra3(g, v, weightFunc, edgeFunc);
        }, {});
      }
    }
  });

  // node_modules/graphlib/lib/alg/tarjan.js
  var require_tarjan = __commonJS({
    "node_modules/graphlib/lib/alg/tarjan.js"(exports, module) {
      var _2 = require_lodash2();
      module.exports = tarjan;
      function tarjan(g) {
        var index2 = 0;
        var stack = [];
        var visited = {};
        var results = [];
        function dfs4(v) {
          var entry = visited[v] = {
            onStack: true,
            lowlink: index2,
            index: index2++
          };
          stack.push(v);
          g.successors(v).forEach(function(w2) {
            if (!_2.has(visited, w2)) {
              dfs4(w2);
              entry.lowlink = Math.min(entry.lowlink, visited[w2].lowlink);
            } else if (visited[w2].onStack) {
              entry.lowlink = Math.min(entry.lowlink, visited[w2].index);
            }
          });
          if (entry.lowlink === entry.index) {
            var cmpt = [];
            var w;
            do {
              w = stack.pop();
              visited[w].onStack = false;
              cmpt.push(w);
            } while (v !== w);
            results.push(cmpt);
          }
        }
        g.nodes().forEach(function(v) {
          if (!_2.has(visited, v)) {
            dfs4(v);
          }
        });
        return results;
      }
    }
  });

  // node_modules/graphlib/lib/alg/find-cycles.js
  var require_find_cycles = __commonJS({
    "node_modules/graphlib/lib/alg/find-cycles.js"(exports, module) {
      var _2 = require_lodash2();
      var tarjan = require_tarjan();
      module.exports = findCycles;
      function findCycles(g) {
        return _2.filter(tarjan(g), function(cmpt) {
          return cmpt.length > 1 || cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]);
        });
      }
    }
  });

  // node_modules/graphlib/lib/alg/floyd-warshall.js
  var require_floyd_warshall = __commonJS({
    "node_modules/graphlib/lib/alg/floyd-warshall.js"(exports, module) {
      var _2 = require_lodash2();
      module.exports = floydWarshall2;
      var DEFAULT_WEIGHT_FUNC = _2.constant(1);
      function floydWarshall2(g, weightFn, edgeFn) {
        return runFloydWarshall(
          g,
          weightFn || DEFAULT_WEIGHT_FUNC,
          edgeFn || function(v) {
            return g.outEdges(v);
          }
        );
      }
      function runFloydWarshall(g, weightFn, edgeFn) {
        var results = {};
        var nodes = g.nodes();
        nodes.forEach(function(v) {
          results[v] = {};
          results[v][v] = { distance: 0 };
          nodes.forEach(function(w) {
            if (v !== w) {
              results[v][w] = { distance: Number.POSITIVE_INFINITY };
            }
          });
          edgeFn(v).forEach(function(edge) {
            var w = edge.v === v ? edge.w : edge.v;
            var d2 = weightFn(edge);
            results[v][w] = { distance: d2, predecessor: v };
          });
        });
        nodes.forEach(function(k) {
          var rowK = results[k];
          nodes.forEach(function(i) {
            var rowI = results[i];
            nodes.forEach(function(j) {
              var ik = rowI[k];
              var kj = rowK[j];
              var ij = rowI[j];
              var altDistance = ik.distance + kj.distance;
              if (altDistance < ij.distance) {
                ij.distance = altDistance;
                ij.predecessor = kj.predecessor;
              }
            });
          });
        });
        return results;
      }
    }
  });

  // node_modules/graphlib/lib/alg/topsort.js
  var require_topsort = __commonJS({
    "node_modules/graphlib/lib/alg/topsort.js"(exports, module) {
      var _2 = require_lodash2();
      module.exports = topsort;
      topsort.CycleException = CycleException;
      function topsort(g) {
        var visited = {};
        var stack = {};
        var results = [];
        function visit(node) {
          if (_2.has(stack, node)) {
            throw new CycleException();
          }
          if (!_2.has(visited, node)) {
            stack[node] = true;
            visited[node] = true;
            _2.each(g.predecessors(node), visit);
            delete stack[node];
            results.push(node);
          }
        }
        _2.each(g.sinks(), visit);
        if (_2.size(visited) !== g.nodeCount()) {
          throw new CycleException();
        }
        return results;
      }
      function CycleException() {
      }
      CycleException.prototype = new Error();
    }
  });

  // node_modules/graphlib/lib/alg/is-acyclic.js
  var require_is_acyclic = __commonJS({
    "node_modules/graphlib/lib/alg/is-acyclic.js"(exports, module) {
      var topsort = require_topsort();
      module.exports = isAcyclic;
      function isAcyclic(g) {
        try {
          topsort(g);
        } catch (e) {
          if (e instanceof topsort.CycleException) {
            return false;
          }
          throw e;
        }
        return true;
      }
    }
  });

  // node_modules/graphlib/lib/alg/dfs.js
  var require_dfs = __commonJS({
    "node_modules/graphlib/lib/alg/dfs.js"(exports, module) {
      var _2 = require_lodash2();
      module.exports = dfs4;
      function dfs4(g, vs, order2) {
        if (!_2.isArray(vs)) {
          vs = [vs];
        }
        var navigation = (g.isDirected() ? g.successors : g.neighbors).bind(g);
        var acc = [];
        var visited = {};
        _2.each(vs, function(v) {
          if (!g.hasNode(v)) {
            throw new Error("Graph does not have node: " + v);
          }
          doDfs(g, v, order2 === "post", visited, navigation, acc);
        });
        return acc;
      }
      function doDfs(g, v, postorder, visited, navigation, acc) {
        if (!_2.has(visited, v)) {
          visited[v] = true;
          if (!postorder) {
            acc.push(v);
          }
          _2.each(navigation(v), function(w) {
            doDfs(g, w, postorder, visited, navigation, acc);
          });
          if (postorder) {
            acc.push(v);
          }
        }
      }
    }
  });

  // node_modules/graphlib/lib/alg/postorder.js
  var require_postorder = __commonJS({
    "node_modules/graphlib/lib/alg/postorder.js"(exports, module) {
      var dfs4 = require_dfs();
      module.exports = postorder;
      function postorder(g, vs) {
        return dfs4(g, vs, "post");
      }
    }
  });

  // node_modules/graphlib/lib/alg/preorder.js
  var require_preorder = __commonJS({
    "node_modules/graphlib/lib/alg/preorder.js"(exports, module) {
      var dfs4 = require_dfs();
      module.exports = preorder;
      function preorder(g, vs) {
        return dfs4(g, vs, "pre");
      }
    }
  });

  // node_modules/graphlib/lib/alg/prim.js
  var require_prim = __commonJS({
    "node_modules/graphlib/lib/alg/prim.js"(exports, module) {
      var _2 = require_lodash2();
      var Graph4 = require_graph();
      var PriorityQueue = require_priority_queue();
      module.exports = prim;
      function prim(g, weightFunc) {
        var result = new Graph4();
        var parents = {};
        var pq = new PriorityQueue();
        var v;
        function updateNeighbors(edge) {
          var w = edge.v === v ? edge.w : edge.v;
          var pri = pq.priority(w);
          if (pri !== void 0) {
            var edgeWeight = weightFunc(edge);
            if (edgeWeight < pri) {
              parents[w] = v;
              pq.decrease(w, edgeWeight);
            }
          }
        }
        if (g.nodeCount() === 0) {
          return result;
        }
        _2.each(g.nodes(), function(v2) {
          pq.add(v2, Number.POSITIVE_INFINITY);
          result.setNode(v2);
        });
        pq.decrease(g.nodes()[0], 0);
        var init = false;
        while (pq.size() > 0) {
          v = pq.removeMin();
          if (_2.has(parents, v)) {
            result.setEdge(v, parents[v]);
          } else if (init) {
            throw new Error("Input graph is not connected: " + g);
          } else {
            init = true;
          }
          g.nodeEdges(v).forEach(updateNeighbors);
        }
        return result;
      }
    }
  });

  // node_modules/graphlib/lib/alg/index.js
  var require_alg = __commonJS({
    "node_modules/graphlib/lib/alg/index.js"(exports, module) {
      module.exports = {
        components: require_components(),
        dijkstra: require_dijkstra(),
        dijkstraAll: require_dijkstra_all(),
        findCycles: require_find_cycles(),
        floydWarshall: require_floyd_warshall(),
        isAcyclic: require_is_acyclic(),
        postorder: require_postorder(),
        preorder: require_preorder(),
        prim: require_prim(),
        tarjan: require_tarjan(),
        topsort: require_topsort()
      };
    }
  });

  // node_modules/graphlib/index.js
  var require_graphlib = __commonJS({
    "node_modules/graphlib/index.js"(exports, module) {
      var lib = require_lib6();
      module.exports = {
        Graph: lib.Graph,
        json: require_json(),
        alg: require_alg(),
        version: lib.version
      };
    }
  });

  // node_modules/dagre/lib/graphlib.js
  var require_graphlib2 = __commonJS({
    "node_modules/dagre/lib/graphlib.js"(exports, module) {
      var graphlib2;
      if (typeof __require === "function") {
        try {
          graphlib2 = require_graphlib();
        } catch (e) {
        }
      }
      if (!graphlib2) {
        graphlib2 = window.graphlib;
      }
      module.exports = graphlib2;
    }
  });

  // node_modules/lodash/cloneDeep.js
  var require_cloneDeep = __commonJS({
    "node_modules/lodash/cloneDeep.js"(exports, module) {
      var baseClone = require_baseClone();
      var CLONE_DEEP_FLAG = 1;
      var CLONE_SYMBOLS_FLAG = 4;
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      module.exports = cloneDeep;
    }
  });

  // node_modules/lodash/_isIterateeCall.js
  var require_isIterateeCall = __commonJS({
    "node_modules/lodash/_isIterateeCall.js"(exports, module) {
      var eq = require_eq();
      var isArrayLike = require_isArrayLike();
      var isIndex = require_isIndex();
      var isObject12 = require_isObject();
      function isIterateeCall(value, index2, object) {
        if (!isObject12(object)) {
          return false;
        }
        var type = typeof index2;
        if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
          return eq(object[index2], value);
        }
        return false;
      }
      module.exports = isIterateeCall;
    }
  });

  // node_modules/lodash/defaults.js
  var require_defaults = __commonJS({
    "node_modules/lodash/defaults.js"(exports, module) {
      var baseRest = require_baseRest();
      var eq = require_eq();
      var isIterateeCall = require_isIterateeCall();
      var keysIn = require_keysIn();
      var objectProto2 = Object.prototype;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      var defaults = baseRest(function(object, sources) {
        object = Object(object);
        var index2 = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index2 < length) {
          var source = sources[index2];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === void 0 || eq(value, objectProto2[key]) && !hasOwnProperty.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      module.exports = defaults;
    }
  });

  // node_modules/lodash/_createFind.js
  var require_createFind = __commonJS({
    "node_modules/lodash/_createFind.js"(exports, module) {
      var baseIteratee = require_baseIteratee();
      var isArrayLike = require_isArrayLike();
      var keys = require_keys2();
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object(collection);
          if (!isArrayLike(collection)) {
            var iteratee = baseIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) {
              return iteratee(iterable[key], key, iterable);
            };
          }
          var index2 = findIndexFunc(collection, predicate, fromIndex);
          return index2 > -1 ? iterable[iteratee ? collection[index2] : index2] : void 0;
        };
      }
      module.exports = createFind;
    }
  });

  // node_modules/lodash/_trimmedEndIndex.js
  var require_trimmedEndIndex = __commonJS({
    "node_modules/lodash/_trimmedEndIndex.js"(exports, module) {
      var reWhitespace = /\s/;
      function trimmedEndIndex(string) {
        var index2 = string.length;
        while (index2-- && reWhitespace.test(string.charAt(index2))) {
        }
        return index2;
      }
      module.exports = trimmedEndIndex;
    }
  });

  // node_modules/lodash/_baseTrim.js
  var require_baseTrim = __commonJS({
    "node_modules/lodash/_baseTrim.js"(exports, module) {
      var trimmedEndIndex = require_trimmedEndIndex();
      var reTrimStart = /^\s+/;
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      module.exports = baseTrim;
    }
  });

  // node_modules/lodash/toNumber.js
  var require_toNumber = __commonJS({
    "node_modules/lodash/toNumber.js"(exports, module) {
      var baseTrim = require_baseTrim();
      var isObject12 = require_isObject();
      var isSymbol = require_isSymbol();
      var NAN = 0 / 0;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject12(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject12(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      module.exports = toNumber;
    }
  });

  // node_modules/lodash/toFinite.js
  var require_toFinite = __commonJS({
    "node_modules/lodash/toFinite.js"(exports, module) {
      var toNumber = require_toNumber();
      var INFINITY = 1 / 0;
      var MAX_INTEGER = 17976931348623157e292;
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      module.exports = toFinite;
    }
  });

  // node_modules/lodash/toInteger.js
  var require_toInteger = __commonJS({
    "node_modules/lodash/toInteger.js"(exports, module) {
      var toFinite = require_toFinite();
      function toInteger(value) {
        var result = toFinite(value), remainder = result % 1;
        return result === result ? remainder ? result - remainder : result : 0;
      }
      module.exports = toInteger;
    }
  });

  // node_modules/lodash/findIndex.js
  var require_findIndex = __commonJS({
    "node_modules/lodash/findIndex.js"(exports, module) {
      var baseFindIndex = require_baseFindIndex();
      var baseIteratee = require_baseIteratee();
      var toInteger = require_toInteger();
      var nativeMax = Math.max;
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseFindIndex(array, baseIteratee(predicate, 3), index2);
      }
      module.exports = findIndex;
    }
  });

  // node_modules/lodash/find.js
  var require_find2 = __commonJS({
    "node_modules/lodash/find.js"(exports, module) {
      var createFind = require_createFind();
      var findIndex = require_findIndex();
      var find4 = createFind(findIndex);
      module.exports = find4;
    }
  });

  // node_modules/lodash/flatten.js
  var require_flatten2 = __commonJS({
    "node_modules/lodash/flatten.js"(exports, module) {
      var baseFlatten = require_baseFlatten();
      function flatten2(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      module.exports = flatten2;
    }
  });

  // node_modules/lodash/forIn.js
  var require_forIn = __commonJS({
    "node_modules/lodash/forIn.js"(exports, module) {
      var baseFor = require_baseFor();
      var castFunction = require_castFunction();
      var keysIn = require_keysIn();
      function forIn(object, iteratee) {
        return object == null ? object : baseFor(object, castFunction(iteratee), keysIn);
      }
      module.exports = forIn;
    }
  });

  // node_modules/lodash/last.js
  var require_last2 = __commonJS({
    "node_modules/lodash/last.js"(exports, module) {
      function last2(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : void 0;
      }
      module.exports = last2;
    }
  });

  // node_modules/lodash/mapValues.js
  var require_mapValues = __commonJS({
    "node_modules/lodash/mapValues.js"(exports, module) {
      var baseAssignValue = require_baseAssignValue();
      var baseForOwn = require_baseForOwn();
      var baseIteratee = require_baseIteratee();
      function mapValues(object, iteratee) {
        var result = {};
        iteratee = baseIteratee(iteratee, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result, key, iteratee(value, key, object2));
        });
        return result;
      }
      module.exports = mapValues;
    }
  });

  // node_modules/lodash/_baseExtremum.js
  var require_baseExtremum = __commonJS({
    "node_modules/lodash/_baseExtremum.js"(exports, module) {
      var isSymbol = require_isSymbol();
      function baseExtremum(array, iteratee, comparator) {
        var index2 = -1, length = array.length;
        while (++index2 < length) {
          var value = array[index2], current2 = iteratee(value);
          if (current2 != null && (computed === void 0 ? current2 === current2 && !isSymbol(current2) : comparator(current2, computed))) {
            var computed = current2, result = value;
          }
        }
        return result;
      }
      module.exports = baseExtremum;
    }
  });

  // node_modules/lodash/_baseGt.js
  var require_baseGt = __commonJS({
    "node_modules/lodash/_baseGt.js"(exports, module) {
      function baseGt(value, other) {
        return value > other;
      }
      module.exports = baseGt;
    }
  });

  // node_modules/lodash/max.js
  var require_max2 = __commonJS({
    "node_modules/lodash/max.js"(exports, module) {
      var baseExtremum = require_baseExtremum();
      var baseGt = require_baseGt();
      var identity3 = require_identity2();
      function max4(array) {
        return array && array.length ? baseExtremum(array, identity3, baseGt) : void 0;
      }
      module.exports = max4;
    }
  });

  // node_modules/lodash/_assignMergeValue.js
  var require_assignMergeValue = __commonJS({
    "node_modules/lodash/_assignMergeValue.js"(exports, module) {
      var baseAssignValue = require_baseAssignValue();
      var eq = require_eq();
      function assignMergeValue(object, key, value) {
        if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      module.exports = assignMergeValue;
    }
  });

  // node_modules/lodash/isPlainObject.js
  var require_isPlainObject = __commonJS({
    "node_modules/lodash/isPlainObject.js"(exports, module) {
      var baseGetTag = require_baseGetTag();
      var getPrototype = require_getPrototype();
      var isObjectLike = require_isObjectLike();
      var objectTag = "[object Object]";
      var funcProto = Function.prototype;
      var objectProto2 = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto2.hasOwnProperty;
      var objectCtorString = funcToString.call(Object);
      function isPlainObject2(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      module.exports = isPlainObject2;
    }
  });

  // node_modules/lodash/_safeGet.js
  var require_safeGet = __commonJS({
    "node_modules/lodash/_safeGet.js"(exports, module) {
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      module.exports = safeGet;
    }
  });

  // node_modules/lodash/toPlainObject.js
  var require_toPlainObject = __commonJS({
    "node_modules/lodash/toPlainObject.js"(exports, module) {
      var copyObject = require_copyObject();
      var keysIn = require_keysIn();
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      module.exports = toPlainObject;
    }
  });

  // node_modules/lodash/_baseMergeDeep.js
  var require_baseMergeDeep = __commonJS({
    "node_modules/lodash/_baseMergeDeep.js"(exports, module) {
      var assignMergeValue = require_assignMergeValue();
      var cloneBuffer = require_cloneBuffer();
      var cloneTypedArray = require_cloneTypedArray();
      var copyArray = require_copyArray();
      var initCloneObject = require_initCloneObject();
      var isArguments = require_isArguments();
      var isArray7 = require_isArray();
      var isArrayLikeObject = require_isArrayLikeObject();
      var isBuffer = require_isBuffer();
      var isFunction35 = require_isFunction();
      var isObject12 = require_isObject();
      var isPlainObject2 = require_isPlainObject();
      var isTypedArray = require_isTypedArray();
      var safeGet = require_safeGet();
      var toPlainObject = require_toPlainObject();
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
        var isCommon = newValue === void 0;
        if (isCommon) {
          var isArr = isArray7(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray7(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject12(objValue) || isFunction35(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      module.exports = baseMergeDeep;
    }
  });

  // node_modules/lodash/_baseMerge.js
  var require_baseMerge = __commonJS({
    "node_modules/lodash/_baseMerge.js"(exports, module) {
      var Stack2 = require_Stack();
      var assignMergeValue = require_assignMergeValue();
      var baseFor = require_baseFor();
      var baseMergeDeep = require_baseMergeDeep();
      var isObject12 = require_isObject();
      var keysIn = require_keysIn();
      var safeGet = require_safeGet();
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack2());
          if (isObject12(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
            if (newValue === void 0) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      module.exports = baseMerge;
    }
  });

  // node_modules/lodash/_createAssigner.js
  var require_createAssigner = __commonJS({
    "node_modules/lodash/_createAssigner.js"(exports, module) {
      var baseRest = require_baseRest();
      var isIterateeCall = require_isIterateeCall();
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? void 0 : customizer;
            length = 1;
          }
          object = Object(object);
          while (++index2 < length) {
            var source = sources[index2];
            if (source) {
              assigner(object, source, index2, customizer);
            }
          }
          return object;
        });
      }
      module.exports = createAssigner;
    }
  });

  // node_modules/lodash/merge.js
  var require_merge = __commonJS({
    "node_modules/lodash/merge.js"(exports, module) {
      var baseMerge = require_baseMerge();
      var createAssigner = require_createAssigner();
      var merge = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      module.exports = merge;
    }
  });

  // node_modules/lodash/_baseLt.js
  var require_baseLt = __commonJS({
    "node_modules/lodash/_baseLt.js"(exports, module) {
      function baseLt(value, other) {
        return value < other;
      }
      module.exports = baseLt;
    }
  });

  // node_modules/lodash/min.js
  var require_min2 = __commonJS({
    "node_modules/lodash/min.js"(exports, module) {
      var baseExtremum = require_baseExtremum();
      var baseLt = require_baseLt();
      var identity3 = require_identity2();
      function min4(array) {
        return array && array.length ? baseExtremum(array, identity3, baseLt) : void 0;
      }
      module.exports = min4;
    }
  });

  // node_modules/lodash/minBy.js
  var require_minBy = __commonJS({
    "node_modules/lodash/minBy.js"(exports, module) {
      var baseExtremum = require_baseExtremum();
      var baseIteratee = require_baseIteratee();
      var baseLt = require_baseLt();
      function minBy3(array, iteratee) {
        return array && array.length ? baseExtremum(array, baseIteratee(iteratee, 2), baseLt) : void 0;
      }
      module.exports = minBy3;
    }
  });

  // node_modules/lodash/now.js
  var require_now = __commonJS({
    "node_modules/lodash/now.js"(exports, module) {
      var root2 = require_root();
      var now2 = function() {
        return root2.Date.now();
      };
      module.exports = now2;
    }
  });

  // node_modules/lodash/_baseSet.js
  var require_baseSet = __commonJS({
    "node_modules/lodash/_baseSet.js"(exports, module) {
      var assignValue = require_assignValue();
      var castPath = require_castPath();
      var isIndex = require_isIndex();
      var isObject12 = require_isObject();
      var toKey = require_toKey();
      function baseSet(object, path, value, customizer) {
        if (!isObject12(object)) {
          return object;
        }
        path = castPath(path, object);
        var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index2 < length) {
          var key = toKey(path[index2]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index2 != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : void 0;
            if (newValue === void 0) {
              newValue = isObject12(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      module.exports = baseSet;
    }
  });

  // node_modules/lodash/_basePickBy.js
  var require_basePickBy = __commonJS({
    "node_modules/lodash/_basePickBy.js"(exports, module) {
      var baseGet = require_baseGet();
      var baseSet = require_baseSet();
      var castPath = require_castPath();
      function basePickBy(object, paths, predicate) {
        var index2 = -1, length = paths.length, result = {};
        while (++index2 < length) {
          var path = paths[index2], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result, castPath(path, object), value);
          }
        }
        return result;
      }
      module.exports = basePickBy;
    }
  });

  // node_modules/lodash/_basePick.js
  var require_basePick = __commonJS({
    "node_modules/lodash/_basePick.js"(exports, module) {
      var basePickBy = require_basePickBy();
      var hasIn = require_hasIn();
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      module.exports = basePick;
    }
  });

  // node_modules/lodash/_flatRest.js
  var require_flatRest = __commonJS({
    "node_modules/lodash/_flatRest.js"(exports, module) {
      var flatten2 = require_flatten2();
      var overRest = require_overRest();
      var setToString = require_setToString();
      function flatRest(func) {
        return setToString(overRest(func, void 0, flatten2), func + "");
      }
      module.exports = flatRest;
    }
  });

  // node_modules/lodash/pick.js
  var require_pick2 = __commonJS({
    "node_modules/lodash/pick.js"(exports, module) {
      var basePick = require_basePick();
      var flatRest = require_flatRest();
      var pick7 = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      module.exports = pick7;
    }
  });

  // node_modules/lodash/_baseRange.js
  var require_baseRange = __commonJS({
    "node_modules/lodash/_baseRange.js"(exports, module) {
      var nativeCeil = Math.ceil;
      var nativeMax = Math.max;
      function baseRange(start, end, step2, fromRight) {
        var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step2 || 1)), 0), result = Array(length);
        while (length--) {
          result[fromRight ? length : ++index2] = start;
          start += step2;
        }
        return result;
      }
      module.exports = baseRange;
    }
  });

  // node_modules/lodash/_createRange.js
  var require_createRange = __commonJS({
    "node_modules/lodash/_createRange.js"(exports, module) {
      var baseRange = require_baseRange();
      var isIterateeCall = require_isIterateeCall();
      var toFinite = require_toFinite();
      function createRange(fromRight) {
        return function(start, end, step2) {
          if (step2 && typeof step2 != "number" && isIterateeCall(start, end, step2)) {
            end = step2 = void 0;
          }
          start = toFinite(start);
          if (end === void 0) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step2 = step2 === void 0 ? start < end ? 1 : -1 : toFinite(step2);
          return baseRange(start, end, step2, fromRight);
        };
      }
      module.exports = createRange;
    }
  });

  // node_modules/lodash/range.js
  var require_range = __commonJS({
    "node_modules/lodash/range.js"(exports, module) {
      var createRange = require_createRange();
      var range = createRange();
      module.exports = range;
    }
  });

  // node_modules/lodash/_baseSortBy.js
  var require_baseSortBy = __commonJS({
    "node_modules/lodash/_baseSortBy.js"(exports, module) {
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      module.exports = baseSortBy;
    }
  });

  // node_modules/lodash/_compareAscending.js
  var require_compareAscending = __commonJS({
    "node_modules/lodash/_compareAscending.js"(exports, module) {
      var isSymbol = require_isSymbol();
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      module.exports = compareAscending;
    }
  });

  // node_modules/lodash/_compareMultiple.js
  var require_compareMultiple = __commonJS({
    "node_modules/lodash/_compareMultiple.js"(exports, module) {
      var compareAscending = require_compareAscending();
      function compareMultiple(object, other, orders) {
        var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index2 < length) {
          var result = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result) {
            if (index2 >= ordersLength) {
              return result;
            }
            var order2 = orders[index2];
            return result * (order2 == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      module.exports = compareMultiple;
    }
  });

  // node_modules/lodash/_baseOrderBy.js
  var require_baseOrderBy = __commonJS({
    "node_modules/lodash/_baseOrderBy.js"(exports, module) {
      var arrayMap = require_arrayMap();
      var baseGet = require_baseGet();
      var baseIteratee = require_baseIteratee();
      var baseMap = require_baseMap();
      var baseSortBy = require_baseSortBy();
      var baseUnary = require_baseUnary();
      var compareMultiple = require_compareMultiple();
      var identity3 = require_identity2();
      var isArray7 = require_isArray();
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee) {
            if (isArray7(iteratee)) {
              return function(value) {
                return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
              };
            }
            return iteratee;
          });
        } else {
          iteratees = [identity3];
        }
        var index2 = -1;
        iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
        var result = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee) {
            return iteratee(value);
          });
          return { "criteria": criteria, "index": ++index2, "value": value };
        });
        return baseSortBy(result, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      module.exports = baseOrderBy;
    }
  });

  // node_modules/lodash/sortBy.js
  var require_sortBy = __commonJS({
    "node_modules/lodash/sortBy.js"(exports, module) {
      var baseFlatten = require_baseFlatten();
      var baseOrderBy = require_baseOrderBy();
      var baseRest = require_baseRest();
      var isIterateeCall = require_isIterateeCall();
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      module.exports = sortBy;
    }
  });

  // node_modules/lodash/uniqueId.js
  var require_uniqueId = __commonJS({
    "node_modules/lodash/uniqueId.js"(exports, module) {
      var toString3 = require_toString();
      var idCounter = 0;
      function uniqueId5(prefix) {
        var id3 = ++idCounter;
        return toString3(prefix) + id3;
      }
      module.exports = uniqueId5;
    }
  });

  // node_modules/lodash/_baseZipObject.js
  var require_baseZipObject = __commonJS({
    "node_modules/lodash/_baseZipObject.js"(exports, module) {
      function baseZipObject(props, values2, assignFunc) {
        var index2 = -1, length = props.length, valsLength = values2.length, result = {};
        while (++index2 < length) {
          var value = index2 < valsLength ? values2[index2] : void 0;
          assignFunc(result, props[index2], value);
        }
        return result;
      }
      module.exports = baseZipObject;
    }
  });

  // node_modules/lodash/zipObject.js
  var require_zipObject = __commonJS({
    "node_modules/lodash/zipObject.js"(exports, module) {
      var assignValue = require_assignValue();
      var baseZipObject = require_baseZipObject();
      function zipObject2(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      module.exports = zipObject2;
    }
  });

  // node_modules/dagre/lib/lodash.js
  var require_lodash3 = __commonJS({
    "node_modules/dagre/lib/lodash.js"(exports, module) {
      var lodash;
      if (typeof __require === "function") {
        try {
          lodash = {
            cloneDeep: require_cloneDeep(),
            constant: require_constant(),
            defaults: require_defaults(),
            each: require_each2(),
            filter: require_filter2(),
            find: require_find2(),
            flatten: require_flatten2(),
            forEach: require_forEach(),
            forIn: require_forIn(),
            has: require_has2(),
            isUndefined: require_isUndefined(),
            last: require_last2(),
            map: require_map2(),
            mapValues: require_mapValues(),
            max: require_max2(),
            merge: require_merge(),
            min: require_min2(),
            minBy: require_minBy(),
            now: require_now(),
            pick: require_pick2(),
            range: require_range(),
            reduce: require_reduce2(),
            sortBy: require_sortBy(),
            uniqueId: require_uniqueId(),
            values: require_values2(),
            zipObject: require_zipObject()
          };
        } catch (e) {
        }
      }
      if (!lodash) {
        lodash = window._;
      }
      module.exports = lodash;
    }
  });

  // node_modules/dagre/lib/data/list.js
  var require_list = __commonJS({
    "node_modules/dagre/lib/data/list.js"(exports, module) {
      module.exports = List3;
      function List3() {
        var sentinel = {};
        sentinel._next = sentinel._prev = sentinel;
        this._sentinel = sentinel;
      }
      List3.prototype.dequeue = function() {
        var sentinel = this._sentinel;
        var entry = sentinel._prev;
        if (entry !== sentinel) {
          unlink2(entry);
          return entry;
        }
      };
      List3.prototype.enqueue = function(entry) {
        var sentinel = this._sentinel;
        if (entry._prev && entry._next) {
          unlink2(entry);
        }
        entry._next = sentinel._next;
        sentinel._next._prev = entry;
        sentinel._next = entry;
        entry._prev = sentinel;
      };
      List3.prototype.toString = function() {
        var strs = [];
        var sentinel = this._sentinel;
        var curr = sentinel._prev;
        while (curr !== sentinel) {
          strs.push(JSON.stringify(curr, filterOutLinks2));
          curr = curr._prev;
        }
        return "[" + strs.join(", ") + "]";
      };
      function unlink2(entry) {
        entry._prev._next = entry._next;
        entry._next._prev = entry._prev;
        delete entry._next;
        delete entry._prev;
      }
      function filterOutLinks2(k, v) {
        if (k !== "_next" && k !== "_prev") {
          return v;
        }
      }
    }
  });

  // node_modules/dagre/lib/greedy-fas.js
  var require_greedy_fas = __commonJS({
    "node_modules/dagre/lib/greedy-fas.js"(exports, module) {
      var _2 = require_lodash3();
      var Graph4 = require_graphlib2().Graph;
      var List3 = require_list();
      module.exports = greedyFAS2;
      var DEFAULT_WEIGHT_FN2 = _2.constant(1);
      function greedyFAS2(g, weightFn) {
        if (g.nodeCount() <= 1) {
          return [];
        }
        var state = buildState2(g, weightFn || DEFAULT_WEIGHT_FN2);
        var results = doGreedyFAS2(state.graph, state.buckets, state.zeroIdx);
        return _2.flatten(_2.map(results, function(e) {
          return g.outEdges(e.v, e.w);
        }), true);
      }
      function doGreedyFAS2(g, buckets, zeroIdx) {
        var results = [];
        var sources = buckets[buckets.length - 1];
        var sinks = buckets[0];
        var entry;
        while (g.nodeCount()) {
          while (entry = sinks.dequeue()) {
            removeNode2(g, buckets, zeroIdx, entry);
          }
          while (entry = sources.dequeue()) {
            removeNode2(g, buckets, zeroIdx, entry);
          }
          if (g.nodeCount()) {
            for (var i = buckets.length - 2; i > 0; --i) {
              entry = buckets[i].dequeue();
              if (entry) {
                results = results.concat(removeNode2(g, buckets, zeroIdx, entry, true));
                break;
              }
            }
          }
        }
        return results;
      }
      function removeNode2(g, buckets, zeroIdx, entry, collectPredecessors) {
        var results = collectPredecessors ? [] : void 0;
        _2.forEach(g.inEdges(entry.v), function(edge) {
          var weight = g.edge(edge);
          var uEntry = g.node(edge.v);
          if (collectPredecessors) {
            results.push({ v: edge.v, w: edge.w });
          }
          uEntry.out -= weight;
          assignBucket2(buckets, zeroIdx, uEntry);
        });
        _2.forEach(g.outEdges(entry.v), function(edge) {
          var weight = g.edge(edge);
          var w = edge.w;
          var wEntry = g.node(w);
          wEntry["in"] -= weight;
          assignBucket2(buckets, zeroIdx, wEntry);
        });
        g.removeNode(entry.v);
        return results;
      }
      function buildState2(g, weightFn) {
        var fasGraph = new Graph4();
        var maxIn = 0;
        var maxOut = 0;
        _2.forEach(g.nodes(), function(v) {
          fasGraph.setNode(v, { v, "in": 0, out: 0 });
        });
        _2.forEach(g.edges(), function(e) {
          var prevWeight = fasGraph.edge(e.v, e.w) || 0;
          var weight = weightFn(e);
          var edgeWeight = prevWeight + weight;
          fasGraph.setEdge(e.v, e.w, edgeWeight);
          maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);
          maxIn = Math.max(maxIn, fasGraph.node(e.w)["in"] += weight);
        });
        var buckets = _2.range(maxOut + maxIn + 3).map(function() {
          return new List3();
        });
        var zeroIdx = maxIn + 1;
        _2.forEach(fasGraph.nodes(), function(v) {
          assignBucket2(buckets, zeroIdx, fasGraph.node(v));
        });
        return { graph: fasGraph, buckets, zeroIdx };
      }
      function assignBucket2(buckets, zeroIdx, entry) {
        if (!entry.out) {
          buckets[0].enqueue(entry);
        } else if (!entry["in"]) {
          buckets[buckets.length - 1].enqueue(entry);
        } else {
          buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
        }
      }
    }
  });

  // node_modules/dagre/lib/acyclic.js
  var require_acyclic = __commonJS({
    "node_modules/dagre/lib/acyclic.js"(exports, module) {
      "use strict";
      var _2 = require_lodash3();
      var greedyFAS2 = require_greedy_fas();
      module.exports = {
        run: run4,
        undo: undo4
      };
      function run4(g) {
        var fas = g.graph().acyclicer === "greedy" ? greedyFAS2(g, weightFn(g)) : dfsFAS2(g);
        _2.forEach(fas, function(e) {
          var label = g.edge(e);
          g.removeEdge(e);
          label.forwardName = e.name;
          label.reversed = true;
          g.setEdge(e.w, e.v, label, _2.uniqueId("rev"));
        });
        function weightFn(g2) {
          return function(e) {
            return g2.edge(e).weight;
          };
        }
      }
      function dfsFAS2(g) {
        var fas = [];
        var stack = {};
        var visited = {};
        function dfs4(v) {
          if (_2.has(visited, v)) {
            return;
          }
          visited[v] = true;
          stack[v] = true;
          _2.forEach(g.outEdges(v), function(e) {
            if (_2.has(stack, e.w)) {
              fas.push(e);
            } else {
              dfs4(e.w);
            }
          });
          delete stack[v];
        }
        _2.forEach(g.nodes(), dfs4);
        return fas;
      }
      function undo4(g) {
        _2.forEach(g.edges(), function(e) {
          var label = g.edge(e);
          if (label.reversed) {
            g.removeEdge(e);
            var forwardName = label.forwardName;
            delete label.reversed;
            delete label.forwardName;
            g.setEdge(e.w, e.v, label, forwardName);
          }
        });
      }
    }
  });

  // node_modules/dagre/lib/util.js
  var require_util = __commonJS({
    "node_modules/dagre/lib/util.js"(exports, module) {
      "use strict";
      var _2 = require_lodash3();
      var Graph4 = require_graphlib2().Graph;
      module.exports = {
        addDummyNode: addDummyNode2,
        simplify: simplify2,
        asNonCompoundGraph: asNonCompoundGraph2,
        successorWeights,
        predecessorWeights,
        intersectRect: intersectRect2,
        buildLayerMatrix: buildLayerMatrix2,
        normalizeRanks: normalizeRanks2,
        removeEmptyRanks: removeEmptyRanks2,
        addBorderNode: addBorderNode3,
        maxRank: maxRank2,
        partition: partition2,
        time,
        notime
      };
      function addDummyNode2(g, type, attrs, name) {
        var v;
        do {
          v = _2.uniqueId(name);
        } while (g.hasNode(v));
        attrs.dummy = type;
        g.setNode(v, attrs);
        return v;
      }
      function simplify2(g) {
        var simplified = new Graph4().setGraph(g.graph());
        _2.forEach(g.nodes(), function(v) {
          simplified.setNode(v, g.node(v));
        });
        _2.forEach(g.edges(), function(e) {
          var simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };
          var label = g.edge(e);
          simplified.setEdge(e.v, e.w, {
            weight: simpleLabel.weight + label.weight,
            minlen: Math.max(simpleLabel.minlen, label.minlen)
          });
        });
        return simplified;
      }
      function asNonCompoundGraph2(g) {
        var simplified = new Graph4({ multigraph: g.isMultigraph() }).setGraph(g.graph());
        _2.forEach(g.nodes(), function(v) {
          if (!g.children(v).length) {
            simplified.setNode(v, g.node(v));
          }
        });
        _2.forEach(g.edges(), function(e) {
          simplified.setEdge(e, g.edge(e));
        });
        return simplified;
      }
      function successorWeights(g) {
        var weightMap = _2.map(g.nodes(), function(v) {
          var sucs = {};
          _2.forEach(g.outEdges(v), function(e) {
            sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;
          });
          return sucs;
        });
        return _2.zipObject(g.nodes(), weightMap);
      }
      function predecessorWeights(g) {
        var weightMap = _2.map(g.nodes(), function(v) {
          var preds = {};
          _2.forEach(g.inEdges(v), function(e) {
            preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;
          });
          return preds;
        });
        return _2.zipObject(g.nodes(), weightMap);
      }
      function intersectRect2(rect2, point4) {
        var x3 = rect2.x;
        var y3 = rect2.y;
        var dx = point4.x - x3;
        var dy = point4.y - y3;
        var w = rect2.width / 2;
        var h = rect2.height / 2;
        if (!dx && !dy) {
          throw new Error("Not possible to find intersection inside of the rectangle");
        }
        var sx, sy;
        if (Math.abs(dy) * w > Math.abs(dx) * h) {
          if (dy < 0) {
            h = -h;
          }
          sx = h * dx / dy;
          sy = h;
        } else {
          if (dx < 0) {
            w = -w;
          }
          sx = w;
          sy = w * dy / dx;
        }
        return { x: x3 + sx, y: y3 + sy };
      }
      function buildLayerMatrix2(g) {
        var layering = _2.map(_2.range(maxRank2(g) + 1), function() {
          return [];
        });
        _2.forEach(g.nodes(), function(v) {
          var node = g.node(v);
          var rank2 = node.rank;
          if (!_2.isUndefined(rank2)) {
            layering[rank2][node.order] = v;
          }
        });
        return layering;
      }
      function normalizeRanks2(g) {
        var min4 = _2.min(_2.map(g.nodes(), function(v) {
          return g.node(v).rank;
        }));
        _2.forEach(g.nodes(), function(v) {
          var node = g.node(v);
          if (_2.has(node, "rank")) {
            node.rank -= min4;
          }
        });
      }
      function removeEmptyRanks2(g) {
        var offset = _2.min(_2.map(g.nodes(), function(v) {
          return g.node(v).rank;
        }));
        var layers = [];
        _2.forEach(g.nodes(), function(v) {
          var rank2 = g.node(v).rank - offset;
          if (!layers[rank2]) {
            layers[rank2] = [];
          }
          layers[rank2].push(v);
        });
        var delta = 0;
        var nodeRankFactor = g.graph().nodeRankFactor;
        _2.forEach(layers, function(vs, i) {
          if (_2.isUndefined(vs) && i % nodeRankFactor !== 0) {
            --delta;
          } else if (delta) {
            _2.forEach(vs, function(v) {
              g.node(v).rank += delta;
            });
          }
        });
      }
      function addBorderNode3(g, prefix, rank2, order2) {
        var node = {
          width: 0,
          height: 0
        };
        if (arguments.length >= 4) {
          node.rank = rank2;
          node.order = order2;
        }
        return addDummyNode2(g, "border", node, prefix);
      }
      function maxRank2(g) {
        return _2.max(_2.map(g.nodes(), function(v) {
          var rank2 = g.node(v).rank;
          if (!_2.isUndefined(rank2)) {
            return rank2;
          }
        }));
      }
      function partition2(collection, fn) {
        var result = { lhs: [], rhs: [] };
        _2.forEach(collection, function(value) {
          if (fn(value)) {
            result.lhs.push(value);
          } else {
            result.rhs.push(value);
          }
        });
        return result;
      }
      function time(name, fn) {
        var start = _2.now();
        try {
          return fn();
        } finally {
          console.log(name + " time: " + (_2.now() - start) + "ms");
        }
      }
      function notime(name, fn) {
        return fn();
      }
    }
  });

  // node_modules/dagre/lib/normalize.js
  var require_normalize = __commonJS({
    "node_modules/dagre/lib/normalize.js"(exports, module) {
      "use strict";
      var _2 = require_lodash3();
      var util = require_util();
      module.exports = {
        run: run4,
        undo: undo4
      };
      function run4(g) {
        g.graph().dummyChains = [];
        _2.forEach(g.edges(), function(edge) {
          normalizeEdge2(g, edge);
        });
      }
      function normalizeEdge2(g, e) {
        var v = e.v;
        var vRank = g.node(v).rank;
        var w = e.w;
        var wRank = g.node(w).rank;
        var name = e.name;
        var edgeLabel = g.edge(e);
        var labelRank = edgeLabel.labelRank;
        if (wRank === vRank + 1) return;
        g.removeEdge(e);
        var dummy, attrs, i;
        for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {
          edgeLabel.points = [];
          attrs = {
            width: 0,
            height: 0,
            edgeLabel,
            edgeObj: e,
            rank: vRank
          };
          dummy = util.addDummyNode(g, "edge", attrs, "_d");
          if (vRank === labelRank) {
            attrs.width = edgeLabel.width;
            attrs.height = edgeLabel.height;
            attrs.dummy = "edge-label";
            attrs.labelpos = edgeLabel.labelpos;
          }
          g.setEdge(v, dummy, { weight: edgeLabel.weight }, name);
          if (i === 0) {
            g.graph().dummyChains.push(dummy);
          }
          v = dummy;
        }
        g.setEdge(v, w, { weight: edgeLabel.weight }, name);
      }
      function undo4(g) {
        _2.forEach(g.graph().dummyChains, function(v) {
          var node = g.node(v);
          var origLabel = node.edgeLabel;
          var w;
          g.setEdge(node.edgeObj, origLabel);
          while (node.dummy) {
            w = g.successors(v)[0];
            g.removeNode(v);
            origLabel.points.push({ x: node.x, y: node.y });
            if (node.dummy === "edge-label") {
              origLabel.x = node.x;
              origLabel.y = node.y;
              origLabel.width = node.width;
              origLabel.height = node.height;
            }
            v = w;
            node = g.node(v);
          }
        });
      }
    }
  });

  // node_modules/dagre/lib/rank/util.js
  var require_util2 = __commonJS({
    "node_modules/dagre/lib/rank/util.js"(exports, module) {
      "use strict";
      var _2 = require_lodash3();
      module.exports = {
        longestPath: longestPath2,
        slack: slack2
      };
      function longestPath2(g) {
        var visited = {};
        function dfs4(v) {
          var label = g.node(v);
          if (_2.has(visited, v)) {
            return label.rank;
          }
          visited[v] = true;
          var rank2 = _2.min(_2.map(g.outEdges(v), function(e) {
            return dfs4(e.w) - g.edge(e).minlen;
          }));
          if (rank2 === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3
          rank2 === void 0 || // return value of _.map([]) for Lodash 4
          rank2 === null) {
            rank2 = 0;
          }
          return label.rank = rank2;
        }
        _2.forEach(g.sources(), dfs4);
      }
      function slack2(g, e) {
        return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;
      }
    }
  });

  // node_modules/dagre/lib/rank/feasible-tree.js
  var require_feasible_tree = __commonJS({
    "node_modules/dagre/lib/rank/feasible-tree.js"(exports, module) {
      "use strict";
      var _2 = require_lodash3();
      var Graph4 = require_graphlib2().Graph;
      var slack2 = require_util2().slack;
      module.exports = feasibleTree2;
      function feasibleTree2(g) {
        var t = new Graph4({ directed: false });
        var start = g.nodes()[0];
        var size2 = g.nodeCount();
        t.setNode(start, {});
        var edge, delta;
        while (tightTree2(t, g) < size2) {
          edge = findMinSlackEdge2(t, g);
          delta = t.hasNode(edge.v) ? slack2(g, edge) : -slack2(g, edge);
          shiftRanks2(t, g, delta);
        }
        return t;
      }
      function tightTree2(t, g) {
        function dfs4(v) {
          _2.forEach(g.nodeEdges(v), function(e) {
            var edgeV = e.v, w = v === edgeV ? e.w : edgeV;
            if (!t.hasNode(w) && !slack2(g, e)) {
              t.setNode(w, {});
              t.setEdge(v, w, {});
              dfs4(w);
            }
          });
        }
        _2.forEach(t.nodes(), dfs4);
        return t.nodeCount();
      }
      function findMinSlackEdge2(t, g) {
        return _2.minBy(g.edges(), function(e) {
          if (t.hasNode(e.v) !== t.hasNode(e.w)) {
            return slack2(g, e);
          }
        });
      }
      function shiftRanks2(t, g, delta) {
        _2.forEach(t.nodes(), function(v) {
          g.node(v).rank += delta;
        });
      }
    }
  });

  // node_modules/dagre/lib/rank/network-simplex.js
  var require_network_simplex = __commonJS({
    "node_modules/dagre/lib/rank/network-simplex.js"(exports, module) {
      "use strict";
      var _2 = require_lodash3();
      var feasibleTree2 = require_feasible_tree();
      var slack2 = require_util2().slack;
      var initRank = require_util2().longestPath;
      var preorder = require_graphlib2().alg.preorder;
      var postorder = require_graphlib2().alg.postorder;
      var simplify2 = require_util().simplify;
      module.exports = networkSimplex2;
      networkSimplex2.initLowLimValues = initLowLimValues2;
      networkSimplex2.initCutValues = initCutValues2;
      networkSimplex2.calcCutValue = calcCutValue2;
      networkSimplex2.leaveEdge = leaveEdge2;
      networkSimplex2.enterEdge = enterEdge2;
      networkSimplex2.exchangeEdges = exchangeEdges2;
      function networkSimplex2(g) {
        g = simplify2(g);
        initRank(g);
        var t = feasibleTree2(g);
        initLowLimValues2(t);
        initCutValues2(t, g);
        var e, f;
        while (e = leaveEdge2(t)) {
          f = enterEdge2(t, g, e);
          exchangeEdges2(t, g, e, f);
        }
      }
      function initCutValues2(t, g) {
        var vs = postorder(t, t.nodes());
        vs = vs.slice(0, vs.length - 1);
        _2.forEach(vs, function(v) {
          assignCutValue2(t, g, v);
        });
      }
      function assignCutValue2(t, g, child) {
        var childLab = t.node(child);
        var parent = childLab.parent;
        t.edge(child, parent).cutvalue = calcCutValue2(t, g, child);
      }
      function calcCutValue2(t, g, child) {
        var childLab = t.node(child);
        var parent = childLab.parent;
        var childIsTail = true;
        var graphEdge = g.edge(child, parent);
        var cutValue = 0;
        if (!graphEdge) {
          childIsTail = false;
          graphEdge = g.edge(parent, child);
        }
        cutValue = graphEdge.weight;
        _2.forEach(g.nodeEdges(child), function(e) {
          var isOutEdge = e.v === child, other = isOutEdge ? e.w : e.v;
          if (other !== parent) {
            var pointsToHead = isOutEdge === childIsTail, otherWeight = g.edge(e).weight;
            cutValue += pointsToHead ? otherWeight : -otherWeight;
            if (isTreeEdge2(t, child, other)) {
              var otherCutValue = t.edge(child, other).cutvalue;
              cutValue += pointsToHead ? -otherCutValue : otherCutValue;
            }
          }
        });
        return cutValue;
      }
      function initLowLimValues2(tree, root2) {
        if (arguments.length < 2) {
          root2 = tree.nodes()[0];
        }
        dfsAssignLowLim2(tree, {}, 1, root2);
      }
      function dfsAssignLowLim2(tree, visited, nextLim, v, parent) {
        var low = nextLim;
        var label = tree.node(v);
        visited[v] = true;
        _2.forEach(tree.neighbors(v), function(w) {
          if (!_2.has(visited, w)) {
            nextLim = dfsAssignLowLim2(tree, visited, nextLim, w, v);
          }
        });
        label.low = low;
        label.lim = nextLim++;
        if (parent) {
          label.parent = parent;
        } else {
          delete label.parent;
        }
        return nextLim;
      }
      function leaveEdge2(tree) {
        return _2.find(tree.edges(), function(e) {
          return tree.edge(e).cutvalue < 0;
        });
      }
      function enterEdge2(t, g, edge) {
        var v = edge.v;
        var w = edge.w;
        if (!g.hasEdge(v, w)) {
          v = edge.w;
          w = edge.v;
        }
        var vLabel = t.node(v);
        var wLabel = t.node(w);
        var tailLabel = vLabel;
        var flip = false;
        if (vLabel.lim > wLabel.lim) {
          tailLabel = wLabel;
          flip = true;
        }
        var candidates = _2.filter(g.edges(), function(edge2) {
          return flip === isDescendant2(t, t.node(edge2.v), tailLabel) && flip !== isDescendant2(t, t.node(edge2.w), tailLabel);
        });
        return _2.minBy(candidates, function(edge2) {
          return slack2(g, edge2);
        });
      }
      function exchangeEdges2(t, g, e, f) {
        var v = e.v;
        var w = e.w;
        t.removeEdge(v, w);
        t.setEdge(f.v, f.w, {});
        initLowLimValues2(t);
        initCutValues2(t, g);
        updateRanks2(t, g);
      }
      function updateRanks2(t, g) {
        var root2 = _2.find(t.nodes(), function(v) {
          return !g.node(v).parent;
        });
        var vs = preorder(t, root2);
        vs = vs.slice(1);
        _2.forEach(vs, function(v) {
          var parent = t.node(v).parent, edge = g.edge(v, parent), flipped = false;
          if (!edge) {
            edge = g.edge(parent, v);
            flipped = true;
          }
          g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
        });
      }
      function isTreeEdge2(tree, u, v) {
        return tree.hasEdge(u, v);
      }
      function isDescendant2(tree, vLabel, rootLabel) {
        return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
      }
    }
  });

  // node_modules/dagre/lib/rank/index.js
  var require_rank = __commonJS({
    "node_modules/dagre/lib/rank/index.js"(exports, module) {
      "use strict";
      var rankUtil = require_util2();
      var longestPath2 = rankUtil.longestPath;
      var feasibleTree2 = require_feasible_tree();
      var networkSimplex2 = require_network_simplex();
      module.exports = rank2;
      function rank2(g) {
        switch (g.graph().ranker) {
          case "network-simplex":
            networkSimplexRanker2(g);
            break;
          case "tight-tree":
            tightTreeRanker2(g);
            break;
          case "longest-path":
            longestPathRanker2(g);
            break;
          default:
            networkSimplexRanker2(g);
        }
      }
      var longestPathRanker2 = longestPath2;
      function tightTreeRanker2(g) {
        longestPath2(g);
        feasibleTree2(g);
      }
      function networkSimplexRanker2(g) {
        networkSimplex2(g);
      }
    }
  });

  // node_modules/dagre/lib/parent-dummy-chains.js
  var require_parent_dummy_chains = __commonJS({
    "node_modules/dagre/lib/parent-dummy-chains.js"(exports, module) {
      var _2 = require_lodash3();
      module.exports = parentDummyChains2;
      function parentDummyChains2(g) {
        var postorderNums = postorder(g);
        _2.forEach(g.graph().dummyChains, function(v) {
          var node = g.node(v);
          var edgeObj = node.edgeObj;
          var pathData = findPath2(g, postorderNums, edgeObj.v, edgeObj.w);
          var path = pathData.path;
          var lca = pathData.lca;
          var pathIdx = 0;
          var pathV = path[pathIdx];
          var ascending = true;
          while (v !== edgeObj.w) {
            node = g.node(v);
            if (ascending) {
              while ((pathV = path[pathIdx]) !== lca && g.node(pathV).maxRank < node.rank) {
                pathIdx++;
              }
              if (pathV === lca) {
                ascending = false;
              }
            }
            if (!ascending) {
              while (pathIdx < path.length - 1 && g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {
                pathIdx++;
              }
              pathV = path[pathIdx];
            }
            g.setParent(v, pathV);
            v = g.successors(v)[0];
          }
        });
      }
      function findPath2(g, postorderNums, v, w) {
        var vPath = [];
        var wPath = [];
        var low = Math.min(postorderNums[v].low, postorderNums[w].low);
        var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);
        var parent;
        var lca;
        parent = v;
        do {
          parent = g.parent(parent);
          vPath.push(parent);
        } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
        lca = parent;
        parent = w;
        while ((parent = g.parent(parent)) !== lca) {
          wPath.push(parent);
        }
        return { path: vPath.concat(wPath.reverse()), lca };
      }
      function postorder(g) {
        var result = {};
        var lim = 0;
        function dfs4(v) {
          var low = lim;
          _2.forEach(g.children(v), dfs4);
          result[v] = { low, lim: lim++ };
        }
        _2.forEach(g.children(), dfs4);
        return result;
      }
    }
  });

  // node_modules/dagre/lib/nesting-graph.js
  var require_nesting_graph = __commonJS({
    "node_modules/dagre/lib/nesting-graph.js"(exports, module) {
      var _2 = require_lodash3();
      var util = require_util();
      module.exports = {
        run: run4,
        cleanup: cleanup2
      };
      function run4(g) {
        var root2 = util.addDummyNode(g, "root", {}, "_root");
        var depths = treeDepths2(g);
        var height = _2.max(_2.values(depths)) - 1;
        var nodeSep = 2 * height + 1;
        g.graph().nestingRoot = root2;
        _2.forEach(g.edges(), function(e) {
          g.edge(e).minlen *= nodeSep;
        });
        var weight = sumWeights2(g) + 1;
        _2.forEach(g.children(), function(child) {
          dfs4(g, root2, nodeSep, weight, height, depths, child);
        });
        g.graph().nodeRankFactor = nodeSep;
      }
      function dfs4(g, root2, nodeSep, weight, height, depths, v) {
        var children = g.children(v);
        if (!children.length) {
          if (v !== root2) {
            g.setEdge(root2, v, { weight: 0, minlen: nodeSep });
          }
          return;
        }
        var top = util.addBorderNode(g, "_bt");
        var bottom = util.addBorderNode(g, "_bb");
        var label = g.node(v);
        g.setParent(top, v);
        label.borderTop = top;
        g.setParent(bottom, v);
        label.borderBottom = bottom;
        _2.forEach(children, function(child) {
          dfs4(g, root2, nodeSep, weight, height, depths, child);
          var childNode = g.node(child);
          var childTop = childNode.borderTop ? childNode.borderTop : child;
          var childBottom = childNode.borderBottom ? childNode.borderBottom : child;
          var thisWeight = childNode.borderTop ? weight : 2 * weight;
          var minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;
          g.setEdge(top, childTop, {
            weight: thisWeight,
            minlen,
            nestingEdge: true
          });
          g.setEdge(childBottom, bottom, {
            weight: thisWeight,
            minlen,
            nestingEdge: true
          });
        });
        if (!g.parent(v)) {
          g.setEdge(root2, top, { weight: 0, minlen: height + depths[v] });
        }
      }
      function treeDepths2(g) {
        var depths = {};
        function dfs5(v, depth) {
          var children = g.children(v);
          if (children && children.length) {
            _2.forEach(children, function(child) {
              dfs5(child, depth + 1);
            });
          }
          depths[v] = depth;
        }
        _2.forEach(g.children(), function(v) {
          dfs5(v, 1);
        });
        return depths;
      }
      function sumWeights2(g) {
        return _2.reduce(g.edges(), function(acc, e) {
          return acc + g.edge(e).weight;
        }, 0);
      }
      function cleanup2(g) {
        var graphLabel = g.graph();
        g.removeNode(graphLabel.nestingRoot);
        delete graphLabel.nestingRoot;
        _2.forEach(g.edges(), function(e) {
          var edge = g.edge(e);
          if (edge.nestingEdge) {
            g.removeEdge(e);
          }
        });
      }
    }
  });

  // node_modules/dagre/lib/add-border-segments.js
  var require_add_border_segments = __commonJS({
    "node_modules/dagre/lib/add-border-segments.js"(exports, module) {
      var _2 = require_lodash3();
      var util = require_util();
      module.exports = addBorderSegments2;
      function addBorderSegments2(g) {
        function dfs4(v) {
          var children = g.children(v);
          var node = g.node(v);
          if (children.length) {
            _2.forEach(children, dfs4);
          }
          if (_2.has(node, "minRank")) {
            node.borderLeft = [];
            node.borderRight = [];
            for (var rank2 = node.minRank, maxRank2 = node.maxRank + 1; rank2 < maxRank2; ++rank2) {
              addBorderNode3(g, "borderLeft", "_bl", v, node, rank2);
              addBorderNode3(g, "borderRight", "_br", v, node, rank2);
            }
          }
        }
        _2.forEach(g.children(), dfs4);
      }
      function addBorderNode3(g, prop, prefix, sg, sgNode, rank2) {
        var label = { width: 0, height: 0, rank: rank2, borderType: prop };
        var prev = sgNode[prop][rank2 - 1];
        var curr = util.addDummyNode(g, "border", label, prefix);
        sgNode[prop][rank2] = curr;
        g.setParent(curr, sg);
        if (prev) {
          g.setEdge(prev, curr, { weight: 1 });
        }
      }
    }
  });

  // node_modules/dagre/lib/coordinate-system.js
  var require_coordinate_system = __commonJS({
    "node_modules/dagre/lib/coordinate-system.js"(exports, module) {
      "use strict";
      var _2 = require_lodash3();
      module.exports = {
        adjust: adjust2,
        undo: undo4
      };
      function adjust2(g) {
        var rankDir = g.graph().rankdir.toLowerCase();
        if (rankDir === "lr" || rankDir === "rl") {
          swapWidthHeight2(g);
        }
      }
      function undo4(g) {
        var rankDir = g.graph().rankdir.toLowerCase();
        if (rankDir === "bt" || rankDir === "rl") {
          reverseY2(g);
        }
        if (rankDir === "lr" || rankDir === "rl") {
          swapXY2(g);
          swapWidthHeight2(g);
        }
      }
      function swapWidthHeight2(g) {
        _2.forEach(g.nodes(), function(v) {
          swapWidthHeightOne2(g.node(v));
        });
        _2.forEach(g.edges(), function(e) {
          swapWidthHeightOne2(g.edge(e));
        });
      }
      function swapWidthHeightOne2(attrs) {
        var w = attrs.width;
        attrs.width = attrs.height;
        attrs.height = w;
      }
      function reverseY2(g) {
        _2.forEach(g.nodes(), function(v) {
          reverseYOne2(g.node(v));
        });
        _2.forEach(g.edges(), function(e) {
          var edge = g.edge(e);
          _2.forEach(edge.points, reverseYOne2);
          if (_2.has(edge, "y")) {
            reverseYOne2(edge);
          }
        });
      }
      function reverseYOne2(attrs) {
        attrs.y = -attrs.y;
      }
      function swapXY2(g) {
        _2.forEach(g.nodes(), function(v) {
          swapXYOne2(g.node(v));
        });
        _2.forEach(g.edges(), function(e) {
          var edge = g.edge(e);
          _2.forEach(edge.points, swapXYOne2);
          if (_2.has(edge, "x")) {
            swapXYOne2(edge);
          }
        });
      }
      function swapXYOne2(attrs) {
        var x3 = attrs.x;
        attrs.x = attrs.y;
        attrs.y = x3;
      }
    }
  });

  // node_modules/dagre/lib/order/init-order.js
  var require_init_order = __commonJS({
    "node_modules/dagre/lib/order/init-order.js"(exports, module) {
      "use strict";
      var _2 = require_lodash3();
      module.exports = initOrder2;
      function initOrder2(g) {
        var visited = {};
        var simpleNodes = _2.filter(g.nodes(), function(v) {
          return !g.children(v).length;
        });
        var maxRank2 = _2.max(_2.map(simpleNodes, function(v) {
          return g.node(v).rank;
        }));
        var layers = _2.map(_2.range(maxRank2 + 1), function() {
          return [];
        });
        function dfs4(v) {
          if (_2.has(visited, v)) return;
          visited[v] = true;
          var node = g.node(v);
          layers[node.rank].push(v);
          _2.forEach(g.successors(v), dfs4);
        }
        var orderedVs = _2.sortBy(simpleNodes, function(v) {
          return g.node(v).rank;
        });
        _2.forEach(orderedVs, dfs4);
        return layers;
      }
    }
  });

  // node_modules/dagre/lib/order/cross-count.js
  var require_cross_count = __commonJS({
    "node_modules/dagre/lib/order/cross-count.js"(exports, module) {
      "use strict";
      var _2 = require_lodash3();
      module.exports = crossCount2;
      function crossCount2(g, layering) {
        var cc = 0;
        for (var i = 1; i < layering.length; ++i) {
          cc += twoLayerCrossCount2(g, layering[i - 1], layering[i]);
        }
        return cc;
      }
      function twoLayerCrossCount2(g, northLayer, southLayer) {
        var southPos = _2.zipObject(
          southLayer,
          _2.map(southLayer, function(v, i) {
            return i;
          })
        );
        var southEntries = _2.flatten(_2.map(northLayer, function(v) {
          return _2.sortBy(_2.map(g.outEdges(v), function(e) {
            return { pos: southPos[e.w], weight: g.edge(e).weight };
          }), "pos");
        }), true);
        var firstIndex = 1;
        while (firstIndex < southLayer.length) firstIndex <<= 1;
        var treeSize = 2 * firstIndex - 1;
        firstIndex -= 1;
        var tree = _2.map(new Array(treeSize), function() {
          return 0;
        });
        var cc = 0;
        _2.forEach(southEntries.forEach(function(entry) {
          var index2 = entry.pos + firstIndex;
          tree[index2] += entry.weight;
          var weightSum = 0;
          while (index2 > 0) {
            if (index2 % 2) {
              weightSum += tree[index2 + 1];
            }
            index2 = index2 - 1 >> 1;
            tree[index2] += entry.weight;
          }
          cc += entry.weight * weightSum;
        }));
        return cc;
      }
    }
  });

  // node_modules/dagre/lib/order/barycenter.js
  var require_barycenter = __commonJS({
    "node_modules/dagre/lib/order/barycenter.js"(exports, module) {
      var _2 = require_lodash3();
      module.exports = barycenter2;
      function barycenter2(g, movable) {
        return _2.map(movable, function(v) {
          var inV = g.inEdges(v);
          if (!inV.length) {
            return { v };
          } else {
            var result = _2.reduce(inV, function(acc, e) {
              var edge = g.edge(e), nodeU = g.node(e.v);
              return {
                sum: acc.sum + edge.weight * nodeU.order,
                weight: acc.weight + edge.weight
              };
            }, { sum: 0, weight: 0 });
            return {
              v,
              barycenter: result.sum / result.weight,
              weight: result.weight
            };
          }
        });
      }
    }
  });

  // node_modules/dagre/lib/order/resolve-conflicts.js
  var require_resolve_conflicts = __commonJS({
    "node_modules/dagre/lib/order/resolve-conflicts.js"(exports, module) {
      "use strict";
      var _2 = require_lodash3();
      module.exports = resolveConflicts2;
      function resolveConflicts2(entries, cg) {
        var mappedEntries = {};
        _2.forEach(entries, function(entry, i) {
          var tmp2 = mappedEntries[entry.v] = {
            indegree: 0,
            "in": [],
            out: [],
            vs: [entry.v],
            i
          };
          if (!_2.isUndefined(entry.barycenter)) {
            tmp2.barycenter = entry.barycenter;
            tmp2.weight = entry.weight;
          }
        });
        _2.forEach(cg.edges(), function(e) {
          var entryV = mappedEntries[e.v];
          var entryW = mappedEntries[e.w];
          if (!_2.isUndefined(entryV) && !_2.isUndefined(entryW)) {
            entryW.indegree++;
            entryV.out.push(mappedEntries[e.w]);
          }
        });
        var sourceSet = _2.filter(mappedEntries, function(entry) {
          return !entry.indegree;
        });
        return doResolveConflicts2(sourceSet);
      }
      function doResolveConflicts2(sourceSet) {
        var entries = [];
        function handleIn(vEntry) {
          return function(uEntry) {
            if (uEntry.merged) {
              return;
            }
            if (_2.isUndefined(uEntry.barycenter) || _2.isUndefined(vEntry.barycenter) || uEntry.barycenter >= vEntry.barycenter) {
              mergeEntries2(vEntry, uEntry);
            }
          };
        }
        function handleOut(vEntry) {
          return function(wEntry) {
            wEntry["in"].push(vEntry);
            if (--wEntry.indegree === 0) {
              sourceSet.push(wEntry);
            }
          };
        }
        while (sourceSet.length) {
          var entry = sourceSet.pop();
          entries.push(entry);
          _2.forEach(entry["in"].reverse(), handleIn(entry));
          _2.forEach(entry.out, handleOut(entry));
        }
        return _2.map(
          _2.filter(entries, function(entry2) {
            return !entry2.merged;
          }),
          function(entry2) {
            return _2.pick(entry2, ["vs", "i", "barycenter", "weight"]);
          }
        );
      }
      function mergeEntries2(target, source) {
        var sum = 0;
        var weight = 0;
        if (target.weight) {
          sum += target.barycenter * target.weight;
          weight += target.weight;
        }
        if (source.weight) {
          sum += source.barycenter * source.weight;
          weight += source.weight;
        }
        target.vs = source.vs.concat(target.vs);
        target.barycenter = sum / weight;
        target.weight = weight;
        target.i = Math.min(source.i, target.i);
        source.merged = true;
      }
    }
  });

  // node_modules/dagre/lib/order/sort.js
  var require_sort = __commonJS({
    "node_modules/dagre/lib/order/sort.js"(exports, module) {
      var _2 = require_lodash3();
      var util = require_util();
      module.exports = sort2;
      function sort2(entries, biasRight) {
        var parts = util.partition(entries, function(entry) {
          return _2.has(entry, "barycenter");
        });
        var sortable = parts.lhs, unsortable = _2.sortBy(parts.rhs, function(entry) {
          return -entry.i;
        }), vs = [], sum = 0, weight = 0, vsIndex = 0;
        sortable.sort(compareWithBias2(!!biasRight));
        vsIndex = consumeUnsortable2(vs, unsortable, vsIndex);
        _2.forEach(sortable, function(entry) {
          vsIndex += entry.vs.length;
          vs.push(entry.vs);
          sum += entry.barycenter * entry.weight;
          weight += entry.weight;
          vsIndex = consumeUnsortable2(vs, unsortable, vsIndex);
        });
        var result = { vs: _2.flatten(vs, true) };
        if (weight) {
          result.barycenter = sum / weight;
          result.weight = weight;
        }
        return result;
      }
      function consumeUnsortable2(vs, unsortable, index2) {
        var last2;
        while (unsortable.length && (last2 = _2.last(unsortable)).i <= index2) {
          unsortable.pop();
          vs.push(last2.vs);
          index2++;
        }
        return index2;
      }
      function compareWithBias2(bias) {
        return function(entryV, entryW) {
          if (entryV.barycenter < entryW.barycenter) {
            return -1;
          } else if (entryV.barycenter > entryW.barycenter) {
            return 1;
          }
          return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
        };
      }
    }
  });

  // node_modules/dagre/lib/order/sort-subgraph.js
  var require_sort_subgraph = __commonJS({
    "node_modules/dagre/lib/order/sort-subgraph.js"(exports, module) {
      var _2 = require_lodash3();
      var barycenter2 = require_barycenter();
      var resolveConflicts2 = require_resolve_conflicts();
      var sort2 = require_sort();
      module.exports = sortSubgraph2;
      function sortSubgraph2(g, v, cg, biasRight) {
        var movable = g.children(v);
        var node = g.node(v);
        var bl = node ? node.borderLeft : void 0;
        var br = node ? node.borderRight : void 0;
        var subgraphs = {};
        if (bl) {
          movable = _2.filter(movable, function(w) {
            return w !== bl && w !== br;
          });
        }
        var barycenters = barycenter2(g, movable);
        _2.forEach(barycenters, function(entry) {
          if (g.children(entry.v).length) {
            var subgraphResult = sortSubgraph2(g, entry.v, cg, biasRight);
            subgraphs[entry.v] = subgraphResult;
            if (_2.has(subgraphResult, "barycenter")) {
              mergeBarycenters2(entry, subgraphResult);
            }
          }
        });
        var entries = resolveConflicts2(barycenters, cg);
        expandSubgraphs2(entries, subgraphs);
        var result = sort2(entries, biasRight);
        if (bl) {
          result.vs = _2.flatten([bl, result.vs, br], true);
          if (g.predecessors(bl).length) {
            var blPred = g.node(g.predecessors(bl)[0]), brPred = g.node(g.predecessors(br)[0]);
            if (!_2.has(result, "barycenter")) {
              result.barycenter = 0;
              result.weight = 0;
            }
            result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);
            result.weight += 2;
          }
        }
        return result;
      }
      function expandSubgraphs2(entries, subgraphs) {
        _2.forEach(entries, function(entry) {
          entry.vs = _2.flatten(entry.vs.map(function(v) {
            if (subgraphs[v]) {
              return subgraphs[v].vs;
            }
            return v;
          }), true);
        });
      }
      function mergeBarycenters2(target, other) {
        if (!_2.isUndefined(target.barycenter)) {
          target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
          target.weight += other.weight;
        } else {
          target.barycenter = other.barycenter;
          target.weight = other.weight;
        }
      }
    }
  });

  // node_modules/dagre/lib/order/build-layer-graph.js
  var require_build_layer_graph = __commonJS({
    "node_modules/dagre/lib/order/build-layer-graph.js"(exports, module) {
      var _2 = require_lodash3();
      var Graph4 = require_graphlib2().Graph;
      module.exports = buildLayerGraph2;
      function buildLayerGraph2(g, rank2, relationship) {
        var root2 = createRootNode2(g), result = new Graph4({ compound: true }).setGraph({ root: root2 }).setDefaultNodeLabel(function(v) {
          return g.node(v);
        });
        _2.forEach(g.nodes(), function(v) {
          var node = g.node(v), parent = g.parent(v);
          if (node.rank === rank2 || node.minRank <= rank2 && rank2 <= node.maxRank) {
            result.setNode(v);
            result.setParent(v, parent || root2);
            _2.forEach(g[relationship](v), function(e) {
              var u = e.v === v ? e.w : e.v, edge = result.edge(u, v), weight = !_2.isUndefined(edge) ? edge.weight : 0;
              result.setEdge(u, v, { weight: g.edge(e).weight + weight });
            });
            if (_2.has(node, "minRank")) {
              result.setNode(v, {
                borderLeft: node.borderLeft[rank2],
                borderRight: node.borderRight[rank2]
              });
            }
          }
        });
        return result;
      }
      function createRootNode2(g) {
        var v;
        while (g.hasNode(v = _2.uniqueId("_root"))) ;
        return v;
      }
    }
  });

  // node_modules/dagre/lib/order/add-subgraph-constraints.js
  var require_add_subgraph_constraints = __commonJS({
    "node_modules/dagre/lib/order/add-subgraph-constraints.js"(exports, module) {
      var _2 = require_lodash3();
      module.exports = addSubgraphConstraints2;
      function addSubgraphConstraints2(g, cg, vs) {
        var prev = {}, rootPrev;
        _2.forEach(vs, function(v) {
          var child = g.parent(v), parent, prevChild;
          while (child) {
            parent = g.parent(child);
            if (parent) {
              prevChild = prev[parent];
              prev[parent] = child;
            } else {
              prevChild = rootPrev;
              rootPrev = child;
            }
            if (prevChild && prevChild !== child) {
              cg.setEdge(prevChild, child);
              return;
            }
            child = parent;
          }
        });
      }
    }
  });

  // node_modules/dagre/lib/order/index.js
  var require_order = __commonJS({
    "node_modules/dagre/lib/order/index.js"(exports, module) {
      "use strict";
      var _2 = require_lodash3();
      var initOrder2 = require_init_order();
      var crossCount2 = require_cross_count();
      var sortSubgraph2 = require_sort_subgraph();
      var buildLayerGraph2 = require_build_layer_graph();
      var addSubgraphConstraints2 = require_add_subgraph_constraints();
      var Graph4 = require_graphlib2().Graph;
      var util = require_util();
      module.exports = order2;
      function order2(g) {
        var maxRank2 = util.maxRank(g), downLayerGraphs = buildLayerGraphs2(g, _2.range(1, maxRank2 + 1), "inEdges"), upLayerGraphs = buildLayerGraphs2(g, _2.range(maxRank2 - 1, -1, -1), "outEdges");
        var layering = initOrder2(g);
        assignOrder2(g, layering);
        var bestCC = Number.POSITIVE_INFINITY, best;
        for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
          sweepLayerGraphs2(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);
          layering = util.buildLayerMatrix(g);
          var cc = crossCount2(g, layering);
          if (cc < bestCC) {
            lastBest = 0;
            best = _2.cloneDeep(layering);
            bestCC = cc;
          }
        }
        assignOrder2(g, best);
      }
      function buildLayerGraphs2(g, ranks, relationship) {
        return _2.map(ranks, function(rank2) {
          return buildLayerGraph2(g, rank2, relationship);
        });
      }
      function sweepLayerGraphs2(layerGraphs, biasRight) {
        var cg = new Graph4();
        _2.forEach(layerGraphs, function(lg) {
          var root2 = lg.graph().root;
          var sorted = sortSubgraph2(lg, root2, cg, biasRight);
          _2.forEach(sorted.vs, function(v, i) {
            lg.node(v).order = i;
          });
          addSubgraphConstraints2(lg, cg, sorted.vs);
        });
      }
      function assignOrder2(g, layering) {
        _2.forEach(layering, function(layer) {
          _2.forEach(layer, function(v, i) {
            g.node(v).order = i;
          });
        });
      }
    }
  });

  // node_modules/dagre/lib/position/bk.js
  var require_bk = __commonJS({
    "node_modules/dagre/lib/position/bk.js"(exports, module) {
      "use strict";
      var _2 = require_lodash3();
      var Graph4 = require_graphlib2().Graph;
      var util = require_util();
      module.exports = {
        positionX: positionX2,
        findType1Conflicts: findType1Conflicts2,
        findType2Conflicts: findType2Conflicts2,
        addConflict: addConflict2,
        hasConflict: hasConflict2,
        verticalAlignment: verticalAlignment2,
        horizontalCompaction: horizontalCompaction2,
        alignCoordinates: alignCoordinates2,
        findSmallestWidthAlignment: findSmallestWidthAlignment2,
        balance: balance2
      };
      function findType1Conflicts2(g, layering) {
        var conflicts = {};
        function visitLayer(prevLayer, layer) {
          var k0 = 0, scanPos = 0, prevLayerLength = prevLayer.length, lastNode = _2.last(layer);
          _2.forEach(layer, function(v, i) {
            var w = findOtherInnerSegmentNode2(g, v), k1 = w ? g.node(w).order : prevLayerLength;
            if (w || v === lastNode) {
              _2.forEach(layer.slice(scanPos, i + 1), function(scanNode) {
                _2.forEach(g.predecessors(scanNode), function(u) {
                  var uLabel = g.node(u), uPos = uLabel.order;
                  if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy)) {
                    addConflict2(conflicts, u, scanNode);
                  }
                });
              });
              scanPos = i + 1;
              k0 = k1;
            }
          });
          return layer;
        }
        _2.reduce(layering, visitLayer);
        return conflicts;
      }
      function findType2Conflicts2(g, layering) {
        var conflicts = {};
        function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
          var v;
          _2.forEach(_2.range(southPos, southEnd), function(i) {
            v = south[i];
            if (g.node(v).dummy) {
              _2.forEach(g.predecessors(v), function(u) {
                var uNode = g.node(u);
                if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
                  addConflict2(conflicts, u, v);
                }
              });
            }
          });
        }
        function visitLayer(north, south) {
          var prevNorthPos = -1, nextNorthPos, southPos = 0;
          _2.forEach(south, function(v, southLookahead) {
            if (g.node(v).dummy === "border") {
              var predecessors = g.predecessors(v);
              if (predecessors.length) {
                nextNorthPos = g.node(predecessors[0]).order;
                scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
                southPos = southLookahead;
                prevNorthPos = nextNorthPos;
              }
            }
            scan(south, southPos, south.length, nextNorthPos, north.length);
          });
          return south;
        }
        _2.reduce(layering, visitLayer);
        return conflicts;
      }
      function findOtherInnerSegmentNode2(g, v) {
        if (g.node(v).dummy) {
          return _2.find(g.predecessors(v), function(u) {
            return g.node(u).dummy;
          });
        }
      }
      function addConflict2(conflicts, v, w) {
        if (v > w) {
          var tmp2 = v;
          v = w;
          w = tmp2;
        }
        var conflictsV = conflicts[v];
        if (!conflictsV) {
          conflicts[v] = conflictsV = {};
        }
        conflictsV[w] = true;
      }
      function hasConflict2(conflicts, v, w) {
        if (v > w) {
          var tmp2 = v;
          v = w;
          w = tmp2;
        }
        return _2.has(conflicts[v], w);
      }
      function verticalAlignment2(g, layering, conflicts, neighborFn) {
        var root2 = {}, align = {}, pos = {};
        _2.forEach(layering, function(layer) {
          _2.forEach(layer, function(v, order2) {
            root2[v] = v;
            align[v] = v;
            pos[v] = order2;
          });
        });
        _2.forEach(layering, function(layer) {
          var prevIdx = -1;
          _2.forEach(layer, function(v) {
            var ws = neighborFn(v);
            if (ws.length) {
              ws = _2.sortBy(ws, function(w2) {
                return pos[w2];
              });
              var mp = (ws.length - 1) / 2;
              for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {
                var w = ws[i];
                if (align[v] === v && prevIdx < pos[w] && !hasConflict2(conflicts, v, w)) {
                  align[w] = v;
                  align[v] = root2[v] = root2[w];
                  prevIdx = pos[w];
                }
              }
            }
          });
        });
        return { root: root2, align };
      }
      function horizontalCompaction2(g, layering, root2, align, reverseSep) {
        var xs = {}, blockG = buildBlockGraph2(g, layering, root2, reverseSep), borderType = reverseSep ? "borderLeft" : "borderRight";
        function iterate(setXsFunc, nextNodesFunc) {
          var stack = blockG.nodes();
          var elem = stack.pop();
          var visited = {};
          while (elem) {
            if (visited[elem]) {
              setXsFunc(elem);
            } else {
              visited[elem] = true;
              stack.push(elem);
              stack = stack.concat(nextNodesFunc(elem));
            }
            elem = stack.pop();
          }
        }
        function pass1(elem) {
          xs[elem] = blockG.inEdges(elem).reduce(function(acc, e) {
            return Math.max(acc, xs[e.v] + blockG.edge(e));
          }, 0);
        }
        function pass2(elem) {
          var min4 = blockG.outEdges(elem).reduce(function(acc, e) {
            return Math.min(acc, xs[e.w] - blockG.edge(e));
          }, Number.POSITIVE_INFINITY);
          var node = g.node(elem);
          if (min4 !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
            xs[elem] = Math.max(xs[elem], min4);
          }
        }
        iterate(pass1, blockG.predecessors.bind(blockG));
        iterate(pass2, blockG.successors.bind(blockG));
        _2.forEach(align, function(v) {
          xs[v] = xs[root2[v]];
        });
        return xs;
      }
      function buildBlockGraph2(g, layering, root2, reverseSep) {
        var blockGraph = new Graph4(), graphLabel = g.graph(), sepFn = sep2(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
        _2.forEach(layering, function(layer) {
          var u;
          _2.forEach(layer, function(v) {
            var vRoot = root2[v];
            blockGraph.setNode(vRoot);
            if (u) {
              var uRoot = root2[u], prevMax = blockGraph.edge(uRoot, vRoot);
              blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));
            }
            u = v;
          });
        });
        return blockGraph;
      }
      function findSmallestWidthAlignment2(g, xss) {
        return _2.minBy(_2.values(xss), function(xs) {
          var max4 = Number.NEGATIVE_INFINITY;
          var min4 = Number.POSITIVE_INFINITY;
          _2.forIn(xs, function(x3, v) {
            var halfWidth = width2(g, v) / 2;
            max4 = Math.max(x3 + halfWidth, max4);
            min4 = Math.min(x3 - halfWidth, min4);
          });
          return max4 - min4;
        });
      }
      function alignCoordinates2(xss, alignTo) {
        var alignToVals = _2.values(alignTo), alignToMin = _2.min(alignToVals), alignToMax = _2.max(alignToVals);
        _2.forEach(["u", "d"], function(vert) {
          _2.forEach(["l", "r"], function(horiz) {
            var alignment = vert + horiz, xs = xss[alignment], delta;
            if (xs === alignTo) return;
            var xsVals = _2.values(xs);
            delta = horiz === "l" ? alignToMin - _2.min(xsVals) : alignToMax - _2.max(xsVals);
            if (delta) {
              xss[alignment] = _2.mapValues(xs, function(x3) {
                return x3 + delta;
              });
            }
          });
        });
      }
      function balance2(xss, align) {
        return _2.mapValues(xss.ul, function(ignore, v) {
          if (align) {
            return xss[align.toLowerCase()][v];
          } else {
            var xs = _2.sortBy(_2.map(xss, v));
            return (xs[1] + xs[2]) / 2;
          }
        });
      }
      function positionX2(g) {
        var layering = util.buildLayerMatrix(g);
        var conflicts = _2.merge(
          findType1Conflicts2(g, layering),
          findType2Conflicts2(g, layering)
        );
        var xss = {};
        var adjustedLayering;
        _2.forEach(["u", "d"], function(vert) {
          adjustedLayering = vert === "u" ? layering : _2.values(layering).reverse();
          _2.forEach(["l", "r"], function(horiz) {
            if (horiz === "r") {
              adjustedLayering = _2.map(adjustedLayering, function(inner) {
                return _2.values(inner).reverse();
              });
            }
            var neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g);
            var align = verticalAlignment2(g, adjustedLayering, conflicts, neighborFn);
            var xs = horizontalCompaction2(
              g,
              adjustedLayering,
              align.root,
              align.align,
              horiz === "r"
            );
            if (horiz === "r") {
              xs = _2.mapValues(xs, function(x3) {
                return -x3;
              });
            }
            xss[vert + horiz] = xs;
          });
        });
        var smallestWidth = findSmallestWidthAlignment2(g, xss);
        alignCoordinates2(xss, smallestWidth);
        return balance2(xss, g.graph().align);
      }
      function sep2(nodeSep, edgeSep, reverseSep) {
        return function(g, v, w) {
          var vLabel = g.node(v);
          var wLabel = g.node(w);
          var sum = 0;
          var delta;
          sum += vLabel.width / 2;
          if (_2.has(vLabel, "labelpos")) {
            switch (vLabel.labelpos.toLowerCase()) {
              case "l":
                delta = -vLabel.width / 2;
                break;
              case "r":
                delta = vLabel.width / 2;
                break;
            }
          }
          if (delta) {
            sum += reverseSep ? delta : -delta;
          }
          delta = 0;
          sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
          sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;
          sum += wLabel.width / 2;
          if (_2.has(wLabel, "labelpos")) {
            switch (wLabel.labelpos.toLowerCase()) {
              case "l":
                delta = wLabel.width / 2;
                break;
              case "r":
                delta = -wLabel.width / 2;
                break;
            }
          }
          if (delta) {
            sum += reverseSep ? delta : -delta;
          }
          delta = 0;
          return sum;
        };
      }
      function width2(g, v) {
        return g.node(v).width;
      }
    }
  });

  // node_modules/dagre/lib/position/index.js
  var require_position = __commonJS({
    "node_modules/dagre/lib/position/index.js"(exports, module) {
      "use strict";
      var _2 = require_lodash3();
      var util = require_util();
      var positionX2 = require_bk().positionX;
      module.exports = position2;
      function position2(g) {
        g = util.asNonCompoundGraph(g);
        positionY2(g);
        _2.forEach(positionX2(g), function(x3, v) {
          g.node(v).x = x3;
        });
      }
      function positionY2(g) {
        var layering = util.buildLayerMatrix(g);
        var rankSep = g.graph().ranksep;
        var prevY = 0;
        _2.forEach(layering, function(layer) {
          var maxHeight = _2.max(_2.map(layer, function(v) {
            return g.node(v).height;
          }));
          _2.forEach(layer, function(v) {
            g.node(v).y = prevY + maxHeight / 2;
          });
          prevY += maxHeight + rankSep;
        });
      }
    }
  });

  // node_modules/dagre/lib/layout.js
  var require_layout = __commonJS({
    "node_modules/dagre/lib/layout.js"(exports, module) {
      "use strict";
      var _2 = require_lodash3();
      var acyclic = require_acyclic();
      var normalize5 = require_normalize();
      var rank2 = require_rank();
      var normalizeRanks2 = require_util().normalizeRanks;
      var parentDummyChains2 = require_parent_dummy_chains();
      var removeEmptyRanks2 = require_util().removeEmptyRanks;
      var nestingGraph = require_nesting_graph();
      var addBorderSegments2 = require_add_border_segments();
      var coordinateSystem = require_coordinate_system();
      var order2 = require_order();
      var position2 = require_position();
      var util = require_util();
      var Graph4 = require_graphlib2().Graph;
      module.exports = layout2;
      function layout2(g, opts) {
        var time = opts && opts.debugTiming ? util.time : util.notime;
        time("layout", function() {
          var layoutGraph = time("  buildLayoutGraph", function() {
            return buildLayoutGraph2(g);
          });
          time("  runLayout", function() {
            runLayout2(layoutGraph, time);
          });
          time("  updateInputGraph", function() {
            updateInputGraph2(g, layoutGraph);
          });
        });
      }
      function runLayout2(g, time) {
        time("    makeSpaceForEdgeLabels", function() {
          makeSpaceForEdgeLabels2(g);
        });
        time("    removeSelfEdges", function() {
          removeSelfEdges2(g);
        });
        time("    acyclic", function() {
          acyclic.run(g);
        });
        time("    nestingGraph.run", function() {
          nestingGraph.run(g);
        });
        time("    rank", function() {
          rank2(util.asNonCompoundGraph(g));
        });
        time("    injectEdgeLabelProxies", function() {
          injectEdgeLabelProxies2(g);
        });
        time("    removeEmptyRanks", function() {
          removeEmptyRanks2(g);
        });
        time("    nestingGraph.cleanup", function() {
          nestingGraph.cleanup(g);
        });
        time("    normalizeRanks", function() {
          normalizeRanks2(g);
        });
        time("    assignRankMinMax", function() {
          assignRankMinMax2(g);
        });
        time("    removeEdgeLabelProxies", function() {
          removeEdgeLabelProxies2(g);
        });
        time("    normalize.run", function() {
          normalize5.run(g);
        });
        time("    parentDummyChains", function() {
          parentDummyChains2(g);
        });
        time("    addBorderSegments", function() {
          addBorderSegments2(g);
        });
        time("    order", function() {
          order2(g);
        });
        time("    insertSelfEdges", function() {
          insertSelfEdges2(g);
        });
        time("    adjustCoordinateSystem", function() {
          coordinateSystem.adjust(g);
        });
        time("    position", function() {
          position2(g);
        });
        time("    positionSelfEdges", function() {
          positionSelfEdges2(g);
        });
        time("    removeBorderNodes", function() {
          removeBorderNodes2(g);
        });
        time("    normalize.undo", function() {
          normalize5.undo(g);
        });
        time("    fixupEdgeLabelCoords", function() {
          fixupEdgeLabelCoords2(g);
        });
        time("    undoCoordinateSystem", function() {
          coordinateSystem.undo(g);
        });
        time("    translateGraph", function() {
          translateGraph2(g);
        });
        time("    assignNodeIntersects", function() {
          assignNodeIntersects2(g);
        });
        time("    reversePoints", function() {
          reversePointsForReversedEdges2(g);
        });
        time("    acyclic.undo", function() {
          acyclic.undo(g);
        });
      }
      function updateInputGraph2(inputGraph, layoutGraph) {
        _2.forEach(inputGraph.nodes(), function(v) {
          var inputLabel = inputGraph.node(v);
          var layoutLabel = layoutGraph.node(v);
          if (inputLabel) {
            inputLabel.x = layoutLabel.x;
            inputLabel.y = layoutLabel.y;
            if (layoutGraph.children(v).length) {
              inputLabel.width = layoutLabel.width;
              inputLabel.height = layoutLabel.height;
            }
          }
        });
        _2.forEach(inputGraph.edges(), function(e) {
          var inputLabel = inputGraph.edge(e);
          var layoutLabel = layoutGraph.edge(e);
          inputLabel.points = layoutLabel.points;
          if (_2.has(layoutLabel, "x")) {
            inputLabel.x = layoutLabel.x;
            inputLabel.y = layoutLabel.y;
          }
        });
        inputGraph.graph().width = layoutGraph.graph().width;
        inputGraph.graph().height = layoutGraph.graph().height;
      }
      var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
      var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
      var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
      var nodeNumAttrs2 = ["width", "height"];
      var nodeDefaults2 = { width: 0, height: 0 };
      var edgeNumAttrs2 = ["minlen", "weight", "width", "height", "labeloffset"];
      var edgeDefaults2 = {
        minlen: 1,
        weight: 1,
        width: 0,
        height: 0,
        labeloffset: 10,
        labelpos: "r"
      };
      var edgeAttrs2 = ["labelpos"];
      function buildLayoutGraph2(inputGraph) {
        var g = new Graph4({ multigraph: true, compound: true });
        var graph = canonicalize2(inputGraph.graph());
        g.setGraph(_2.merge(
          {},
          graphDefaults,
          selectNumberAttrs2(graph, graphNumAttrs),
          _2.pick(graph, graphAttrs)
        ));
        _2.forEach(inputGraph.nodes(), function(v) {
          var node = canonicalize2(inputGraph.node(v));
          g.setNode(v, _2.defaults(selectNumberAttrs2(node, nodeNumAttrs2), nodeDefaults2));
          g.setParent(v, inputGraph.parent(v));
        });
        _2.forEach(inputGraph.edges(), function(e) {
          var edge = canonicalize2(inputGraph.edge(e));
          g.setEdge(e, _2.merge(
            {},
            edgeDefaults2,
            selectNumberAttrs2(edge, edgeNumAttrs2),
            _2.pick(edge, edgeAttrs2)
          ));
        });
        return g;
      }
      function makeSpaceForEdgeLabels2(g) {
        var graph = g.graph();
        graph.ranksep /= 2;
        _2.forEach(g.edges(), function(e) {
          var edge = g.edge(e);
          edge.minlen *= 2;
          if (edge.labelpos.toLowerCase() !== "c") {
            if (graph.rankdir === "TB" || graph.rankdir === "BT") {
              edge.width += edge.labeloffset;
            } else {
              edge.height += edge.labeloffset;
            }
          }
        });
      }
      function injectEdgeLabelProxies2(g) {
        _2.forEach(g.edges(), function(e) {
          var edge = g.edge(e);
          if (edge.width && edge.height) {
            var v = g.node(e.v);
            var w = g.node(e.w);
            var label = { rank: (w.rank - v.rank) / 2 + v.rank, e };
            util.addDummyNode(g, "edge-proxy", label, "_ep");
          }
        });
      }
      function assignRankMinMax2(g) {
        var maxRank2 = 0;
        _2.forEach(g.nodes(), function(v) {
          var node = g.node(v);
          if (node.borderTop) {
            node.minRank = g.node(node.borderTop).rank;
            node.maxRank = g.node(node.borderBottom).rank;
            maxRank2 = _2.max(maxRank2, node.maxRank);
          }
        });
        g.graph().maxRank = maxRank2;
      }
      function removeEdgeLabelProxies2(g) {
        _2.forEach(g.nodes(), function(v) {
          var node = g.node(v);
          if (node.dummy === "edge-proxy") {
            g.edge(node.e).labelRank = node.rank;
            g.removeNode(v);
          }
        });
      }
      function translateGraph2(g) {
        var minX = Number.POSITIVE_INFINITY;
        var maxX = 0;
        var minY = Number.POSITIVE_INFINITY;
        var maxY = 0;
        var graphLabel = g.graph();
        var marginX = graphLabel.marginx || 0;
        var marginY = graphLabel.marginy || 0;
        function getExtremes(attrs) {
          var x3 = attrs.x;
          var y3 = attrs.y;
          var w = attrs.width;
          var h = attrs.height;
          minX = Math.min(minX, x3 - w / 2);
          maxX = Math.max(maxX, x3 + w / 2);
          minY = Math.min(minY, y3 - h / 2);
          maxY = Math.max(maxY, y3 + h / 2);
        }
        _2.forEach(g.nodes(), function(v) {
          getExtremes(g.node(v));
        });
        _2.forEach(g.edges(), function(e) {
          var edge = g.edge(e);
          if (_2.has(edge, "x")) {
            getExtremes(edge);
          }
        });
        minX -= marginX;
        minY -= marginY;
        _2.forEach(g.nodes(), function(v) {
          var node = g.node(v);
          node.x -= minX;
          node.y -= minY;
        });
        _2.forEach(g.edges(), function(e) {
          var edge = g.edge(e);
          _2.forEach(edge.points, function(p) {
            p.x -= minX;
            p.y -= minY;
          });
          if (_2.has(edge, "x")) {
            edge.x -= minX;
          }
          if (_2.has(edge, "y")) {
            edge.y -= minY;
          }
        });
        graphLabel.width = maxX - minX + marginX;
        graphLabel.height = maxY - minY + marginY;
      }
      function assignNodeIntersects2(g) {
        _2.forEach(g.edges(), function(e) {
          var edge = g.edge(e);
          var nodeV = g.node(e.v);
          var nodeW = g.node(e.w);
          var p1, p2;
          if (!edge.points) {
            edge.points = [];
            p1 = nodeW;
            p2 = nodeV;
          } else {
            p1 = edge.points[0];
            p2 = edge.points[edge.points.length - 1];
          }
          edge.points.unshift(util.intersectRect(nodeV, p1));
          edge.points.push(util.intersectRect(nodeW, p2));
        });
      }
      function fixupEdgeLabelCoords2(g) {
        _2.forEach(g.edges(), function(e) {
          var edge = g.edge(e);
          if (_2.has(edge, "x")) {
            if (edge.labelpos === "l" || edge.labelpos === "r") {
              edge.width -= edge.labeloffset;
            }
            switch (edge.labelpos) {
              case "l":
                edge.x -= edge.width / 2 + edge.labeloffset;
                break;
              case "r":
                edge.x += edge.width / 2 + edge.labeloffset;
                break;
            }
          }
        });
      }
      function reversePointsForReversedEdges2(g) {
        _2.forEach(g.edges(), function(e) {
          var edge = g.edge(e);
          if (edge.reversed) {
            edge.points.reverse();
          }
        });
      }
      function removeBorderNodes2(g) {
        _2.forEach(g.nodes(), function(v) {
          if (g.children(v).length) {
            var node = g.node(v);
            var t = g.node(node.borderTop);
            var b = g.node(node.borderBottom);
            var l = g.node(_2.last(node.borderLeft));
            var r = g.node(_2.last(node.borderRight));
            node.width = Math.abs(r.x - l.x);
            node.height = Math.abs(b.y - t.y);
            node.x = l.x + node.width / 2;
            node.y = t.y + node.height / 2;
          }
        });
        _2.forEach(g.nodes(), function(v) {
          if (g.node(v).dummy === "border") {
            g.removeNode(v);
          }
        });
      }
      function removeSelfEdges2(g) {
        _2.forEach(g.edges(), function(e) {
          if (e.v === e.w) {
            var node = g.node(e.v);
            if (!node.selfEdges) {
              node.selfEdges = [];
            }
            node.selfEdges.push({ e, label: g.edge(e) });
            g.removeEdge(e);
          }
        });
      }
      function insertSelfEdges2(g) {
        var layers = util.buildLayerMatrix(g);
        _2.forEach(layers, function(layer) {
          var orderShift = 0;
          _2.forEach(layer, function(v, i) {
            var node = g.node(v);
            node.order = i + orderShift;
            _2.forEach(node.selfEdges, function(selfEdge) {
              util.addDummyNode(g, "selfedge", {
                width: selfEdge.label.width,
                height: selfEdge.label.height,
                rank: node.rank,
                order: i + ++orderShift,
                e: selfEdge.e,
                label: selfEdge.label
              }, "_se");
            });
            delete node.selfEdges;
          });
        });
      }
      function positionSelfEdges2(g) {
        _2.forEach(g.nodes(), function(v) {
          var node = g.node(v);
          if (node.dummy === "selfedge") {
            var selfNode = g.node(node.e.v);
            var x3 = selfNode.x + selfNode.width / 2;
            var y3 = selfNode.y;
            var dx = node.x - x3;
            var dy = selfNode.height / 2;
            g.setEdge(node.e, node.label);
            g.removeNode(v);
            node.label.points = [
              { x: x3 + 2 * dx / 3, y: y3 - dy },
              { x: x3 + 5 * dx / 6, y: y3 - dy },
              { x: x3 + dx, y: y3 },
              { x: x3 + 5 * dx / 6, y: y3 + dy },
              { x: x3 + 2 * dx / 3, y: y3 + dy }
            ];
            node.label.x = node.x;
            node.label.y = node.y;
          }
        });
      }
      function selectNumberAttrs2(obj, attrs) {
        return _2.mapValues(_2.pick(obj, attrs), Number);
      }
      function canonicalize2(attrs) {
        var newAttrs = {};
        _2.forEach(attrs, function(v, k) {
          newAttrs[k.toLowerCase()] = v;
        });
        return newAttrs;
      }
    }
  });

  // node_modules/dagre/lib/debug.js
  var require_debug = __commonJS({
    "node_modules/dagre/lib/debug.js"(exports, module) {
      var _2 = require_lodash3();
      var util = require_util();
      var Graph4 = require_graphlib2().Graph;
      module.exports = {
        debugOrdering
      };
      function debugOrdering(g) {
        var layerMatrix = util.buildLayerMatrix(g);
        var h = new Graph4({ compound: true, multigraph: true }).setGraph({});
        _2.forEach(g.nodes(), function(v) {
          h.setNode(v, { label: v });
          h.setParent(v, "layer" + g.node(v).rank);
        });
        _2.forEach(g.edges(), function(e) {
          h.setEdge(e.v, e.w, {}, e.name);
        });
        _2.forEach(layerMatrix, function(layer, i) {
          var layerV = "layer" + i;
          h.setNode(layerV, { rank: "same" });
          _2.reduce(layer, function(u, v) {
            h.setEdge(u, v, { style: "invis" });
            return v;
          });
        });
        return h;
      }
    }
  });

  // node_modules/dagre/lib/version.js
  var require_version2 = __commonJS({
    "node_modules/dagre/lib/version.js"(exports, module) {
      module.exports = "0.8.5";
    }
  });

  // node_modules/dagre/index.js
  var require_dagre = __commonJS({
    "node_modules/dagre/index.js"(exports, module) {
      module.exports = {
        graphlib: require_graphlib2(),
        layout: require_layout(),
        debug: require_debug(),
        util: {
          time: require_util().time,
          notime: require_util().notime
        },
        version: require_version2()
      };
    }
  });

  // node_modules/color-name/index.js
  var require_color_name = __commonJS({
    "node_modules/color-name/index.js"(exports, module) {
      "use strict";
      module.exports = {
        "aliceblue": [240, 248, 255],
        "antiquewhite": [250, 235, 215],
        "aqua": [0, 255, 255],
        "aquamarine": [127, 255, 212],
        "azure": [240, 255, 255],
        "beige": [245, 245, 220],
        "bisque": [255, 228, 196],
        "black": [0, 0, 0],
        "blanchedalmond": [255, 235, 205],
        "blue": [0, 0, 255],
        "blueviolet": [138, 43, 226],
        "brown": [165, 42, 42],
        "burlywood": [222, 184, 135],
        "cadetblue": [95, 158, 160],
        "chartreuse": [127, 255, 0],
        "chocolate": [210, 105, 30],
        "coral": [255, 127, 80],
        "cornflowerblue": [100, 149, 237],
        "cornsilk": [255, 248, 220],
        "crimson": [220, 20, 60],
        "cyan": [0, 255, 255],
        "darkblue": [0, 0, 139],
        "darkcyan": [0, 139, 139],
        "darkgoldenrod": [184, 134, 11],
        "darkgray": [169, 169, 169],
        "darkgreen": [0, 100, 0],
        "darkgrey": [169, 169, 169],
        "darkkhaki": [189, 183, 107],
        "darkmagenta": [139, 0, 139],
        "darkolivegreen": [85, 107, 47],
        "darkorange": [255, 140, 0],
        "darkorchid": [153, 50, 204],
        "darkred": [139, 0, 0],
        "darksalmon": [233, 150, 122],
        "darkseagreen": [143, 188, 143],
        "darkslateblue": [72, 61, 139],
        "darkslategray": [47, 79, 79],
        "darkslategrey": [47, 79, 79],
        "darkturquoise": [0, 206, 209],
        "darkviolet": [148, 0, 211],
        "deeppink": [255, 20, 147],
        "deepskyblue": [0, 191, 255],
        "dimgray": [105, 105, 105],
        "dimgrey": [105, 105, 105],
        "dodgerblue": [30, 144, 255],
        "firebrick": [178, 34, 34],
        "floralwhite": [255, 250, 240],
        "forestgreen": [34, 139, 34],
        "fuchsia": [255, 0, 255],
        "gainsboro": [220, 220, 220],
        "ghostwhite": [248, 248, 255],
        "gold": [255, 215, 0],
        "goldenrod": [218, 165, 32],
        "gray": [128, 128, 128],
        "green": [0, 128, 0],
        "greenyellow": [173, 255, 47],
        "grey": [128, 128, 128],
        "honeydew": [240, 255, 240],
        "hotpink": [255, 105, 180],
        "indianred": [205, 92, 92],
        "indigo": [75, 0, 130],
        "ivory": [255, 255, 240],
        "khaki": [240, 230, 140],
        "lavender": [230, 230, 250],
        "lavenderblush": [255, 240, 245],
        "lawngreen": [124, 252, 0],
        "lemonchiffon": [255, 250, 205],
        "lightblue": [173, 216, 230],
        "lightcoral": [240, 128, 128],
        "lightcyan": [224, 255, 255],
        "lightgoldenrodyellow": [250, 250, 210],
        "lightgray": [211, 211, 211],
        "lightgreen": [144, 238, 144],
        "lightgrey": [211, 211, 211],
        "lightpink": [255, 182, 193],
        "lightsalmon": [255, 160, 122],
        "lightseagreen": [32, 178, 170],
        "lightskyblue": [135, 206, 250],
        "lightslategray": [119, 136, 153],
        "lightslategrey": [119, 136, 153],
        "lightsteelblue": [176, 196, 222],
        "lightyellow": [255, 255, 224],
        "lime": [0, 255, 0],
        "limegreen": [50, 205, 50],
        "linen": [250, 240, 230],
        "magenta": [255, 0, 255],
        "maroon": [128, 0, 0],
        "mediumaquamarine": [102, 205, 170],
        "mediumblue": [0, 0, 205],
        "mediumorchid": [186, 85, 211],
        "mediumpurple": [147, 112, 219],
        "mediumseagreen": [60, 179, 113],
        "mediumslateblue": [123, 104, 238],
        "mediumspringgreen": [0, 250, 154],
        "mediumturquoise": [72, 209, 204],
        "mediumvioletred": [199, 21, 133],
        "midnightblue": [25, 25, 112],
        "mintcream": [245, 255, 250],
        "mistyrose": [255, 228, 225],
        "moccasin": [255, 228, 181],
        "navajowhite": [255, 222, 173],
        "navy": [0, 0, 128],
        "oldlace": [253, 245, 230],
        "olive": [128, 128, 0],
        "olivedrab": [107, 142, 35],
        "orange": [255, 165, 0],
        "orangered": [255, 69, 0],
        "orchid": [218, 112, 214],
        "palegoldenrod": [238, 232, 170],
        "palegreen": [152, 251, 152],
        "paleturquoise": [175, 238, 238],
        "palevioletred": [219, 112, 147],
        "papayawhip": [255, 239, 213],
        "peachpuff": [255, 218, 185],
        "peru": [205, 133, 63],
        "pink": [255, 192, 203],
        "plum": [221, 160, 221],
        "powderblue": [176, 224, 230],
        "purple": [128, 0, 128],
        "rebeccapurple": [102, 51, 153],
        "red": [255, 0, 0],
        "rosybrown": [188, 143, 143],
        "royalblue": [65, 105, 225],
        "saddlebrown": [139, 69, 19],
        "salmon": [250, 128, 114],
        "sandybrown": [244, 164, 96],
        "seagreen": [46, 139, 87],
        "seashell": [255, 245, 238],
        "sienna": [160, 82, 45],
        "silver": [192, 192, 192],
        "skyblue": [135, 206, 235],
        "slateblue": [106, 90, 205],
        "slategray": [112, 128, 144],
        "slategrey": [112, 128, 144],
        "snow": [255, 250, 250],
        "springgreen": [0, 255, 127],
        "steelblue": [70, 130, 180],
        "tan": [210, 180, 140],
        "teal": [0, 128, 128],
        "thistle": [216, 191, 216],
        "tomato": [255, 99, 71],
        "turquoise": [64, 224, 208],
        "violet": [238, 130, 238],
        "wheat": [245, 222, 179],
        "white": [255, 255, 255],
        "whitesmoke": [245, 245, 245],
        "yellow": [255, 255, 0],
        "yellowgreen": [154, 205, 50]
      };
    }
  });

  // node_modules/is-arrayish/index.js
  var require_is_arrayish = __commonJS({
    "node_modules/is-arrayish/index.js"(exports, module) {
      module.exports = function isArrayish(obj) {
        if (!obj || typeof obj === "string") {
          return false;
        }
        return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
      };
    }
  });

  // node_modules/simple-swizzle/index.js
  var require_simple_swizzle = __commonJS({
    "node_modules/simple-swizzle/index.js"(exports, module) {
      "use strict";
      var isArrayish = require_is_arrayish();
      var concat = Array.prototype.concat;
      var slice = Array.prototype.slice;
      var swizzle = module.exports = function swizzle2(args) {
        var results = [];
        for (var i = 0, len = args.length; i < len; i++) {
          var arg = args[i];
          if (isArrayish(arg)) {
            results = concat.call(results, slice.call(arg));
          } else {
            results.push(arg);
          }
        }
        return results;
      };
      swizzle.wrap = function(fn) {
        return function() {
          return fn(swizzle(arguments));
        };
      };
    }
  });

  // node_modules/color-string/index.js
  var require_color_string = __commonJS({
    "node_modules/color-string/index.js"(exports, module) {
      var colorNames = require_color_name();
      var swizzle = require_simple_swizzle();
      var hasOwnProperty = Object.hasOwnProperty;
      var reverseNames = /* @__PURE__ */ Object.create(null);
      for (name in colorNames) {
        if (hasOwnProperty.call(colorNames, name)) {
          reverseNames[colorNames[name]] = name;
        }
      }
      var name;
      var cs = module.exports = {
        to: {},
        get: {}
      };
      cs.get = function(string) {
        var prefix = string.substring(0, 3).toLowerCase();
        var val;
        var model;
        switch (prefix) {
          case "hsl":
            val = cs.get.hsl(string);
            model = "hsl";
            break;
          case "hwb":
            val = cs.get.hwb(string);
            model = "hwb";
            break;
          default:
            val = cs.get.rgb(string);
            model = "rgb";
            break;
        }
        if (!val) {
          return null;
        }
        return { model, value: val };
      };
      cs.get.rgb = function(string) {
        if (!string) {
          return null;
        }
        var abbr = /^#([a-f0-9]{3,4})$/i;
        var hex2 = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
        var rgba2 = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
        var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
        var keyword = /^(\w+)$/;
        var rgb2 = [0, 0, 0, 1];
        var match2;
        var i;
        var hexAlpha;
        if (match2 = string.match(hex2)) {
          hexAlpha = match2[2];
          match2 = match2[1];
          for (i = 0; i < 3; i++) {
            var i2 = i * 2;
            rgb2[i] = parseInt(match2.slice(i2, i2 + 2), 16);
          }
          if (hexAlpha) {
            rgb2[3] = parseInt(hexAlpha, 16) / 255;
          }
        } else if (match2 = string.match(abbr)) {
          match2 = match2[1];
          hexAlpha = match2[3];
          for (i = 0; i < 3; i++) {
            rgb2[i] = parseInt(match2[i] + match2[i], 16);
          }
          if (hexAlpha) {
            rgb2[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
          }
        } else if (match2 = string.match(rgba2)) {
          for (i = 0; i < 3; i++) {
            rgb2[i] = parseInt(match2[i + 1], 0);
          }
          if (match2[4]) {
            if (match2[5]) {
              rgb2[3] = parseFloat(match2[4]) * 0.01;
            } else {
              rgb2[3] = parseFloat(match2[4]);
            }
          }
        } else if (match2 = string.match(per)) {
          for (i = 0; i < 3; i++) {
            rgb2[i] = Math.round(parseFloat(match2[i + 1]) * 2.55);
          }
          if (match2[4]) {
            if (match2[5]) {
              rgb2[3] = parseFloat(match2[4]) * 0.01;
            } else {
              rgb2[3] = parseFloat(match2[4]);
            }
          }
        } else if (match2 = string.match(keyword)) {
          if (match2[1] === "transparent") {
            return [0, 0, 0, 0];
          }
          if (!hasOwnProperty.call(colorNames, match2[1])) {
            return null;
          }
          rgb2 = colorNames[match2[1]];
          rgb2[3] = 1;
          return rgb2;
        } else {
          return null;
        }
        for (i = 0; i < 3; i++) {
          rgb2[i] = clamp12(rgb2[i], 0, 255);
        }
        rgb2[3] = clamp12(rgb2[3], 0, 1);
        return rgb2;
      };
      cs.get.hsl = function(string) {
        if (!string) {
          return null;
        }
        var hsl2 = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
        var match2 = string.match(hsl2);
        if (match2) {
          var alpha = parseFloat(match2[4]);
          var h = (parseFloat(match2[1]) % 360 + 360) % 360;
          var s = clamp12(parseFloat(match2[2]), 0, 100);
          var l = clamp12(parseFloat(match2[3]), 0, 100);
          var a2 = clamp12(isNaN(alpha) ? 1 : alpha, 0, 1);
          return [h, s, l, a2];
        }
        return null;
      };
      cs.get.hwb = function(string) {
        if (!string) {
          return null;
        }
        var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
        var match2 = string.match(hwb);
        if (match2) {
          var alpha = parseFloat(match2[4]);
          var h = (parseFloat(match2[1]) % 360 + 360) % 360;
          var w = clamp12(parseFloat(match2[2]), 0, 100);
          var b = clamp12(parseFloat(match2[3]), 0, 100);
          var a2 = clamp12(isNaN(alpha) ? 1 : alpha, 0, 1);
          return [h, w, b, a2];
        }
        return null;
      };
      cs.to.hex = function() {
        var rgba2 = swizzle(arguments);
        return "#" + hexDouble(rgba2[0]) + hexDouble(rgba2[1]) + hexDouble(rgba2[2]) + (rgba2[3] < 1 ? hexDouble(Math.round(rgba2[3] * 255)) : "");
      };
      cs.to.rgb = function() {
        var rgba2 = swizzle(arguments);
        return rgba2.length < 4 || rgba2[3] === 1 ? "rgb(" + Math.round(rgba2[0]) + ", " + Math.round(rgba2[1]) + ", " + Math.round(rgba2[2]) + ")" : "rgba(" + Math.round(rgba2[0]) + ", " + Math.round(rgba2[1]) + ", " + Math.round(rgba2[2]) + ", " + rgba2[3] + ")";
      };
      cs.to.rgb.percent = function() {
        var rgba2 = swizzle(arguments);
        var r = Math.round(rgba2[0] / 255 * 100);
        var g = Math.round(rgba2[1] / 255 * 100);
        var b = Math.round(rgba2[2] / 255 * 100);
        return rgba2.length < 4 || rgba2[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba2[3] + ")";
      };
      cs.to.hsl = function() {
        var hsla2 = swizzle(arguments);
        return hsla2.length < 4 || hsla2[3] === 1 ? "hsl(" + hsla2[0] + ", " + hsla2[1] + "%, " + hsla2[2] + "%)" : "hsla(" + hsla2[0] + ", " + hsla2[1] + "%, " + hsla2[2] + "%, " + hsla2[3] + ")";
      };
      cs.to.hwb = function() {
        var hwba = swizzle(arguments);
        var a2 = "";
        if (hwba.length >= 4 && hwba[3] !== 1) {
          a2 = ", " + hwba[3];
        }
        return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a2 + ")";
      };
      cs.to.keyword = function(rgb2) {
        return reverseNames[rgb2.slice(0, 3)];
      };
      function clamp12(num, min4, max4) {
        return Math.min(Math.max(min4, num), max4);
      }
      function hexDouble(num) {
        var str = Math.round(num).toString(16).toUpperCase();
        return str.length < 2 ? "0" + str : str;
      }
    }
  });

  // node_modules/@babel/runtime/helpers/typeof.js
  var require_typeof = __commonJS({
    "node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
      function _typeof2(o) {
        "@babel/helpers - typeof";
        return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(o);
      }
      module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/toPrimitive.js
  var require_toPrimitive = __commonJS({
    "node_modules/@babel/runtime/helpers/toPrimitive.js"(exports, module) {
      var _typeof2 = require_typeof()["default"];
      function toPrimitive2(t, r) {
        if ("object" != _typeof2(t) || !t) return t;
        var e = t[Symbol.toPrimitive];
        if (void 0 !== e) {
          var i = e.call(t, r || "default");
          if ("object" != _typeof2(i)) return i;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === r ? String : Number)(t);
      }
      module.exports = toPrimitive2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/toPropertyKey.js
  var require_toPropertyKey = __commonJS({
    "node_modules/@babel/runtime/helpers/toPropertyKey.js"(exports, module) {
      var _typeof2 = require_typeof()["default"];
      var toPrimitive2 = require_toPrimitive();
      function toPropertyKey2(t) {
        var i = toPrimitive2(t, "string");
        return "symbol" == _typeof2(i) ? i : i + "";
      }
      module.exports = toPropertyKey2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/defineProperty.js
  var require_defineProperty2 = __commonJS({
    "node_modules/@babel/runtime/helpers/defineProperty.js"(exports, module) {
      var toPropertyKey2 = require_toPropertyKey();
      function _defineProperty2(e, r, t) {
        return (r = toPropertyKey2(r)) in e ? Object.defineProperty(e, r, {
          value: t,
          enumerable: true,
          configurable: true,
          writable: true
        }) : e[r] = t, e;
      }
      module.exports = _defineProperty2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/objectSpread2.js
  var require_objectSpread2 = __commonJS({
    "node_modules/@babel/runtime/helpers/objectSpread2.js"(exports, module) {
      var defineProperty = require_defineProperty2();
      function ownKeys3(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
          })), t.push.apply(t, o);
        }
        return t;
      }
      function _objectSpread22(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2 ? ownKeys3(Object(t), true).forEach(function(r2) {
            defineProperty(e, r2, t[r2]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys3(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
          });
        }
        return e;
      }
      module.exports = _objectSpread22, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/classCallCheck.js
  var require_classCallCheck = __commonJS({
    "node_modules/@babel/runtime/helpers/classCallCheck.js"(exports, module) {
      function _classCallCheck2(a2, n) {
        if (!(a2 instanceof n)) throw new TypeError("Cannot call a class as a function");
      }
      module.exports = _classCallCheck2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/createClass.js
  var require_createClass = __commonJS({
    "node_modules/@babel/runtime/helpers/createClass.js"(exports, module) {
      var toPropertyKey2 = require_toPropertyKey();
      function _defineProperties2(e, r) {
        for (var t = 0; t < r.length; t++) {
          var o = r[t];
          o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey2(o.key), o);
        }
      }
      function _createClass2(e, r, t) {
        return r && _defineProperties2(e.prototype, r), t && _defineProperties2(e, t), Object.defineProperty(e, "prototype", {
          writable: false
        }), e;
      }
      module.exports = _createClass2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/arrayLikeToArray.js
  var require_arrayLikeToArray = __commonJS({
    "node_modules/@babel/runtime/helpers/arrayLikeToArray.js"(exports, module) {
      function _arrayLikeToArray2(r, a2) {
        (null == a2 || a2 > r.length) && (a2 = r.length);
        for (var e = 0, n = Array(a2); e < a2; e++) n[e] = r[e];
        return n;
      }
      module.exports = _arrayLikeToArray2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/arrayWithoutHoles.js
  var require_arrayWithoutHoles = __commonJS({
    "node_modules/@babel/runtime/helpers/arrayWithoutHoles.js"(exports, module) {
      var arrayLikeToArray = require_arrayLikeToArray();
      function _arrayWithoutHoles2(r) {
        if (Array.isArray(r)) return arrayLikeToArray(r);
      }
      module.exports = _arrayWithoutHoles2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/iterableToArray.js
  var require_iterableToArray = __commonJS({
    "node_modules/@babel/runtime/helpers/iterableToArray.js"(exports, module) {
      function _iterableToArray2(r) {
        if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
      }
      module.exports = _iterableToArray2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js
  var require_unsupportedIterableToArray = __commonJS({
    "node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js"(exports, module) {
      var arrayLikeToArray = require_arrayLikeToArray();
      function _unsupportedIterableToArray2(r, a2) {
        if (r) {
          if ("string" == typeof r) return arrayLikeToArray(r, a2);
          var t = {}.toString.call(r).slice(8, -1);
          return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r, a2) : void 0;
        }
      }
      module.exports = _unsupportedIterableToArray2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/nonIterableSpread.js
  var require_nonIterableSpread = __commonJS({
    "node_modules/@babel/runtime/helpers/nonIterableSpread.js"(exports, module) {
      function _nonIterableSpread2() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      module.exports = _nonIterableSpread2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/toConsumableArray.js
  var require_toConsumableArray = __commonJS({
    "node_modules/@babel/runtime/helpers/toConsumableArray.js"(exports, module) {
      var arrayWithoutHoles = require_arrayWithoutHoles();
      var iterableToArray = require_iterableToArray();
      var unsupportedIterableToArray = require_unsupportedIterableToArray();
      var nonIterableSpread = require_nonIterableSpread();
      function _toConsumableArray2(r) {
        return arrayWithoutHoles(r) || iterableToArray(r) || unsupportedIterableToArray(r) || nonIterableSpread();
      }
      module.exports = _toConsumableArray2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/getPrototypeOf.js
  var require_getPrototypeOf = __commonJS({
    "node_modules/@babel/runtime/helpers/getPrototypeOf.js"(exports, module) {
      function _getPrototypeOf2(t) {
        return module.exports = _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
          return t2.__proto__ || Object.getPrototypeOf(t2);
        }, module.exports.__esModule = true, module.exports["default"] = module.exports, _getPrototypeOf2(t);
      }
      module.exports = _getPrototypeOf2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js
  var require_isNativeReflectConstruct = __commonJS({
    "node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js"(exports, module) {
      function _isNativeReflectConstruct2() {
        try {
          var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch (t2) {
        }
        return (module.exports = _isNativeReflectConstruct2 = function _isNativeReflectConstruct3() {
          return !!t;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
      }
      module.exports = _isNativeReflectConstruct2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/assertThisInitialized.js
  var require_assertThisInitialized = __commonJS({
    "node_modules/@babel/runtime/helpers/assertThisInitialized.js"(exports, module) {
      function _assertThisInitialized2(e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e;
      }
      module.exports = _assertThisInitialized2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
  var require_possibleConstructorReturn = __commonJS({
    "node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"(exports, module) {
      var _typeof2 = require_typeof()["default"];
      var assertThisInitialized = require_assertThisInitialized();
      function _possibleConstructorReturn2(t, e) {
        if (e && ("object" == _typeof2(e) || "function" == typeof e)) return e;
        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
        return assertThisInitialized(t);
      }
      module.exports = _possibleConstructorReturn2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/callSuper.js
  var require_callSuper = __commonJS({
    "node_modules/@babel/runtime/helpers/callSuper.js"(exports, module) {
      var getPrototypeOf = require_getPrototypeOf();
      var isNativeReflectConstruct = require_isNativeReflectConstruct();
      var possibleConstructorReturn = require_possibleConstructorReturn();
      function _callSuper2(t, o, e) {
        return o = getPrototypeOf(o), possibleConstructorReturn(t, isNativeReflectConstruct() ? Reflect.construct(o, e || [], getPrototypeOf(t).constructor) : o.apply(t, e));
      }
      module.exports = _callSuper2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/setPrototypeOf.js
  var require_setPrototypeOf = __commonJS({
    "node_modules/@babel/runtime/helpers/setPrototypeOf.js"(exports, module) {
      function _setPrototypeOf2(t, e) {
        return module.exports = _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e3) {
          return t2.__proto__ = e3, t2;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports, _setPrototypeOf2(t, e);
      }
      module.exports = _setPrototypeOf2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/inherits.js
  var require_inherits = __commonJS({
    "node_modules/@babel/runtime/helpers/inherits.js"(exports, module) {
      var setPrototypeOf = require_setPrototypeOf();
      function _inherits2(t, e) {
        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
        t.prototype = Object.create(e && e.prototype, {
          constructor: {
            value: t,
            writable: true,
            configurable: true
          }
        }), Object.defineProperty(t, "prototype", {
          writable: false
        }), e && setPrototypeOf(t, e);
      }
      module.exports = _inherits2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/arrayWithHoles.js
  var require_arrayWithHoles = __commonJS({
    "node_modules/@babel/runtime/helpers/arrayWithHoles.js"(exports, module) {
      function _arrayWithHoles2(r) {
        if (Array.isArray(r)) return r;
      }
      module.exports = _arrayWithHoles2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/iterableToArrayLimit.js
  var require_iterableToArrayLimit = __commonJS({
    "node_modules/@babel/runtime/helpers/iterableToArrayLimit.js"(exports, module) {
      function _iterableToArrayLimit2(r, l) {
        var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
        if (null != t) {
          var e, n, i, u, a2 = [], f = true, o = false;
          try {
            if (i = (t = t.call(r)).next, 0 === l) {
              if (Object(t) !== t) return;
              f = false;
            } else for (; !(f = (e = i.call(t)).done) && (a2.push(e.value), a2.length !== l); f = true) ;
          } catch (r2) {
            o = true, n = r2;
          } finally {
            try {
              if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
            } finally {
              if (o) throw n;
            }
          }
          return a2;
        }
      }
      module.exports = _iterableToArrayLimit2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/nonIterableRest.js
  var require_nonIterableRest = __commonJS({
    "node_modules/@babel/runtime/helpers/nonIterableRest.js"(exports, module) {
      function _nonIterableRest2() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      module.exports = _nonIterableRest2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/slicedToArray.js
  var require_slicedToArray = __commonJS({
    "node_modules/@babel/runtime/helpers/slicedToArray.js"(exports, module) {
      var arrayWithHoles = require_arrayWithHoles();
      var iterableToArrayLimit = require_iterableToArrayLimit();
      var unsupportedIterableToArray = require_unsupportedIterableToArray();
      var nonIterableRest = require_nonIterableRest();
      function _slicedToArray2(r, e) {
        return arrayWithHoles(r) || iterableToArrayLimit(r, e) || unsupportedIterableToArray(r, e) || nonIterableRest();
      }
      module.exports = _slicedToArray2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/readOnlyError.js
  var require_readOnlyError = __commonJS({
    "node_modules/@babel/runtime/helpers/readOnlyError.js"(exports, module) {
      function _readOnlyError(r) {
        throw new TypeError('"' + r + '" is read-only');
      }
      module.exports = _readOnlyError, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/superPropBase.js
  var require_superPropBase = __commonJS({
    "node_modules/@babel/runtime/helpers/superPropBase.js"(exports, module) {
      var getPrototypeOf = require_getPrototypeOf();
      function _superPropBase2(t, o) {
        for (; !{}.hasOwnProperty.call(t, o) && null !== (t = getPrototypeOf(t)); ) ;
        return t;
      }
      module.exports = _superPropBase2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/get.js
  var require_get3 = __commonJS({
    "node_modules/@babel/runtime/helpers/get.js"(exports, module) {
      var superPropBase = require_superPropBase();
      function _get2() {
        return module.exports = _get2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {
          var p = superPropBase(e, t);
          if (p) {
            var n = Object.getOwnPropertyDescriptor(p, t);
            return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
          }
        }, module.exports.__esModule = true, module.exports["default"] = module.exports, _get2.apply(null, arguments);
      }
      module.exports = _get2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/superPropGet.js
  var require_superPropGet = __commonJS({
    "node_modules/@babel/runtime/helpers/superPropGet.js"(exports, module) {
      var get9 = require_get3();
      var getPrototypeOf = require_getPrototypeOf();
      function _superPropGet2(t, o, e, r) {
        var p = get9(getPrototypeOf(1 & r ? t.prototype : t), o, e);
        return 2 & r && "function" == typeof p ? function(t2) {
          return p.apply(e, t2);
        } : p;
      }
      module.exports = _superPropGet2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@antv/g-math/dist/index.js
  var require_dist = __commonJS({
    "node_modules/@antv/g-math/dist/index.js"(exports) {
      "use strict";
      var _slicedToArray2 = require_slicedToArray();
      var _toConsumableArray2 = require_toConsumableArray();
      var util = require_lib();
      var glMatrix = require_cjs();
      function distance6(x1, y1, x22, y22) {
        var dx = x1 - x22;
        var dy = y1 - y22;
        return Math.sqrt(dx * dx + dy * dy);
      }
      function getBBoxByArray2(xArr, yArr) {
        var minX = Math.min.apply(Math, _toConsumableArray2(xArr));
        var minY = Math.min.apply(Math, _toConsumableArray2(yArr));
        var maxX = Math.max.apply(Math, _toConsumableArray2(xArr));
        var maxY = Math.max.apply(Math, _toConsumableArray2(yArr));
        return {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        };
      }
      function piMod(angle2) {
        return (angle2 + Math.PI * 2) % (Math.PI * 2);
      }
      function copysign(v1, v2) {
        var absv = Math.abs(v1);
        return v2 > 0 ? absv : absv * -1;
      }
      function nearestPoint$4(x3, y3, rx, ry, x0, y0) {
        var a2 = rx;
        var b = ry;
        if (a2 === 0 || b === 0) {
          return {
            x: x3,
            y: y3
          };
        }
        var relativeX = x0 - x3;
        var relativeY = y0 - y3;
        var px = Math.abs(relativeX);
        var py = Math.abs(relativeY);
        var squareA = a2 * a2;
        var squareB = b * b;
        var t = Math.PI / 4;
        var nearestX = 0;
        var nearestY = 0;
        for (var i = 0; i < 4; i++) {
          nearestX = a2 * Math.cos(t);
          nearestY = b * Math.sin(t);
          var ex = (squareA - squareB) * Math.pow(Math.cos(t), 3) / a2;
          var ey = (squareB - squareA) * Math.pow(Math.sin(t), 3) / b;
          var rx1 = nearestX - ex;
          var ry1 = nearestY - ey;
          var qx = px - ex;
          var qy = py - ey;
          var r = Math.hypot(ry1, rx1);
          var q = Math.hypot(qy, qx);
          var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));
          var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);
          t += delta_t;
          t = Math.min(Math.PI / 2, Math.max(0, t));
        }
        return {
          x: x3 + copysign(nearestX, relativeX),
          y: y3 + copysign(nearestY, relativeY)
        };
      }
      function derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle2) {
        return -1 * rx * Math.cos(xRotation) * Math.sin(angle2) - ry * Math.sin(xRotation) * Math.cos(angle2);
      }
      function derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle2) {
        return -1 * rx * Math.sin(xRotation) * Math.sin(angle2) + ry * Math.cos(xRotation) * Math.cos(angle2);
      }
      function xExtrema2(rx, ry, xRotation) {
        return Math.atan(-ry / rx * Math.tan(xRotation));
      }
      function yExtrema2(rx, ry, xRotation) {
        return Math.atan(ry / (rx * Math.tan(xRotation)));
      }
      function xAt2(cx, cy, rx, ry, xRotation, angle2) {
        return rx * Math.cos(xRotation) * Math.cos(angle2) - ry * Math.sin(xRotation) * Math.sin(angle2) + cx;
      }
      function yAt2(cx, cy, rx, ry, xRotation, angle2) {
        return rx * Math.sin(xRotation) * Math.cos(angle2) + ry * Math.cos(xRotation) * Math.sin(angle2) + cy;
      }
      function getAngle3(rx, ry, x0, y0) {
        var angle2 = Math.atan2(y0 * rx, x0 * ry);
        return (angle2 + Math.PI * 2) % (Math.PI * 2);
      }
      function getPoint(rx, ry, angle2) {
        return {
          x: rx * Math.cos(angle2),
          y: ry * Math.sin(angle2)
        };
      }
      function rotate3(x3, y3, angle2) {
        var cos = Math.cos(angle2);
        var sin = Math.sin(angle2);
        return [x3 * cos - y3 * sin, x3 * sin + y3 * cos];
      }
      function box$52(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
        var xDim = xExtrema2(rx, ry, xRotation);
        var minX = Infinity;
        var maxX = -Infinity;
        var xs = [startAngle, endAngle];
        for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
          var xAngle = xDim + i;
          if (startAngle < endAngle) {
            if (startAngle < xAngle && xAngle < endAngle) {
              xs.push(xAngle);
            }
          } else if (endAngle < xAngle && xAngle < startAngle) {
            xs.push(xAngle);
          }
        }
        for (var _i = 0; _i < xs.length; _i++) {
          var x3 = xAt2(cx, cy, rx, ry, xRotation, xs[_i]);
          if (x3 < minX) {
            minX = x3;
          }
          if (x3 > maxX) {
            maxX = x3;
          }
        }
        var yDim = yExtrema2(rx, ry, xRotation);
        var minY = Infinity;
        var maxY = -Infinity;
        var ys = [startAngle, endAngle];
        for (var _i2 = -Math.PI * 2; _i2 <= Math.PI * 2; _i2 += Math.PI) {
          var yAngle = yDim + _i2;
          if (startAngle < endAngle) {
            if (startAngle < yAngle && yAngle < endAngle) {
              ys.push(yAngle);
            }
          } else if (endAngle < yAngle && yAngle < startAngle) {
            ys.push(yAngle);
          }
        }
        for (var _i3 = 0; _i3 < ys.length; _i3++) {
          var y3 = yAt2(cx, cy, rx, ry, xRotation, ys[_i3]);
          if (y3 < minY) {
            minY = y3;
          }
          if (y3 > maxY) {
            maxY = y3;
          }
        }
        return {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        };
      }
      function nearestPoint$3(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
        var relativeVector = rotate3(x0 - cx, y0 - cy, -xRotation);
        var _relativeVector = _slicedToArray2(relativeVector, 2), x1 = _relativeVector[0], y1 = _relativeVector[1];
        var relativePoint = nearestPoint$4(0, 0, rx, ry, x1, y1);
        var angle2 = getAngle3(rx, ry, relativePoint.x, relativePoint.y);
        if (angle2 < startAngle) {
          relativePoint = getPoint(rx, ry, startAngle);
        } else if (angle2 > endAngle) {
          relativePoint = getPoint(rx, ry, endAngle);
        }
        var vector = rotate3(relativePoint.x, relativePoint.y, xRotation);
        return {
          x: vector[0] + cx,
          y: vector[1] + cy
        };
      }
      function tangentAngle$4(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
        var angle2 = (endAngle - startAngle) * t + startAngle;
        var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle2);
        var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle2);
        return piMod(Math.atan2(dy, dx));
      }
      var EPSILON3 = 1e-4;
      function nearestPoint$22(xArr, yArr, x3, y3, tCallback, length2) {
        var t = -1;
        var d2 = Infinity;
        var v0 = [x3, y3];
        var segNum = 20;
        if (length2 && length2 > 200) {
          segNum = length2 / 10;
        }
        var increaseRate = 1 / segNum;
        var interval2 = increaseRate / 10;
        for (var i = 0; i <= segNum; i++) {
          var _t = i * increaseRate;
          var v1 = [tCallback.apply(void 0, _toConsumableArray2(xArr.concat([_t]))), tCallback.apply(void 0, _toConsumableArray2(yArr.concat([_t])))];
          var d1 = distance6(v0[0], v0[1], v1[0], v1[1]);
          if (d1 < d2) {
            t = _t;
            d2 = d1;
          }
        }
        if (t === 0) {
          return {
            x: xArr[0],
            y: yArr[0]
          };
        }
        if (t === 1) {
          var count = xArr.length;
          return {
            x: xArr[count - 1],
            y: yArr[count - 1]
          };
        }
        d2 = Infinity;
        for (var _i = 0; _i < 32; _i++) {
          if (interval2 < EPSILON3) {
            break;
          }
          var prev = t - interval2;
          var next = t + interval2;
          var _v = [tCallback.apply(void 0, _toConsumableArray2(xArr.concat([prev]))), tCallback.apply(void 0, _toConsumableArray2(yArr.concat([prev])))];
          var _d = distance6(v0[0], v0[1], _v[0], _v[1]);
          if (prev >= 0 && _d < d2) {
            t = prev;
            d2 = _d;
          } else {
            var v2 = [tCallback.apply(void 0, _toConsumableArray2(xArr.concat([next]))), tCallback.apply(void 0, _toConsumableArray2(yArr.concat([next])))];
            var d22 = distance6(v0[0], v0[1], v2[0], v2[1]);
            if (next <= 1 && d22 < d2) {
              t = next;
              d2 = d22;
            } else {
              interval2 *= 0.5;
            }
          }
        }
        return {
          x: tCallback.apply(void 0, _toConsumableArray2(xArr.concat([t]))),
          y: tCallback.apply(void 0, _toConsumableArray2(yArr.concat([t])))
        };
      }
      function snapLength(xArr, yArr) {
        var totalLength = 0;
        var count = xArr.length;
        for (var i = 0; i < count; i++) {
          var x3 = xArr[i];
          var y3 = yArr[i];
          var nextX = xArr[(i + 1) % count];
          var nextY = yArr[(i + 1) % count];
          totalLength += distance6(x3, y3, nextX, nextY);
        }
        return totalLength / 2;
      }
      function box$4(x1, y1, x22, y22) {
        return getBBoxByArray2([x1, x22], [y1, y22]);
      }
      function length$42(x1, y1, x22, y22) {
        return distance6(x1, y1, x22, y22);
      }
      function pointAt$32(x1, y1, x22, y22, t) {
        return {
          x: (1 - t) * x1 + t * x22,
          y: (1 - t) * y1 + t * y22
        };
      }
      function pointDistance$4(x1, y1, x22, y22, x3, y3) {
        var cross3 = (x22 - x1) * (x3 - x1) + (y22 - y1) * (y3 - y1);
        if (cross3 < 0) {
          return distance6(x1, y1, x3, y3);
        }
        var lengthSquare = (x22 - x1) * (x22 - x1) + (y22 - y1) * (y22 - y1);
        if (cross3 > lengthSquare) {
          return distance6(x22, y22, x3, y3);
        }
        return pointToLine2(x1, y1, x22, y22, x3, y3);
      }
      function pointToLine2(x1, y1, x22, y22, x3, y3) {
        var d2 = [x22 - x1, y22 - y1];
        if (glMatrix.vec2.exactEquals(d2, [0, 0])) {
          return Math.sqrt((x3 - x1) * (x3 - x1) + (y3 - y1) * (y3 - y1));
        }
        var u = [-d2[1], d2[0]];
        glMatrix.vec2.normalize(u, u);
        var a2 = [x3 - x1, y3 - y1];
        return Math.abs(glMatrix.vec2.dot(a2, u));
      }
      function tangentAngle$3(x1, y1, x22, y22) {
        return Math.atan2(y22 - y1, x22 - x1);
      }
      function cubicAt2(p0, p1, p2, p3, t) {
        var onet = 1 - t;
        return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;
      }
      function derivativeAt(p0, p1, p2, p3, t) {
        var onet = 1 - t;
        return 3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2));
      }
      function extrema$12(p0, p1, p2, p3) {
        var a2 = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
        var b = 6 * p0 - 12 * p1 + 6 * p2;
        var c2 = 3 * p1 - 3 * p0;
        var extremas = [];
        var t1;
        var t2;
        var discSqrt;
        if (util.isNumberEqual(a2, 0)) {
          if (!util.isNumberEqual(b, 0)) {
            t1 = -c2 / b;
            if (t1 >= 0 && t1 <= 1) {
              extremas.push(t1);
            }
          }
        } else {
          var disc = b * b - 4 * a2 * c2;
          if (util.isNumberEqual(disc, 0)) {
            extremas.push(-b / (2 * a2));
          } else if (disc > 0) {
            discSqrt = Math.sqrt(disc);
            t1 = (-b + discSqrt) / (2 * a2);
            t2 = (-b - discSqrt) / (2 * a2);
            if (t1 >= 0 && t1 <= 1) {
              extremas.push(t1);
            }
            if (t2 >= 0 && t2 <= 1) {
              extremas.push(t2);
            }
          }
        }
        return extremas;
      }
      function divideCubic(x1, y1, x22, y22, x3, y3, x4, y4, t) {
        var xt = cubicAt2(x1, x22, x3, x4, t);
        var yt = cubicAt2(y1, y22, y3, y4, t);
        var c1 = pointAt$32(x1, y1, x22, y22, t);
        var c2 = pointAt$32(x22, y22, x3, y3, t);
        var c3 = pointAt$32(x3, y3, x4, y4, t);
        var c12 = pointAt$32(c1.x, c1.y, c2.x, c2.y, t);
        var c23 = pointAt$32(c2.x, c2.y, c3.x, c3.y, t);
        return [[x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt], [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4]];
      }
      function cubicLength(x1, y1, x22, y22, x3, y3, x4, y4, iterationCount) {
        if (iterationCount === 0) {
          return snapLength([x1, x22, x3, x4], [y1, y22, y3, y4]);
        }
        var cubics = divideCubic(x1, y1, x22, y22, x3, y3, x4, y4, 0.5);
        var left = [].concat(_toConsumableArray2(cubics[0]), [iterationCount - 1]);
        var right = [].concat(_toConsumableArray2(cubics[1]), [iterationCount - 1]);
        return cubicLength.apply(void 0, _toConsumableArray2(left)) + cubicLength.apply(void 0, _toConsumableArray2(right));
      }
      function box$32(x1, y1, x22, y22, x3, y3, x4, y4) {
        var xArr = [x1, x4];
        var yArr = [y1, y4];
        var xExtrema3 = extrema$12(x1, x22, x3, x4);
        var yExtrema3 = extrema$12(y1, y22, y3, y4);
        for (var i = 0; i < xExtrema3.length; i++) {
          xArr.push(cubicAt2(x1, x22, x3, x4, xExtrema3[i]));
        }
        for (var _i = 0; _i < yExtrema3.length; _i++) {
          yArr.push(cubicAt2(y1, y22, y3, y4, yExtrema3[_i]));
        }
        return getBBoxByArray2(xArr, yArr);
      }
      function length$3(x1, y1, x22, y22, x3, y3, x4, y4) {
        return cubicLength(x1, y1, x22, y22, x3, y3, x4, y4, 3);
      }
      function nearestPoint$12(x1, y1, x22, y22, x3, y3, x4, y4, x0, y0, length2) {
        return nearestPoint$22([x1, x22, x3, x4], [y1, y22, y3, y4], x0, y0, cubicAt2, length2);
      }
      function pointDistance$32(x1, y1, x22, y22, x3, y3, x4, y4, x0, y0, length2) {
        var point4 = nearestPoint$12(x1, y1, x22, y22, x3, y3, x4, y4, x0, y0, length2);
        return distance6(point4.x, point4.y, x0, y0);
      }
      function pointAt$2(x1, y1, x22, y22, x3, y3, x4, y4, t) {
        return {
          x: cubicAt2(x1, x22, x3, x4, t),
          y: cubicAt2(y1, y22, y3, y4, t)
        };
      }
      function tangentAngle$2(x1, y1, x22, y22, x3, y3, x4, y4, t) {
        var dx = derivativeAt(x1, x22, x3, x4, t);
        var dy = derivativeAt(y1, y22, y3, y4, t);
        return piMod(Math.atan2(dy, dx));
      }
      function analyzePoints(points) {
        var totalLength = 0;
        var segments = [];
        for (var i = 0; i < points.length - 1; i++) {
          var from = points[i];
          var to = points[i + 1];
          var length2 = distance6(from[0], from[1], to[0], to[1]);
          var seg = {
            from,
            to,
            length: length2
          };
          segments.push(seg);
          totalLength += length2;
        }
        return {
          segments,
          totalLength
        };
      }
      function lengthOfSegment2(points) {
        if (points.length < 2) {
          return 0;
        }
        var totalLength = 0;
        for (var i = 0; i < points.length - 1; i++) {
          var from = points[i];
          var to = points[i + 1];
          totalLength += distance6(from[0], from[1], to[0], to[1]);
        }
        return totalLength;
      }
      function pointAtSegments(points, t) {
        if (t > 1 || t < 0 || points.length < 2) {
          return null;
        }
        var _analyzePoints = analyzePoints(points), segments = _analyzePoints.segments, totalLength = _analyzePoints.totalLength;
        if (totalLength === 0) {
          return {
            x: points[0][0],
            y: points[0][1]
          };
        }
        var startRatio = 0;
        var point4 = null;
        for (var i = 0; i < segments.length; i++) {
          var seg = segments[i];
          var from = seg.from, to = seg.to;
          var currentRatio = seg.length / totalLength;
          if (t >= startRatio && t <= startRatio + currentRatio) {
            var localRatio = (t - startRatio) / currentRatio;
            point4 = pointAt$32(from[0], from[1], to[0], to[1], localRatio);
            break;
          }
          startRatio += currentRatio;
        }
        return point4;
      }
      function angleAtSegments(points, t) {
        if (t > 1 || t < 0 || points.length < 2) {
          return 0;
        }
        var _analyzePoints2 = analyzePoints(points), segments = _analyzePoints2.segments, totalLength = _analyzePoints2.totalLength;
        var startRatio = 0;
        var angle2 = 0;
        for (var i = 0; i < segments.length; i++) {
          var seg = segments[i];
          var from = seg.from, to = seg.to;
          var currentRatio = seg.length / totalLength;
          if (t >= startRatio && t <= startRatio + currentRatio) {
            angle2 = Math.atan2(to[1] - from[1], to[0] - from[0]);
            break;
          }
          startRatio += currentRatio;
        }
        return angle2;
      }
      function distanceAtSegment(points, x3, y3) {
        var minDistance = Infinity;
        for (var i = 0; i < points.length - 1; i++) {
          var point4 = points[i];
          var nextPoint = points[i + 1];
          var _distance = pointDistance$4(point4[0], point4[1], nextPoint[0], nextPoint[1], x3, y3);
          if (_distance < minDistance) {
            minDistance = _distance;
          }
        }
        return minDistance;
      }
      function box$2(points) {
        var xArr = [];
        var yArr = [];
        for (var i = 0; i < points.length; i++) {
          var point4 = points[i];
          xArr.push(point4[0]);
          yArr.push(point4[1]);
        }
        return getBBoxByArray2(xArr, yArr);
      }
      function length$22(points) {
        return lengthOfSegment2(points);
      }
      function pointAt$1(points, t) {
        return pointAtSegments(points, t);
      }
      function pointDistance$2(points, x3, y3) {
        return distanceAtSegment(points, x3, y3);
      }
      function tangentAngle$1(points, t) {
        return angleAtSegments(points, t);
      }
      function getAllPoints(points) {
        var tmp2 = points.slice(0);
        if (points.length) {
          tmp2.push(points[0]);
        }
        return tmp2;
      }
      function box$1(points) {
        return box$2(points);
      }
      function length$1(points) {
        return lengthOfSegment2(getAllPoints(points));
      }
      function pointAt(points, t) {
        return pointAtSegments(getAllPoints(points), t);
      }
      function pointDistance$1(points, x3, y3) {
        return distanceAtSegment(getAllPoints(points), x3, y3);
      }
      function tangentAngle(points, t) {
        return angleAtSegments(getAllPoints(points), t);
      }
      function quadraticAt2(p0, p1, p2, t) {
        var onet = 1 - t;
        return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
      }
      function extrema2(p0, p1, p2) {
        var a2 = p0 + p2 - 2 * p1;
        if (util.isNumberEqual(a2, 0)) {
          return [0.5];
        }
        var rst = (p0 - p1) / a2;
        if (rst <= 1 && rst >= 0) {
          return [rst];
        }
        return [];
      }
      function divideQuadratic(x1, y1, x22, y22, x3, y3, t) {
        var xt = quadraticAt2(x1, x22, x3, t);
        var yt = quadraticAt2(y1, y22, y3, t);
        var controlPoint1 = pointAt$32(x1, y1, x22, y22, t);
        var controlPoint2 = pointAt$32(x22, y22, x3, y3, t);
        return [[x1, y1, controlPoint1.x, controlPoint1.y, xt, yt], [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3]];
      }
      function quadraticLength(x1, y1, x22, y22, x3, y3, iterationCount) {
        if (iterationCount === 0) {
          return (distance6(x1, y1, x22, y22) + distance6(x22, y22, x3, y3) + distance6(x1, y1, x3, y3)) / 2;
        }
        var quadratics = divideQuadratic(x1, y1, x22, y22, x3, y3, 0.5);
        var left = quadratics[0];
        var right = quadratics[1];
        left.push(iterationCount - 1);
        right.push(iterationCount - 1);
        return quadraticLength.apply(void 0, _toConsumableArray2(left)) + quadraticLength.apply(void 0, _toConsumableArray2(right));
      }
      function box2(x1, y1, x22, y22, x3, y3) {
        var xExtrema3 = extrema2(x1, x22, x3)[0];
        var yExtrema3 = extrema2(y1, y22, y3)[0];
        var xArr = [x1, x3];
        var yArr = [y1, y3];
        if (xExtrema3 !== void 0) {
          xArr.push(quadraticAt2(x1, x22, x3, xExtrema3));
        }
        if (yExtrema3 !== void 0) {
          yArr.push(quadraticAt2(y1, y22, y3, yExtrema3));
        }
        return getBBoxByArray2(xArr, yArr);
      }
      function length(x1, y1, x22, y22, x3, y3) {
        return quadraticLength(x1, y1, x22, y22, x3, y3, 3);
      }
      function nearestPoint2(x1, y1, x22, y22, x3, y3, x0, y0) {
        return nearestPoint$22([x1, x22, x3], [y1, y22, y3], x0, y0, quadraticAt2);
      }
      function pointDistance2(x1, y1, x22, y22, x3, y3, x0, y0) {
        var point4 = nearestPoint2(x1, y1, x22, y22, x3, y3, x0, y0);
        return distance6(point4.x, point4.y, x0, y0);
      }
      exports.arcBox = box$52;
      exports.arcNearestPoint = nearestPoint$3;
      exports.arcTangentAngle = tangentAngle$4;
      exports.cubicBox = box$32;
      exports.cubicLength = length$3;
      exports.cubicNearestPoint = nearestPoint$12;
      exports.cubicPointAt = pointAt$2;
      exports.cubicPointDistance = pointDistance$32;
      exports.cubicTangentAngle = tangentAngle$2;
      exports.distance = distance6;
      exports.lineBox = box$4;
      exports.lineLength = length$42;
      exports.linePointAt = pointAt$32;
      exports.linePointDistance = pointDistance$4;
      exports.linePointToLine = pointToLine2;
      exports.lineTangentAngle = tangentAngle$3;
      exports.polygonBox = box$1;
      exports.polygonLength = length$1;
      exports.polygonPointAt = pointAt;
      exports.polygonPointDistance = pointDistance$1;
      exports.polygonTangentAngle = tangentAngle;
      exports.polylineBox = box$2;
      exports.polylineLength = length$22;
      exports.polylinePointAt = pointAt$1;
      exports.polylinePointDistance = pointDistance$2;
      exports.polylineTangentAngle = tangentAngle$1;
      exports.quadBox = box2;
      exports.quadLength = length;
      exports.quadNearestPoint = nearestPoint2;
      exports.quadPointDistance = pointDistance2;
    }
  });

  // node_modules/@babel/runtime/helpers/OverloadYield.js
  var require_OverloadYield = __commonJS({
    "node_modules/@babel/runtime/helpers/OverloadYield.js"(exports, module) {
      function _OverloadYield2(e, d2) {
        this.v = e, this.k = d2;
      }
      module.exports = _OverloadYield2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/regeneratorDefine.js
  var require_regeneratorDefine = __commonJS({
    "node_modules/@babel/runtime/helpers/regeneratorDefine.js"(exports, module) {
      function _regeneratorDefine2(e, r, n, t) {
        var i = Object.defineProperty;
        try {
          i({}, "", {});
        } catch (e3) {
          i = 0;
        }
        module.exports = _regeneratorDefine2 = function regeneratorDefine(e3, r2, n2, t2) {
          function o(r3, n3) {
            _regeneratorDefine2(e3, r3, function(e4) {
              return this._invoke(r3, n3, e4);
            });
          }
          r2 ? i ? i(e3, r2, {
            value: n2,
            enumerable: !t2,
            configurable: !t2,
            writable: !t2
          }) : e3[r2] = n2 : (o("next", 0), o("throw", 1), o("return", 2));
        }, module.exports.__esModule = true, module.exports["default"] = module.exports, _regeneratorDefine2(e, r, n, t);
      }
      module.exports = _regeneratorDefine2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/regenerator.js
  var require_regenerator = __commonJS({
    "node_modules/@babel/runtime/helpers/regenerator.js"(exports, module) {
      var regeneratorDefine = require_regeneratorDefine();
      function _regenerator2() {
        var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag";
        function i(r2, n2, o2, i2) {
          var c3 = n2 && n2.prototype instanceof Generator ? n2 : Generator, u2 = Object.create(c3.prototype);
          return regeneratorDefine(u2, "_invoke", (function(r3, n3, o3) {
            var i3, c4, u3, f2 = 0, p = o3 || [], y3 = false, G = {
              p: 0,
              n: 0,
              v: e,
              a: d2,
              f: d2.bind(e, 4),
              d: function d3(t2, r4) {
                return i3 = t2, c4 = 0, u3 = e, G.n = r4, a2;
              }
            };
            function d2(r4, n4) {
              for (c4 = r4, u3 = n4, t = 0; !y3 && f2 && !o4 && t < p.length; t++) {
                var o4, i4 = p[t], d3 = G.p, l = i4[2];
                r4 > 3 ? (o4 = l === n4) && (u3 = i4[(c4 = i4[4]) ? 5 : (c4 = 3, 3)], i4[4] = i4[5] = e) : i4[0] <= d3 && ((o4 = r4 < 2 && d3 < i4[1]) ? (c4 = 0, G.v = n4, G.n = i4[1]) : d3 < l && (o4 = r4 < 3 || i4[0] > n4 || n4 > l) && (i4[4] = r4, i4[5] = n4, G.n = l, c4 = 0));
              }
              if (o4 || r4 > 1) return a2;
              throw y3 = true, n4;
            }
            return function(o4, p2, l) {
              if (f2 > 1) throw TypeError("Generator is already running");
              for (y3 && 1 === p2 && d2(p2, l), c4 = p2, u3 = l; (t = c4 < 2 ? e : u3) || !y3; ) {
                i3 || (c4 ? c4 < 3 ? (c4 > 1 && (G.n = -1), d2(c4, u3)) : G.n = u3 : G.v = u3);
                try {
                  if (f2 = 2, i3) {
                    if (c4 || (o4 = "next"), t = i3[o4]) {
                      if (!(t = t.call(i3, u3))) throw TypeError("iterator result is not an object");
                      if (!t.done) return t;
                      u3 = t.value, c4 < 2 && (c4 = 0);
                    } else 1 === c4 && (t = i3["return"]) && t.call(i3), c4 < 2 && (u3 = TypeError("The iterator does not provide a '" + o4 + "' method"), c4 = 1);
                    i3 = e;
                  } else if ((t = (y3 = G.n < 0) ? u3 : r3.call(n3, G)) !== a2) break;
                } catch (t2) {
                  i3 = e, c4 = 1, u3 = t2;
                } finally {
                  f2 = 1;
                }
              }
              return {
                value: t,
                done: y3
              };
            };
          })(r2, o2, i2), true), u2;
        }
        var a2 = {};
        function Generator() {
        }
        function GeneratorFunction() {
        }
        function GeneratorFunctionPrototype() {
        }
        t = Object.getPrototypeOf;
        var c2 = [][n] ? t(t([][n]())) : (regeneratorDefine(t = {}, n, function() {
          return this;
        }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c2);
        function f(e3) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(e3, GeneratorFunctionPrototype) : (e3.__proto__ = GeneratorFunctionPrototype, regeneratorDefine(e3, o, "GeneratorFunction")), e3.prototype = Object.create(u), e3;
        }
        return GeneratorFunction.prototype = GeneratorFunctionPrototype, regeneratorDefine(u, "constructor", GeneratorFunctionPrototype), regeneratorDefine(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", regeneratorDefine(GeneratorFunctionPrototype, o, "GeneratorFunction"), regeneratorDefine(u), regeneratorDefine(u, o, "Generator"), regeneratorDefine(u, n, function() {
          return this;
        }), regeneratorDefine(u, "toString", function() {
          return "[object Generator]";
        }), (module.exports = _regenerator2 = function _regenerator3() {
          return {
            w: i,
            m: f
          };
        }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
      }
      module.exports = _regenerator2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/regeneratorAsyncIterator.js
  var require_regeneratorAsyncIterator = __commonJS({
    "node_modules/@babel/runtime/helpers/regeneratorAsyncIterator.js"(exports, module) {
      var OverloadYield = require_OverloadYield();
      var regeneratorDefine = require_regeneratorDefine();
      function AsyncIterator3(t, e) {
        function n(r2, o, i, f) {
          try {
            var c2 = t[r2](o), u = c2.value;
            return u instanceof OverloadYield ? e.resolve(u.v).then(function(t2) {
              n("next", t2, i, f);
            }, function(t2) {
              n("throw", t2, i, f);
            }) : e.resolve(u).then(function(t2) {
              c2.value = t2, i(c2);
            }, function(t2) {
              return n("throw", t2, i, f);
            });
          } catch (t2) {
            f(t2);
          }
        }
        var r;
        this.next || (regeneratorDefine(AsyncIterator3.prototype), regeneratorDefine(AsyncIterator3.prototype, "function" == typeof Symbol && Symbol.asyncIterator || "@asyncIterator", function() {
          return this;
        })), regeneratorDefine(this, "_invoke", function(t2, o, i) {
          function f() {
            return new e(function(e3, r2) {
              n(t2, i, e3, r2);
            });
          }
          return r = r ? r.then(f, f) : f();
        }, true);
      }
      module.exports = AsyncIterator3, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/regeneratorAsyncGen.js
  var require_regeneratorAsyncGen = __commonJS({
    "node_modules/@babel/runtime/helpers/regeneratorAsyncGen.js"(exports, module) {
      var regenerator = require_regenerator();
      var regeneratorAsyncIterator = require_regeneratorAsyncIterator();
      function _regeneratorAsyncGen2(r, e, t, o, n) {
        return new regeneratorAsyncIterator(regenerator().w(r, e, t, o), n || Promise);
      }
      module.exports = _regeneratorAsyncGen2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/regeneratorAsync.js
  var require_regeneratorAsync = __commonJS({
    "node_modules/@babel/runtime/helpers/regeneratorAsync.js"(exports, module) {
      var regeneratorAsyncGen = require_regeneratorAsyncGen();
      function _regeneratorAsync2(n, e, r, t, o) {
        var a2 = regeneratorAsyncGen(n, e, r, t, o);
        return a2.next().then(function(n2) {
          return n2.done ? n2.value : a2.next();
        });
      }
      module.exports = _regeneratorAsync2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/regeneratorKeys.js
  var require_regeneratorKeys = __commonJS({
    "node_modules/@babel/runtime/helpers/regeneratorKeys.js"(exports, module) {
      function _regeneratorKeys2(e) {
        var n = Object(e), r = [];
        for (var t in n) r.unshift(t);
        return function e3() {
          for (; r.length; ) if ((t = r.pop()) in n) return e3.value = t, e3.done = false, e3;
          return e3.done = true, e3;
        };
      }
      module.exports = _regeneratorKeys2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/regeneratorValues.js
  var require_regeneratorValues = __commonJS({
    "node_modules/@babel/runtime/helpers/regeneratorValues.js"(exports, module) {
      var _typeof2 = require_typeof()["default"];
      function _regeneratorValues2(e) {
        if (null != e) {
          var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0;
          if (t) return t.call(e);
          if ("function" == typeof e.next) return e;
          if (!isNaN(e.length)) return {
            next: function next() {
              return e && r >= e.length && (e = void 0), {
                value: e && e[r++],
                done: !e
              };
            }
          };
        }
        throw new TypeError(_typeof2(e) + " is not iterable");
      }
      module.exports = _regeneratorValues2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/regeneratorRuntime.js
  var require_regeneratorRuntime = __commonJS({
    "node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports, module) {
      var OverloadYield = require_OverloadYield();
      var regenerator = require_regenerator();
      var regeneratorAsync = require_regeneratorAsync();
      var regeneratorAsyncGen = require_regeneratorAsyncGen();
      var regeneratorAsyncIterator = require_regeneratorAsyncIterator();
      var regeneratorKeys = require_regeneratorKeys();
      var regeneratorValues = require_regeneratorValues();
      function _regeneratorRuntime2() {
        "use strict";
        var r = regenerator(), e = r.m(_regeneratorRuntime2), t = (Object.getPrototypeOf ? Object.getPrototypeOf(e) : e.__proto__).constructor;
        function n(r2) {
          var e3 = "function" == typeof r2 && r2.constructor;
          return !!e3 && (e3 === t || "GeneratorFunction" === (e3.displayName || e3.name));
        }
        var o = {
          "throw": 1,
          "return": 2,
          "break": 3,
          "continue": 3
        };
        function a2(r2) {
          var e3, t2;
          return function(n2) {
            e3 || (e3 = {
              stop: function stop() {
                return t2(n2.a, 2);
              },
              "catch": function _catch() {
                return n2.v;
              },
              abrupt: function abrupt(r3, e4) {
                return t2(n2.a, o[r3], e4);
              },
              delegateYield: function delegateYield(r3, o2, a3) {
                return e3.resultName = o2, t2(n2.d, regeneratorValues(r3), a3);
              },
              finish: function finish(r3) {
                return t2(n2.f, r3);
              }
            }, t2 = function t3(r3, _t, o2) {
              n2.p = e3.prev, n2.n = e3.next;
              try {
                return r3(_t, o2);
              } finally {
                e3.next = n2.n;
              }
            }), e3.resultName && (e3[e3.resultName] = n2.v, e3.resultName = void 0), e3.sent = n2.v, e3.next = n2.n;
            try {
              return r2.call(this, e3);
            } finally {
              n2.p = e3.prev, n2.n = e3.next;
            }
          };
        }
        return (module.exports = _regeneratorRuntime2 = function _regeneratorRuntime3() {
          return {
            wrap: function wrap3(e3, t2, n2, o2) {
              return r.w(a2(e3), t2, n2, o2 && o2.reverse());
            },
            isGeneratorFunction: n,
            mark: r.m,
            awrap: function awrap(r2, e3) {
              return new OverloadYield(r2, e3);
            },
            AsyncIterator: regeneratorAsyncIterator,
            async: function async(r2, e3, t2, o2, u) {
              return (n(e3) ? regeneratorAsyncGen : regeneratorAsync)(a2(r2), e3, t2, o2, u);
            },
            keys: regeneratorKeys,
            values: regeneratorValues
          };
        }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
      }
      module.exports = _regeneratorRuntime2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/asyncToGenerator.js
  var require_asyncToGenerator = __commonJS({
    "node_modules/@babel/runtime/helpers/asyncToGenerator.js"(exports, module) {
      function asyncGeneratorStep2(n, t, e, r, o, a2, c2) {
        try {
          var i = n[a2](c2), u = i.value;
        } catch (n2) {
          return void e(n2);
        }
        i.done ? t(u) : Promise.resolve(u).then(r, o);
      }
      function _asyncToGenerator2(n) {
        return function() {
          var t = this, e = arguments;
          return new Promise(function(r, o) {
            var a2 = n.apply(t, e);
            function _next(n2) {
              asyncGeneratorStep2(a2, r, o, _next, _throw, "next", n2);
            }
            function _throw(n2) {
              asyncGeneratorStep2(a2, r, o, _next, _throw, "throw", n2);
            }
            _next(void 0);
          });
        };
      }
      module.exports = _asyncToGenerator2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js
  var require_createForOfIteratorHelper = __commonJS({
    "node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js"(exports, module) {
      var unsupportedIterableToArray = require_unsupportedIterableToArray();
      function _createForOfIteratorHelper2(r, e) {
        var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
        if (!t) {
          if (Array.isArray(r) || (t = unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
            t && (r = t);
            var _n = 0, F = function F2() {
            };
            return {
              s: F,
              n: function n() {
                return _n >= r.length ? {
                  done: true
                } : {
                  done: false,
                  value: r[_n++]
                };
              },
              e: function e3(r2) {
                throw r2;
              },
              f: F
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var o, a2 = true, u = false;
        return {
          s: function s() {
            t = t.call(r);
          },
          n: function n() {
            var r2 = t.next();
            return a2 = r2.done, r2;
          },
          e: function e3(r2) {
            u = true, o = r2;
          },
          f: function f() {
            try {
              a2 || null == t["return"] || t["return"]();
            } finally {
              if (u) throw o;
            }
          }
        };
      }
      module.exports = _createForOfIteratorHelper2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js
  var require_objectWithoutPropertiesLoose = __commonJS({
    "node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js"(exports, module) {
      function _objectWithoutPropertiesLoose2(r, e) {
        if (null == r) return {};
        var t = {};
        for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
          if (-1 !== e.indexOf(n)) continue;
          t[n] = r[n];
        }
        return t;
      }
      module.exports = _objectWithoutPropertiesLoose2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/objectWithoutProperties.js
  var require_objectWithoutProperties = __commonJS({
    "node_modules/@babel/runtime/helpers/objectWithoutProperties.js"(exports, module) {
      var objectWithoutPropertiesLoose = require_objectWithoutPropertiesLoose();
      function _objectWithoutProperties2(e, t) {
        if (null == e) return {};
        var o, r, i = objectWithoutPropertiesLoose(e, t);
        if (Object.getOwnPropertySymbols) {
          var n = Object.getOwnPropertySymbols(e);
          for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
        }
        return i;
      }
      module.exports = _objectWithoutProperties2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@antv/g-lite/dist/index.js
  var require_dist2 = __commonJS({
    "node_modules/@antv/g-lite/dist/index.js"(exports) {
      "use strict";
      var _objectSpread = require_objectSpread2();
      var _classCallCheck2 = require_classCallCheck();
      var _createClass2 = require_createClass();
      var _toConsumableArray2 = require_toConsumableArray();
      var _callSuper2 = require_callSuper();
      var _inherits2 = require_inherits();
      var _slicedToArray2 = require_slicedToArray();
      var EventEmitter3 = require_eventemitter3();
      var glMatrix = require_cjs();
      require_readOnlyError();
      var util = require_lib();
      var _defineProperty2 = require_defineProperty2();
      var _superPropGet2 = require_superPropGet();
      var gMath = require_dist();
      var _regeneratorRuntime2 = require_regeneratorRuntime();
      var _asyncToGenerator2 = require_asyncToGenerator();
      var _createForOfIteratorHelper2 = require_createForOfIteratorHelper();
      var _objectWithoutProperties2 = require_objectWithoutProperties();
      var commonjsGlobal2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      var rbush2 = { exports: {} };
      (function(module2, exports2) {
        (function(global2, factory) {
          module2.exports = factory();
        })(commonjsGlobal2, function() {
          function quickselect(arr, k, left, right, compare) {
            quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare3);
          }
          function quickselectStep(arr, k, left, right, compare) {
            while (right > left) {
              if (right - left > 600) {
                var n = right - left + 1;
                var m2 = k - left + 1;
                var z = Math.log(n);
                var s = 0.5 * Math.exp(2 * z / 3);
                var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m2 - n / 2 < 0 ? -1 : 1);
                var newLeft = Math.max(left, Math.floor(k - m2 * s / n + sd));
                var newRight = Math.min(right, Math.floor(k + (n - m2) * s / n + sd));
                quickselectStep(arr, k, newLeft, newRight, compare);
              }
              var t = arr[k];
              var i = left;
              var j = right;
              swap(arr, left, k);
              if (compare(arr[right], t) > 0) {
                swap(arr, left, right);
              }
              while (i < j) {
                swap(arr, i, j);
                i++;
                j--;
                while (compare(arr[i], t) < 0) {
                  i++;
                }
                while (compare(arr[j], t) > 0) {
                  j--;
                }
              }
              if (compare(arr[left], t) === 0) {
                swap(arr, left, j);
              } else {
                j++;
                swap(arr, j, right);
              }
              if (j <= k) {
                left = j + 1;
              }
              if (k <= j) {
                right = j - 1;
              }
            }
          }
          function swap(arr, i, j) {
            var tmp3 = arr[i];
            arr[i] = arr[j];
            arr[j] = tmp3;
          }
          function defaultCompare3(a2, b) {
            return a2 < b ? -1 : a2 > b ? 1 : 0;
          }
          var RBush3 = function RBush4(maxEntries) {
            if (maxEntries === void 0) maxEntries = 9;
            this._maxEntries = Math.max(4, maxEntries);
            this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
            this.clear();
          };
          RBush3.prototype.all = function all() {
            return this._all(this.data, []);
          };
          RBush3.prototype.search = function search(bbox) {
            var node = this.data;
            var result = [];
            if (!intersects(bbox, node)) {
              return result;
            }
            var toBBox = this.toBBox;
            var nodesToSearch = [];
            while (node) {
              for (var i = 0; i < node.children.length; i++) {
                var child = node.children[i];
                var childBBox = node.leaf ? toBBox(child) : child;
                if (intersects(bbox, childBBox)) {
                  if (node.leaf) {
                    result.push(child);
                  } else if (contains(bbox, childBBox)) {
                    this._all(child, result);
                  } else {
                    nodesToSearch.push(child);
                  }
                }
              }
              node = nodesToSearch.pop();
            }
            return result;
          };
          RBush3.prototype.collides = function collides(bbox) {
            var node = this.data;
            if (!intersects(bbox, node)) {
              return false;
            }
            var nodesToSearch = [];
            while (node) {
              for (var i = 0; i < node.children.length; i++) {
                var child = node.children[i];
                var childBBox = node.leaf ? this.toBBox(child) : child;
                if (intersects(bbox, childBBox)) {
                  if (node.leaf || contains(bbox, childBBox)) {
                    return true;
                  }
                  nodesToSearch.push(child);
                }
              }
              node = nodesToSearch.pop();
            }
            return false;
          };
          RBush3.prototype.load = function load(data3) {
            if (!(data3 && data3.length)) {
              return this;
            }
            if (data3.length < this._minEntries) {
              for (var i = 0; i < data3.length; i++) {
                this.insert(data3[i]);
              }
              return this;
            }
            var node = this._build(data3.slice(), 0, data3.length - 1, 0);
            if (!this.data.children.length) {
              this.data = node;
            } else if (this.data.height === node.height) {
              this._splitRoot(this.data, node);
            } else {
              if (this.data.height < node.height) {
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
              }
              this._insert(node, this.data.height - node.height - 1, true);
            }
            return this;
          };
          RBush3.prototype.insert = function insert(item) {
            if (item) {
              this._insert(item, this.data.height - 1);
            }
            return this;
          };
          RBush3.prototype.clear = function clear() {
            this.data = createNode([]);
            return this;
          };
          RBush3.prototype.remove = function remove(item, equalsFn) {
            if (!item) {
              return this;
            }
            var node = this.data;
            var bbox = this.toBBox(item);
            var path = [];
            var indexes = [];
            var i, parent, goingUp;
            while (node || path.length) {
              if (!node) {
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
              }
              if (node.leaf) {
                var index2 = findItem(item, node.children, equalsFn);
                if (index2 !== -1) {
                  node.children.splice(index2, 1);
                  path.push(node);
                  this._condense(path);
                  return this;
                }
              }
              if (!goingUp && !node.leaf && contains(node, bbox)) {
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];
              } else if (parent) {
                i++;
                node = parent.children[i];
                goingUp = false;
              } else {
                node = null;
              }
            }
            return this;
          };
          RBush3.prototype.toBBox = function toBBox(item) {
            return item;
          };
          RBush3.prototype.compareMinX = function compareMinX(a2, b) {
            return a2.minX - b.minX;
          };
          RBush3.prototype.compareMinY = function compareMinY(a2, b) {
            return a2.minY - b.minY;
          };
          RBush3.prototype.toJSON = function toJSON() {
            return this.data;
          };
          RBush3.prototype.fromJSON = function fromJSON(data3) {
            this.data = data3;
            return this;
          };
          RBush3.prototype._all = function _all(node, result) {
            var nodesToSearch = [];
            while (node) {
              if (node.leaf) {
                result.push.apply(result, node.children);
              } else {
                nodesToSearch.push.apply(nodesToSearch, node.children);
              }
              node = nodesToSearch.pop();
            }
            return result;
          };
          RBush3.prototype._build = function _build(items, left, right, height) {
            var N2 = right - left + 1;
            var M = this._maxEntries;
            var node;
            if (N2 <= M) {
              node = createNode(items.slice(left, right + 1));
              calcBBox(node, this.toBBox);
              return node;
            }
            if (!height) {
              height = Math.ceil(Math.log(N2) / Math.log(M));
              M = Math.ceil(N2 / Math.pow(M, height - 1));
            }
            node = createNode([]);
            node.leaf = false;
            node.height = height;
            var N22 = Math.ceil(N2 / M);
            var N1 = N22 * Math.ceil(Math.sqrt(M));
            multiSelect(items, left, right, N1, this.compareMinX);
            for (var i = left; i <= right; i += N1) {
              var right2 = Math.min(i + N1 - 1, right);
              multiSelect(items, i, right2, N22, this.compareMinY);
              for (var j = i; j <= right2; j += N22) {
                var right3 = Math.min(j + N22 - 1, right2);
                node.children.push(this._build(items, j, right3, height - 1));
              }
            }
            calcBBox(node, this.toBBox);
            return node;
          };
          RBush3.prototype._chooseSubtree = function _chooseSubtree(bbox, node, level, path) {
            while (true) {
              path.push(node);
              if (node.leaf || path.length - 1 === level) {
                break;
              }
              var minArea = Infinity;
              var minEnlargement = Infinity;
              var targetNode = void 0;
              for (var i = 0; i < node.children.length; i++) {
                var child = node.children[i];
                var area = bboxArea(child);
                var enlargement = enlargedArea(bbox, child) - area;
                if (enlargement < minEnlargement) {
                  minEnlargement = enlargement;
                  minArea = area < minArea ? area : minArea;
                  targetNode = child;
                } else if (enlargement === minEnlargement) {
                  if (area < minArea) {
                    minArea = area;
                    targetNode = child;
                  }
                }
              }
              node = targetNode || node.children[0];
            }
            return node;
          };
          RBush3.prototype._insert = function _insert(item, level, isNode2) {
            var bbox = isNode2 ? item : this.toBBox(item);
            var insertPath = [];
            var node = this._chooseSubtree(bbox, this.data, level, insertPath);
            node.children.push(item);
            extend3(node, bbox);
            while (level >= 0) {
              if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
              } else {
                break;
              }
            }
            this._adjustParentBBoxes(bbox, insertPath, level);
          };
          RBush3.prototype._split = function _split(insertPath, level) {
            var node = insertPath[level];
            var M = node.children.length;
            var m2 = this._minEntries;
            this._chooseSplitAxis(node, m2, M);
            var splitIndex = this._chooseSplitIndex(node, m2, M);
            var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
            newNode.height = node.height;
            newNode.leaf = node.leaf;
            calcBBox(node, this.toBBox);
            calcBBox(newNode, this.toBBox);
            if (level) {
              insertPath[level - 1].children.push(newNode);
            } else {
              this._splitRoot(node, newNode);
            }
          };
          RBush3.prototype._splitRoot = function _splitRoot(node, newNode) {
            this.data = createNode([node, newNode]);
            this.data.height = node.height + 1;
            this.data.leaf = false;
            calcBBox(this.data, this.toBBox);
          };
          RBush3.prototype._chooseSplitIndex = function _chooseSplitIndex(node, m2, M) {
            var index2;
            var minOverlap = Infinity;
            var minArea = Infinity;
            for (var i = m2; i <= M - m2; i++) {
              var bbox1 = distBBox(node, 0, i, this.toBBox);
              var bbox2 = distBBox(node, i, M, this.toBBox);
              var overlap = intersectionArea(bbox1, bbox2);
              var area = bboxArea(bbox1) + bboxArea(bbox2);
              if (overlap < minOverlap) {
                minOverlap = overlap;
                index2 = i;
                minArea = area < minArea ? area : minArea;
              } else if (overlap === minOverlap) {
                if (area < minArea) {
                  minArea = area;
                  index2 = i;
                }
              }
            }
            return index2 || M - m2;
          };
          RBush3.prototype._chooseSplitAxis = function _chooseSplitAxis(node, m2, M) {
            var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
            var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
            var xMargin = this._allDistMargin(node, m2, M, compareMinX);
            var yMargin = this._allDistMargin(node, m2, M, compareMinY);
            if (xMargin < yMargin) {
              node.children.sort(compareMinX);
            }
          };
          RBush3.prototype._allDistMargin = function _allDistMargin(node, m2, M, compare) {
            node.children.sort(compare);
            var toBBox = this.toBBox;
            var leftBBox = distBBox(node, 0, m2, toBBox);
            var rightBBox = distBBox(node, M - m2, M, toBBox);
            var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
            for (var i = m2; i < M - m2; i++) {
              var child = node.children[i];
              extend3(leftBBox, node.leaf ? toBBox(child) : child);
              margin += bboxMargin(leftBBox);
            }
            for (var i$1 = M - m2 - 1; i$1 >= m2; i$1--) {
              var child$1 = node.children[i$1];
              extend3(rightBBox, node.leaf ? toBBox(child$1) : child$1);
              margin += bboxMargin(rightBBox);
            }
            return margin;
          };
          RBush3.prototype._adjustParentBBoxes = function _adjustParentBBoxes(bbox, path, level) {
            for (var i = level; i >= 0; i--) {
              extend3(path[i], bbox);
            }
          };
          RBush3.prototype._condense = function _condense(path) {
            for (var i = path.length - 1, siblings = void 0; i >= 0; i--) {
              if (path[i].children.length === 0) {
                if (i > 0) {
                  siblings = path[i - 1].children;
                  siblings.splice(siblings.indexOf(path[i]), 1);
                } else {
                  this.clear();
                }
              } else {
                calcBBox(path[i], this.toBBox);
              }
            }
          };
          function findItem(item, items, equalsFn) {
            if (!equalsFn) {
              return items.indexOf(item);
            }
            for (var i = 0; i < items.length; i++) {
              if (equalsFn(item, items[i])) {
                return i;
              }
            }
            return -1;
          }
          function calcBBox(node, toBBox) {
            distBBox(node, 0, node.children.length, toBBox, node);
          }
          function distBBox(node, k, p, toBBox, destNode) {
            if (!destNode) {
              destNode = createNode(null);
            }
            destNode.minX = Infinity;
            destNode.minY = Infinity;
            destNode.maxX = -Infinity;
            destNode.maxY = -Infinity;
            for (var i = k; i < p; i++) {
              var child = node.children[i];
              extend3(destNode, node.leaf ? toBBox(child) : child);
            }
            return destNode;
          }
          function extend3(a2, b) {
            a2.minX = Math.min(a2.minX, b.minX);
            a2.minY = Math.min(a2.minY, b.minY);
            a2.maxX = Math.max(a2.maxX, b.maxX);
            a2.maxY = Math.max(a2.maxY, b.maxY);
            return a2;
          }
          function compareNodeMinX(a2, b) {
            return a2.minX - b.minX;
          }
          function compareNodeMinY(a2, b) {
            return a2.minY - b.minY;
          }
          function bboxArea(a2) {
            return (a2.maxX - a2.minX) * (a2.maxY - a2.minY);
          }
          function bboxMargin(a2) {
            return a2.maxX - a2.minX + (a2.maxY - a2.minY);
          }
          function enlargedArea(a2, b) {
            return (Math.max(b.maxX, a2.maxX) - Math.min(b.minX, a2.minX)) * (Math.max(b.maxY, a2.maxY) - Math.min(b.minY, a2.minY));
          }
          function intersectionArea(a2, b) {
            var minX = Math.max(a2.minX, b.minX);
            var minY = Math.max(a2.minY, b.minY);
            var maxX = Math.min(a2.maxX, b.maxX);
            var maxY = Math.min(a2.maxY, b.maxY);
            return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
          }
          function contains(a2, b) {
            return a2.minX <= b.minX && a2.minY <= b.minY && b.maxX <= a2.maxX && b.maxY <= a2.maxY;
          }
          function intersects(a2, b) {
            return b.minX <= a2.maxX && b.minY <= a2.maxY && b.maxX >= a2.minX && b.maxY >= a2.minY;
          }
          function createNode(children) {
            return {
              children,
              height: 1,
              leaf: true,
              minX: Infinity,
              minY: Infinity,
              maxX: -Infinity,
              maxY: -Infinity
            };
          }
          function multiSelect(arr, left, right, n, compare) {
            var stack = [left, right];
            while (stack.length) {
              right = stack.pop();
              left = stack.pop();
              if (right - left <= n) {
                continue;
              }
              var mid = left + Math.ceil((right - left) / n / 2) * n;
              quickselect(arr, mid, left, right, compare);
              stack.push(left, mid, mid, right);
            }
          }
          return RBush3;
        });
      })(rbush2);
      var RBush2 = rbush2.exports;
      var Shape2 = /* @__PURE__ */ (function(Shape3) {
        Shape3["GROUP"] = "g";
        Shape3["FRAGMENT"] = "fragment";
        Shape3["CIRCLE"] = "circle";
        Shape3["ELLIPSE"] = "ellipse";
        Shape3["IMAGE"] = "image";
        Shape3["RECT"] = "rect";
        Shape3["LINE"] = "line";
        Shape3["POLYLINE"] = "polyline";
        Shape3["POLYGON"] = "polygon";
        Shape3["TEXT"] = "text";
        Shape3["PATH"] = "path";
        Shape3["HTML"] = "html";
        Shape3["MESH"] = "mesh";
        return Shape3;
      })({});
      var ClipSpaceNearZ2 = /* @__PURE__ */ (function(ClipSpaceNearZ3) {
        ClipSpaceNearZ3[ClipSpaceNearZ3["ZERO"] = 0] = "ZERO";
        ClipSpaceNearZ3[ClipSpaceNearZ3["NEGATIVE_ONE"] = 1] = "NEGATIVE_ONE";
        return ClipSpaceNearZ3;
      })({});
      var AbstractRendererPlugin2 = /* @__PURE__ */ (function() {
        function AbstractRendererPlugin3() {
          _classCallCheck2(this, AbstractRendererPlugin3);
          this.plugins = [];
        }
        return _createClass2(AbstractRendererPlugin3, [{
          key: "addRenderingPlugin",
          value: function addRenderingPlugin(plugin) {
            this.plugins.push(plugin);
            this.context.renderingPlugins.push(plugin);
          }
        }, {
          key: "removeAllRenderingPlugins",
          value: function removeAllRenderingPlugins() {
            var _this2 = this;
            this.plugins.forEach(function(plugin) {
              var index2 = _this2.context.renderingPlugins.indexOf(plugin);
              if (index2 >= 0) {
                _this2.context.renderingPlugins.splice(index2, 1);
              }
            });
          }
        }]);
      })();
      var AbstractRenderer2 = /* @__PURE__ */ (function() {
        function AbstractRenderer3(config) {
          _classCallCheck2(this, AbstractRenderer3);
          this.clipSpaceNearZ = ClipSpaceNearZ2.NEGATIVE_ONE;
          this.plugins = [];
          this.config = _objectSpread({
            /**
             * only dirty object will cause re-render
             */
            enableDirtyCheck: true,
            enableCulling: false,
            /**
             * enable auto rendering by default
             */
            enableAutoRendering: true,
            /**
             * enable dirty rectangle rendering by default
             */
            enableDirtyRectangleRendering: true,
            enableDirtyRectangleRenderingDebug: false,
            enableSizeAttenuation: true,
            enableRenderingOptimization: false
          }, config);
        }
        return _createClass2(AbstractRenderer3, [{
          key: "registerPlugin",
          value: function registerPlugin(plugin) {
            var index2 = this.plugins.findIndex(function(p) {
              return p === plugin;
            });
            if (index2 === -1) {
              this.plugins.push(plugin);
            }
          }
        }, {
          key: "unregisterPlugin",
          value: function unregisterPlugin(plugin) {
            var index2 = this.plugins.findIndex(function(p) {
              return p === plugin;
            });
            if (index2 > -1) {
              this.plugins.splice(index2, 1);
            }
          }
        }, {
          key: "getPlugins",
          value: function getPlugins() {
            return this.plugins;
          }
        }, {
          key: "getPlugin",
          value: function getPlugin(name) {
            return this.plugins.find(function(plugin) {
              return plugin.name === name;
            });
          }
        }, {
          key: "getConfig",
          value: function getConfig() {
            return this.config;
          }
        }, {
          key: "setConfig",
          value: function setConfig(config) {
            Object.assign(this.config, config);
          }
        }]);
      })();
      var addVec32 = glMatrix.vec3.add;
      var copyVec32 = glMatrix.vec3.copy;
      var maxVec32 = glMatrix.vec3.max;
      var minVec32 = glMatrix.vec3.min;
      var scaleVec32 = glMatrix.vec3.scale;
      var subVec32 = glMatrix.vec3.sub;
      var AABB2 = /* @__PURE__ */ (function() {
        function AABB3() {
          _classCallCheck2(this, AABB3);
          this.center = [0, 0, 0];
          this.halfExtents = [0, 0, 0];
          this.min = [0, 0, 0];
          this.max = [0, 0, 0];
        }
        return _createClass2(AABB3, [{
          key: "update",
          value: function update(center, halfExtents) {
            copyVec32(this.center, center);
            copyVec32(this.halfExtents, halfExtents);
            subVec32(this.min, this.center, this.halfExtents);
            addVec32(this.max, this.center, this.halfExtents);
          }
        }, {
          key: "setMinMax",
          value: function setMinMax(min4, max4) {
            addVec32(this.center, max4, min4);
            scaleVec32(this.center, this.center, 0.5);
            subVec32(this.halfExtents, max4, min4);
            scaleVec32(this.halfExtents, this.halfExtents, 0.5);
            copyVec32(this.min, min4);
            copyVec32(this.max, max4);
          }
        }, {
          key: "getMin",
          value: function getMin() {
            return this.min;
          }
        }, {
          key: "getMax",
          value: function getMax() {
            return this.max;
          }
        }, {
          key: "add",
          value: function add5(aabb) {
            if (AABB3.isEmpty(aabb)) {
              return;
            }
            if (AABB3.isEmpty(this)) {
              this.setMinMax(aabb.getMin(), aabb.getMax());
              return;
            }
            var tc = this.center;
            var tcx = tc[0];
            var tcy = tc[1];
            var tcz = tc[2];
            var th = this.halfExtents;
            var thx = th[0];
            var thy = th[1];
            var thz = th[2];
            var tminx = tcx - thx;
            var tmaxx = tcx + thx;
            var tminy = tcy - thy;
            var tmaxy = tcy + thy;
            var tminz = tcz - thz;
            var tmaxz = tcz + thz;
            var oc = aabb.center;
            var ocx = oc[0];
            var ocy = oc[1];
            var ocz = oc[2];
            var oh = aabb.halfExtents;
            var ohx = oh[0];
            var ohy = oh[1];
            var ohz = oh[2];
            var ominx = ocx - ohx;
            var omaxx = ocx + ohx;
            var ominy = ocy - ohy;
            var omaxy = ocy + ohy;
            var ominz = ocz - ohz;
            var omaxz = ocz + ohz;
            if (ominx < tminx) {
              tminx = ominx;
            }
            if (omaxx > tmaxx) {
              tmaxx = omaxx;
            }
            if (ominy < tminy) {
              tminy = ominy;
            }
            if (omaxy > tmaxy) {
              tmaxy = omaxy;
            }
            if (ominz < tminz) {
              tminz = ominz;
            }
            if (omaxz > tmaxz) {
              tmaxz = omaxz;
            }
            tc[0] = (tminx + tmaxx) * 0.5;
            tc[1] = (tminy + tmaxy) * 0.5;
            tc[2] = (tminz + tmaxz) * 0.5;
            th[0] = (tmaxx - tminx) * 0.5;
            th[1] = (tmaxy - tminy) * 0.5;
            th[2] = (tmaxz - tminz) * 0.5;
            this.min[0] = tminx;
            this.min[1] = tminy;
            this.min[2] = tminz;
            this.max[0] = tmaxx;
            this.max[1] = tmaxy;
            this.max[2] = tmaxz;
          }
        }, {
          key: "setFromTransformedAABB",
          value: function setFromTransformedAABB(aabb, m2) {
            var bc = this.center;
            var br = this.halfExtents;
            var ac = aabb.center;
            var ar = aabb.halfExtents;
            var mx0 = m2[0];
            var mx1 = m2[4];
            var mx2 = m2[8];
            var my0 = m2[1];
            var my1 = m2[5];
            var my2 = m2[9];
            var mz0 = m2[2];
            var mz1 = m2[6];
            var mz2 = m2[10];
            var mx0a = Math.abs(mx0);
            var mx1a = Math.abs(mx1);
            var mx2a = Math.abs(mx2);
            var my0a = Math.abs(my0);
            var my1a = Math.abs(my1);
            var my2a = Math.abs(my2);
            var mz0a = Math.abs(mz0);
            var mz1a = Math.abs(mz1);
            var mz2a = Math.abs(mz2);
            bc[0] = m2[12] + mx0 * ac[0] + mx1 * ac[1] + mx2 * ac[2];
            bc[1] = m2[13] + my0 * ac[0] + my1 * ac[1] + my2 * ac[2];
            bc[2] = m2[14] + mz0 * ac[0] + mz1 * ac[1] + mz2 * ac[2];
            br[0] = mx0a * ar[0] + mx1a * ar[1] + mx2a * ar[2];
            br[1] = my0a * ar[0] + my1a * ar[1] + my2a * ar[2];
            br[2] = mz0a * ar[0] + mz1a * ar[1] + mz2a * ar[2];
            subVec32(this.min, bc, br);
            addVec32(this.max, bc, br);
          }
        }, {
          key: "intersects",
          value: function intersects(aabb) {
            var aMax = this.getMax();
            var aMin = this.getMin();
            var bMax = aabb.getMax();
            var bMin = aabb.getMin();
            return aMin[0] <= bMax[0] && aMax[0] >= bMin[0] && aMin[1] <= bMax[1] && aMax[1] >= bMin[1] && aMin[2] <= bMax[2] && aMax[2] >= bMin[2];
          }
        }, {
          key: "intersection",
          value: function intersection(aabb) {
            if (!this.intersects(aabb)) {
              return null;
            }
            var intersection2 = new AABB3();
            var min4 = maxVec32([0, 0, 0], this.getMin(), aabb.getMin());
            var max4 = minVec32([0, 0, 0], this.getMax(), aabb.getMax());
            intersection2.setMinMax(min4, max4);
            return intersection2;
          }
          /**
           * get n-vertex
           * @param plane plane of CullingVolume
           */
        }, {
          key: "getNegativeFarPoint",
          value: function getNegativeFarPoint(plane) {
            if (plane.pnVertexFlag === 273) {
              return copyVec32([0, 0, 0], this.min);
            }
            if (plane.pnVertexFlag === 272) {
              return [this.min[0], this.min[1], this.max[2]];
            }
            if (plane.pnVertexFlag === 257) {
              return [this.min[0], this.max[1], this.min[2]];
            }
            if (plane.pnVertexFlag === 256) {
              return [this.min[0], this.max[1], this.max[2]];
            }
            if (plane.pnVertexFlag === 17) {
              return [this.max[0], this.min[1], this.min[2]];
            }
            if (plane.pnVertexFlag === 16) {
              return [this.max[0], this.min[1], this.max[2]];
            }
            if (plane.pnVertexFlag === 1) {
              return [this.max[0], this.max[1], this.min[2]];
            }
            return [this.max[0], this.max[1], this.max[2]];
          }
          /**
           * get p-vertex
           * @param plane plane of CullingVolume
           */
        }, {
          key: "getPositiveFarPoint",
          value: function getPositiveFarPoint(plane) {
            if (plane.pnVertexFlag === 273) {
              return copyVec32([0, 0, 0], this.max);
            }
            if (plane.pnVertexFlag === 272) {
              return [this.max[0], this.max[1], this.min[2]];
            }
            if (plane.pnVertexFlag === 257) {
              return [this.max[0], this.min[1], this.max[2]];
            }
            if (plane.pnVertexFlag === 256) {
              return [this.max[0], this.min[1], this.min[2]];
            }
            if (plane.pnVertexFlag === 17) {
              return [this.min[0], this.max[1], this.max[2]];
            }
            if (plane.pnVertexFlag === 16) {
              return [this.min[0], this.max[1], this.min[2]];
            }
            if (plane.pnVertexFlag === 1) {
              return [this.min[0], this.min[1], this.max[2]];
            }
            return [this.min[0], this.min[1], this.min[2]];
          }
        }], [{
          key: "isEmpty",
          value: function isEmpty7(aabb) {
            return !aabb || aabb.halfExtents[0] === 0 && aabb.halfExtents[1] === 0 && aabb.halfExtents[2] === 0;
          }
        }]);
      })();
      var Plane2 = /* @__PURE__ */ (function() {
        function Plane3(distance6, normal) {
          _classCallCheck2(this, Plane3);
          this.distance = distance6 || 0;
          this.normal = normal || glMatrix.vec3.fromValues(0, 1, 0);
          this.updatePNVertexFlag();
        }
        return _createClass2(Plane3, [{
          key: "updatePNVertexFlag",
          value: function updatePNVertexFlag() {
            this.pnVertexFlag = (Number(this.normal[0] >= 0) << 8) + (Number(this.normal[1] >= 0) << 4) + Number(this.normal[2] >= 0);
          }
        }, {
          key: "distanceToPoint",
          value: function distanceToPoint(point4) {
            return glMatrix.vec3.dot(point4, this.normal) - this.distance;
          }
        }, {
          key: "normalize",
          value: function normalize6() {
            var invLen = 1 / glMatrix.vec3.len(this.normal);
            glMatrix.vec3.scale(this.normal, this.normal, invLen);
            this.distance *= invLen;
          }
        }, {
          key: "intersectsLine",
          value: function intersectsLine2(start, end, point4) {
            var d0 = this.distanceToPoint(start);
            var d1 = this.distanceToPoint(end);
            var t = d0 / (d0 - d1);
            var intersects = t >= 0 && t <= 1;
            if (intersects && point4) {
              glMatrix.vec3.lerp(point4, start, end, t);
            }
            return intersects;
          }
        }]);
      })();
      var Mask2 = /* @__PURE__ */ (function(Mask3) {
        Mask3[Mask3["OUTSIDE"] = 4294967295] = "OUTSIDE";
        Mask3[Mask3["INSIDE"] = 0] = "INSIDE";
        Mask3[Mask3["INDETERMINATE"] = 2147483647] = "INDETERMINATE";
        return Mask3;
      })({});
      var Frustum2 = /* @__PURE__ */ (function() {
        function Frustum3(planes) {
          _classCallCheck2(this, Frustum3);
          this.planes = [];
          if (planes) {
            this.planes = planes;
          } else {
            for (var i = 0; i < 6; i++) {
              this.planes.push(new Plane2());
            }
          }
        }
        return _createClass2(Frustum3, [{
          key: "extractFromVPMatrix",
          value: function extractFromVPMatrix(projectionMatrix) {
            var _projectionMatrix = _slicedToArray2(projectionMatrix, 16), m0 = _projectionMatrix[0], m1 = _projectionMatrix[1], m2 = _projectionMatrix[2], m3 = _projectionMatrix[3], m4 = _projectionMatrix[4], m5 = _projectionMatrix[5], m6 = _projectionMatrix[6], m7 = _projectionMatrix[7], m8 = _projectionMatrix[8], m9 = _projectionMatrix[9], m10 = _projectionMatrix[10], m11 = _projectionMatrix[11], m12 = _projectionMatrix[12], m13 = _projectionMatrix[13], m14 = _projectionMatrix[14], m15 = _projectionMatrix[15];
            glMatrix.vec3.set(this.planes[0].normal, m3 - m0, m7 - m4, m11 - m8);
            this.planes[0].distance = m15 - m12;
            glMatrix.vec3.set(this.planes[1].normal, m3 + m0, m7 + m4, m11 + m8);
            this.planes[1].distance = m15 + m12;
            glMatrix.vec3.set(this.planes[2].normal, m3 + m1, m7 + m5, m11 + m9);
            this.planes[2].distance = m15 + m13;
            glMatrix.vec3.set(this.planes[3].normal, m3 - m1, m7 - m5, m11 - m9);
            this.planes[3].distance = m15 - m13;
            glMatrix.vec3.set(this.planes[4].normal, m3 - m2, m7 - m6, m11 - m10);
            this.planes[4].distance = m15 - m14;
            glMatrix.vec3.set(this.planes[5].normal, m3 + m2, m7 + m6, m11 + m10);
            this.planes[5].distance = m15 + m14;
            this.planes.forEach(function(plane) {
              plane.normalize();
              plane.updatePNVertexFlag();
            });
          }
        }]);
      })();
      var Point2 = /* @__PURE__ */ (function() {
        function Point3() {
          var x3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          _classCallCheck2(this, Point3);
          this.x = 0;
          this.y = 0;
          this.x = x3;
          this.y = y3;
        }
        return _createClass2(Point3, [{
          key: "clone",
          value: function clone8() {
            return new Point3(this.x, this.y);
          }
        }, {
          key: "copyFrom",
          value: function copyFrom(p) {
            this.x = p.x;
            this.y = p.y;
          }
        }]);
      })();
      var Rectangle3 = /* @__PURE__ */ (function() {
        function Rectangle4(x3, y3, width2, height) {
          _classCallCheck2(this, Rectangle4);
          this.x = x3;
          this.y = y3;
          this.width = width2;
          this.height = height;
          this.left = x3;
          this.right = x3 + width2;
          this.top = y3;
          this.bottom = y3 + height;
        }
        return _createClass2(Rectangle4, [{
          key: "toJSON",
          value: function toJSON() {
          }
        }], [{
          key: "fromRect",
          value: (
            /**
             * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMRect/fromRect_static
             */
            function fromRect(rect2) {
              return new Rectangle4(rect2.x, rect2.y, rect2.width, rect2.height);
            }
          )
          /**
           * will return a new rect instance
           */
        }, {
          key: "applyTransform",
          value: function applyTransform2(rect2, matrix3) {
            var topLeft = glMatrix.vec4.fromValues(rect2.x, rect2.y, 0, 1);
            var topRight = glMatrix.vec4.fromValues(rect2.x + rect2.width, rect2.y, 0, 1);
            var bottomLeft = glMatrix.vec4.fromValues(rect2.x, rect2.y + rect2.height, 0, 1);
            var bottomRight = glMatrix.vec4.fromValues(rect2.x + rect2.width, rect2.y + rect2.height, 0, 1);
            var transformedTopLeft = glMatrix.vec4.create();
            var transformedTopRight = glMatrix.vec4.create();
            var transformedBottomLeft = glMatrix.vec4.create();
            var transformedBottomRight = glMatrix.vec4.create();
            glMatrix.vec4.transformMat4(transformedTopLeft, topLeft, matrix3);
            glMatrix.vec4.transformMat4(transformedTopRight, topRight, matrix3);
            glMatrix.vec4.transformMat4(transformedBottomLeft, bottomLeft, matrix3);
            glMatrix.vec4.transformMat4(transformedBottomRight, bottomRight, matrix3);
            var minX = Math.min(transformedTopLeft[0], transformedTopRight[0], transformedBottomLeft[0], transformedBottomRight[0]);
            var minY = Math.min(transformedTopLeft[1], transformedTopRight[1], transformedBottomLeft[1], transformedBottomRight[1]);
            var maxX = Math.max(transformedTopLeft[0], transformedTopRight[0], transformedBottomLeft[0], transformedBottomRight[0]);
            var maxY = Math.max(transformedTopLeft[1], transformedTopRight[1], transformedBottomLeft[1], transformedBottomRight[1]);
            return Rectangle4.fromRect({
              x: minX,
              y: minY,
              width: maxX - minX,
              height: maxY - minY
            });
          }
        }]);
      })();
      var ERROR_MSG_METHOD_NOT_IMPLEMENTED2 = "Method not implemented.";
      var ERROR_MSG_USE_DOCUMENT_ELEMENT2 = "Use document.documentElement instead.";
      var ERROR_MSG_APPEND_DESTROYED_ELEMENT2 = "Cannot append a destroyed element.";
      function getAngle3(angle2) {
        if (angle2 === void 0) {
          return 0;
        }
        if (angle2 > 360 || angle2 < -360) {
          return angle2 % 360;
        }
        return angle2;
      }
      var $vec3$32 = glMatrix.vec3.create();
      function createVec32(x3) {
        var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var clone8 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
        if (Array.isArray(x3) && x3.length === 3) {
          return clone8 ? glMatrix.vec3.clone(x3) : glMatrix.vec3.copy($vec3$32, x3);
        }
        if (util.isNumber(x3)) {
          return clone8 ? glMatrix.vec3.fromValues(x3, y3, z) : glMatrix.vec3.set($vec3$32, x3, y3, z);
        }
        return clone8 ? glMatrix.vec3.fromValues(x3[0], x3[1] || y3, x3[2] || z) : glMatrix.vec3.set($vec3$32, x3[0], x3[1] || y3, x3[2] || z);
      }
      var DEG_RAD2 = Math.PI / 180;
      function deg2rad2(deg) {
        return deg * DEG_RAD2;
      }
      var RAD_DEG2 = 180 / Math.PI;
      function rad2deg2(rad2) {
        return rad2 * RAD_DEG2;
      }
      var GRAD_DEG = 0.9;
      function grad2deg(grads) {
        grads %= 400;
        if (grads < 0) {
          grads += 400;
        }
        return grads * GRAD_DEG;
      }
      function deg2turn(deg) {
        return deg / 360;
      }
      function turn2deg2(turn) {
        return 360 * turn;
      }
      var HALF_PI2 = Math.PI / 2;
      function getEulerFromQuat2(out, quat4) {
        var x3 = quat4[0];
        var y3 = quat4[1];
        var z = quat4[2];
        var w = quat4[3];
        var x22 = x3 * x3;
        var y22 = y3 * y3;
        var z2 = z * z;
        var w2 = w * w;
        var unit = x22 + y22 + z2 + w2;
        var test = x3 * w - y3 * z;
        if (test > 0.499995 * unit) {
          out[0] = HALF_PI2;
          out[1] = 2 * Math.atan2(y3, x3);
          out[2] = 0;
        } else if (test < -0.499995 * unit) {
          out[0] = -HALF_PI2;
          out[1] = 2 * Math.atan2(y3, x3);
          out[2] = 0;
        } else {
          out[0] = Math.asin(2 * (x3 * z - w * y3));
          out[1] = Math.atan2(2 * (x3 * w + y3 * z), 1 - 2 * (z2 + w2));
          out[2] = Math.atan2(2 * (x3 * y3 + z * w), 1 - 2 * (y22 + z2));
        }
        return out;
      }
      function getEulerFromMat42(out, m2) {
        var x3;
        var z;
        var _mat4$getScaling = glMatrix.mat4.getScaling(glMatrix.vec3.create(), m2), _mat4$getScaling2 = _slicedToArray2(_mat4$getScaling, 3), sx = _mat4$getScaling2[0], sy = _mat4$getScaling2[1], sz = _mat4$getScaling2[2];
        var y3 = Math.asin(-m2[2] / sx);
        if (y3 < HALF_PI2) {
          if (y3 > -HALF_PI2) {
            x3 = Math.atan2(m2[6] / sy, m2[10] / sz);
            z = Math.atan2(m2[1] / sx, m2[0] / sx);
          } else {
            z = 0;
            x3 = -Math.atan2(m2[4] / sy, m2[5] / sy);
          }
        } else {
          z = 0;
          x3 = Math.atan2(m2[4] / sy, m2[5] / sy);
        }
        out[0] = x3;
        out[1] = y3;
        out[2] = z;
        return out;
      }
      function getEuler2(out, quat4) {
        if (quat4.length === 16) {
          return getEulerFromMat42(out, quat4);
        }
        return getEulerFromQuat2(out, quat4);
      }
      function fromRotationTranslationScale2(rotation, x3, y3, scaleX2, scaleY2) {
        var cos = Math.cos(rotation);
        var sin = Math.sin(rotation);
        return glMatrix.mat3.fromValues(scaleX2 * cos, scaleY2 * sin, 0, -scaleX2 * sin, scaleY2 * cos, 0, x3, y3, 1);
      }
      function makePerspective2(out, left, right, top, bottom, near, far) {
        var zero = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
        var twoNear = 2 * near;
        var rightMinusLeft = right - left;
        var topMinusBottom = top - bottom;
        var x3 = twoNear / rightMinusLeft;
        var y3 = twoNear / topMinusBottom;
        var a2 = (right + left) / rightMinusLeft;
        var b = (top + bottom) / topMinusBottom;
        var c2;
        var d2;
        var farMinusNear = far - near;
        var farMulNear = far * near;
        if (zero) {
          c2 = -far / farMinusNear;
          d2 = -farMulNear / farMinusNear;
        } else {
          c2 = -(far + near) / farMinusNear;
          d2 = -2 * farMulNear / farMinusNear;
        }
        out[0] = x3;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = y3;
        out[6] = 0;
        out[7] = 0;
        out[8] = a2;
        out[9] = b;
        out[10] = c2;
        out[11] = -1;
        out[12] = 0;
        out[13] = 0;
        out[14] = d2;
        out[15] = 0;
        return out;
      }
      function decompose2(mat) {
        var row0x = mat[0];
        var row0y = mat[1];
        var row1x = mat[3];
        var row1y = mat[4];
        var scalingX = Math.sqrt(row0x * row0x + row0y * row0y);
        var scalingY = Math.sqrt(row1x * row1x + row1y * row1y);
        var determinant2 = row0x * row1y - row0y * row1x;
        if (determinant2 < 0) {
          if (row0x < row1y) {
            scalingX = -scalingX;
          } else {
            scalingY = -scalingY;
          }
        }
        if (scalingX) {
          var invScalingX = 1 / scalingX;
          row0x *= invScalingX;
          row0y *= invScalingX;
        }
        if (scalingY) {
          var invScalingY = 1 / scalingY;
          row1x *= invScalingY;
          row1y *= invScalingY;
        }
        var rotation = Math.atan2(row0y, row0x);
        var angle2 = rad2deg2(rotation);
        return [mat[6], mat[7], scalingX, scalingY, angle2];
      }
      var tmp2 = glMatrix.mat4.create();
      var perspectiveMatrix2 = glMatrix.mat4.create();
      var tmpVec42 = glMatrix.vec4.create();
      var row2 = [glMatrix.vec3.create(), glMatrix.vec3.create(), glMatrix.vec3.create()];
      var pdum32 = glMatrix.vec3.create();
      function decomposeMat42(matrix3, translation, scale4, skew2, perspective, quaternion) {
        if (!normalize5(tmp2, matrix3)) return false;
        glMatrix.mat4.copy(perspectiveMatrix2, tmp2);
        perspectiveMatrix2[3] = 0;
        perspectiveMatrix2[7] = 0;
        perspectiveMatrix2[11] = 0;
        perspectiveMatrix2[15] = 1;
        if (Math.abs(glMatrix.mat4.determinant(perspectiveMatrix2)) < 1e-8) return false;
        var a03 = tmp2[3];
        var a13 = tmp2[7];
        var a23 = tmp2[11];
        var a30 = tmp2[12];
        var a31 = tmp2[13];
        var a32 = tmp2[14];
        var a33 = tmp2[15];
        if (a03 !== 0 || a13 !== 0 || a23 !== 0) {
          tmpVec42[0] = a03;
          tmpVec42[1] = a13;
          tmpVec42[2] = a23;
          tmpVec42[3] = a33;
          var ret = glMatrix.mat4.invert(perspectiveMatrix2, perspectiveMatrix2);
          if (!ret) return false;
          glMatrix.mat4.transpose(perspectiveMatrix2, perspectiveMatrix2);
          glMatrix.vec4.transformMat4(perspective, tmpVec42, perspectiveMatrix2);
        } else {
          perspective[0] = perspective[1] = perspective[2] = 0;
          perspective[3] = 1;
        }
        translation[0] = a30;
        translation[1] = a31;
        translation[2] = a32;
        mat3from42(row2, tmp2);
        scale4[0] = glMatrix.vec3.length(row2[0]);
        glMatrix.vec3.normalize(row2[0], row2[0]);
        skew2[0] = glMatrix.vec3.dot(row2[0], row2[1]);
        combine2(row2[1], row2[1], row2[0], 1, -skew2[0]);
        scale4[1] = glMatrix.vec3.length(row2[1]);
        glMatrix.vec3.normalize(row2[1], row2[1]);
        skew2[0] /= scale4[1];
        skew2[1] = glMatrix.vec3.dot(row2[0], row2[2]);
        combine2(row2[2], row2[2], row2[0], 1, -skew2[1]);
        skew2[2] = glMatrix.vec3.dot(row2[1], row2[2]);
        combine2(row2[2], row2[2], row2[1], 1, -skew2[2]);
        scale4[2] = glMatrix.vec3.length(row2[2]);
        glMatrix.vec3.normalize(row2[2], row2[2]);
        skew2[1] /= scale4[2];
        skew2[2] /= scale4[2];
        glMatrix.vec3.cross(pdum32, row2[1], row2[2]);
        if (glMatrix.vec3.dot(row2[0], pdum32) < 0) {
          for (var i = 0; i < 3; i++) {
            scale4[i] *= -1;
            row2[i][0] *= -1;
            row2[i][1] *= -1;
            row2[i][2] *= -1;
          }
        }
        quaternion[0] = 0.5 * Math.sqrt(Math.max(1 + row2[0][0] - row2[1][1] - row2[2][2], 0));
        quaternion[1] = 0.5 * Math.sqrt(Math.max(1 - row2[0][0] + row2[1][1] - row2[2][2], 0));
        quaternion[2] = 0.5 * Math.sqrt(Math.max(1 - row2[0][0] - row2[1][1] + row2[2][2], 0));
        quaternion[3] = 0.5 * Math.sqrt(Math.max(1 + row2[0][0] + row2[1][1] + row2[2][2], 0));
        if (row2[2][1] > row2[1][2]) quaternion[0] = -quaternion[0];
        if (row2[0][2] > row2[2][0]) quaternion[1] = -quaternion[1];
        if (row2[1][0] > row2[0][1]) quaternion[2] = -quaternion[2];
        return true;
      }
      function normalize5(out, mat) {
        var m44 = mat[15];
        if (m44 === 0) return false;
        var scale4 = 1 / m44;
        for (var i = 0; i < 16; i++) out[i] = mat[i] * scale4;
        return true;
      }
      function mat3from42(out, mat4x4) {
        out[0][0] = mat4x4[0];
        out[0][1] = mat4x4[1];
        out[0][2] = mat4x4[2];
        out[1][0] = mat4x4[4];
        out[1][1] = mat4x4[5];
        out[1][2] = mat4x4[6];
        out[2][0] = mat4x4[8];
        out[2][1] = mat4x4[9];
        out[2][2] = mat4x4[10];
      }
      function combine2(out, a2, b, scale1, scale22) {
        out[0] = a2[0] * scale1 + b[0] * scale22;
        out[1] = a2[1] * scale1 + b[1] * scale22;
        out[2] = a2[2] * scale1 + b[2] * scale22;
      }
      var CameraType2 = /* @__PURE__ */ (function(CameraType3) {
        CameraType3[CameraType3["ORBITING"] = 0] = "ORBITING";
        CameraType3[CameraType3["EXPLORING"] = 1] = "EXPLORING";
        CameraType3[CameraType3["TRACKING"] = 2] = "TRACKING";
        return CameraType3;
      })({});
      var CameraTrackingMode2 = /* @__PURE__ */ (function(CameraTrackingMode3) {
        CameraTrackingMode3[CameraTrackingMode3["DEFAULT"] = 0] = "DEFAULT";
        CameraTrackingMode3[CameraTrackingMode3["ROTATIONAL"] = 1] = "ROTATIONAL";
        CameraTrackingMode3[CameraTrackingMode3["TRANSLATIONAL"] = 2] = "TRANSLATIONAL";
        CameraTrackingMode3[CameraTrackingMode3["CINEMATIC"] = 3] = "CINEMATIC";
        return CameraTrackingMode3;
      })({});
      var CameraProjectionMode2 = /* @__PURE__ */ (function(CameraProjectionMode3) {
        CameraProjectionMode3[CameraProjectionMode3["ORTHOGRAPHIC"] = 0] = "ORTHOGRAPHIC";
        CameraProjectionMode3[CameraProjectionMode3["PERSPECTIVE"] = 1] = "PERSPECTIVE";
        return CameraProjectionMode3;
      })({});
      var CameraEvent2 = {
        UPDATED: "updated"
      };
      var MIN_DISTANCE2 = 2e-4;
      var Camera2 = /* @__PURE__ */ (function() {
        function Camera3() {
          _classCallCheck2(this, Camera3);
          this.clipSpaceNearZ = ClipSpaceNearZ2.NEGATIVE_ONE;
          this.eventEmitter = new EventEmitter3();
          this.matrix = glMatrix.mat4.create();
          this.right = glMatrix.vec3.fromValues(1, 0, 0);
          this.up = glMatrix.vec3.fromValues(0, 1, 0);
          this.forward = glMatrix.vec3.fromValues(0, 0, 1);
          this.position = glMatrix.vec3.fromValues(0, 0, 1);
          this.focalPoint = glMatrix.vec3.fromValues(0, 0, 0);
          this.distanceVector = glMatrix.vec3.fromValues(0, 0, -1);
          this.distance = 1;
          this.azimuth = 0;
          this.elevation = 0;
          this.roll = 0;
          this.relAzimuth = 0;
          this.relElevation = 0;
          this.relRoll = 0;
          this.dollyingStep = 0;
          this.maxDistance = Infinity;
          this.minDistance = -Infinity;
          this.zoom = 1;
          this.rotateWorld = false;
          this.fov = 30;
          this.near = 0.1;
          this.far = 1e3;
          this.aspect = 1;
          this.projectionMatrix = glMatrix.mat4.create();
          this.projectionMatrixInverse = glMatrix.mat4.create();
          this.jitteredProjectionMatrix = void 0;
          this.enableUpdate = true;
          this.type = CameraType2.EXPLORING;
          this.trackingMode = CameraTrackingMode2.DEFAULT;
          this.projectionMode = CameraProjectionMode2.PERSPECTIVE;
          this.frustum = new Frustum2();
          this.orthoMatrix = glMatrix.mat4.create();
        }
        return _createClass2(Camera3, [{
          key: "isOrtho",
          value: (
            // constructor(type = CameraType.EXPLORING, trackingMode = CameraTrackingMode.DEFAULT) {
            //   this.setType(type, trackingMode);
            // }
            function isOrtho() {
              return this.projectionMode === CameraProjectionMode2.ORTHOGRAPHIC;
            }
          )
        }, {
          key: "getProjectionMode",
          value: function getProjectionMode() {
            return this.projectionMode;
          }
        }, {
          key: "getPerspective",
          value: function getPerspective() {
            return this.jitteredProjectionMatrix || this.projectionMatrix;
          }
        }, {
          key: "getPerspectiveInverse",
          value: function getPerspectiveInverse() {
            return this.projectionMatrixInverse;
          }
        }, {
          key: "getFrustum",
          value: function getFrustum() {
            return this.frustum;
          }
        }, {
          key: "getPosition",
          value: function getPosition() {
            return this.position;
          }
        }, {
          key: "getFocalPoint",
          value: function getFocalPoint() {
            return this.focalPoint;
          }
        }, {
          key: "getDollyingStep",
          value: function getDollyingStep() {
            return this.dollyingStep;
          }
        }, {
          key: "getNear",
          value: function getNear() {
            return this.near;
          }
        }, {
          key: "getFar",
          value: function getFar() {
            return this.far;
          }
        }, {
          key: "getZoom",
          value: function getZoom() {
            return this.zoom;
          }
        }, {
          key: "getOrthoMatrix",
          value: function getOrthoMatrix() {
            return this.orthoMatrix;
          }
        }, {
          key: "getView",
          value: function getView() {
            return this.view;
          }
        }, {
          key: "setEnableUpdate",
          value: function setEnableUpdate(enabled) {
            this.enableUpdate = enabled;
          }
        }, {
          key: "setType",
          value: function setType(type, trackingMode) {
            this.type = type;
            if (this.type === CameraType2.EXPLORING) {
              this.setWorldRotation(true);
            } else {
              this.setWorldRotation(false);
            }
            this._getAngles();
            if (this.type === CameraType2.TRACKING && trackingMode !== void 0) {
              this.setTrackingMode(trackingMode);
            }
            return this;
          }
        }, {
          key: "setProjectionMode",
          value: function setProjectionMode(projectionMode) {
            this.projectionMode = projectionMode;
            return this;
          }
        }, {
          key: "setTrackingMode",
          value: function setTrackingMode(trackingMode) {
            if (this.type !== CameraType2.TRACKING) {
              throw new Error("Impossible to set a tracking mode if the camera is not of tracking type");
            }
            this.trackingMode = trackingMode;
            return this;
          }
          /**
           * If flag is true, it reverses the azimuth and elevation angles.
           * Subsequent calls to rotate, setAzimuth, setElevation,
           * changeAzimuth or changeElevation will cause the inverted effect.
           * setRoll or changeRoll is not affected by this method.
           *
           * This inversion is useful when one wants to simulate that the world
           * is moving, instead of the camera.
           *
           * By default the camera angles are not reversed.
           * @param {Boolean} flag the boolean flag to reverse the angles.
           */
        }, {
          key: "setWorldRotation",
          value: function setWorldRotation(flag) {
            this.rotateWorld = flag;
            this._getAngles();
            return this;
          }
          /**
           * 计算 MV 矩阵，为相机矩阵的逆矩阵
           */
        }, {
          key: "getViewTransform",
          value: function getViewTransform() {
            return glMatrix.mat4.invert(glMatrix.mat4.create(), this.matrix);
          }
        }, {
          key: "getWorldTransform",
          value: function getWorldTransform() {
            return this.matrix;
          }
        }, {
          key: "jitterProjectionMatrix",
          value: function jitterProjectionMatrix(x3, y3) {
            var translation = glMatrix.mat4.fromTranslation(glMatrix.mat4.create(), [x3, y3, 0]);
            this.jitteredProjectionMatrix = glMatrix.mat4.multiply(glMatrix.mat4.create(), translation, this.projectionMatrix);
          }
        }, {
          key: "clearJitterProjectionMatrix",
          value: function clearJitterProjectionMatrix() {
            this.jitteredProjectionMatrix = void 0;
          }
          /**
           * 设置相机矩阵
           */
        }, {
          key: "setMatrix",
          value: function setMatrix(matrix3) {
            this.matrix = matrix3;
            this._update();
            return this;
          }
          /**
           * Set projection matrix manually.
           */
        }, {
          key: "setProjectionMatrix",
          value: function setProjectionMatrix(matrix3) {
            this.projectionMatrix = matrix3;
          }
        }, {
          key: "setFov",
          value: function setFov(fov) {
            this.setPerspective(this.near, this.far, fov, this.aspect);
            return this;
          }
        }, {
          key: "setAspect",
          value: function setAspect(aspect) {
            this.setPerspective(this.near, this.far, this.fov, aspect);
            return this;
          }
        }, {
          key: "setNear",
          value: function setNear(near) {
            if (this.projectionMode === CameraProjectionMode2.PERSPECTIVE) {
              this.setPerspective(near, this.far, this.fov, this.aspect);
            } else {
              this.setOrthographic(this.left, this.rright, this.top, this.bottom, near, this.far);
            }
            return this;
          }
        }, {
          key: "setFar",
          value: function setFar(far) {
            if (this.projectionMode === CameraProjectionMode2.PERSPECTIVE) {
              this.setPerspective(this.near, far, this.fov, this.aspect);
            } else {
              this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, far);
            }
            return this;
          }
          /**
           * Sets an offset in a larger frustum, used in PixelPicking
           */
        }, {
          key: "setViewOffset",
          value: function setViewOffset(fullWidth, fullHeight, x3, y3, width2, height) {
            this.aspect = fullWidth / fullHeight;
            if (this.view === void 0) {
              this.view = {
                enabled: true,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
              };
            }
            this.view.enabled = true;
            this.view.fullWidth = fullWidth;
            this.view.fullHeight = fullHeight;
            this.view.offsetX = x3;
            this.view.offsetY = y3;
            this.view.width = width2;
            this.view.height = height;
            if (this.projectionMode === CameraProjectionMode2.PERSPECTIVE) {
              this.setPerspective(this.near, this.far, this.fov, this.aspect);
            } else {
              this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
            }
            return this;
          }
        }, {
          key: "clearViewOffset",
          value: function clearViewOffset() {
            if (this.view !== void 0) {
              this.view.enabled = false;
            }
            if (this.projectionMode === CameraProjectionMode2.PERSPECTIVE) {
              this.setPerspective(this.near, this.far, this.fov, this.aspect);
            } else {
              this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
            }
            return this;
          }
        }, {
          key: "setZoom",
          value: function setZoom(zoom) {
            this.zoom = zoom;
            if (this.projectionMode === CameraProjectionMode2.ORTHOGRAPHIC) {
              this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
            } else if (this.projectionMode === CameraProjectionMode2.PERSPECTIVE) {
              this.setPerspective(this.near, this.far, this.fov, this.aspect);
            }
            return this;
          }
          /**
           * Zoom by specified point in viewport coordinates.
           */
        }, {
          key: "setZoomByViewportPoint",
          value: function setZoomByViewportPoint(zoom, viewportPoint) {
            var _this$canvas$viewport = this.canvas.viewport2Canvas({
              x: viewportPoint[0],
              y: viewportPoint[1]
            }), ox = _this$canvas$viewport.x, oy = _this$canvas$viewport.y;
            var roll = this.roll;
            this.rotate(0, 0, -roll);
            this.setPosition(ox, oy);
            this.setFocalPoint(ox, oy);
            this.setZoom(zoom);
            this.rotate(0, 0, roll);
            var _this$canvas$viewport2 = this.canvas.viewport2Canvas({
              x: viewportPoint[0],
              y: viewportPoint[1]
            }), cx = _this$canvas$viewport2.x, cy = _this$canvas$viewport2.y;
            var dvec = glMatrix.vec3.fromValues(cx - ox, cy - oy, 0);
            var dx = glMatrix.vec3.dot(dvec, this.right) / glMatrix.vec3.length(this.right);
            var dy = glMatrix.vec3.dot(dvec, this.up) / glMatrix.vec3.length(this.up);
            var _this$getPosition = this.getPosition(), _this$getPosition2 = _slicedToArray2(_this$getPosition, 2), px = _this$getPosition2[0], py = _this$getPosition2[1];
            var _this$getFocalPoint = this.getFocalPoint(), _this$getFocalPoint2 = _slicedToArray2(_this$getFocalPoint, 2), fx = _this$getFocalPoint2[0], fy = _this$getFocalPoint2[1];
            this.setPosition(px - dx, py - dy);
            this.setFocalPoint(fx - dx, fy - dy);
            return this;
          }
        }, {
          key: "setPerspective",
          value: function setPerspective(near, far, fov, aspect) {
            var _this$view;
            this.projectionMode = CameraProjectionMode2.PERSPECTIVE;
            this.fov = fov;
            this.near = near;
            this.far = far;
            this.aspect = aspect;
            var top = this.near * Math.tan(deg2rad2(0.5 * this.fov)) / this.zoom;
            var height = 2 * top;
            var width2 = this.aspect * height;
            var left = -0.5 * width2;
            if ((_this$view = this.view) !== null && _this$view !== void 0 && _this$view.enabled) {
              var fullWidth = this.view.fullWidth;
              var fullHeight = this.view.fullHeight;
              left += this.view.offsetX * width2 / fullWidth;
              top -= this.view.offsetY * height / fullHeight;
              width2 *= this.view.width / fullWidth;
              height *= this.view.height / fullHeight;
            }
            makePerspective2(this.projectionMatrix, left, left + width2, top - height, top, near, this.far, this.clipSpaceNearZ === ClipSpaceNearZ2.ZERO);
            glMatrix.mat4.invert(this.projectionMatrixInverse, this.projectionMatrix);
            this.triggerUpdate();
            return this;
          }
        }, {
          key: "setOrthographic",
          value: function setOrthographic(l, r, t, b, near, far) {
            var _this$view2;
            this.projectionMode = CameraProjectionMode2.ORTHOGRAPHIC;
            this.rright = r;
            this.left = l;
            this.top = t;
            this.bottom = b;
            this.near = near;
            this.far = far;
            var dx = (this.rright - this.left) / (2 * this.zoom);
            var dy = (this.top - this.bottom) / (2 * this.zoom);
            var cx = (this.rright + this.left) / 2;
            var cy = (this.top + this.bottom) / 2;
            var left = cx - dx;
            var right = cx + dx;
            var top = cy + dy;
            var bottom = cy - dy;
            if ((_this$view2 = this.view) !== null && _this$view2 !== void 0 && _this$view2.enabled) {
              var scaleW = (this.rright - this.left) / this.view.fullWidth / this.zoom;
              var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
              left += scaleW * this.view.offsetX;
              right = left + scaleW * this.view.width;
              top -= scaleH * this.view.offsetY;
              bottom = top - scaleH * this.view.height;
            }
            if (this.clipSpaceNearZ === ClipSpaceNearZ2.NEGATIVE_ONE) {
              glMatrix.mat4.ortho(this.projectionMatrix, left, right, top, bottom, near, far);
            } else {
              glMatrix.mat4.orthoZO(this.projectionMatrix, left, right, top, bottom, near, far);
            }
            glMatrix.mat4.invert(this.projectionMatrixInverse, this.projectionMatrix);
            this._getOrthoMatrix();
            this.triggerUpdate();
            return this;
          }
          /**
           * Move the camera in world coordinates.
           * It will keep looking at the current focal point.
           *
           * support scalars or vectors.
           * @example
           * setPosition(1, 2, 3);
           * setPosition([1, 2, 3]);
           */
        }, {
          key: "setPosition",
          value: function setPosition(x3) {
            var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.position[1];
            var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.position[2];
            var position2 = createVec32(x3, y3, z);
            this._setPosition(position2);
            this.setFocalPoint(this.focalPoint);
            this.triggerUpdate();
            return this;
          }
          /**
           * Sets the focal point of this camera in world coordinates.
           *
           * support scalars or vectors.
           * @example
           * setFocalPoint(1, 2, 3);
           * setFocalPoint([1, 2, 3]);
           */
        }, {
          key: "setFocalPoint",
          value: function setFocalPoint(x3) {
            var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.focalPoint[1];
            var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.focalPoint[2];
            var up = glMatrix.vec3.fromValues(0, 1, 0);
            this.focalPoint = createVec32(x3, y3, z);
            if (this.trackingMode === CameraTrackingMode2.CINEMATIC) {
              var d2 = glMatrix.vec3.subtract(glMatrix.vec3.create(), this.focalPoint, this.position);
              x3 = d2[0];
              y3 = d2[1];
              z = d2[2];
              var r = glMatrix.vec3.length(d2);
              var el = rad2deg2(Math.asin(y3 / r));
              var az = 90 + rad2deg2(Math.atan2(z, x3));
              var m2 = glMatrix.mat4.create();
              glMatrix.mat4.rotateY(m2, m2, deg2rad2(az));
              glMatrix.mat4.rotateX(m2, m2, deg2rad2(el));
              up = glMatrix.vec3.transformMat4(glMatrix.vec3.create(), [0, 1, 0], m2);
            }
            glMatrix.mat4.invert(this.matrix, glMatrix.mat4.lookAt(glMatrix.mat4.create(), this.position, this.focalPoint, up));
            this._getAxes();
            this._getDistance();
            this._getAngles();
            this.triggerUpdate();
            return this;
          }
        }, {
          key: "getDistance",
          value: function getDistance2() {
            return this.distance;
          }
        }, {
          key: "getDistanceVector",
          value: function getDistanceVector() {
            return this.distanceVector;
          }
          /**
           * Moves the camera towards/from the focal point.
           */
        }, {
          key: "setDistance",
          value: function setDistance(d2) {
            if (this.distance === d2 || d2 < 0) {
              return this;
            }
            this.distance = d2;
            if (this.distance < MIN_DISTANCE2) {
              this.distance = MIN_DISTANCE2;
            }
            this.dollyingStep = this.distance / 100;
            var pos = glMatrix.vec3.create();
            d2 = this.distance;
            var n = this.forward;
            var f = this.focalPoint;
            pos[0] = d2 * n[0] + f[0];
            pos[1] = d2 * n[1] + f[1];
            pos[2] = d2 * n[2] + f[2];
            this._setPosition(pos);
            this.triggerUpdate();
            return this;
          }
        }, {
          key: "setMaxDistance",
          value: function setMaxDistance(d2) {
            this.maxDistance = d2;
            return this;
          }
        }, {
          key: "setMinDistance",
          value: function setMinDistance(d2) {
            this.minDistance = d2;
            return this;
          }
          /**
           * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
           * the azimuth in degrees
           */
        }, {
          key: "setAzimuth",
          value: function setAzimuth(az) {
            this.azimuth = getAngle3(az);
            this.computeMatrix();
            this._getAxes();
            if (this.type === CameraType2.ORBITING || this.type === CameraType2.EXPLORING) {
              this._getPosition();
            } else if (this.type === CameraType2.TRACKING) {
              this._getFocalPoint();
            }
            this.triggerUpdate();
            return this;
          }
        }, {
          key: "getAzimuth",
          value: function getAzimuth() {
            return this.azimuth;
          }
          /**
           * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
           */
        }, {
          key: "setElevation",
          value: function setElevation(el) {
            this.elevation = getAngle3(el);
            this.computeMatrix();
            this._getAxes();
            if (this.type === CameraType2.ORBITING || this.type === CameraType2.EXPLORING) {
              this._getPosition();
            } else if (this.type === CameraType2.TRACKING) {
              this._getFocalPoint();
            }
            this.triggerUpdate();
            return this;
          }
        }, {
          key: "getElevation",
          value: function getElevation() {
            return this.elevation;
          }
          /**
           * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
           */
        }, {
          key: "setRoll",
          value: function setRoll(angle2) {
            this.roll = getAngle3(angle2);
            this.computeMatrix();
            this._getAxes();
            if (this.type === CameraType2.ORBITING || this.type === CameraType2.EXPLORING) {
              this._getPosition();
            } else if (this.type === CameraType2.TRACKING) {
              this._getFocalPoint();
            }
            this.triggerUpdate();
            return this;
          }
        }, {
          key: "getRoll",
          value: function getRoll() {
            return this.roll;
          }
          /**
           * 根据相机矩阵重新计算各种相机参数
           */
        }, {
          key: "_update",
          value: function _update() {
            this._getAxes();
            this._getPosition();
            this._getDistance();
            this._getAngles();
            this._getOrthoMatrix();
            this.triggerUpdate();
          }
          /**
           * 计算相机矩阵
           */
        }, {
          key: "computeMatrix",
          value: function computeMatrix() {
            var rotZ = glMatrix.quat.setAxisAngle(glMatrix.quat.create(), [0, 0, 1], deg2rad2(this.roll));
            glMatrix.mat4.identity(this.matrix);
            var rotX = glMatrix.quat.setAxisAngle(glMatrix.quat.create(), [1, 0, 0], deg2rad2((this.rotateWorld && this.type !== CameraType2.TRACKING || this.type === CameraType2.TRACKING ? 1 : -1) * this.elevation));
            var rotY = glMatrix.quat.setAxisAngle(glMatrix.quat.create(), [0, 1, 0], deg2rad2((this.rotateWorld && this.type !== CameraType2.TRACKING || this.type === CameraType2.TRACKING ? 1 : -1) * this.azimuth));
            var rotQ = glMatrix.quat.multiply(glMatrix.quat.create(), rotY, rotX);
            rotQ = glMatrix.quat.multiply(glMatrix.quat.create(), rotQ, rotZ);
            var rotMatrix = glMatrix.mat4.fromQuat(glMatrix.mat4.create(), rotQ);
            if (this.type === CameraType2.ORBITING || this.type === CameraType2.EXPLORING) {
              glMatrix.mat4.translate(this.matrix, this.matrix, this.focalPoint);
              glMatrix.mat4.multiply(this.matrix, this.matrix, rotMatrix);
              glMatrix.mat4.translate(this.matrix, this.matrix, [0, 0, this.distance]);
            } else if (this.type === CameraType2.TRACKING) {
              glMatrix.mat4.translate(this.matrix, this.matrix, this.position);
              glMatrix.mat4.multiply(this.matrix, this.matrix, rotMatrix);
            }
          }
          /**
           * Sets the camera position in the camera matrix
           */
        }, {
          key: "_setPosition",
          value: function _setPosition(x3, y3, z) {
            this.position = createVec32(x3, y3, z);
            var m2 = this.matrix;
            m2[12] = this.position[0];
            m2[13] = this.position[1];
            m2[14] = this.position[2];
            m2[15] = 1;
            this._getOrthoMatrix();
          }
          /**
           * Recalculates axes based on the current matrix
           */
        }, {
          key: "_getAxes",
          value: function _getAxes() {
            glMatrix.vec3.copy(this.right, createVec32(glMatrix.vec4.transformMat4(glMatrix.vec4.create(), [1, 0, 0, 0], this.matrix)));
            glMatrix.vec3.copy(this.up, createVec32(glMatrix.vec4.transformMat4(glMatrix.vec4.create(), [0, 1, 0, 0], this.matrix)));
            glMatrix.vec3.copy(this.forward, createVec32(glMatrix.vec4.transformMat4(glMatrix.vec4.create(), [0, 0, 1, 0], this.matrix)));
            glMatrix.vec3.normalize(this.right, this.right);
            glMatrix.vec3.normalize(this.up, this.up);
            glMatrix.vec3.normalize(this.forward, this.forward);
          }
          /**
           * Recalculates euler angles based on the current state
           */
        }, {
          key: "_getAngles",
          value: function _getAngles() {
            var x3 = this.distanceVector[0];
            var y3 = this.distanceVector[1];
            var z = this.distanceVector[2];
            var r = glMatrix.vec3.length(this.distanceVector);
            if (r === 0) {
              this.elevation = 0;
              this.azimuth = 0;
              return;
            }
            if (this.type === CameraType2.TRACKING) {
              this.elevation = rad2deg2(Math.asin(y3 / r));
              this.azimuth = rad2deg2(Math.atan2(-x3, -z));
            } else if (this.rotateWorld) {
              this.elevation = rad2deg2(Math.asin(y3 / r));
              this.azimuth = rad2deg2(Math.atan2(-x3, -z));
            } else {
              this.elevation = -rad2deg2(Math.asin(y3 / r));
              this.azimuth = -rad2deg2(Math.atan2(-x3, -z));
            }
          }
          /**
           * 重新计算相机位置，只有 ORBITING 模式相机位置才会发生变化
           */
        }, {
          key: "_getPosition",
          value: function _getPosition() {
            glMatrix.vec3.copy(this.position, createVec32(glMatrix.vec4.transformMat4(glMatrix.vec4.create(), [0, 0, 0, 1], this.matrix)));
            this._getDistance();
          }
          /**
           * 重新计算视点，只有 TRACKING 模式视点才会发生变化
           */
        }, {
          key: "_getFocalPoint",
          value: function _getFocalPoint() {
            glMatrix.vec3.transformMat3(this.distanceVector, [0, 0, -this.distance], glMatrix.mat3.fromMat4(glMatrix.mat3.create(), this.matrix));
            glMatrix.vec3.add(this.focalPoint, this.position, this.distanceVector);
            this._getDistance();
          }
          /**
           * 重新计算视距
           */
        }, {
          key: "_getDistance",
          value: function _getDistance() {
            this.distanceVector = glMatrix.vec3.subtract(glMatrix.vec3.create(), this.focalPoint, this.position);
            this.distance = glMatrix.vec3.length(this.distanceVector);
            this.dollyingStep = this.distance / 100;
          }
        }, {
          key: "_getOrthoMatrix",
          value: function _getOrthoMatrix() {
            if (this.projectionMode !== CameraProjectionMode2.ORTHOGRAPHIC) {
              return;
            }
            var position2 = this.position;
            var rotZ = glMatrix.quat.setAxisAngle(glMatrix.quat.create(), [0, 0, 1], -this.roll * Math.PI / 180);
            glMatrix.mat4.fromRotationTranslationScaleOrigin(this.orthoMatrix, rotZ, glMatrix.vec3.fromValues((this.rright - this.left) / 2 - position2[0], (this.top - this.bottom) / 2 - position2[1], 0), glMatrix.vec3.fromValues(this.zoom, this.zoom, 1), position2);
          }
        }, {
          key: "triggerUpdate",
          value: function triggerUpdate() {
            if (this.enableUpdate) {
              var viewMatrix = this.getViewTransform();
              var vpMatrix = glMatrix.mat4.multiply(glMatrix.mat4.create(), this.getPerspective(), viewMatrix);
              this.getFrustum().extractFromVPMatrix(vpMatrix);
              this.eventEmitter.emit(CameraEvent2.UPDATED);
            }
          }
        }, {
          key: "rotate",
          value: function rotate3(azimuth, elevation, roll) {
            throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED2);
          }
        }, {
          key: "pan",
          value: function pan(tx, ty) {
            throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED2);
          }
        }, {
          key: "dolly",
          value: function dolly(value) {
            throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED2);
          }
        }, {
          key: "createLandmark",
          value: function createLandmark(name, params) {
            throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED2);
          }
        }, {
          key: "gotoLandmark",
          value: function gotoLandmark(name, options) {
            throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED2);
          }
        }, {
          key: "cancelLandmarkAnimation",
          value: function cancelLandmarkAnimation() {
            throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED2);
          }
        }]);
      })();
      var Strategy2 = /* @__PURE__ */ (function(Strategy3) {
        Strategy3[Strategy3["Standard"] = 0] = "Standard";
        return Strategy3;
      })({});
      var SortReason2 = /* @__PURE__ */ (function(SortReason3) {
        SortReason3[SortReason3["ADDED"] = 0] = "ADDED";
        SortReason3[SortReason3["REMOVED"] = 1] = "REMOVED";
        SortReason3[SortReason3["Z_INDEX_CHANGED"] = 2] = "Z_INDEX_CHANGED";
        return SortReason3;
      })({});
      var $vec3$22 = glMatrix.vec3.create();
      var $mat4$12 = glMatrix.mat4.create();
      var $quat$22 = glMatrix.quat.create();
      function updateLocalTransform2(transform) {
        if (!transform.localDirtyFlag) {
          return;
        }
        var hasSkew = transform.localSkew[0] !== 0 || transform.localSkew[1] !== 0;
        if (hasSkew) {
          glMatrix.mat4.fromRotationTranslationScaleOrigin(transform.localTransform, transform.localRotation, transform.localPosition, glMatrix.vec3.fromValues(1, 1, 1), transform.origin);
          if (transform.localSkew[0] !== 0 || transform.localSkew[1] !== 0) {
            glMatrix.mat4.identity($mat4$12);
            $mat4$12[4] = Math.tan(transform.localSkew[0]);
            $mat4$12[1] = Math.tan(transform.localSkew[1]);
            glMatrix.mat4.multiply(transform.localTransform, transform.localTransform, $mat4$12);
          }
          var scaling = glMatrix.mat4.fromRotationTranslationScaleOrigin($mat4$12, glMatrix.quat.set($quat$22, 0, 0, 0, 1), glMatrix.vec3.set($vec3$22, 1, 1, 1), transform.localScale, transform.origin);
          glMatrix.mat4.multiply(transform.localTransform, transform.localTransform, scaling);
        } else {
          var localTransform = transform.localTransform, localPosition = transform.localPosition, localRotation = transform.localRotation, localScale = transform.localScale, origin = transform.origin;
          var hasPosition2 = localPosition[0] !== 0 || localPosition[1] !== 0 || localPosition[2] !== 0;
          var hasRotation = localRotation[3] !== 1 || localRotation[0] !== 0 || localRotation[1] !== 0 || localRotation[2] !== 0;
          var hasScale = localScale[0] !== 1 || localScale[1] !== 1 || localScale[2] !== 1;
          var hasOrigin = origin[0] !== 0 || origin[1] !== 0 || origin[2] !== 0;
          if (!hasRotation && !hasScale && !hasOrigin) {
            if (hasPosition2) {
              glMatrix.mat4.fromTranslation(localTransform, localPosition);
            } else {
              glMatrix.mat4.identity(localTransform);
            }
          } else {
            glMatrix.mat4.fromRotationTranslationScaleOrigin(localTransform, localRotation, localPosition, localScale, origin);
          }
        }
        transform.localDirtyFlag = false;
      }
      function updateWorldTransform2(transform, parentTransform) {
        if (!transform.dirtyFlag) {
          return;
        }
        if (!parentTransform) {
          glMatrix.mat4.copy(transform.worldTransform, transform.localTransform);
        } else {
          glMatrix.mat4.multiply(transform.worldTransform, parentTransform.worldTransform, transform.localTransform);
        }
        transform.dirtyFlag = false;
      }
      var EMPTY_PARSED_PATH2 = {
        absolutePath: [],
        hasArc: false,
        segments: [],
        polygons: [],
        polylines: [],
        curve: null,
        totalLength: 0,
        rect: new Rectangle3(0, 0, 0, 0)
      };
      var PropertySyntax2 = /* @__PURE__ */ (function(PropertySyntax3) {
        PropertySyntax3["COORDINATE"] = "<coordinate>";
        PropertySyntax3["COLOR"] = "<color>";
        PropertySyntax3["PAINT"] = "<paint>";
        PropertySyntax3["NUMBER"] = "<number>";
        PropertySyntax3["ANGLE"] = "<angle>";
        PropertySyntax3["OPACITY_VALUE"] = "<opacity-value>";
        PropertySyntax3["SHADOW_BLUR"] = "<shadow-blur>";
        PropertySyntax3["LENGTH"] = "<length>";
        PropertySyntax3["PERCENTAGE"] = "<percentage>";
        PropertySyntax3["LENGTH_PERCENTAGE"] = "<length> | <percentage>";
        PropertySyntax3["LENGTH_PERCENTAGE_12"] = "[<length> | <percentage>]{1,2}";
        PropertySyntax3["LENGTH_PERCENTAGE_14"] = "[<length> | <percentage>]{1,4}";
        PropertySyntax3["LIST_OF_POINTS"] = "<list-of-points>";
        PropertySyntax3["PATH"] = "<path>";
        PropertySyntax3["FILTER"] = "<filter>";
        PropertySyntax3["Z_INDEX"] = "<z-index>";
        PropertySyntax3["OFFSET_DISTANCE"] = "<offset-distance>";
        PropertySyntax3["DEFINED_PATH"] = "<defined-path>";
        PropertySyntax3["MARKER"] = "<marker>";
        PropertySyntax3["TRANSFORM"] = "<transform>";
        PropertySyntax3["TRANSFORM_ORIGIN"] = "<transform-origin>";
        PropertySyntax3["TEXT"] = "<text>";
        PropertySyntax3["TEXT_TRANSFORM"] = "<text-transform>";
        return PropertySyntax3;
      })({});
      function define3(constructor, factory, prototype) {
        constructor.prototype = factory.prototype = prototype;
        prototype.constructor = constructor;
      }
      function extend2(parent, definition) {
        var prototype = Object.create(parent.prototype);
        for (var key in definition) prototype[key] = definition[key];
        return prototype;
      }
      function Color2() {
      }
      var darker2 = 0.7;
      var brighter2 = 1 / darker2;
      var reI2 = "\\s*([+-]?\\d+)\\s*";
      var reN2 = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
      var reP2 = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
      var reHex2 = /^#([0-9a-f]{3,8})$/;
      var reRgbInteger2 = new RegExp(`^rgb\\(${reI2},${reI2},${reI2}\\)$`);
      var reRgbPercent2 = new RegExp(`^rgb\\(${reP2},${reP2},${reP2}\\)$`);
      var reRgbaInteger2 = new RegExp(`^rgba\\(${reI2},${reI2},${reI2},${reN2}\\)$`);
      var reRgbaPercent2 = new RegExp(`^rgba\\(${reP2},${reP2},${reP2},${reN2}\\)$`);
      var reHslPercent2 = new RegExp(`^hsl\\(${reN2},${reP2},${reP2}\\)$`);
      var reHslaPercent2 = new RegExp(`^hsla\\(${reN2},${reP2},${reP2},${reN2}\\)$`);
      var named2 = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
      };
      define3(Color2, color2, {
        copy(channels) {
          return Object.assign(new this.constructor(), this, channels);
        },
        displayable() {
          return this.rgb().displayable();
        },
        hex: color_formatHex2,
        // Deprecated! Use color.formatHex.
        formatHex: color_formatHex2,
        formatHex8: color_formatHex82,
        formatHsl: color_formatHsl2,
        formatRgb: color_formatRgb2,
        toString: color_formatRgb2
      });
      function color_formatHex2() {
        return this.rgb().formatHex();
      }
      function color_formatHex82() {
        return this.rgb().formatHex8();
      }
      function color_formatHsl2() {
        return hslConvert2(this).formatHsl();
      }
      function color_formatRgb2() {
        return this.rgb().formatRgb();
      }
      function color2(format2) {
        var m2, l;
        format2 = (format2 + "").trim().toLowerCase();
        return (m2 = reHex2.exec(format2)) ? (l = m2[1].length, m2 = parseInt(m2[1], 16), l === 6 ? rgbn2(m2) : l === 3 ? new Rgb2(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l === 8 ? rgba2(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l === 4 ? rgba2(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger2.exec(format2)) ? new Rgb2(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent2.exec(format2)) ? new Rgb2(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger2.exec(format2)) ? rgba2(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent2.exec(format2)) ? rgba2(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent2.exec(format2)) ? hsla2(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent2.exec(format2)) ? hsla2(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named2.hasOwnProperty(format2) ? rgbn2(named2[format2]) : format2 === "transparent" ? new Rgb2(NaN, NaN, NaN, 0) : null;
      }
      function rgbn2(n) {
        return new Rgb2(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
      }
      function rgba2(r, g, b, a2) {
        if (a2 <= 0) r = g = b = NaN;
        return new Rgb2(r, g, b, a2);
      }
      function rgbConvert2(o) {
        if (!(o instanceof Color2)) o = color2(o);
        if (!o) return new Rgb2();
        o = o.rgb();
        return new Rgb2(o.r, o.g, o.b, o.opacity);
      }
      function rgb2(r, g, b, opacity) {
        return arguments.length === 1 ? rgbConvert2(r) : new Rgb2(r, g, b, opacity == null ? 1 : opacity);
      }
      function Rgb2(r, g, b, opacity) {
        this.r = +r;
        this.g = +g;
        this.b = +b;
        this.opacity = +opacity;
      }
      define3(Rgb2, rgb2, extend2(Color2, {
        brighter(k) {
          k = k == null ? brighter2 : Math.pow(brighter2, k);
          return new Rgb2(this.r * k, this.g * k, this.b * k, this.opacity);
        },
        darker(k) {
          k = k == null ? darker2 : Math.pow(darker2, k);
          return new Rgb2(this.r * k, this.g * k, this.b * k, this.opacity);
        },
        rgb() {
          return this;
        },
        clamp() {
          return new Rgb2(clampi2(this.r), clampi2(this.g), clampi2(this.b), clampa2(this.opacity));
        },
        displayable() {
          return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
        },
        hex: rgb_formatHex2,
        // Deprecated! Use color.formatHex.
        formatHex: rgb_formatHex2,
        formatHex8: rgb_formatHex82,
        formatRgb: rgb_formatRgb2,
        toString: rgb_formatRgb2
      }));
      function rgb_formatHex2() {
        return `#${hex2(this.r)}${hex2(this.g)}${hex2(this.b)}`;
      }
      function rgb_formatHex82() {
        return `#${hex2(this.r)}${hex2(this.g)}${hex2(this.b)}${hex2((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
      }
      function rgb_formatRgb2() {
        const a2 = clampa2(this.opacity);
        return `${a2 === 1 ? "rgb(" : "rgba("}${clampi2(this.r)}, ${clampi2(this.g)}, ${clampi2(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
      }
      function clampa2(opacity) {
        return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
      }
      function clampi2(value) {
        return Math.max(0, Math.min(255, Math.round(value) || 0));
      }
      function hex2(value) {
        value = clampi2(value);
        return (value < 16 ? "0" : "") + value.toString(16);
      }
      function hsla2(h, s, l, a2) {
        if (a2 <= 0) h = s = l = NaN;
        else if (l <= 0 || l >= 1) h = s = NaN;
        else if (s <= 0) h = NaN;
        return new Hsl2(h, s, l, a2);
      }
      function hslConvert2(o) {
        if (o instanceof Hsl2) return new Hsl2(o.h, o.s, o.l, o.opacity);
        if (!(o instanceof Color2)) o = color2(o);
        if (!o) return new Hsl2();
        if (o instanceof Hsl2) return o;
        o = o.rgb();
        var r = o.r / 255, g = o.g / 255, b = o.b / 255, min4 = Math.min(r, g, b), max4 = Math.max(r, g, b), h = NaN, s = max4 - min4, l = (max4 + min4) / 2;
        if (s) {
          if (r === max4) h = (g - b) / s + (g < b) * 6;
          else if (g === max4) h = (b - r) / s + 2;
          else h = (r - g) / s + 4;
          s /= l < 0.5 ? max4 + min4 : 2 - max4 - min4;
          h *= 60;
        } else {
          s = l > 0 && l < 1 ? 0 : h;
        }
        return new Hsl2(h, s, l, o.opacity);
      }
      function hsl2(h, s, l, opacity) {
        return arguments.length === 1 ? hslConvert2(h) : new Hsl2(h, s, l, opacity == null ? 1 : opacity);
      }
      function Hsl2(h, s, l, opacity) {
        this.h = +h;
        this.s = +s;
        this.l = +l;
        this.opacity = +opacity;
      }
      define3(Hsl2, hsl2, extend2(Color2, {
        brighter(k) {
          k = k == null ? brighter2 : Math.pow(brighter2, k);
          return new Hsl2(this.h, this.s, this.l * k, this.opacity);
        },
        darker(k) {
          k = k == null ? darker2 : Math.pow(darker2, k);
          return new Hsl2(this.h, this.s, this.l * k, this.opacity);
        },
        rgb() {
          var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
          return new Rgb2(
            hsl2rgb2(h >= 240 ? h - 240 : h + 120, m1, m2),
            hsl2rgb2(h, m1, m2),
            hsl2rgb2(h < 120 ? h + 240 : h - 120, m1, m2),
            this.opacity
          );
        },
        clamp() {
          return new Hsl2(clamph2(this.h), clampt2(this.s), clampt2(this.l), clampa2(this.opacity));
        },
        displayable() {
          return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
        },
        formatHsl() {
          const a2 = clampa2(this.opacity);
          return `${a2 === 1 ? "hsl(" : "hsla("}${clamph2(this.h)}, ${clampt2(this.s) * 100}%, ${clampt2(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
        }
      }));
      function clamph2(value) {
        value = (value || 0) % 360;
        return value < 0 ? value + 360 : value;
      }
      function clampt2(value) {
        return Math.max(0, Math.min(1, value || 0));
      }
      function hsl2rgb2(h, m1, m2) {
        return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
      }
      function memoize4(func, resolver) {
        if (typeof func !== "function" || resolver != null && typeof resolver !== "function") {
          throw new TypeError("Expected a function");
        }
        var _memoized = function memoized() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var key = resolver ? resolver.apply(this, args) : args[0];
          var cache = _memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          _memoized.cache = cache.set(key, result) || cache;
          return result;
        };
        _memoized.cache = new (memoize4.Cache || Map)();
        memoize4.cacheList.push(_memoized.cache);
        return _memoized;
      }
      memoize4.Cache = Map;
      memoize4.cacheList = [];
      memoize4.clearCache = function() {
        memoize4.cacheList.forEach(function(cache) {
          return cache.clear();
        });
      };
      var UnitType2 = /* @__PURE__ */ (function(UnitType3) {
        UnitType3[UnitType3["kUnknown"] = 0] = "kUnknown";
        UnitType3[UnitType3["kNumber"] = 1] = "kNumber";
        UnitType3[UnitType3["kPercentage"] = 2] = "kPercentage";
        UnitType3[UnitType3["kEms"] = 3] = "kEms";
        UnitType3[UnitType3["kPixels"] = 4] = "kPixels";
        UnitType3[UnitType3["kRems"] = 5] = "kRems";
        UnitType3[UnitType3["kDegrees"] = 6] = "kDegrees";
        UnitType3[UnitType3["kRadians"] = 7] = "kRadians";
        UnitType3[UnitType3["kGradians"] = 8] = "kGradians";
        UnitType3[UnitType3["kTurns"] = 9] = "kTurns";
        UnitType3[UnitType3["kMilliseconds"] = 10] = "kMilliseconds";
        UnitType3[UnitType3["kSeconds"] = 11] = "kSeconds";
        UnitType3[UnitType3["kInteger"] = 12] = "kInteger";
        return UnitType3;
      })({});
      var UnitCategory2 = /* @__PURE__ */ (function(UnitCategory3) {
        UnitCategory3[UnitCategory3["kUNumber"] = 0] = "kUNumber";
        UnitCategory3[UnitCategory3["kUPercent"] = 1] = "kUPercent";
        UnitCategory3[UnitCategory3["kULength"] = 2] = "kULength";
        UnitCategory3[UnitCategory3["kUAngle"] = 3] = "kUAngle";
        UnitCategory3[UnitCategory3["kUTime"] = 4] = "kUTime";
        UnitCategory3[UnitCategory3["kUOther"] = 5] = "kUOther";
        return UnitCategory3;
      })({});
      var Nested2 = /* @__PURE__ */ (function(Nested3) {
        Nested3[Nested3["kYes"] = 0] = "kYes";
        Nested3[Nested3["kNo"] = 1] = "kNo";
        return Nested3;
      })({});
      var ParenLess2 = /* @__PURE__ */ (function(ParenLess3) {
        ParenLess3[ParenLess3["kYes"] = 0] = "kYes";
        ParenLess3[ParenLess3["kNo"] = 1] = "kNo";
        return ParenLess3;
      })({});
      var data2 = [
        {
          name: "em",
          unit_type: UnitType2.kEms
        },
        // {
        //   name: 'ex',
        //   unit_type: UnitType.kExs,
        // },
        {
          name: "px",
          unit_type: UnitType2.kPixels
        },
        // {
        //   name: "cm",
        //   unit_type: UnitType.kCentimeters,
        // },
        // {
        //   name: "mm",
        //   unit_type: UnitType.kMillimeters,
        // },
        // {
        //   name: "q",
        //   unit_type: UnitType.kQuarterMillimeters,
        // },
        // {
        //   name: "in",
        //   unit_type: UnitType.kInches,
        // },
        // {
        //   name: "pt",
        //   unit_type: UnitType.kPoints,
        // },
        // {
        //   name: "pc",
        //   unit_type: UnitType.kPicas,
        // },
        {
          name: "deg",
          unit_type: UnitType2.kDegrees
        },
        {
          name: "rad",
          unit_type: UnitType2.kRadians
        },
        {
          name: "grad",
          unit_type: UnitType2.kGradians
        },
        {
          name: "ms",
          unit_type: UnitType2.kMilliseconds
        },
        {
          name: "s",
          unit_type: UnitType2.kSeconds
        },
        // {
        //   name: "hz",
        //   unit_type: UnitType.kHertz,
        // },
        // {
        //   name: "khz",
        //   unit_type: UnitType.kKilohertz,
        // },
        // {
        //   name: "dpi",
        //   unit_type: "kDotsPerInch",
        // },
        // {
        //   name: "dpcm",
        //   unit_type: "kDotsPerCentimeter",
        // },
        // {
        //   name: "dppx",
        //   unit_type: "kDotsPerPixel",
        // },
        // {
        //   name: "x",
        //   unit_type: "kDotsPerPixel",
        // },
        // {
        //   name: "vw",
        //   unit_type: "kViewportWidth",
        // },
        // {
        //   name: "vh",
        //   unit_type: "kViewportHeight",
        // },
        // {
        //   name: "vi",
        //   unit_type: "kViewportInlineSize",
        // },
        // {
        //   name: "vb",
        //   unit_type: "kViewportBlockSize",
        // },
        // {
        //   name: "vmin",
        //   unit_type: UnitType.kViewportMin,
        // },
        // {
        //   name: "vmax",
        //   unit_type: UnitType.kViewportMax,
        // },
        // {
        //   name: "svw",
        //   unit_type: "kSmallViewportWidth",
        // },
        // {
        //   name: "svh",
        //   unit_type: "kSmallViewportHeight",
        // },
        // {
        //   name: "svi",
        //   unit_type: "kSmallViewportInlineSize",
        // },
        // {
        //   name: "svb",
        //   unit_type: "kSmallViewportBlockSize",
        // },
        // {
        //   name: "svmin",
        //   unit_type: "kSmallViewportMin",
        // },
        // {
        //   name: "svmax",
        //   unit_type: "kSmallViewportMax",
        // },
        // {
        //   name: "lvw",
        //   unit_type: "kLargeViewportWidth",
        // },
        // {
        //   name: "lvh",
        //   unit_type: "kLargeViewportHeight",
        // },
        // {
        //   name: "lvi",
        //   unit_type: "kLargeViewportInlineSize",
        // },
        // {
        //   name: "lvb",
        //   unit_type: "kLargeViewportBlockSize",
        // },
        // {
        //   name: "lvmin",
        //   unit_type: UnitType.kLargeViewportMin,
        // },
        // {
        //   name: "lvmax",
        //   unit_type: UnitType.kLargeViewportMax,
        // },
        // {
        //   name: "dvw",
        //   unit_type: UnitType.kDynamicViewportWidth,
        // },
        // {
        //   name: "dvh",
        //   unit_type: UnitType.kDynamicViewportHeight,
        // },
        // {
        //   name: "dvi",
        //   unit_type: UnitType.kDynamicViewportInlineSize,
        // },
        // {
        //   name: "dvb",
        //   unit_type: UnitType.kDynamicViewportBlockSize,
        // },
        // {
        //   name: "dvmin",
        //   unit_type: UnitType.kDynamicViewportMin,
        // },
        // {
        //   name: "dvmax",
        //   unit_type: UnitType.kDynamicViewportMax,
        // },
        // {
        //   name: "cqw",
        //   unit_type: UnitType.kContainerWidth,
        // },
        // {
        //   name: "cqh",
        //   unit_type: UnitType.kContainerHeight,
        // },
        // {
        //   name: "cqi",
        //   unit_type: UnitType.kContainerInlineSize,
        // },
        // {
        //   name: "cqb",
        //   unit_type: UnitType.kContainerBlockSize,
        // },
        // {
        //   name: "cqmin",
        //   unit_type: UnitType.kContainerMin,
        // },
        // {
        //   name: "cqmax",
        //   unit_type: UnitType.kContainerMax,
        // },
        {
          name: "rem",
          unit_type: UnitType2.kRems
        },
        // {
        //   name: 'fr',
        //   unit_type: UnitType.kFraction,
        // },
        {
          name: "turn",
          unit_type: UnitType2.kTurns
        }
        // {
        //   name: 'ch',
        //   unit_type: UnitType.kChs,
        // },
        // {
        //   name: '__qem',
        //   unit_type: UnitType.kQuirkyEms,
        // },
      ];
      var CSSStyleValueType2 = /* @__PURE__ */ (function(CSSStyleValueType3) {
        CSSStyleValueType3[CSSStyleValueType3["kUnknownType"] = 0] = "kUnknownType";
        CSSStyleValueType3[CSSStyleValueType3["kUnparsedType"] = 1] = "kUnparsedType";
        CSSStyleValueType3[CSSStyleValueType3["kKeywordType"] = 2] = "kKeywordType";
        CSSStyleValueType3[CSSStyleValueType3["kUnitType"] = 3] = "kUnitType";
        CSSStyleValueType3[CSSStyleValueType3["kSumType"] = 4] = "kSumType";
        CSSStyleValueType3[CSSStyleValueType3["kProductType"] = 5] = "kProductType";
        CSSStyleValueType3[CSSStyleValueType3["kNegateType"] = 6] = "kNegateType";
        CSSStyleValueType3[CSSStyleValueType3["kInvertType"] = 7] = "kInvertType";
        CSSStyleValueType3[CSSStyleValueType3["kMinType"] = 8] = "kMinType";
        CSSStyleValueType3[CSSStyleValueType3["kMaxType"] = 9] = "kMaxType";
        CSSStyleValueType3[CSSStyleValueType3["kClampType"] = 10] = "kClampType";
        CSSStyleValueType3[CSSStyleValueType3["kTransformType"] = 11] = "kTransformType";
        CSSStyleValueType3[CSSStyleValueType3["kPositionType"] = 12] = "kPositionType";
        CSSStyleValueType3[CSSStyleValueType3["kURLImageType"] = 13] = "kURLImageType";
        CSSStyleValueType3[CSSStyleValueType3["kColorType"] = 14] = "kColorType";
        CSSStyleValueType3[CSSStyleValueType3["kUnsupportedColorType"] = 15] = "kUnsupportedColorType";
        return CSSStyleValueType3;
      })({});
      var stringToUnitType3 = function stringToUnitType4(name) {
        return data2.find(function(item) {
          return item.name === name;
        }).unit_type;
      };
      var unitFromName3 = function unitFromName4(name) {
        if (!name) {
          return UnitType2.kUnknown;
        }
        if (name === "number") {
          return UnitType2.kNumber;
        }
        if (name === "percent" || name === "%") {
          return UnitType2.kPercentage;
        }
        return stringToUnitType3(name);
      };
      var unitTypeToUnitCategory3 = function unitTypeToUnitCategory4(type) {
        switch (type) {
          case UnitType2.kNumber:
          case UnitType2.kInteger:
            return UnitCategory2.kUNumber;
          case UnitType2.kPercentage:
            return UnitCategory2.kUPercent;
          case UnitType2.kPixels:
            return UnitCategory2.kULength;
          case UnitType2.kMilliseconds:
          case UnitType2.kSeconds:
            return UnitCategory2.kUTime;
          case UnitType2.kDegrees:
          case UnitType2.kRadians:
          case UnitType2.kGradians:
          case UnitType2.kTurns:
            return UnitCategory2.kUAngle;
          // case UnitType.kHertz:
          // case UnitType.kKilohertz:
          //   return UnitCategory.kUFrequency;
          // case UnitType.kDotsPerPixel:
          // case UnitType.kDotsPerInch:
          // case UnitType.kDotsPerCentimeter:
          //   return UnitCategory.kUResolution;
          default:
            return UnitCategory2.kUOther;
        }
      };
      var canonicalUnitTypeForCategory3 = function canonicalUnitTypeForCategory4(category) {
        switch (category) {
          case UnitCategory2.kUNumber:
            return UnitType2.kNumber;
          case UnitCategory2.kULength:
            return UnitType2.kPixels;
          case UnitCategory2.kUPercent:
            return UnitType2.kPercentage;
          // return UnitType.kUnknown; // Cannot convert between numbers and percent.
          case UnitCategory2.kUTime:
            return UnitType2.kSeconds;
          case UnitCategory2.kUAngle:
            return UnitType2.kDegrees;
          // case UnitCategory.kUFrequency:
          //   return UnitType.kHertz;
          // case UnitCategory.kUResolution:
          //   return UnitType.kDotsPerPixel;
          default:
            return UnitType2.kUnknown;
        }
      };
      var conversionToCanonicalUnitsScaleFactor3 = function conversionToCanonicalUnitsScaleFactor4(unit_type) {
        var factor = 1;
        switch (unit_type) {
          // These are "canonical" units in their respective categories.
          case UnitType2.kPixels:
          // case UnitType.kUserUnits:
          case UnitType2.kDegrees:
          case UnitType2.kSeconds:
            break;
          case UnitType2.kMilliseconds:
            factor = 1e-3;
            break;
          // case UnitType.kCentimeters:
          //   // factor = kCssPixelsPerCentimeter;
          //   break;
          // case UnitType.kDotsPerCentimeter:
          //   // factor = 1 / kCssPixelsPerCentimeter;
          //   break;
          // case UnitType.kMillimeters:
          //   // factor = kCssPixelsPerMillimeter;
          //   break;
          // case UnitType.kQuarterMillimeters:
          //   // factor = kCssPixelsPerQuarterMillimeter;
          //   break;
          // case UnitType.kInches:
          //   // factor = kCssPixelsPerInch;
          //   break;
          // case UnitType.kDotsPerInch:
          //   // factor = 1 / kCssPixelsPerInch;
          //   break;
          // case UnitType.kPoints:
          //   // factor = kCssPixelsPerPoint;
          //   break;
          // case UnitType.kPicas:
          //   // factor = kCssPixelsPerPica;
          //   break;
          case UnitType2.kRadians:
            factor = 180 / Math.PI;
            break;
          case UnitType2.kGradians:
            factor = 0.9;
            break;
          case UnitType2.kTurns:
            factor = 360;
            break;
        }
        return factor;
      };
      var unitTypeToString3 = function unitTypeToString4(type) {
        switch (type) {
          case UnitType2.kNumber:
          case UnitType2.kInteger:
            return "";
          case UnitType2.kPercentage:
            return "%";
          case UnitType2.kEms:
            return "em";
          // case UnitType.kExs:
          //   return 'ex';
          case UnitType2.kRems:
            return "rem";
          // case UnitType.kChs:
          //   return 'ch';
          case UnitType2.kPixels:
            return "px";
          // case UnitType.kCentimeters:
          //   return 'cm';
          // case UnitType.kDotsPerPixel:
          //   return 'dppx';
          // case UnitType.kDotsPerInch:
          //   return 'dpi';
          // case UnitType.kDotsPerCentimeter:
          //   return 'dpcm';
          // case UnitType.kMillimeters:
          //   return 'mm';
          // case UnitType.kQuarterMillimeters:
          //   return 'q';
          // case UnitType.kInches:
          //   return 'in';
          // case UnitType.kPoints:
          //   return 'pt';
          // case UnitType.kPicas:
          //   return 'pc';
          case UnitType2.kDegrees:
            return "deg";
          case UnitType2.kRadians:
            return "rad";
          case UnitType2.kGradians:
            return "grad";
          case UnitType2.kMilliseconds:
            return "ms";
          case UnitType2.kSeconds:
            return "s";
          // case UnitType.kHertz:
          //   return 'hz';
          // case UnitType.kKilohertz:
          //   return 'khz';
          case UnitType2.kTurns:
            return "turn";
        }
        return "";
      };
      var CSSStyleValue2 = /* @__PURE__ */ (function() {
        function CSSStyleValue3() {
          _classCallCheck2(this, CSSStyleValue3);
        }
        return _createClass2(CSSStyleValue3, [{
          key: "toString",
          value: (
            // protected abstract toCSSValue(): CSSValue;
            function toString3() {
              return this.buildCSSText(Nested2.kNo, ParenLess2.kNo, "");
            }
          )
        }, {
          key: "isNumericValue",
          value: function isNumericValue() {
            return this.getType() >= CSSStyleValueType2.kUnitType && this.getType() <= CSSStyleValueType2.kClampType;
          }
        }], [{
          key: "isAngle",
          value: (
            // static parse(propertyName: string, value: string): CSSStyleValue {
            //   return parseCSSStyleValue(propertyName, value)[0];
            // }
            // static parseAll(propertyName: string, value: string): CSSStyleValue[] {
            //   return parseCSSStyleValue(propertyName, value);
            // }
            function isAngle(unit) {
              return unit === UnitType2.kDegrees || unit === UnitType2.kRadians || unit === UnitType2.kGradians || unit === UnitType2.kTurns;
            }
          )
          // static isViewportPercentageLength(type: UnitType) {
          //   return type >= UnitType.kViewportWidth && type <= UnitType.kDynamicViewportMax;
          // }
          // static isContainerPercentageLength(type: UnitType) {
          //   return type >= UnitType.kContainerWidth && type <= UnitType.kContainerMax;
          // }
        }, {
          key: "isLength",
          value: function isLength(type) {
            return type >= UnitType2.kEms && type < UnitType2.kDegrees;
          }
        }, {
          key: "isRelativeUnit",
          value: function isRelativeUnit(type) {
            return type === UnitType2.kPercentage || type === UnitType2.kEms || // type === UnitType.kExs ||
            type === UnitType2.kRems;
          }
        }, {
          key: "isTime",
          value: function isTime(unit) {
            return unit === UnitType2.kSeconds || unit === UnitType2.kMilliseconds;
          }
          // static isFrequency(unit: UnitType) {
          //   return unit == UnitType.kHertz || unit == UnitType.kKilohertz;
          // }
          // static isResolution(type: UnitType) {
          //   return type >= UnitType.kDotsPerPixel && type <= UnitType.kDotsPerCentimeter;
          // }
          // static isFlex(unit: UnitType) {
          //   return unit === UnitType.kFraction;
          // }
        }]);
      })();
      var CSSColorValue2 = /* @__PURE__ */ (function(_CSSStyleValue) {
        function CSSColorValue3(colorSpace) {
          var _this2;
          _classCallCheck2(this, CSSColorValue3);
          _this2 = _callSuper2(this, CSSColorValue3);
          _this2.colorSpace = colorSpace;
          return _this2;
        }
        _inherits2(CSSColorValue3, _CSSStyleValue);
        return _createClass2(CSSColorValue3, [{
          key: "getType",
          value: function getType2() {
            return CSSStyleValueType2.kColorType;
          }
          /**
           * @see https://drafts.css-houdini.org/css-typed-om-1/#dom-csscolorvalue-to
           */
        }, {
          key: "to",
          value: function to(colorSpace) {
            return this;
          }
        }]);
      })(CSSStyleValue2);
      var GradientType2 = /* @__PURE__ */ (function(GradientType3) {
        GradientType3[GradientType3["Constant"] = 0] = "Constant";
        GradientType3[GradientType3["LinearGradient"] = 1] = "LinearGradient";
        GradientType3[GradientType3["RadialGradient"] = 2] = "RadialGradient";
        return GradientType3;
      })({});
      var CSSGradientValue2 = /* @__PURE__ */ (function(_CSSStyleValue) {
        function CSSGradientValue3(type, value) {
          var _this2;
          _classCallCheck2(this, CSSGradientValue3);
          _this2 = _callSuper2(this, CSSGradientValue3);
          _this2.type = type;
          _this2.value = value;
          return _this2;
        }
        _inherits2(CSSGradientValue3, _CSSStyleValue);
        return _createClass2(CSSGradientValue3, [{
          key: "clone",
          value: function clone8() {
            return new CSSGradientValue3(this.type, this.value);
          }
        }, {
          key: "buildCSSText",
          value: function buildCSSText(n, p, result) {
            return result;
          }
        }, {
          key: "getType",
          value: function getType2() {
            return CSSStyleValueType2.kColorType;
          }
        }]);
      })(CSSStyleValue2);
      var CSSKeywordValue2 = /* @__PURE__ */ (function(_CSSStyleValue) {
        function CSSKeywordValue3(value) {
          var _this2;
          _classCallCheck2(this, CSSKeywordValue3);
          _this2 = _callSuper2(this, CSSKeywordValue3);
          _this2.value = value;
          return _this2;
        }
        _inherits2(CSSKeywordValue3, _CSSStyleValue);
        return _createClass2(CSSKeywordValue3, [{
          key: "clone",
          value: function clone8() {
            return new CSSKeywordValue3(this.value);
          }
        }, {
          key: "getType",
          value: function getType2() {
            return CSSStyleValueType2.kKeywordType;
          }
        }, {
          key: "buildCSSText",
          value: function buildCSSText(n, p, result) {
            return result + this.value;
          }
        }]);
      })(CSSStyleValue2);
      var formatInfinityOrNaN3 = function formatInfinityOrNaN4(number) {
        var suffix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        var result = "";
        if (!Number.isFinite(number)) {
          if (number > 0) result = "infinity";
          else result = "-infinity";
        } else {
          result = "NaN";
        }
        return result += suffix;
      };
      var toCanonicalUnit3 = function toCanonicalUnit4(unit) {
        return canonicalUnitTypeForCategory3(unitTypeToUnitCategory3(unit));
      };
      var CSSUnitValue2 = /* @__PURE__ */ (function(_CSSStyleValue) {
        function CSSUnitValue3(value) {
          var _this2;
          var unitOrName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : UnitType2.kNumber;
          _classCallCheck2(this, CSSUnitValue3);
          _this2 = _callSuper2(this, CSSUnitValue3);
          var unit;
          if (typeof unitOrName === "string") {
            unit = unitFromName3(unitOrName);
          } else {
            unit = unitOrName;
          }
          _this2.unit = unit;
          _this2.value = value;
          return _this2;
        }
        _inherits2(CSSUnitValue3, _CSSStyleValue);
        return _createClass2(CSSUnitValue3, [{
          key: "clone",
          value: function clone8() {
            return new CSSUnitValue3(this.value, this.unit);
          }
        }, {
          key: "equals",
          value: function equals(other) {
            var other_unit_value = other;
            return this.value === other_unit_value.value && this.unit === other_unit_value.unit;
          }
        }, {
          key: "getType",
          value: function getType2() {
            return CSSStyleValueType2.kUnitType;
          }
        }, {
          key: "convertTo",
          value: function convertTo(target_unit) {
            if (this.unit === target_unit) {
              return new CSSUnitValue3(this.value, this.unit);
            }
            var canonical_unit = toCanonicalUnit3(this.unit);
            if (canonical_unit !== toCanonicalUnit3(target_unit) || canonical_unit === UnitType2.kUnknown) {
              return null;
            }
            var scale_factor = conversionToCanonicalUnitsScaleFactor3(this.unit) / conversionToCanonicalUnitsScaleFactor3(target_unit);
            return new CSSUnitValue3(this.value * scale_factor, target_unit);
          }
        }, {
          key: "buildCSSText",
          value: function buildCSSText(n, p, result) {
            var text;
            switch (this.unit) {
              case UnitType2.kUnknown:
                break;
              case UnitType2.kInteger:
                text = Number(this.value).toFixed(0);
                break;
              case UnitType2.kNumber:
              case UnitType2.kPercentage:
              case UnitType2.kEms:
              // case UnitType.kQuirkyEms:
              // case UnitType.kExs:
              case UnitType2.kRems:
              // case UnitType.kChs:
              case UnitType2.kPixels:
              // case UnitType.kCentimeters:
              // case UnitType.kDotsPerPixel:
              // case UnitType.kDotsPerInch:
              // case UnitType.kDotsPerCentimeter:
              // case UnitType.kMillimeters:
              // case UnitType.kQuarterMillimeters:
              // case UnitType.kInches:
              // case UnitType.kPoints:
              // case UnitType.kPicas:
              // case UnitType.kUserUnits:
              case UnitType2.kDegrees:
              case UnitType2.kRadians:
              case UnitType2.kGradians:
              case UnitType2.kMilliseconds:
              case UnitType2.kSeconds:
              // case UnitType.kHertz:
              // case UnitType.kKilohertz:
              case UnitType2.kTurns: {
                var kMinInteger = -999999;
                var kMaxInteger = 999999;
                var value = this.value;
                var unit = unitTypeToString3(this.unit);
                if (value < kMinInteger || value > kMaxInteger) {
                  var _unit = unitTypeToString3(this.unit);
                  if (!Number.isFinite(value) || Number.isNaN(value)) {
                    text = formatInfinityOrNaN3(value, _unit);
                  } else {
                    text = value + (_unit || "");
                  }
                } else {
                  text = "".concat(value).concat(unit);
                }
              }
            }
            result += text;
            return result;
          }
        }]);
      })(CSSStyleValue2);
      var Opx2 = new CSSUnitValue2(0, "px");
      new CSSUnitValue2(1, "px");
      var Odeg2 = new CSSUnitValue2(0, "deg");
      var CSSRGB2 = /* @__PURE__ */ (function(_CSSColorValue) {
        function CSSRGB3(r, g, b) {
          var _this2;
          var alpha = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
          var isNone = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
          _classCallCheck2(this, CSSRGB3);
          _this2 = _callSuper2(this, CSSRGB3, ["rgb"]);
          _this2.r = r;
          _this2.g = g;
          _this2.b = b;
          _this2.alpha = alpha;
          _this2.isNone = isNone;
          return _this2;
        }
        _inherits2(CSSRGB3, _CSSColorValue);
        return _createClass2(CSSRGB3, [{
          key: "clone",
          value: function clone8() {
            return new CSSRGB3(this.r, this.g, this.b, this.alpha);
          }
        }, {
          key: "buildCSSText",
          value: function buildCSSText(n, p, result) {
            return "".concat(result, "rgba(").concat(this.r, ",").concat(this.g, ",").concat(this.b, ",").concat(this.alpha, ")");
          }
        }]);
      })(CSSColorValue2);
      var unsetKeywordValue2 = new CSSKeywordValue2("unset");
      var initialKeywordValue2 = new CSSKeywordValue2("initial");
      var inheritKeywordValue2 = new CSSKeywordValue2("inherit");
      var keywordCache2 = {
        "": unsetKeywordValue2,
        unset: unsetKeywordValue2,
        initial: initialKeywordValue2,
        inherit: inheritKeywordValue2
      };
      var getOrCreateKeyword3 = function getOrCreateKeyword4(name) {
        if (!keywordCache2[name]) {
          keywordCache2[name] = new CSSKeywordValue2(name);
        }
        return keywordCache2[name];
      };
      var noneColor2 = new CSSRGB2(0, 0, 0, 0, true);
      var transparentColor2 = new CSSRGB2(0, 0, 0, 0);
      var getOrCreateRGBA2 = memoize4(function(r, g, b, a2) {
        return new CSSRGB2(r, g, b, a2);
      }, function(r, g, b, a2) {
        return "rgba(".concat(r, ",").concat(g, ",").concat(b, ",").concat(a2, ")");
      });
      var getOrCreateUnitValue3 = function getOrCreateUnitValue4(value) {
        var unitOrName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : UnitType2.kNumber;
        return new CSSUnitValue2(value, unitOrName);
      };
      new CSSUnitValue2(50, "%");
      function colorStopToString2(colorStop) {
        var type = colorStop.type, value = colorStop.value;
        if (type === "hex") {
          return "#".concat(value);
        }
        if (type === "literal") {
          return value;
        }
        if (type === "rgb") {
          return "rgb(".concat(value.join(","), ")");
        }
        return "rgba(".concat(value.join(","), ")");
      }
      var parseGradient$12 = /* @__PURE__ */ (function() {
        var tokens3 = {
          linearGradient: /^(linear\-gradient)/i,
          repeatingLinearGradient: /^(repeating\-linear\-gradient)/i,
          radialGradient: /^(radial\-gradient)/i,
          repeatingRadialGradient: /^(repeating\-radial\-gradient)/i,
          /**
           * @see https://projects.verou.me/conic-gradient/
           */
          conicGradient: /^(conic\-gradient)/i,
          sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
          extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
          positionKeywords: /^(left|center|right|top|bottom)/i,
          pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
          percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
          emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
          angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
          startCall: /^\(/,
          endCall: /^\)/,
          comma: /^,/,
          hexColor: /^\#([0-9a-fA-F]+)/,
          literalColor: /^([a-zA-Z]+)/,
          rgbColor: /^rgb/i,
          rgbaColor: /^rgba/i,
          number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
        };
        var input = "";
        function error2(msg) {
          throw new Error("".concat(input, ": ").concat(msg));
        }
        function getAST() {
          var ast = matchListDefinitions();
          if (input.length > 0) {
            error2("Invalid input not EOF");
          }
          return ast;
        }
        function matchListDefinitions() {
          return matchListing(matchDefinition);
        }
        function matchDefinition() {
          return matchGradient("linear-gradient", tokens3.linearGradient, matchLinearOrientation) || matchGradient("repeating-linear-gradient", tokens3.repeatingLinearGradient, matchLinearOrientation) || matchGradient("radial-gradient", tokens3.radialGradient, matchListRadialOrientations) || matchGradient("repeating-radial-gradient", tokens3.repeatingRadialGradient, matchListRadialOrientations) || matchGradient("conic-gradient", tokens3.conicGradient, matchListRadialOrientations);
        }
        function matchGradient(gradientType, pattern, orientationMatcher) {
          return matchCall(pattern, function(captures) {
            var orientation5 = orientationMatcher();
            if (orientation5) {
              if (!scan(tokens3.comma)) {
                error2("Missing comma before color stops");
              }
            }
            return {
              type: gradientType,
              orientation: orientation5,
              colorStops: matchListing(matchColorStop)
            };
          });
        }
        function matchCall(pattern, callback) {
          var captures = scan(pattern);
          if (captures) {
            if (!scan(tokens3.startCall)) {
              error2("Missing (");
            }
            var result = callback(captures);
            if (!scan(tokens3.endCall)) {
              error2("Missing )");
            }
            return result;
          }
        }
        function matchLinearOrientation() {
          return matchSideOrCorner() || matchAngle();
        }
        function matchSideOrCorner() {
          return match2("directional", tokens3.sideOrCorner, 1);
        }
        function matchAngle() {
          return match2("angular", tokens3.angleValue, 1);
        }
        function matchListRadialOrientations() {
          var radialOrientations;
          var radialOrientation = matchRadialOrientation();
          var lookaheadCache;
          if (radialOrientation) {
            radialOrientations = [];
            radialOrientations.push(radialOrientation);
            lookaheadCache = input;
            if (scan(tokens3.comma)) {
              radialOrientation = matchRadialOrientation();
              if (radialOrientation) {
                radialOrientations.push(radialOrientation);
              } else {
                input = lookaheadCache;
              }
            }
          }
          return radialOrientations;
        }
        function matchRadialOrientation() {
          var radialType = matchCircle() || matchEllipse();
          if (radialType) {
            radialType.at = matchAtPosition();
          } else {
            var extent = matchExtentKeyword();
            if (extent) {
              radialType = extent;
              var positionAt = matchAtPosition();
              if (positionAt) {
                radialType.at = positionAt;
              }
            } else {
              var defaultPosition = matchPositioning();
              if (defaultPosition) {
                radialType = {
                  type: "default-radial",
                  // @ts-ignore
                  at: defaultPosition
                };
              }
            }
          }
          return radialType;
        }
        function matchCircle() {
          var circle3 = match2("shape", /^(circle)/i, 0);
          if (circle3) {
            circle3.style = matchLength() || matchExtentKeyword();
          }
          return circle3;
        }
        function matchEllipse() {
          var ellipse = match2("shape", /^(ellipse)/i, 0);
          if (ellipse) {
            ellipse.style = matchDistance() || matchExtentKeyword();
          }
          return ellipse;
        }
        function matchExtentKeyword() {
          return match2("extent-keyword", tokens3.extentKeywords, 1);
        }
        function matchAtPosition() {
          if (match2("position", /^at/, 0)) {
            var positioning = matchPositioning();
            if (!positioning) {
              error2("Missing positioning value");
            }
            return positioning;
          }
        }
        function matchPositioning() {
          var location = matchCoordinates();
          if (location.x || location.y) {
            return {
              type: "position",
              value: location
            };
          }
        }
        function matchCoordinates() {
          return {
            x: matchDistance(),
            y: matchDistance()
          };
        }
        function matchListing(matcher) {
          var captures = matcher();
          var result = [];
          if (captures) {
            result.push(captures);
            while (scan(tokens3.comma)) {
              captures = matcher();
              if (captures) {
                result.push(captures);
              } else {
                error2("One extra comma");
              }
            }
          }
          return result;
        }
        function matchColorStop() {
          var color3 = matchColor();
          if (!color3) {
            error2("Expected color definition");
          }
          color3.length = matchDistance();
          return color3;
        }
        function matchColor() {
          return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor();
        }
        function matchLiteralColor() {
          return match2("literal", tokens3.literalColor, 0);
        }
        function matchHexColor() {
          return match2("hex", tokens3.hexColor, 1);
        }
        function matchRGBColor() {
          return matchCall(tokens3.rgbColor, function() {
            return {
              type: "rgb",
              value: matchListing(matchNumber)
            };
          });
        }
        function matchRGBAColor() {
          return matchCall(tokens3.rgbaColor, function() {
            return {
              type: "rgba",
              value: matchListing(matchNumber)
            };
          });
        }
        function matchNumber() {
          return scan(tokens3.number)[1];
        }
        function matchDistance() {
          return match2("%", tokens3.percentageValue, 1) || matchPositionKeyword() || matchLength();
        }
        function matchPositionKeyword() {
          return match2("position-keyword", tokens3.positionKeywords, 1);
        }
        function matchLength() {
          return match2("px", tokens3.pixelValue, 1) || match2("em", tokens3.emValue, 1);
        }
        function match2(type, pattern, captureIndex) {
          var captures = scan(pattern);
          if (captures) {
            return {
              type,
              value: captures[captureIndex]
            };
          }
        }
        function scan(regexp) {
          var blankCaptures = /^[\n\r\t\s]+/.exec(input);
          if (blankCaptures) {
            consume(blankCaptures[0].length);
          }
          var captures = regexp.exec(input);
          if (captures) {
            consume(captures[0].length);
          }
          return captures;
        }
        function consume(size2) {
          input = input.substring(size2);
        }
        return function(code) {
          input = code;
          return getAST();
        };
      })();
      function computeLinearGradient2(min4, width2, height, angle2) {
        var rad2 = deg2rad2(angle2.value);
        var rx = 0;
        var ry = 0;
        var rcx = rx + width2 / 2;
        var rcy = ry + height / 2;
        var length = Math.abs(width2 * Math.cos(rad2)) + Math.abs(height * Math.sin(rad2));
        var x1 = min4[0] + rcx - Math.cos(rad2) * length / 2;
        var y1 = min4[1] + rcy - Math.sin(rad2) * length / 2;
        var x22 = min4[0] + rcx + Math.cos(rad2) * length / 2;
        var y22 = min4[1] + rcy + Math.sin(rad2) * length / 2;
        return {
          x1,
          y1,
          x2: x22,
          y2: y22
        };
      }
      function computeRadialGradient2(min4, width2, height, cx, cy, size2) {
        var x3 = cx.value;
        var y3 = cy.value;
        if (cx.unit === UnitType2.kPercentage) {
          x3 = cx.value / 100 * width2;
        }
        if (cy.unit === UnitType2.kPercentage) {
          y3 = cy.value / 100 * height;
        }
        var r = Math.max(util.distanceSquareRoot([0, 0], [x3, y3]), util.distanceSquareRoot([0, height], [x3, y3]), util.distanceSquareRoot([width2, height], [x3, y3]), util.distanceSquareRoot([width2, 0], [x3, y3]));
        if (size2) {
          if (size2 instanceof CSSUnitValue2) {
            r = size2.value;
          } else if (size2 instanceof CSSKeywordValue2) {
            if (size2.value === "closest-side") {
              r = Math.min(x3, width2 - x3, y3, height - y3);
            } else if (size2.value === "farthest-side") {
              r = Math.max(x3, width2 - x3, y3, height - y3);
            } else if (size2.value === "closest-corner") {
              r = Math.min(util.distanceSquareRoot([0, 0], [x3, y3]), util.distanceSquareRoot([0, height], [x3, y3]), util.distanceSquareRoot([width2, height], [x3, y3]), util.distanceSquareRoot([width2, 0], [x3, y3]));
            }
          }
        }
        return {
          x: x3 + min4[0],
          y: y3 + min4[1],
          r
        };
      }
      var regexLG2 = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
      var regexRG2 = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
      var regexPR2 = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
      var regexColorStop2 = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
      function spaceColorStops2(colorStops) {
        var _colorStops$length;
        var length = colorStops.length;
        colorStops[length - 1].length = (_colorStops$length = colorStops[length - 1].length) !== null && _colorStops$length !== void 0 ? _colorStops$length : {
          type: "%",
          value: "100"
        };
        if (length > 1) {
          var _colorStops$0$length;
          colorStops[0].length = (_colorStops$0$length = colorStops[0].length) !== null && _colorStops$0$length !== void 0 ? _colorStops$0$length : {
            type: "%",
            value: "0"
          };
        }
        var previousIndex = 0;
        var previousOffset = Number(colorStops[0].length.value);
        for (var i = 1; i < length; i++) {
          var _colorStops$i$length;
          var offset = (_colorStops$i$length = colorStops[i].length) === null || _colorStops$i$length === void 0 ? void 0 : _colorStops$i$length.value;
          if (!util.isNil(offset) && !util.isNil(previousOffset)) {
            for (var j = 1; j < i - previousIndex; j++) colorStops[previousIndex + j].length = {
              type: "%",
              value: "".concat(previousOffset + (Number(offset) - previousOffset) * j / (i - previousIndex))
            };
            previousIndex = i;
            previousOffset = Number(offset);
          }
        }
      }
      var SideOrCornerToDegMap2 = {
        left: 270 - 90,
        top: 0 - 90,
        bottom: 180 - 90,
        right: 90 - 90,
        "left top": 315 - 90,
        "top left": 315 - 90,
        "left bottom": 225 - 90,
        "bottom left": 225 - 90,
        "right top": 45 - 90,
        "top right": 45 - 90,
        "right bottom": 135 - 90,
        "bottom right": 135 - 90
      };
      var angleToDeg2 = memoize4(function(orientation5) {
        var angle2;
        if (orientation5.type === "angular") {
          angle2 = Number(orientation5.value);
        } else {
          angle2 = SideOrCornerToDegMap2[orientation5.value] || 0;
        }
        return getOrCreateUnitValue3(angle2, "deg");
      });
      var positonToCSSUnitValue2 = memoize4(function(position2) {
        var cx = 50;
        var cy = 50;
        var unitX = "%";
        var unitY = "%";
        if ((position2 === null || position2 === void 0 ? void 0 : position2.type) === "position") {
          var _position$value = position2.value, x3 = _position$value.x, y3 = _position$value.y;
          if ((x3 === null || x3 === void 0 ? void 0 : x3.type) === "position-keyword") {
            if (x3.value === "left") {
              cx = 0;
            } else if (x3.value === "center") {
              cx = 50;
            } else if (x3.value === "right") {
              cx = 100;
            } else if (x3.value === "top") {
              cy = 0;
            } else if (x3.value === "bottom") {
              cy = 100;
            }
          }
          if ((y3 === null || y3 === void 0 ? void 0 : y3.type) === "position-keyword") {
            if (y3.value === "left") {
              cx = 0;
            } else if (y3.value === "center") {
              cy = 50;
            } else if (y3.value === "right") {
              cx = 100;
            } else if (y3.value === "top") {
              cy = 0;
            } else if (y3.value === "bottom") {
              cy = 100;
            }
          }
          if ((x3 === null || x3 === void 0 ? void 0 : x3.type) === "px" || (x3 === null || x3 === void 0 ? void 0 : x3.type) === "%" || (x3 === null || x3 === void 0 ? void 0 : x3.type) === "em") {
            unitX = x3 === null || x3 === void 0 ? void 0 : x3.type;
            cx = Number(x3.value);
          }
          if ((y3 === null || y3 === void 0 ? void 0 : y3.type) === "px" || (y3 === null || y3 === void 0 ? void 0 : y3.type) === "%" || (y3 === null || y3 === void 0 ? void 0 : y3.type) === "em") {
            unitY = y3 === null || y3 === void 0 ? void 0 : y3.type;
            cy = Number(y3.value);
          }
        }
        return {
          cx: getOrCreateUnitValue3(cx, unitX),
          cy: getOrCreateUnitValue3(cy, unitY)
        };
      });
      var parseGradient2 = memoize4(function(colorStr) {
        if (colorStr.indexOf("linear") > -1 || colorStr.indexOf("radial") > -1) {
          var ast = parseGradient$12(colorStr);
          return ast.map(function(_ref) {
            var type2 = _ref.type, orientation5 = _ref.orientation, colorStops = _ref.colorStops;
            spaceColorStops2(colorStops);
            var steps2 = colorStops.map(function(colorStop) {
              return {
                offset: getOrCreateUnitValue3(Number(colorStop.length.value), "%"),
                color: colorStopToString2(colorStop)
              };
            });
            if (type2 === "linear-gradient") {
              return new CSSGradientValue2(GradientType2.LinearGradient, {
                angle: orientation5 ? angleToDeg2(orientation5) : Odeg2,
                steps: steps2
              });
            }
            if (type2 === "radial-gradient") {
              if (!orientation5) {
                orientation5 = [{
                  type: "shape",
                  value: "circle"
                }];
              }
              if (orientation5[0].type === "shape" && orientation5[0].value === "circle") {
                var _positonToCSSUnitValu = positonToCSSUnitValue2(orientation5[0].at), cx = _positonToCSSUnitValu.cx, cy = _positonToCSSUnitValu.cy;
                var size2;
                if (orientation5[0].style) {
                  var _orientation$0$style = orientation5[0].style, _type = _orientation$0$style.type, value = _orientation$0$style.value;
                  if (_type === "extent-keyword") {
                    size2 = getOrCreateKeyword3(value);
                  } else {
                    size2 = getOrCreateUnitValue3(value, _type);
                  }
                }
                return new CSSGradientValue2(GradientType2.RadialGradient, {
                  cx,
                  cy,
                  size: size2,
                  steps: steps2
                });
              }
            }
            return void 0;
          });
        }
        var type = colorStr[0];
        if (colorStr[1] === "(" || colorStr[2] === "(") {
          if (type === "l") {
            var arr = regexLG2.exec(colorStr);
            if (arr) {
              var _arr$2$match;
              var steps = ((_arr$2$match = arr[2].match(regexColorStop2)) === null || _arr$2$match === void 0 ? void 0 : _arr$2$match.map(function(stop) {
                return stop.split(":");
              })) || [];
              return [new CSSGradientValue2(GradientType2.LinearGradient, {
                angle: getOrCreateUnitValue3(parseFloat(arr[1]), "deg"),
                steps: steps.map(function(_ref2) {
                  var _ref3 = _slicedToArray2(_ref2, 2), offset = _ref3[0], color3 = _ref3[1];
                  return {
                    offset: getOrCreateUnitValue3(Number(offset) * 100, "%"),
                    color: color3
                  };
                })
              })];
            }
          } else if (type === "r") {
            var parsedRadialGradient = parseRadialGradient2(colorStr);
            if (parsedRadialGradient) {
              if (util.isString(parsedRadialGradient)) {
                colorStr = parsedRadialGradient;
              } else {
                return [new CSSGradientValue2(GradientType2.RadialGradient, parsedRadialGradient)];
              }
            }
          } else if (type === "p") {
            return parsePattern2(colorStr);
          }
        }
      });
      function parseRadialGradient2(gradientStr) {
        var arr = regexRG2.exec(gradientStr);
        if (arr) {
          var _arr$4$match;
          var steps = ((_arr$4$match = arr[4].match(regexColorStop2)) === null || _arr$4$match === void 0 ? void 0 : _arr$4$match.map(function(stop) {
            return stop.split(":");
          })) || [];
          return {
            cx: getOrCreateUnitValue3(50, "%"),
            cy: getOrCreateUnitValue3(50, "%"),
            steps: steps.map(function(_ref4) {
              var _ref5 = _slicedToArray2(_ref4, 2), offset = _ref5[0], color3 = _ref5[1];
              return {
                offset: getOrCreateUnitValue3(Number(offset) * 100, "%"),
                color: color3
              };
            })
          };
        }
        return null;
      }
      function parsePattern2(patternStr) {
        var arr = regexPR2.exec(patternStr);
        if (arr) {
          var repetition = arr[1];
          var src = arr[2];
          switch (repetition) {
            case "a":
              repetition = "repeat";
              break;
            case "x":
              repetition = "repeat-x";
              break;
            case "y":
              repetition = "repeat-y";
              break;
            case "n":
              repetition = "no-repeat";
              break;
            default:
              repetition = "no-repeat";
          }
          return {
            image: src,
            // @ts-ignore
            repetition
          };
        }
        return null;
      }
      function isCSSGradientValue(object) {
        return !!object.type && !!object.value;
      }
      function isPattern2(object) {
        return object && !!object.image;
      }
      function isCSSRGB2(object) {
        return object && !util.isNil(object.r) && !util.isNil(object.g) && !util.isNil(object.b);
      }
      var parseColor2 = memoize4(function(colorStr) {
        if (isPattern2(colorStr)) {
          return _objectSpread({
            repetition: "repeat"
          }, colorStr);
        }
        if (util.isNil(colorStr)) {
          colorStr = "";
        }
        if (colorStr === "transparent") {
          return transparentColor2;
        }
        if (colorStr === "currentColor") {
          colorStr = "black";
        } else if (colorStr === "none") {
          return noneColor2;
        }
        var g = parseGradient2(colorStr);
        if (g) {
          return g;
        }
        var color$1 = color2(colorStr);
        var rgba3 = [0, 0, 0, 0];
        if (color$1 !== null) {
          rgba3[0] = color$1.r || 0;
          rgba3[1] = color$1.g || 0;
          rgba3[2] = color$1.b || 0;
          rgba3[3] = color$1.opacity;
        }
        return getOrCreateRGBA2.apply(void 0, rgba3);
      });
      function mergeColors2(left, right) {
        if (!isCSSRGB2(left) || !isCSSRGB2(right)) {
          return;
        }
        return [[Number(left.r), Number(left.g), Number(left.b), Number(left.alpha)], [Number(right.r), Number(right.g), Number(right.b), Number(right.alpha)], function(color3) {
          var rgba3 = color3.slice();
          if (rgba3[3]) {
            for (var i = 0; i < 3; i++) rgba3[i] = Math.round(util.clamp(rgba3[i], 0, 255));
          }
          rgba3[3] = util.clamp(rgba3[3], 0, 1);
          return "rgba(".concat(rgba3.join(","), ")");
        }];
      }
      function parseDimension2(unitRegExp, string) {
        if (util.isNil(string)) {
          return getOrCreateUnitValue3(0, "px");
        }
        string = "".concat(string).trim().toLowerCase();
        if (isFinite(Number(string))) {
          if ("px".search(unitRegExp) >= 0) {
            return getOrCreateUnitValue3(Number(string), "px");
          }
          if ("deg".search(unitRegExp) >= 0) {
            return getOrCreateUnitValue3(Number(string), "deg");
          }
        }
        var matchedUnits = [];
        string = string.replace(unitRegExp, function(match2) {
          matchedUnits.push(match2);
          return "U".concat(match2);
        });
        var taggedUnitRegExp = "U(".concat(unitRegExp.source, ")");
        return matchedUnits.map(function(unit) {
          return getOrCreateUnitValue3(Number(string.replace(new RegExp("U".concat(unit), "g"), "").replace(new RegExp(taggedUnitRegExp, "g"), "*0")), unit);
        })[0];
      }
      var parseLengthUnmemoize3 = function parseLengthUnmemoize4(css) {
        return parseDimension2(new RegExp("px", "g"), css);
      };
      var parseLength2 = memoize4(parseLengthUnmemoize3);
      var parserPercentageUnmemoize3 = function parserPercentageUnmemoize4(css) {
        return parseDimension2(new RegExp("%", "g"), css);
      };
      memoize4(parserPercentageUnmemoize3);
      var parseLengthOrPercentageUnmemoize3 = function parseLengthOrPercentageUnmemoize4(css) {
        if (util.isNumber(css) || isFinite(Number(css))) {
          return getOrCreateUnitValue3(Number(css) || 0, "px");
        }
        return parseDimension2(new RegExp("px|%|em|rem", "g"), css);
      };
      var parseLengthOrPercentage2 = memoize4(parseLengthOrPercentageUnmemoize3);
      var parseAngleUnmemoize3 = function parseAngleUnmemoize4(css) {
        return parseDimension2(new RegExp("deg|rad|grad|turn", "g"), css);
      };
      var parseAngle2 = memoize4(parseAngleUnmemoize3);
      function mergeDimensions2(left, right, target, nonNegative) {
        var index2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
        var unit = "";
        var leftValue = left.value || 0;
        var rightValue = right.value || 0;
        var canonicalUnit = toCanonicalUnit3(left.unit);
        var leftCanonicalUnitValue = left.convertTo(canonicalUnit);
        var rightCanonicalUnitValue = right.convertTo(canonicalUnit);
        if (leftCanonicalUnitValue && rightCanonicalUnitValue) {
          leftValue = leftCanonicalUnitValue.value;
          rightValue = rightCanonicalUnitValue.value;
          unit = unitTypeToString3(left.unit);
        } else if (CSSUnitValue2.isLength(left.unit) || CSSUnitValue2.isLength(right.unit)) {
          leftValue = convertPercentUnit2(left, index2, target);
          rightValue = convertPercentUnit2(right, index2, target);
          unit = "px";
        }
        return [leftValue, rightValue, function(value) {
          if (nonNegative) {
            value = Math.max(value, 0);
          }
          return value + unit;
        }];
      }
      function convertAngleUnit2(value) {
        var deg = 0;
        if (value.unit === UnitType2.kDegrees) {
          deg = value.value;
        } else if (value.unit === UnitType2.kRadians) {
          deg = rad2deg2(Number(value.value));
        } else if (value.unit === UnitType2.kTurns) {
          deg = turn2deg2(Number(value.value));
        } else if (value.value) {
          deg = value.value;
        }
        return deg;
      }
      function parseDimensionArrayFormat2(string, size2) {
        var parsed;
        if (Array.isArray(string)) {
          parsed = string.map(function(segment) {
            return Number(segment);
          });
        } else if (util.isString(string)) {
          parsed = string.split(" ").map(function(segment) {
            return Number(segment);
          });
        } else if (util.isNumber(string)) {
          parsed = [string];
        }
        if (size2 === 2) {
          if (parsed.length === 1) {
            return [parsed[0], parsed[0]];
          }
          return [parsed[0], parsed[1]];
        }
        if (size2 === 4) {
          if (parsed.length === 1) {
            return [parsed[0], parsed[0], parsed[0], parsed[0]];
          }
          if (parsed.length === 2) {
            return [parsed[0], parsed[1], parsed[0], parsed[1]];
          }
          if (parsed.length === 3) {
            return [parsed[0], parsed[1], parsed[2], parsed[1]];
          }
          return [parsed[0], parsed[1], parsed[2], parsed[3]];
        }
        if (size2 === "even" && parsed.length % 2 === 1) {
          return [].concat(_toConsumableArray2(parsed), _toConsumableArray2(parsed));
        }
        return parsed;
      }
      function convertPercentUnit2(valueWithUnit, vec3Index, target) {
        var useMin = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
        if (valueWithUnit.unit === UnitType2.kPixels) {
          return Number(valueWithUnit.value);
        }
        if (valueWithUnit.unit === UnitType2.kPercentage && target) {
          var bounds = target.nodeName === Shape2.GROUP ? target.getLocalBounds() : target.getGeometryBounds();
          return (useMin ? bounds.min[vec3Index] : 0) + valueWithUnit.value / 100 * bounds.halfExtents[vec3Index] * 2;
        }
        return 0;
      }
      var parseParam3 = function parseParam4(css) {
        return parseDimension2(/deg|rad|grad|turn|px|%/g, css);
      };
      var supportedFilters2 = ["blur", "brightness", "drop-shadow", "contrast", "grayscale", "sepia", "saturate", "hue-rotate", "invert"];
      function parseFilter2() {
        var filterStr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        filterStr = filterStr.toLowerCase().trim();
        if (filterStr === "none") {
          return [];
        }
        var filterRegExp = /\s*([\w-]+)\(([^)]*)\)/g;
        var result = [];
        var match2;
        var prevLastIndex = 0;
        while (match2 = filterRegExp.exec(filterStr)) {
          if (match2.index !== prevLastIndex) {
            return [];
          }
          prevLastIndex = match2.index + match2[0].length;
          if (supportedFilters2.indexOf(match2[1]) > -1) {
            result.push({
              name: match2[1],
              params: match2[2].split(" ").map(function(p) {
                return parseParam3(p) || parseColor2(p);
              })
            });
          }
          if (filterRegExp.lastIndex === filterStr.length) {
            return result;
          }
        }
        return [];
      }
      function numberToString2(x3) {
        return x3.toString();
      }
      var parseNumberUnmemoize3 = function parseNumberUnmemoize4(string) {
        if (typeof string === "number") {
          return getOrCreateUnitValue3(string);
        }
        if (/^\s*[-+]?(\d*\.)?\d+\s*$/.test(string)) {
          return getOrCreateUnitValue3(Number(string));
        }
        return getOrCreateUnitValue3(0);
      };
      var parseNumber2 = memoize4(parseNumberUnmemoize3);
      memoize4(function(string) {
        if (util.isString(string)) {
          return string.split(" ").map(parseNumber2);
        }
        return string.map(parseNumber2);
      });
      function mergeNumbers2(left, right) {
        return [left, right, numberToString2];
      }
      function clampedMergeNumbers2(min4, max4) {
        return function(left, right) {
          return [left, right, function(x3) {
            return numberToString2(util.clamp(x3, min4, max4));
          }];
        };
      }
      function mergeNumberLists2(left, right) {
        if (left.length !== right.length) {
          return;
        }
        return [left, right, function(numberList) {
          return numberList;
        }];
      }
      function getOrCalculatePathTotalLength2(path) {
        if (path.parsedStyle.d.totalLength === 0) {
          path.parsedStyle.d.totalLength = util.getTotalLength(path.parsedStyle.d.absolutePath);
        }
        return path.parsedStyle.d.totalLength;
      }
      function getOrCalculatePolylineTotalLength2(polyline) {
        if (polyline.parsedStyle.points.totalLength === 0) {
          polyline.parsedStyle.points.totalLength = gMath.polylineLength(polyline.parsedStyle.points.points);
        }
        return polyline.parsedStyle.points.totalLength;
      }
      function removeRedundantMCommand2(path) {
        for (var i = 0; i < path.length; i++) {
          var prevSegment = path[i - 1];
          var segment = path[i];
          var cmd = segment[0];
          if (cmd === "M") {
            if (prevSegment) {
              var prevCmd = prevSegment[0];
              var srcPoint = [segment[1], segment[2]];
              var destPoint = void 0;
              if (prevCmd === "L" || prevCmd === "M") {
                destPoint = [prevSegment[1], prevSegment[2]];
              } else if (prevCmd === "C" || prevCmd === "A" || prevCmd === "Q") {
                destPoint = [prevSegment[prevSegment.length - 2], prevSegment[prevSegment.length - 1]];
              }
              if (destPoint && isSamePoint2(srcPoint, destPoint)) {
                path.splice(i, 1);
                i--;
              }
            }
          }
        }
      }
      function hasArcOrBezier2(path) {
        var hasArc = false;
        var count = path.length;
        for (var i = 0; i < count; i++) {
          var params = path[i];
          var cmd = params[0];
          if (cmd === "C" || cmd === "A" || cmd === "Q") {
            hasArc = true;
            break;
          }
        }
        return hasArc;
      }
      function extractPolygons2(pathArray) {
        var polygons = [];
        var polylines = [];
        var points = [];
        for (var i = 0; i < pathArray.length; i++) {
          var params = pathArray[i];
          var cmd = params[0];
          if (cmd === "M") {
            if (points.length) {
              polylines.push(points);
              points = [];
            }
            points.push([params[1], params[2]]);
          } else if (cmd === "Z") {
            if (points.length) {
              polygons.push(points);
              points = [];
            }
          } else {
            points.push([params[1], params[2]]);
          }
        }
        if (points.length > 0) {
          polylines.push(points);
        }
        return {
          polygons,
          polylines
        };
      }
      function isSamePoint2(point1, point22) {
        return point1[0] === point22[0] && point1[1] === point22[1];
      }
      function getPathBBox2(segments, lineWidth) {
        var xArr = [];
        var yArr = [];
        var segmentsWithAngle = [];
        for (var i = 0; i < segments.length; i++) {
          var segment = segments[i];
          var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
          var box2 = void 0;
          switch (segment.command) {
            case "Q":
              box2 = gMath.quadBox(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
              break;
            case "C":
              box2 = gMath.cubicBox(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
              break;
            case "A":
              var arcParams = segment.arcParams;
              box2 = gMath.arcBox(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
              break;
            default:
              xArr.push(currentPoint[0]);
              yArr.push(currentPoint[1]);
              break;
          }
          if (box2) {
            segment.box = box2;
            xArr.push(box2.x, box2.x + box2.width);
            yArr.push(box2.y, box2.y + box2.height);
          }
          if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) {
            segmentsWithAngle.push(segment);
          }
        }
        xArr = xArr.filter(function(item) {
          return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
        });
        yArr = yArr.filter(function(item) {
          return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
        });
        var minX = util.min(xArr);
        var minY = util.min(yArr);
        var maxX = util.max(xArr);
        var maxY = util.max(yArr);
        if (segmentsWithAngle.length === 0) {
          return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
          };
        }
        for (var _i = 0; _i < segmentsWithAngle.length; _i++) {
          var _segment = segmentsWithAngle[_i];
          var _currentPoint = _segment.currentPoint;
          var extra = void 0;
          if (_currentPoint[0] === minX) {
            extra = getExtraFromSegmentWithAngle2(_segment, lineWidth);
            minX -= extra.xExtra;
          } else if (_currentPoint[0] === maxX) {
            extra = getExtraFromSegmentWithAngle2(_segment, lineWidth);
            maxX += extra.xExtra;
          }
          if (_currentPoint[1] === minY) {
            extra = getExtraFromSegmentWithAngle2(_segment, lineWidth);
            minY -= extra.yExtra;
          } else if (_currentPoint[1] === maxY) {
            extra = getExtraFromSegmentWithAngle2(_segment, lineWidth);
            maxY += extra.yExtra;
          }
        }
        return {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        };
      }
      function getExtraFromSegmentWithAngle2(segment, lineWidth) {
        var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
        var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
        var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
        var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
        var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
        if (!currentAngle || Math.sin(currentAngle) === 0 || util.isNumberEqual(currentAngle, 0)) {
          return {
            xExtra: 0,
            yExtra: 0
          };
        }
        var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
        var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
        xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
        yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
        var extra = {
          // 水平方向投影
          xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
          // 垂直方向投影
          yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
        };
        return extra;
      }
      function toSymmetry2(point4, center) {
        return [center[0] + (center[0] - point4[0]), center[1] + (center[1] - point4[1])];
      }
      var angleBetween3 = function angleBetween4(v0, v1) {
        var p = v0.x * v1.x + v0.y * v1.y;
        var n = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)));
        var sign = v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1;
        var angle2 = sign * Math.acos(p / n);
        return angle2;
      };
      var pointOnEllipticalArc3 = function pointOnEllipticalArc4(p0, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p1, t) {
        rx = Math.abs(rx);
        ry = Math.abs(ry);
        xAxisRotation = util.mod(xAxisRotation, 360);
        var xAxisRotationRadians = deg2rad2(xAxisRotation);
        if (p0.x === p1.x && p0.y === p1.y) {
          return {
            x: p0.x,
            y: p0.y,
            ellipticalArcAngle: 0
          };
        }
        if (rx === 0 || ry === 0) {
          return {
            x: 0,
            y: 0,
            ellipticalArcAngle: 0
          };
        }
        var dx = (p0.x - p1.x) / 2;
        var dy = (p0.y - p1.y) / 2;
        var transformedPoint = {
          x: Math.cos(xAxisRotationRadians) * dx + Math.sin(xAxisRotationRadians) * dy,
          y: -Math.sin(xAxisRotationRadians) * dx + Math.cos(xAxisRotationRadians) * dy
        };
        var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
        if (radiiCheck > 1) {
          rx *= Math.sqrt(radiiCheck);
          ry *= Math.sqrt(radiiCheck);
        }
        var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
        var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
        var cRadicand = cSquareNumerator / cSquareRootDenom;
        cRadicand = cRadicand < 0 ? 0 : cRadicand;
        var cCoef = (largeArcFlag !== sweepFlag ? 1 : -1) * Math.sqrt(cRadicand);
        var transformedCenter = {
          x: cCoef * (rx * transformedPoint.y / ry),
          y: cCoef * (-(ry * transformedPoint.x) / rx)
        };
        var center = {
          x: Math.cos(xAxisRotationRadians) * transformedCenter.x - Math.sin(xAxisRotationRadians) * transformedCenter.y + (p0.x + p1.x) / 2,
          y: Math.sin(xAxisRotationRadians) * transformedCenter.x + Math.cos(xAxisRotationRadians) * transformedCenter.y + (p0.y + p1.y) / 2
        };
        var startVector = {
          x: (transformedPoint.x - transformedCenter.x) / rx,
          y: (transformedPoint.y - transformedCenter.y) / ry
        };
        var startAngle = angleBetween3({
          x: 1,
          y: 0
        }, startVector);
        var endVector = {
          x: (-transformedPoint.x - transformedCenter.x) / rx,
          y: (-transformedPoint.y - transformedCenter.y) / ry
        };
        var sweepAngle = angleBetween3(startVector, endVector);
        if (!sweepFlag && sweepAngle > 0) {
          sweepAngle -= 2 * Math.PI;
        } else if (sweepFlag && sweepAngle < 0) {
          sweepAngle += 2 * Math.PI;
        }
        sweepAngle %= 2 * Math.PI;
        var angle2 = startAngle + sweepAngle * t;
        var ellipseComponentX = rx * Math.cos(angle2);
        var ellipseComponentY = ry * Math.sin(angle2);
        var point4 = {
          x: Math.cos(xAxisRotationRadians) * ellipseComponentX - Math.sin(xAxisRotationRadians) * ellipseComponentY + center.x,
          y: Math.sin(xAxisRotationRadians) * ellipseComponentX + Math.cos(xAxisRotationRadians) * ellipseComponentY + center.y,
          ellipticalArcStartAngle: startAngle,
          ellipticalArcEndAngle: startAngle + sweepAngle,
          ellipticalArcAngle: angle2,
          ellipticalArcCenter: center,
          resultantRx: rx,
          resultantRy: ry
        };
        return point4;
      };
      function path2Segments2(path) {
        var segments = [];
        var currentPoint = null;
        var nextParams = null;
        var startMovePoint = null;
        var lastStartMovePointIndex = 0;
        var count = path.length;
        for (var i = 0; i < count; i++) {
          var params = path[i];
          nextParams = path[i + 1];
          var command = params[0];
          var segment = {
            command,
            prePoint: currentPoint,
            params,
            startTangent: null,
            endTangent: null,
            currentPoint: null,
            nextPoint: null,
            arcParams: null,
            box: null,
            cubicParams: null
          };
          switch (command) {
            case "M":
              startMovePoint = [params[1], params[2]];
              lastStartMovePointIndex = i;
              break;
            case "A":
              var arcParams = getArcParams2(currentPoint, params);
              segment.arcParams = arcParams;
              break;
          }
          if (command === "Z") {
            currentPoint = startMovePoint;
            nextParams = path[lastStartMovePointIndex + 1];
          } else {
            var len = params.length;
            currentPoint = [params[len - 2], params[len - 1]];
          }
          if (nextParams && nextParams[0] === "Z") {
            nextParams = path[lastStartMovePointIndex];
            if (segments[lastStartMovePointIndex]) {
              segments[lastStartMovePointIndex].prePoint = currentPoint;
            }
          }
          segment.currentPoint = currentPoint;
          if (segments[lastStartMovePointIndex] && isSamePoint2(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
            segments[lastStartMovePointIndex].prePoint = segment.prePoint;
          }
          var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
          segment.nextPoint = nextPoint;
          var prePoint = segment.prePoint;
          if (["L", "H", "V"].includes(command)) {
            segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
            segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
          } else if (command === "Q") {
            var cp = [params[1], params[2]];
            segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
            segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
          } else if (command === "T") {
            var preSegment = segments[i - 1];
            var _cp = toSymmetry2(preSegment.currentPoint, prePoint);
            if (preSegment.command === "Q") {
              segment.command = "Q";
              segment.startTangent = [prePoint[0] - _cp[0], prePoint[1] - _cp[1]];
              segment.endTangent = [currentPoint[0] - _cp[0], currentPoint[1] - _cp[1]];
            } else {
              segment.command = "TL";
              segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
              segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
            }
          } else if (command === "C") {
            var cp1 = [params[1], params[2]];
            var cp2 = [params[3], params[4]];
            segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
            segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
            if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
              segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
            }
            if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
              segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
            }
          } else if (command === "S") {
            var _preSegment = segments[i - 1];
            var _cp2 = toSymmetry2(_preSegment.currentPoint, prePoint);
            var _cp3 = [params[1], params[2]];
            if (_preSegment.command === "C") {
              segment.command = "C";
              segment.startTangent = [prePoint[0] - _cp2[0], prePoint[1] - _cp2[1]];
              segment.endTangent = [currentPoint[0] - _cp3[0], currentPoint[1] - _cp3[1]];
            } else {
              segment.command = "SQ";
              segment.startTangent = [prePoint[0] - _cp3[0], prePoint[1] - _cp3[1]];
              segment.endTangent = [currentPoint[0] - _cp3[0], currentPoint[1] - _cp3[1]];
            }
          } else if (command === "A") {
            var _getTangentAtRatio = getTangentAtRatio2(segment, 0), dx1 = _getTangentAtRatio.x, dy1 = _getTangentAtRatio.y;
            var _getTangentAtRatio2 = getTangentAtRatio2(segment, 1, false), dx2 = _getTangentAtRatio2.x, dy2 = _getTangentAtRatio2.y;
            segment.startTangent = [dx1, dy1];
            segment.endTangent = [dx2, dy2];
          }
          segments.push(segment);
        }
        return segments;
      }
      function getTangentAtRatio2(segment, ratio) {
        var sign = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
        var _segment$arcParams = segment.arcParams, _segment$arcParams$rx = _segment$arcParams.rx, rx = _segment$arcParams$rx === void 0 ? 0 : _segment$arcParams$rx, _segment$arcParams$ry = _segment$arcParams.ry, ry = _segment$arcParams$ry === void 0 ? 0 : _segment$arcParams$ry, xRotation = _segment$arcParams.xRotation, arcFlag = _segment$arcParams.arcFlag, sweepFlag = _segment$arcParams.sweepFlag;
        var p1 = pointOnEllipticalArc3({
          x: segment.prePoint[0],
          y: segment.prePoint[1]
        }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, {
          x: segment.currentPoint[0],
          y: segment.currentPoint[1]
        }, ratio);
        var p2 = pointOnEllipticalArc3({
          x: segment.prePoint[0],
          y: segment.prePoint[1]
        }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, {
          x: segment.currentPoint[0],
          y: segment.currentPoint[1]
        }, sign ? ratio + 5e-3 : ratio - 5e-3);
        var xDist = p2.x - p1.x;
        var yDist = p2.y - p1.y;
        var dist = Math.sqrt(xDist * xDist + yDist * yDist);
        return {
          x: -xDist / dist,
          y: -yDist / dist
        };
      }
      function vMag2(v) {
        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
      }
      function vRatio2(u, v) {
        return vMag2(u) * vMag2(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag2(u) * vMag2(v)) : 1;
      }
      function vAngle2(u, v) {
        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio2(u, v));
      }
      function getArcParams2(startPoint, params) {
        var rx = params[1];
        var ry = params[2];
        var xRotation = util.mod(deg2rad2(params[3]), Math.PI * 2);
        var arcFlag = params[4];
        var sweepFlag = params[5];
        var x1 = startPoint[0];
        var y1 = startPoint[1];
        var x22 = params[6];
        var y22 = params[7];
        var xp = Math.cos(xRotation) * (x1 - x22) / 2 + Math.sin(xRotation) * (y1 - y22) / 2;
        var yp = -1 * Math.sin(xRotation) * (x1 - x22) / 2 + Math.cos(xRotation) * (y1 - y22) / 2;
        var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
        if (lambda > 1) {
          rx *= Math.sqrt(lambda);
          ry *= Math.sqrt(lambda);
        }
        var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
        var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
        if (arcFlag === sweepFlag) {
          f *= -1;
        }
        if (isNaN(f)) {
          f = 0;
        }
        var cxp = ry ? f * rx * yp / ry : 0;
        var cyp = rx ? f * -ry * xp / rx : 0;
        var cx = (x1 + x22) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
        var cy = (y1 + y22) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
        var u = [(xp - cxp) / rx, (yp - cyp) / ry];
        var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
        var theta = vAngle2([1, 0], u);
        var dTheta = vAngle2(u, v);
        if (vRatio2(u, v) <= -1) {
          dTheta = Math.PI;
        }
        if (vRatio2(u, v) >= 1) {
          dTheta = 0;
        }
        if (sweepFlag === 0 && dTheta > 0) {
          dTheta -= 2 * Math.PI;
        }
        if (sweepFlag === 1 && dTheta < 0) {
          dTheta += 2 * Math.PI;
        }
        return {
          cx,
          cy,
          // 弧形的起点和终点相同时，长轴和短轴的长度按 0 处理
          rx: isSamePoint2(startPoint, [x22, y22]) ? 0 : rx,
          ry: isSamePoint2(startPoint, [x22, y22]) ? 0 : ry,
          startAngle: theta,
          endAngle: theta + dTheta,
          xRotation,
          arcFlag,
          sweepFlag
        };
      }
      function commandsToPathString(commands, object, transform) {
        return commands.reduce(function(prev, cur) {
          var path = "";
          if (cur[0] === "M" || cur[0] === "L") {
            var p = glMatrix.vec3.fromValues(cur[1], cur[2], 0);
            if (transform) {
              glMatrix.vec3.transformMat4(p, p, transform);
            }
            path = "".concat(cur[0]).concat(p[0], ",").concat(p[1]);
          } else if (cur[0] === "Z") {
            path = cur[0];
          } else if (cur[0] === "C") {
            var p1 = glMatrix.vec3.fromValues(cur[1], cur[2], 0);
            var p2 = glMatrix.vec3.fromValues(cur[3], cur[4], 0);
            var p3 = glMatrix.vec3.fromValues(cur[5], cur[6], 0);
            if (transform) {
              glMatrix.vec3.transformMat4(p1, p1, transform);
              glMatrix.vec3.transformMat4(p2, p2, transform);
              glMatrix.vec3.transformMat4(p3, p3, transform);
            }
            path = "".concat(cur[0]).concat(p1[0], ",").concat(p1[1], ",").concat(p2[0], ",").concat(p2[1], ",").concat(p3[0], ",").concat(p3[1]);
          } else if (cur[0] === "A") {
            var c2 = glMatrix.vec3.fromValues(cur[6], cur[7], 0);
            if (transform) {
              glMatrix.vec3.transformMat4(c2, c2, transform);
            }
            path = "".concat(cur[0]).concat(cur[1], ",").concat(cur[2], ",").concat(cur[3], ",").concat(cur[4], ",").concat(cur[5], ",").concat(c2[0], ",").concat(c2[1]);
          } else if (cur[0] === "Q") {
            var _p = glMatrix.vec3.fromValues(cur[1], cur[2], 0);
            var _p2 = glMatrix.vec3.fromValues(cur[3], cur[4], 0);
            if (transform) {
              glMatrix.vec3.transformMat4(_p, _p, transform);
              glMatrix.vec3.transformMat4(_p2, _p2, transform);
            }
            path = "".concat(cur[0]).concat(cur[1], ",").concat(cur[2], ",").concat(cur[3], ",").concat(cur[4], "}");
          }
          return prev += path;
        }, "");
      }
      function lineToCommands(x1, y1, x22, y22) {
        return [["M", x1, y1], ["L", x22, y22]];
      }
      function ellipseToCommands(rx, ry, cx, cy) {
        var factor = (-1 + Math.sqrt(2)) / 3 * 4;
        var dx = rx * factor;
        var dy = ry * factor;
        var left = cx - rx;
        var right = cx + rx;
        var top = cy - ry;
        var bottom = cy + ry;
        return [["M", left, cy], ["C", left, cy - dy, cx - dx, top, cx, top], ["C", cx + dx, top, right, cy - dy, right, cy], ["C", right, cy + dy, cx + dx, bottom, cx, bottom], ["C", cx - dx, bottom, left, cy + dy, left, cy], ["Z"]];
      }
      function polygonToCommands(points, closed) {
        var result = points.map(function(point4, i) {
          return [i === 0 ? "M" : "L", point4[0], point4[1]];
        });
        if (closed) {
          result.push(["Z"]);
        }
        return result;
      }
      function rectToCommands(width2, height, x3, y3, radius) {
        if (radius) {
          var _radius = _slicedToArray2(radius, 4), tlr = _radius[0], trr = _radius[1], brr = _radius[2], blr = _radius[3];
          var signX = width2 > 0 ? 1 : -1;
          var signY = height > 0 ? 1 : -1;
          var sweepFlag = signX + signY !== 0 ? 1 : 0;
          return [["M", signX * tlr + x3, y3], ["L", width2 - signX * trr + x3, y3], trr ? ["A", trr, trr, 0, 0, sweepFlag, width2 + x3, signY * trr + y3] : null, ["L", width2 + x3, height - signY * brr + y3], brr ? ["A", brr, brr, 0, 0, sweepFlag, width2 + x3 - signX * brr, height + y3] : null, ["L", x3 + signX * blr, height + y3], blr ? ["A", blr, blr, 0, 0, sweepFlag, x3, height + y3 - signY * blr] : null, ["L", x3, signY * tlr + y3], tlr ? ["A", tlr, tlr, 0, 0, sweepFlag, signX * tlr + x3, y3] : null, ["Z"]].filter(function(command) {
            return command;
          });
        }
        return [["M", x3, y3], ["L", x3 + width2, y3], ["L", x3 + width2, y3 + height], ["L", x3, y3 + height], ["Z"]];
      }
      function convertToPath(object) {
        var transform = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : object.getLocalTransform();
        var commands = [];
        switch (object.nodeName) {
          case Shape2.LINE:
            var _parsedStyle = object.parsedStyle, _parsedStyle$x = _parsedStyle.x1, x1 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = _parsedStyle.y1, y1 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, _parsedStyle$x2 = _parsedStyle.x2, x22 = _parsedStyle$x2 === void 0 ? 0 : _parsedStyle$x2, _parsedStyle$y2 = _parsedStyle.y2, y22 = _parsedStyle$y2 === void 0 ? 0 : _parsedStyle$y2;
            commands = lineToCommands(x1, y1, x22, y22);
            break;
          case Shape2.CIRCLE: {
            var _parsedStyle2 = object.parsedStyle, _parsedStyle2$r = _parsedStyle2.r, r = _parsedStyle2$r === void 0 ? 0 : _parsedStyle2$r, _parsedStyle2$cx = _parsedStyle2.cx, cx = _parsedStyle2$cx === void 0 ? 0 : _parsedStyle2$cx, _parsedStyle2$cy = _parsedStyle2.cy, cy = _parsedStyle2$cy === void 0 ? 0 : _parsedStyle2$cy;
            commands = ellipseToCommands(r, r, cx, cy);
            break;
          }
          case Shape2.ELLIPSE: {
            var _parsedStyle3 = object.parsedStyle, _parsedStyle3$rx = _parsedStyle3.rx, rx = _parsedStyle3$rx === void 0 ? 0 : _parsedStyle3$rx, _parsedStyle3$ry = _parsedStyle3.ry, ry = _parsedStyle3$ry === void 0 ? 0 : _parsedStyle3$ry, _parsedStyle3$cx = _parsedStyle3.cx, _cx = _parsedStyle3$cx === void 0 ? 0 : _parsedStyle3$cx, _parsedStyle3$cy = _parsedStyle3.cy, _cy = _parsedStyle3$cy === void 0 ? 0 : _parsedStyle3$cy;
            commands = ellipseToCommands(rx, ry, _cx, _cy);
            break;
          }
          case Shape2.POLYLINE:
          case Shape2.POLYGON:
            var points = object.parsedStyle.points;
            commands = polygonToCommands(points.points, object.nodeName === Shape2.POLYGON);
            break;
          case Shape2.RECT:
            var _parsedStyle4 = object.parsedStyle, _parsedStyle4$width = _parsedStyle4.width, width2 = _parsedStyle4$width === void 0 ? 0 : _parsedStyle4$width, _parsedStyle4$height = _parsedStyle4.height, height = _parsedStyle4$height === void 0 ? 0 : _parsedStyle4$height, _parsedStyle4$x = _parsedStyle4.x, x3 = _parsedStyle4$x === void 0 ? 0 : _parsedStyle4$x, _parsedStyle4$y = _parsedStyle4.y, y3 = _parsedStyle4$y === void 0 ? 0 : _parsedStyle4$y, radius = _parsedStyle4.radius;
            var hasRadius = radius && radius.some(function(r2) {
              return r2 !== 0;
            });
            commands = rectToCommands(width2, height, x3, y3, hasRadius && radius.map(function(r2) {
              return util.clamp(r2, 0, Math.min(Math.abs(width2) / 2, Math.abs(height) / 2));
            }));
            break;
          case Shape2.PATH:
            var absolutePath = object.parsedStyle.d.absolutePath;
            commands = _toConsumableArray2(absolutePath);
            break;
        }
        if (commands.length) {
          return commandsToPathString(commands, object, transform);
        }
      }
      function translatePathToString(absolutePath) {
        var startOffsetX = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var startOffsetY = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var endOffsetX = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        var endOffsetY = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
        var newValue = absolutePath.map(function(params, i) {
          var command = params[0];
          var nextSegment = absolutePath[i + 1];
          var useStartOffset = i === 0 && (startOffsetX !== 0 || startOffsetY !== 0);
          var useEndOffset = (i === absolutePath.length - 1 || nextSegment && (nextSegment[0] === "M" || nextSegment[0] === "Z")) && endOffsetX !== 0 && endOffsetY !== 0;
          var _ref = useStartOffset ? [startOffsetX, startOffsetY] : [0, 0], _ref2 = _slicedToArray2(_ref, 2), startOffsetXTemp = _ref2[0], startOffsetYTemp = _ref2[1];
          var _ref3 = useEndOffset ? [endOffsetX, endOffsetY] : [0, 0], _ref4 = _slicedToArray2(_ref3, 2), endOffsetXTemp = _ref4[0], endOffsetYTemp = _ref4[1];
          switch (command) {
            case "M":
              return "M ".concat(params[1] + startOffsetXTemp, ",").concat(params[2] + startOffsetYTemp);
            case "L":
              return "L ".concat(params[1] + endOffsetXTemp, ",").concat(params[2] + endOffsetYTemp);
            case "Q":
              return "Q ".concat(params[1], " ").concat(params[2], ",").concat(params[3] + endOffsetXTemp, " ").concat(params[4] + endOffsetYTemp);
            case "C":
              return "C ".concat(params[1], " ").concat(params[2], ",").concat(params[3], " ").concat(params[4], ",").concat(params[5] + endOffsetXTemp, " ").concat(params[6] + endOffsetYTemp);
            case "A":
              return "A ".concat(params[1], " ").concat(params[2], " ").concat(params[3], " ").concat(params[4], " ").concat(params[5], " ").concat(params[6], " ").concat(params[7]).concat(useEndOffset ? " L ".concat(params[6] + endOffsetX, ",").concat(params[7] + endOffsetY) : "");
            case "Z":
              return "Z";
            default:
              return null;
          }
        }).filter(function(item) {
          return item !== null;
        }).join(" ");
        if (~newValue.indexOf("NaN")) {
          return "";
        }
        return newValue;
      }
      var internalParsePath3 = function internalParsePath4(path) {
        if (path === "" || Array.isArray(path) && path.length === 0) {
          return {
            absolutePath: [],
            hasArc: false,
            segments: [],
            polygons: [],
            polylines: [],
            curve: null,
            totalLength: 0,
            rect: {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            }
          };
        }
        var absolutePath;
        try {
          absolutePath = util.normalizePath(path);
        } catch (_unused) {
          absolutePath = util.normalizePath("");
          console.error("[g]: Invalid SVG Path definition: ".concat(path));
        }
        removeRedundantMCommand2(absolutePath);
        var hasArc = hasArcOrBezier2(absolutePath);
        var _extractPolygons = extractPolygons2(absolutePath), polygons = _extractPolygons.polygons, polylines = _extractPolygons.polylines;
        var segments = path2Segments2(absolutePath);
        var _getPathBBox = getPathBBox2(segments, 0), x3 = _getPathBBox.x, y3 = _getPathBBox.y, width2 = _getPathBBox.width, height = _getPathBBox.height;
        return {
          absolutePath,
          hasArc,
          segments,
          polygons,
          polylines,
          // curve,
          // Delay the calculation of length.
          totalLength: 0,
          rect: {
            x: Number.isFinite(x3) ? x3 : 0,
            y: Number.isFinite(y3) ? y3 : 0,
            width: Number.isFinite(width2) ? width2 : 0,
            height: Number.isFinite(height) ? height : 0
          }
        };
      };
      var memoizedParsePath2 = memoize4(internalParsePath3);
      function parsePath3(path) {
        return util.isString(path) ? memoizedParsePath2(path) : internalParsePath3(path);
      }
      function mergePaths2(left, right, object) {
        var curve1 = left.curve;
        var curve2 = right.curve;
        if (!curve1 || curve1.length === 0) {
          curve1 = util.path2Curve(left.absolutePath, false);
          left.curve = curve1;
        }
        if (!curve2 || curve2.length === 0) {
          curve2 = util.path2Curve(right.absolutePath, false);
          right.curve = curve2;
        }
        var curves = [curve1, curve2];
        if (curve1.length !== curve2.length) {
          curves = util.equalizeSegments(curve1, curve2);
        }
        var curve0 = util.getDrawDirection(curves[0]) !== util.getDrawDirection(curves[1]) ? util.reverseCurve(curves[0]) : util.clonePath(curves[0]);
        return [curve0, util.getRotatedCurve(curves[1], curve0), function(pathArray) {
          return pathArray;
        }];
      }
      function parsePoints2(pointsOrStr, object) {
        var points;
        if (util.isString(pointsOrStr)) {
          points = pointsOrStr.split(" ").map(function(pointStr) {
            var _pointStr$split = pointStr.split(","), _pointStr$split2 = _slicedToArray2(_pointStr$split, 2), x3 = _pointStr$split2[0], y3 = _pointStr$split2[1];
            return [Number(x3), Number(y3)];
          });
        } else {
          points = pointsOrStr;
        }
        return {
          points,
          totalLength: 0,
          segments: []
        };
      }
      function mergePoints2(left, right) {
        return [left.points, right.points, function(points) {
          return points;
        }];
      }
      var _2 = null;
      var TRANSFORM_REGEXP2 = /\s*(\w+)\(([^)]*)\)/g;
      function cast2(pattern) {
        return function(contents) {
          var i = 0;
          return pattern.map(function(x3) {
            return x3 === _2 ? contents[i++] : x3;
          });
        };
      }
      function id3(x3) {
        return x3;
      }
      var transformFunctions2 = {
        // @ts-ignore
        matrix: ["NNNNNN", [_2, _2, 0, 0, _2, _2, 0, 0, 0, 0, 1, 0, _2, _2, 0, 1], id3],
        matrix3d: ["NNNNNNNNNNNNNNNN", id3],
        rotate: ["A"],
        rotateX: ["A"],
        rotateY: ["A"],
        rotateZ: ["A"],
        rotate3d: ["NNNA"],
        perspective: ["L"],
        scale: ["Nn", cast2([_2, _2, new CSSUnitValue2(1)]), id3],
        scaleX: ["N", cast2([_2, new CSSUnitValue2(1), new CSSUnitValue2(1)]), cast2([_2, new CSSUnitValue2(1)])],
        scaleY: ["N", cast2([new CSSUnitValue2(1), _2, new CSSUnitValue2(1)]), cast2([new CSSUnitValue2(1), _2])],
        scaleZ: ["N", cast2([new CSSUnitValue2(1), new CSSUnitValue2(1), _2])],
        scale3d: ["NNN", id3],
        skew: ["Aa", null, id3],
        skewX: ["A", null, cast2([_2, Odeg2])],
        skewY: ["A", null, cast2([Odeg2, _2])],
        translate: ["Tt", cast2([_2, _2, Opx2]), id3],
        translateX: ["T", cast2([_2, Opx2, Opx2]), cast2([_2, Opx2])],
        translateY: ["T", cast2([Opx2, _2, Opx2]), cast2([Opx2, _2])],
        translateZ: ["L", cast2([Opx2, Opx2, _2])],
        translate3d: ["TTL", id3]
      };
      function parseArrayTransform2(transform) {
        var result = [];
        var length = transform.length;
        for (var i = 0; i < length; i++) {
          var item = transform[i];
          var name = item[0];
          var args = item.slice(1);
          if (name === "translate" || name === "skew") {
            if (args.length === 1) args.push(0);
          } else if (name === "scale") {
            if (args.length === 1) args.push(args[0]);
          }
          var functionData = transformFunctions2[name];
          if (!functionData) return [];
          var parsedArgs = args.map(function(value) {
            return getOrCreateUnitValue3(value);
          });
          result.push({
            t: name,
            d: parsedArgs
          });
        }
        return result;
      }
      function parseTransform2(transform) {
        if (Array.isArray(transform)) {
          return parseArrayTransform2(transform);
        }
        transform = (transform || "none").trim();
        if (transform === "none") {
          return [];
        }
        var result = [];
        var match2;
        var prevLastIndex = 0;
        TRANSFORM_REGEXP2.lastIndex = 0;
        while (match2 = TRANSFORM_REGEXP2.exec(transform)) {
          if (match2.index !== prevLastIndex) {
            return [];
          }
          prevLastIndex = match2.index + match2[0].length;
          var functionName = match2[1];
          var functionData = transformFunctions2[functionName];
          if (!functionData) {
            return [];
          }
          var args = match2[2].split(",");
          var argTypes = functionData[0];
          if (argTypes.length < args.length) {
            return [];
          }
          var parsedArgs = [];
          for (var i = 0; i < argTypes.length; i++) {
            var arg = args[i];
            var type = argTypes[i];
            var parsedArg = void 0;
            if (!arg) {
              parsedArg = {
                a: Odeg2,
                n: parsedArgs[0],
                t: Opx2
              }[type];
            } else {
              parsedArg = {
                A: function A3(s) {
                  return s.trim() === "0" ? Odeg2 : parseAngle2(s);
                },
                N: parseNumber2,
                T: parseLengthOrPercentage2,
                L: parseLength2
              }[type.toUpperCase()](arg);
            }
            if (parsedArg === void 0) {
              return [];
            }
            parsedArgs.push(parsedArg);
          }
          result.push({
            t: functionName,
            d: parsedArgs
          });
          if (TRANSFORM_REGEXP2.lastIndex === transform.length) {
            return result;
          }
        }
        return [];
      }
      function parseTransformUnmemoize2(transform) {
        if (Array.isArray(transform)) {
          return parseArrayTransform2(transform);
        }
        transform = (transform || "none").trim();
        if (transform === "none") {
          return [];
        }
        var result = [];
        var match2;
        var prevLastIndex = 0;
        TRANSFORM_REGEXP2.lastIndex = 0;
        while (match2 = TRANSFORM_REGEXP2.exec(transform)) {
          if (match2.index !== prevLastIndex) {
            return [];
          }
          prevLastIndex = match2.index + match2[0].length;
          var functionName = match2[1];
          var functionData = transformFunctions2[functionName];
          if (!functionData) {
            return [];
          }
          var args = match2[2].split(",");
          var argTypes = functionData[0];
          if (argTypes.length < args.length) {
            return [];
          }
          var parsedArgs = [];
          for (var i = 0; i < argTypes.length; i++) {
            var arg = args[i];
            var type = argTypes[i];
            var parsedArg = void 0;
            if (!arg) {
              parsedArg = {
                a: Odeg2,
                n: parsedArgs[0],
                t: Opx2
              }[type];
            } else {
              parsedArg = {
                A: function A3(s) {
                  return s.trim() === "0" ? Odeg2 : parseAngleUnmemoize3(s);
                },
                N: parseNumberUnmemoize3,
                T: parseLengthOrPercentageUnmemoize3,
                L: parseLengthUnmemoize3
              }[type.toUpperCase()](arg);
            }
            if (parsedArg === void 0) {
              return [];
            }
            parsedArgs.push(parsedArg);
          }
          result.push({
            t: functionName,
            d: parsedArgs
          });
          if (TRANSFORM_REGEXP2.lastIndex === transform.length) {
            return result;
          }
        }
        return [];
      }
      function convertItemToMatrix2(item) {
        var x3;
        var y3;
        var z;
        var angle2;
        switch (item.t) {
          case "rotateX":
            angle2 = deg2rad2(convertAngleUnit2(item.d[0]));
            return [1, 0, 0, 0, 0, Math.cos(angle2), Math.sin(angle2), 0, 0, -Math.sin(angle2), Math.cos(angle2), 0, 0, 0, 0, 1];
          case "rotateY":
            angle2 = deg2rad2(convertAngleUnit2(item.d[0]));
            return [Math.cos(angle2), 0, -Math.sin(angle2), 0, 0, 1, 0, 0, Math.sin(angle2), 0, Math.cos(angle2), 0, 0, 0, 0, 1];
          case "rotate":
          case "rotateZ":
            angle2 = deg2rad2(convertAngleUnit2(item.d[0]));
            return [Math.cos(angle2), Math.sin(angle2), 0, 0, -Math.sin(angle2), Math.cos(angle2), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
          case "rotate3d":
            x3 = item.d[0].value;
            y3 = item.d[1].value;
            z = item.d[2].value;
            angle2 = deg2rad2(convertAngleUnit2(item.d[3]));
            var sqrLength = x3 * x3 + y3 * y3 + z * z;
            if (sqrLength === 0) {
              x3 = 1;
              y3 = 0;
              z = 0;
            } else if (sqrLength !== 1) {
              var length = Math.sqrt(sqrLength);
              x3 /= length;
              y3 /= length;
              z /= length;
            }
            var s = Math.sin(angle2 / 2);
            var sc = s * Math.cos(angle2 / 2);
            var sq = s * s;
            return [1 - 2 * (y3 * y3 + z * z) * sq, 2 * (x3 * y3 * sq + z * sc), 2 * (x3 * z * sq - y3 * sc), 0, 2 * (x3 * y3 * sq - z * sc), 1 - 2 * (x3 * x3 + z * z) * sq, 2 * (y3 * z * sq + x3 * sc), 0, 2 * (x3 * z * sq + y3 * sc), 2 * (y3 * z * sq - x3 * sc), 1 - 2 * (x3 * x3 + y3 * y3) * sq, 0, 0, 0, 0, 1];
          case "scale":
            return [item.d[0].value, 0, 0, 0, 0, item.d[1].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
          case "scaleX":
            return [item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
          case "scaleY":
            return [1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
          case "scaleZ":
            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1];
          case "scale3d":
            return [item.d[0].value, 0, 0, 0, 0, item.d[1].value, 0, 0, 0, 0, item.d[2].value, 0, 0, 0, 0, 1];
          case "skew":
            var xAngle = deg2rad2(convertAngleUnit2(item.d[0]));
            var yAngle = deg2rad2(convertAngleUnit2(item.d[1]));
            return [1, Math.tan(yAngle), 0, 0, Math.tan(xAngle), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
          case "skewX":
            angle2 = deg2rad2(convertAngleUnit2(item.d[0]));
            return [1, 0, 0, 0, Math.tan(angle2), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
          case "skewY":
            angle2 = deg2rad2(convertAngleUnit2(item.d[0]));
            return [1, Math.tan(angle2), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
          case "translate":
            x3 = convertPercentUnit2(item.d[0], 0, null) || 0;
            y3 = convertPercentUnit2(item.d[1], 0, null) || 0;
            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x3, y3, 0, 1];
          case "translateX":
            x3 = convertPercentUnit2(item.d[0], 0, null) || 0;
            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x3, 0, 0, 1];
          case "translateY":
            y3 = convertPercentUnit2(item.d[0], 0, null) || 0;
            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, y3, 0, 1];
          case "translateZ":
            z = convertPercentUnit2(item.d[0], 0, null) || 0;
            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, z, 1];
          case "translate3d":
            x3 = convertPercentUnit2(item.d[0], 0, null) || 0;
            y3 = convertPercentUnit2(item.d[1], 0, null) || 0;
            z = convertPercentUnit2(item.d[2], 0, null) || 0;
            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x3, y3, z, 1];
          case "perspective":
            var t = convertPercentUnit2(item.d[0], 0, null) || 0;
            var p = t ? -1 / t : 0;
            return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, p, 0, 0, 0, 1];
          case "matrix":
            return [item.d[0].value, item.d[1].value, 0, 0, item.d[2].value, item.d[3].value, 0, 0, 0, 0, 1, 0, item.d[4].value, item.d[5].value, 0, 1];
          case "matrix3d":
            return item.d.map(function(d2) {
              return d2.value;
            });
        }
      }
      function multiplyMatrices2(a2, b) {
        return [a2[0] * b[0] + a2[4] * b[1] + a2[8] * b[2] + a2[12] * b[3], a2[1] * b[0] + a2[5] * b[1] + a2[9] * b[2] + a2[13] * b[3], a2[2] * b[0] + a2[6] * b[1] + a2[10] * b[2] + a2[14] * b[3], a2[3] * b[0] + a2[7] * b[1] + a2[11] * b[2] + a2[15] * b[3], a2[0] * b[4] + a2[4] * b[5] + a2[8] * b[6] + a2[12] * b[7], a2[1] * b[4] + a2[5] * b[5] + a2[9] * b[6] + a2[13] * b[7], a2[2] * b[4] + a2[6] * b[5] + a2[10] * b[6] + a2[14] * b[7], a2[3] * b[4] + a2[7] * b[5] + a2[11] * b[6] + a2[15] * b[7], a2[0] * b[8] + a2[4] * b[9] + a2[8] * b[10] + a2[12] * b[11], a2[1] * b[8] + a2[5] * b[9] + a2[9] * b[10] + a2[13] * b[11], a2[2] * b[8] + a2[6] * b[9] + a2[10] * b[10] + a2[14] * b[11], a2[3] * b[8] + a2[7] * b[9] + a2[11] * b[10] + a2[15] * b[11], a2[0] * b[12] + a2[4] * b[13] + a2[8] * b[14] + a2[12] * b[15], a2[1] * b[12] + a2[5] * b[13] + a2[9] * b[14] + a2[13] * b[15], a2[2] * b[12] + a2[6] * b[13] + a2[10] * b[14] + a2[14] * b[15], a2[3] * b[12] + a2[7] * b[13] + a2[11] * b[14] + a2[15] * b[15]];
      }
      function convertToMatrix2(transformList) {
        if (transformList.length === 0) {
          return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        }
        return transformList.map(convertItemToMatrix2).reduce(multiplyMatrices2);
      }
      function makeMatrixDecomposition2(transformList) {
        var translate3 = [0, 0, 0];
        var scale4 = [1, 1, 1];
        var skew2 = [0, 0, 0];
        var perspective = [0, 0, 0, 1];
        var quaternion = [0, 0, 0, 1];
        decomposeMat42(
          // @ts-ignore
          convertToMatrix2(transformList),
          translate3,
          scale4,
          skew2,
          perspective,
          quaternion
        );
        return [[translate3, scale4, skew2, quaternion, perspective]];
      }
      var composeMatrix2 = /* @__PURE__ */ (function() {
        function multiply2(a2, b) {
          var result = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];
          for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 4; j++) {
              for (var k = 0; k < 4; k++) {
                result[i][j] += b[i][k] * a2[k][j];
              }
            }
          }
          return result;
        }
        function is2D(m2) {
          return m2[0][2] === 0 && m2[0][3] === 0 && m2[1][2] === 0 && m2[1][3] === 0 && m2[2][0] === 0 && m2[2][1] === 0 && m2[2][2] === 1 && m2[2][3] === 0 && m2[3][2] === 0 && m2[3][3] === 1;
        }
        function composeMatrix3(translate3, scale4, skew2, quat4, perspective) {
          var matrix3 = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
          for (var i = 0; i < 4; i++) {
            matrix3[i][3] = perspective[i];
          }
          for (var _i = 0; _i < 3; _i++) {
            for (var j = 0; j < 3; j++) {
              matrix3[3][_i] += translate3[j] * matrix3[j][_i];
            }
          }
          var x3 = quat4[0];
          var y3 = quat4[1];
          var z = quat4[2];
          var w = quat4[3];
          var rotMatrix = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
          rotMatrix[0][0] = 1 - 2 * (y3 * y3 + z * z);
          rotMatrix[0][1] = 2 * (x3 * y3 - z * w);
          rotMatrix[0][2] = 2 * (x3 * z + y3 * w);
          rotMatrix[1][0] = 2 * (x3 * y3 + z * w);
          rotMatrix[1][1] = 1 - 2 * (x3 * x3 + z * z);
          rotMatrix[1][2] = 2 * (y3 * z - x3 * w);
          rotMatrix[2][0] = 2 * (x3 * z - y3 * w);
          rotMatrix[2][1] = 2 * (y3 * z + x3 * w);
          rotMatrix[2][2] = 1 - 2 * (x3 * x3 + y3 * y3);
          matrix3 = multiply2(matrix3, rotMatrix);
          var temp = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
          if (skew2[2]) {
            temp[2][1] = skew2[2];
            matrix3 = multiply2(matrix3, temp);
          }
          if (skew2[1]) {
            temp[2][1] = 0;
            temp[2][0] = skew2[0];
            matrix3 = multiply2(matrix3, temp);
          }
          if (skew2[0]) {
            temp[2][0] = 0;
            temp[1][0] = skew2[0];
            matrix3 = multiply2(matrix3, temp);
          }
          for (var _i2 = 0; _i2 < 3; _i2++) {
            for (var _j = 0; _j < 3; _j++) {
              matrix3[_i2][_j] *= scale4[_i2];
            }
          }
          if (is2D(matrix3)) {
            return [matrix3[0][0], matrix3[0][1], matrix3[1][0], matrix3[1][1], matrix3[3][0], matrix3[3][1]];
          }
          return matrix3[0].concat(matrix3[1], matrix3[2], matrix3[3]);
        }
        return composeMatrix3;
      })();
      function numberToLongString2(x3) {
        return x3.toFixed(6).replace(".000000", "");
      }
      function mergeMatrices2(left, right) {
        var leftArgs;
        var rightArgs;
        if (left.decompositionPair !== right) {
          left.decompositionPair = right;
          leftArgs = makeMatrixDecomposition2(left);
        }
        if (right.decompositionPair !== left) {
          right.decompositionPair = left;
          rightArgs = makeMatrixDecomposition2(right);
        }
        if (leftArgs[0] === null || rightArgs[0] === null) return [
          // @ts-ignore
          [false],
          // @ts-ignore
          [true],
          // @ts-ignore
          function(x3) {
            return x3 ? right[0].d : left[0].d;
          }
        ];
        leftArgs[0].push(0);
        rightArgs[0].push(1);
        return [
          leftArgs,
          rightArgs,
          // @ts-ignore
          function(list) {
            var q = quat3(leftArgs[0][3], rightArgs[0][3], list[5]);
            var mat = composeMatrix2(list[0], list[1], list[2], q, list[4]);
            var stringifiedArgs = mat.map(numberToLongString2).join(",");
            return stringifiedArgs;
          }
        ];
      }
      function dot4(v1, v2) {
        var result = 0;
        for (var i = 0; i < v1.length; i++) {
          result += v1[i] * v2[i];
        }
        return result;
      }
      function quat3(fromQ, toQ, f) {
        var product = dot4(fromQ, toQ);
        product = util.clamp(product, -1, 1);
        var quat4 = [];
        if (product === 1) {
          quat4 = fromQ;
        } else {
          var theta = Math.acos(product);
          var w = Math.sin(f * theta) * 1 / Math.sqrt(1 - product * product);
          for (var i = 0; i < 4; i++) {
            quat4.push(fromQ[i] * (Math.cos(f * theta) - product * w) + toQ[i] * w);
          }
        }
        return quat4;
      }
      function typeTo2D2(type) {
        return type.replace(/[XY]/, "");
      }
      function typeTo3D2(type) {
        return type.replace(/(X|Y|Z|3d)?$/, "3d");
      }
      var isMatrixOrPerspective3 = function isMatrixOrPerspective4(lt, rt) {
        return lt === "perspective" && rt === "perspective" || (lt === "matrix" || lt === "matrix3d") && (rt === "matrix" || rt === "matrix3d");
      };
      function mergeTransforms2(left, right, target) {
        var flipResults = false;
        if (!left.length || !right.length) {
          if (!left.length) {
            flipResults = true;
            left = right;
            right = [];
          }
          var _loop = function _loop2() {
            var _left$i = left[i], type2 = _left$i.t, args = _left$i.d;
            var defaultValue = type2.substring(0, 5) === "scale" ? 1 : 0;
            right.push({
              t: type2,
              d: args.map(function(arg) {
                if (typeof arg === "number") {
                  return getOrCreateUnitValue3(defaultValue);
                }
                return getOrCreateUnitValue3(defaultValue, arg.unit);
              })
            });
          };
          for (var i = 0; i < left.length; i++) {
            _loop();
          }
        }
        var leftResult = [];
        var rightResult = [];
        var types = [];
        if (left.length !== right.length) {
          var merged = mergeMatrices2(left, right);
          leftResult = [merged[0]];
          rightResult = [merged[1]];
          types = [["matrix", [merged[2]]]];
        } else {
          for (var _i3 = 0; _i3 < left.length; _i3++) {
            var leftType = left[_i3].t;
            var rightType = right[_i3].t;
            var leftArgs = left[_i3].d;
            var rightArgs = right[_i3].d;
            var leftFunctionData = transformFunctions2[leftType];
            var rightFunctionData = transformFunctions2[rightType];
            var type = void 0;
            if (isMatrixOrPerspective3(leftType, rightType)) {
              var _merged = mergeMatrices2([left[_i3]], [right[_i3]]);
              leftResult.push(_merged[0]);
              rightResult.push(_merged[1]);
              types.push(["matrix", [_merged[2]]]);
              continue;
            } else if (leftType === rightType) {
              type = leftType;
            } else if (leftFunctionData[2] && rightFunctionData[2] && typeTo2D2(leftType) === typeTo2D2(rightType)) {
              type = typeTo2D2(leftType);
              leftArgs = leftFunctionData[2](leftArgs);
              rightArgs = rightFunctionData[2](rightArgs);
            } else if (leftFunctionData[1] && rightFunctionData[1] && typeTo3D2(leftType) === typeTo3D2(rightType)) {
              type = typeTo3D2(leftType);
              leftArgs = leftFunctionData[1](leftArgs);
              rightArgs = rightFunctionData[1](rightArgs);
            } else {
              var _merged2 = mergeMatrices2(left, right);
              leftResult = [_merged2[0]];
              rightResult = [_merged2[1]];
              types = [["matrix", [_merged2[2]]]];
              break;
            }
            var leftArgsCopy = [];
            var rightArgsCopy = [];
            var stringConversions = [];
            for (var j = 0; j < leftArgs.length; j++) {
              var _merged3 = mergeDimensions2(leftArgs[j], rightArgs[j], target, false, j);
              leftArgsCopy[j] = _merged3[0];
              rightArgsCopy[j] = _merged3[1];
              stringConversions.push(_merged3[2]);
            }
            leftResult.push(leftArgsCopy);
            rightResult.push(rightArgsCopy);
            types.push([type, stringConversions]);
          }
        }
        if (flipResults) {
          var tmp3 = leftResult;
          leftResult = rightResult;
          rightResult = tmp3;
        }
        return [leftResult, rightResult, function(list) {
          return list.map(function(args, i2) {
            var stringifiedArgs = args.map(function(arg, j2) {
              return types[i2][1][j2](arg);
            }).join(",");
            if (types[i2][0] === "matrix" && stringifiedArgs.split(",").length === 16) {
              types[i2][0] = "matrix3d";
            }
            if (types[i2][0] === "matrix3d" && stringifiedArgs.split(",").length === 6) {
              types[i2][0] = "matrix";
            }
            return "".concat(types[i2][0], "(").concat(stringifiedArgs, ")");
          }).join(" ");
        }];
      }
      var parseTransformOrigin2 = memoize4(function(value) {
        if (util.isString(value)) {
          if (value === "text-anchor") {
            return [getOrCreateUnitValue3(0, "px"), getOrCreateUnitValue3(0, "px")];
          }
          var values2 = value.split(" ");
          if (values2.length === 1) {
            if (values2[0] === "top" || values2[0] === "bottom") {
              values2[1] = values2[0];
              values2[0] = "center";
            } else {
              values2[1] = "center";
            }
          }
          if (values2.length !== 2) {
            return null;
          }
          return [parseLengthOrPercentage2(convertKeyword2Percent2(values2[0])), parseLengthOrPercentage2(convertKeyword2Percent2(values2[1]))];
        }
        return [getOrCreateUnitValue3(value[0] || 0, "px"), getOrCreateUnitValue3(value[1] || 0, "px")];
      });
      function convertKeyword2Percent2(keyword) {
        if (keyword === "center") {
          return "50%";
        }
        if (keyword === "left" || keyword === "top") {
          return "0%";
        }
        if (keyword === "right" || keyword === "bottom") {
          return "100%";
        }
        return keyword;
      }
      var BUILT_IN_PROPERTIES2 = [
        {
          /**
           * used in CSS Layout API
           * eg. `display: 'flex'`
           */
          n: "display",
          k: ["none"]
        },
        {
          /**
           * range [0.0, 1.0]
           * @see https://developer.mozilla.org/en-US/docs/Web/CSS/opacity
           */
          n: "opacity",
          "int": true,
          inh: true,
          d: "1",
          syntax: PropertySyntax2.OPACITY_VALUE
        },
        {
          /**
           * inheritable, range [0.0, 1.0]
           * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-opacity
           * @see https://svgwg.org/svg2-draft/painting.html#FillOpacity
           */
          n: "fillOpacity",
          "int": true,
          inh: true,
          d: "1",
          syntax: PropertySyntax2.OPACITY_VALUE
        },
        {
          /**
           * inheritable, range [0.0, 1.0]
           * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-opacity
           * @see https://svgwg.org/svg2-draft/painting.html#StrokeOpacity
           */
          n: "strokeOpacity",
          "int": true,
          inh: true,
          d: "1",
          syntax: PropertySyntax2.OPACITY_VALUE
        },
        {
          /**
           * background-color is not inheritable
           * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes
           */
          n: "fill",
          "int": true,
          k: ["none"],
          d: "none",
          syntax: PropertySyntax2.PAINT
        },
        {
          n: "fillRule",
          k: ["nonzero", "evenodd"],
          d: "nonzero"
        },
        /**
         * default to none
         * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke#usage_notes
         */
        {
          n: "stroke",
          "int": true,
          k: ["none"],
          d: "none",
          syntax: PropertySyntax2.PAINT,
          /**
           * Stroke 'none' won't affect geometry but others will.
           */
          l: true
        },
        {
          n: "shadowType",
          k: ["inner", "outer", "both"],
          d: "outer",
          l: true
        },
        {
          n: "shadowColor",
          "int": true,
          syntax: PropertySyntax2.COLOR
        },
        {
          n: "shadowOffsetX",
          "int": true,
          l: true,
          d: "0",
          syntax: PropertySyntax2.LENGTH_PERCENTAGE
        },
        {
          n: "shadowOffsetY",
          "int": true,
          l: true,
          d: "0",
          syntax: PropertySyntax2.LENGTH_PERCENTAGE
        },
        {
          n: "shadowBlur",
          "int": true,
          l: true,
          d: "0",
          syntax: PropertySyntax2.SHADOW_BLUR
        },
        {
          /**
           * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-width
           */
          n: "lineWidth",
          "int": true,
          inh: true,
          d: "1",
          l: true,
          a: ["strokeWidth"],
          syntax: PropertySyntax2.LENGTH_PERCENTAGE
        },
        {
          n: "increasedLineWidthForHitTesting",
          inh: true,
          d: "0",
          l: true,
          syntax: PropertySyntax2.LENGTH_PERCENTAGE
        },
        {
          n: "lineJoin",
          inh: true,
          l: true,
          a: ["strokeLinejoin"],
          k: ["miter", "bevel", "round"],
          d: "miter"
        },
        {
          n: "lineCap",
          inh: true,
          l: true,
          a: ["strokeLinecap"],
          k: ["butt", "round", "square"],
          d: "butt"
        },
        {
          n: "lineDash",
          "int": true,
          inh: true,
          k: ["none"],
          a: ["strokeDasharray"],
          syntax: PropertySyntax2.LENGTH_PERCENTAGE_12
        },
        {
          n: "lineDashOffset",
          "int": true,
          inh: true,
          d: "0",
          a: ["strokeDashoffset"],
          syntax: PropertySyntax2.LENGTH_PERCENTAGE
        },
        {
          n: "offsetPath",
          syntax: PropertySyntax2.DEFINED_PATH
        },
        {
          n: "offsetDistance",
          "int": true,
          syntax: PropertySyntax2.OFFSET_DISTANCE
        },
        {
          n: "dx",
          "int": true,
          l: true,
          d: "0",
          syntax: PropertySyntax2.LENGTH_PERCENTAGE
        },
        {
          n: "dy",
          "int": true,
          l: true,
          d: "0",
          syntax: PropertySyntax2.LENGTH_PERCENTAGE
        },
        {
          n: "zIndex",
          ind: true,
          "int": true,
          d: "0",
          k: ["auto"],
          syntax: PropertySyntax2.Z_INDEX
        },
        {
          n: "visibility",
          k: ["visible", "hidden"],
          ind: true,
          inh: true,
          /**
           * support interpolation
           * @see https://developer.mozilla.org/en-US/docs/Web/CSS/visibility#interpolation
           */
          "int": true,
          d: "visible"
        },
        {
          n: "pointerEvents",
          inh: true,
          k: [
            "none",
            "auto",
            "stroke",
            "fill",
            "painted",
            "visible",
            "visiblestroke",
            "visiblefill",
            "visiblepainted",
            // 'bounding-box',
            "all"
          ],
          d: "auto"
        },
        {
          n: "filter",
          ind: true,
          l: true,
          k: ["none"],
          d: "none",
          syntax: PropertySyntax2.FILTER
        },
        {
          n: "clipPath",
          syntax: PropertySyntax2.DEFINED_PATH
        },
        {
          n: "textPath",
          syntax: PropertySyntax2.DEFINED_PATH
        },
        {
          n: "textPathSide",
          k: ["left", "right"],
          d: "left"
        },
        {
          n: "textPathStartOffset",
          l: true,
          d: "0",
          syntax: PropertySyntax2.LENGTH_PERCENTAGE
        },
        {
          n: "transform",
          p: 100,
          "int": true,
          k: ["none"],
          d: "none",
          syntax: PropertySyntax2.TRANSFORM
        },
        {
          n: "transformOrigin",
          p: 100,
          d: "0 0",
          // // int: true,
          // d: (nodeName: string) => {
          //   if (nodeName === Shape.CIRCLE || nodeName === Shape.ELLIPSE) {
          //     return 'center';
          //   }
          //   if (nodeName === Shape.TEXT) {
          //     return 'text-anchor';
          //   }
          //   return 'left top';
          // },
          l: true,
          syntax: PropertySyntax2.TRANSFORM_ORIGIN
        },
        {
          n: "cx",
          "int": true,
          l: true,
          d: "0",
          syntax: PropertySyntax2.COORDINATE
        },
        {
          n: "cy",
          "int": true,
          l: true,
          d: "0",
          syntax: PropertySyntax2.COORDINATE
        },
        {
          n: "cz",
          "int": true,
          l: true,
          d: "0",
          syntax: PropertySyntax2.COORDINATE
        },
        {
          n: "r",
          "int": true,
          l: true,
          d: "0",
          syntax: PropertySyntax2.LENGTH_PERCENTAGE
        },
        {
          n: "rx",
          "int": true,
          l: true,
          d: "0",
          syntax: PropertySyntax2.LENGTH_PERCENTAGE
        },
        {
          n: "ry",
          "int": true,
          l: true,
          d: "0",
          syntax: PropertySyntax2.LENGTH_PERCENTAGE
        },
        // Rect Image Group
        {
          // x in local space
          n: "x",
          "int": true,
          l: true,
          d: "0",
          syntax: PropertySyntax2.COORDINATE
        },
        {
          // y in local space
          n: "y",
          "int": true,
          l: true,
          d: "0",
          syntax: PropertySyntax2.COORDINATE
        },
        {
          // z in local space
          n: "z",
          "int": true,
          l: true,
          d: "0",
          syntax: PropertySyntax2.COORDINATE
        },
        {
          n: "width",
          "int": true,
          l: true,
          /**
           * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/width
           */
          k: ["auto", "fit-content", "min-content", "max-content"],
          d: "0",
          syntax: PropertySyntax2.LENGTH_PERCENTAGE
        },
        {
          n: "height",
          "int": true,
          l: true,
          /**
           * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/height
           */
          k: ["auto", "fit-content", "min-content", "max-content"],
          d: "0",
          syntax: PropertySyntax2.LENGTH_PERCENTAGE
        },
        {
          n: "radius",
          "int": true,
          l: true,
          d: "0",
          syntax: PropertySyntax2.LENGTH_PERCENTAGE_14
        },
        // Line
        {
          n: "x1",
          "int": true,
          l: true,
          syntax: PropertySyntax2.COORDINATE
        },
        {
          n: "y1",
          "int": true,
          l: true,
          syntax: PropertySyntax2.COORDINATE
        },
        {
          n: "z1",
          "int": true,
          l: true,
          syntax: PropertySyntax2.COORDINATE
        },
        {
          n: "x2",
          "int": true,
          l: true,
          syntax: PropertySyntax2.COORDINATE
        },
        {
          n: "y2",
          "int": true,
          l: true,
          syntax: PropertySyntax2.COORDINATE
        },
        {
          n: "z2",
          "int": true,
          l: true,
          syntax: PropertySyntax2.COORDINATE
        },
        // Path
        {
          n: "d",
          "int": true,
          l: true,
          d: "",
          syntax: PropertySyntax2.PATH,
          p: 50
        },
        // Polyline & Polygon
        {
          n: "points",
          /**
           * support interpolation
           */
          "int": true,
          l: true,
          syntax: PropertySyntax2.LIST_OF_POINTS,
          p: 50
        },
        // Text
        {
          n: "text",
          l: true,
          d: "",
          syntax: PropertySyntax2.TEXT,
          p: 50
        },
        {
          n: "textTransform",
          l: true,
          inh: true,
          k: ["capitalize", "uppercase", "lowercase", "none"],
          d: "none",
          syntax: PropertySyntax2.TEXT_TRANSFORM,
          p: 51
          // it must get parsed after text
        },
        {
          n: "font",
          l: true
        },
        {
          n: "fontSize",
          "int": true,
          inh: true,
          /**
           * @see https://www.w3schools.com/css/css_font_size.asp
           */
          d: "16px",
          l: true,
          syntax: PropertySyntax2.LENGTH_PERCENTAGE
        },
        {
          n: "fontFamily",
          l: true,
          inh: true,
          d: "sans-serif"
        },
        {
          n: "fontStyle",
          l: true,
          inh: true,
          k: ["normal", "italic", "oblique"],
          d: "normal"
        },
        {
          n: "fontWeight",
          l: true,
          inh: true,
          k: ["normal", "bold", "bolder", "lighter"],
          d: "normal"
        },
        {
          n: "fontVariant",
          l: true,
          inh: true,
          k: ["normal", "small-caps"],
          d: "normal"
        },
        {
          n: "lineHeight",
          l: true,
          syntax: PropertySyntax2.LENGTH,
          "int": true,
          d: "0"
        },
        {
          n: "letterSpacing",
          l: true,
          syntax: PropertySyntax2.LENGTH,
          "int": true,
          d: "0"
        },
        {
          n: "miterLimit",
          l: true,
          syntax: PropertySyntax2.NUMBER,
          d: function d2(nodeName) {
            if (nodeName === Shape2.PATH || nodeName === Shape2.POLYGON || nodeName === Shape2.POLYLINE) {
              return "4";
            }
            return "10";
          }
        },
        {
          n: "wordWrap",
          l: true
        },
        {
          n: "wordWrapWidth",
          l: true
        },
        {
          n: "maxLines",
          l: true
        },
        {
          n: "textOverflow",
          l: true,
          d: "clip"
        },
        {
          n: "leading",
          l: true
        },
        {
          n: "textBaseline",
          l: true,
          inh: true,
          k: ["top", "hanging", "middle", "alphabetic", "ideographic", "bottom"],
          d: "alphabetic"
        },
        {
          n: "textAlign",
          l: true,
          inh: true,
          k: ["start", "center", "middle", "end", "left", "right"],
          d: "start"
        },
        // {
        //   n: 'whiteSpace',
        //   l: true,
        // },
        {
          n: "markerStart",
          syntax: PropertySyntax2.MARKER
        },
        {
          n: "markerEnd",
          syntax: PropertySyntax2.MARKER
        },
        {
          n: "markerMid",
          syntax: PropertySyntax2.MARKER
        },
        {
          n: "markerStartOffset",
          syntax: PropertySyntax2.LENGTH,
          l: true,
          "int": true,
          d: "0"
        },
        {
          n: "markerEndOffset",
          syntax: PropertySyntax2.LENGTH,
          l: true,
          "int": true,
          d: "0"
        }
      ];
      var GEOMETRY_ATTRIBUTE_NAMES2 = new Set(BUILT_IN_PROPERTIES2.filter(function(n) {
        return !!n.l;
      }).map(function(n) {
        return n.n;
      }));
      var propertyMetadataCache2 = {};
      var DefaultStyleValueRegistry2 = /* @__PURE__ */ (function() {
        function DefaultStyleValueRegistry3(runtime3) {
          var _this2 = this;
          _classCallCheck2(this, DefaultStyleValueRegistry3);
          this.runtime = runtime3;
          BUILT_IN_PROPERTIES2.forEach(function(property) {
            _this2.registerMetadata(property);
          });
        }
        return _createClass2(DefaultStyleValueRegistry3, [{
          key: "registerMetadata",
          value: function registerMetadata(metadata) {
            [metadata.n].concat(_toConsumableArray2(metadata.a || [])).forEach(function(name) {
              propertyMetadataCache2[name] = metadata;
            });
          }
        }, {
          key: "getPropertySyntax",
          value: function getPropertySyntax(syntax) {
            return this.runtime.CSSPropertySyntaxFactory[syntax];
          }
          /**
           * * parse value, eg.
           * fill: 'red' => CSSRGB
           * translateX: '10px' => CSSUnitValue { unit: 'px', value: 10 }
           * fontSize: '2em' => { unit: 'px', value: 32 }
           *
           * * calculate used value
           * * post process
           */
        }, {
          key: "processProperties",
          value: function processProperties(object, attributes) {
            var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
              skipUpdateAttribute: false,
              skipParse: false,
              forceUpdateGeometry: false,
              usedAttributes: [],
              memoize: true
            };
            Object.assign(object.attributes, attributes);
            var oldClipPath = object.parsedStyle.clipPath;
            var oldOffsetPath = object.parsedStyle.offsetPath;
            assignParsedStyle2(object, attributes);
            var needUpdateGeometry = !!options.forceUpdateGeometry;
            if (!needUpdateGeometry) {
              for (var i in attributes) {
                if (GEOMETRY_ATTRIBUTE_NAMES2.has(i)) {
                  needUpdateGeometry = true;
                  break;
                }
              }
            }
            var list = getParsedStyleListOf2(object);
            if (list.has("fill") && attributes.fill) {
              object.parsedStyle.fill = parseColor2(attributes.fill);
            }
            if (list.has("stroke") && attributes.stroke) {
              object.parsedStyle.stroke = parseColor2(attributes.stroke);
            }
            if (list.has("shadowColor") && attributes.shadowColor) {
              object.parsedStyle.shadowColor = parseColor2(attributes.shadowColor);
            }
            if (list.has("filter") && attributes.filter) {
              object.parsedStyle.filter = parseFilter2(attributes.filter);
            }
            if (list.has("radius") && !util.isNil(attributes.radius)) {
              object.parsedStyle.radius = parseDimensionArrayFormat2(
                // @ts-ignore
                attributes.radius,
                4
              );
            }
            if (list.has("lineDash") && !util.isNil(attributes.lineDash)) {
              object.parsedStyle.lineDash = parseDimensionArrayFormat2(attributes.lineDash, "even");
            }
            if (list.has("points") && attributes.points) {
              object.parsedStyle.points = parsePoints2(attributes.points);
            }
            if (list.has("d") && attributes.d === "") {
              object.parsedStyle.d = _objectSpread({}, EMPTY_PARSED_PATH2);
            }
            if (list.has("d") && attributes.d) {
              object.parsedStyle.d = parsePath3(
                // @ts-ignore
                attributes.d
              );
            }
            if (list.has("textTransform") && attributes.textTransform) {
              this.runtime.CSSPropertySyntaxFactory[PropertySyntax2.TEXT_TRANSFORM].calculator(null, null, {
                value: attributes.textTransform
              }, object, null);
            }
            if (list.has("clipPath") && !util.isUndefined(attributes.clipPath)) {
              this.runtime.CSSPropertySyntaxFactory[PropertySyntax2.DEFINED_PATH].calculator("clipPath", oldClipPath, attributes.clipPath, object, this.runtime);
            }
            if (list.has("offsetPath") && attributes.offsetPath) {
              this.runtime.CSSPropertySyntaxFactory[PropertySyntax2.DEFINED_PATH].calculator("offsetPath", oldOffsetPath, attributes.offsetPath, object, this.runtime);
            }
            if (list.has("transform") && attributes.transform) {
              object.parsedStyle.transform = parseTransform2(attributes.transform);
            }
            if (list.has("transformOrigin") && attributes.transformOrigin) {
              object.parsedStyle.transformOrigin = parseTransformOrigin2(attributes.transformOrigin);
            }
            if (list.has("markerStart") && attributes.markerStart) {
              object.parsedStyle.markerStart = this.runtime.CSSPropertySyntaxFactory[PropertySyntax2.MARKER].calculator(
                null,
                // @ts-ignore
                attributes.markerStart,
                // @ts-ignore
                attributes.markerStart,
                null,
                null
              );
            }
            if (list.has("markerEnd") && attributes.markerEnd) {
              object.parsedStyle.markerEnd = this.runtime.CSSPropertySyntaxFactory[PropertySyntax2.MARKER].calculator(
                null,
                // @ts-ignore
                attributes.markerEnd,
                // @ts-ignore
                attributes.markerEnd,
                null,
                null
              );
            }
            if (list.has("markerMid") && attributes.markerMid) {
              object.parsedStyle.markerMid = this.runtime.CSSPropertySyntaxFactory[PropertySyntax2.MARKER].calculator(
                "",
                // @ts-ignore
                attributes.markerMid,
                // @ts-ignore
                attributes.markerMid,
                null,
                null
              );
            }
            if (list.has("zIndex") && !util.isNil(attributes.zIndex)) {
              this.runtime.CSSPropertySyntaxFactory[PropertySyntax2.Z_INDEX].postProcessor(object);
            }
            if (list.has("offsetDistance") && !util.isNil(attributes.offsetDistance)) {
              this.runtime.CSSPropertySyntaxFactory[PropertySyntax2.OFFSET_DISTANCE].postProcessor(object);
            }
            if (list.has("transform") && attributes.transform) {
              this.runtime.CSSPropertySyntaxFactory[PropertySyntax2.TRANSFORM].postProcessor(object);
            }
            if (list.has("transformOrigin") && attributes.transformOrigin) {
              this.runtime.CSSPropertySyntaxFactory[PropertySyntax2.TRANSFORM_ORIGIN].postProcessor(object);
            }
            if (needUpdateGeometry) {
              object.geometry.dirty = true;
              object.dirty(true, true);
              if (!options.forceUpdateGeometry) {
                this.runtime.sceneGraphService.dirtyToRoot(object);
              }
            }
          }
          /**
           * update geometry when relative props changed,
           * eg. r of Circle, width/height of Rect
           */
        }, {
          key: "updateGeometry",
          value: function updateGeometry(object) {
            var nodeName = object.nodeName;
            var geometryUpdater = this.runtime.geometryUpdaterFactory[nodeName];
            if (geometryUpdater) {
              var geometry = object.geometry;
              if (!geometry.contentBounds) {
                geometry.contentBounds = new AABB2();
              }
              if (!geometry.renderBounds) {
                geometry.renderBounds = new AABB2();
              }
              var parsedStyle = object.parsedStyle;
              var _geometryUpdater$upda = geometryUpdater.update(parsedStyle, object), _geometryUpdater$upda2 = _geometryUpdater$upda.cx, cx = _geometryUpdater$upda2 === void 0 ? 0 : _geometryUpdater$upda2, _geometryUpdater$upda3 = _geometryUpdater$upda.cy, cy = _geometryUpdater$upda3 === void 0 ? 0 : _geometryUpdater$upda3, _geometryUpdater$upda4 = _geometryUpdater$upda.cz, cz = _geometryUpdater$upda4 === void 0 ? 0 : _geometryUpdater$upda4, _geometryUpdater$upda5 = _geometryUpdater$upda.hwidth, hwidth = _geometryUpdater$upda5 === void 0 ? 0 : _geometryUpdater$upda5, _geometryUpdater$upda6 = _geometryUpdater$upda.hheight, hheight = _geometryUpdater$upda6 === void 0 ? 0 : _geometryUpdater$upda6, _geometryUpdater$upda7 = _geometryUpdater$upda.hdepth, hdepth = _geometryUpdater$upda7 === void 0 ? 0 : _geometryUpdater$upda7;
              var halfExtents = [Math.abs(hwidth), Math.abs(hheight), hdepth];
              var stroke = parsedStyle.stroke, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$increase = parsedStyle.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _parsedStyle$increase === void 0 ? 0 : _parsedStyle$increase, _parsedStyle$shadowTy = parsedStyle.shadowType, shadowType = _parsedStyle$shadowTy === void 0 ? "outer" : _parsedStyle$shadowTy, shadowColor = parsedStyle.shadowColor, _parsedStyle$filter = parsedStyle.filter, filter = _parsedStyle$filter === void 0 ? [] : _parsedStyle$filter, transformOrigin = parsedStyle.transformOrigin;
              var center = [cx, cy, cz];
              geometry.contentBounds.update(center, halfExtents);
              var expansion = nodeName === Shape2.POLYLINE || nodeName === Shape2.POLYGON || nodeName === Shape2.PATH ? Math.SQRT2 : 0.5;
              var hasStroke = stroke && !stroke.isNone;
              if (hasStroke) {
                var halfLineWidth = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) * expansion;
                halfExtents[0] += halfLineWidth;
                halfExtents[1] += halfLineWidth;
              }
              geometry.renderBounds.update(center, halfExtents);
              if (shadowColor && shadowType && shadowType !== "inner") {
                var _geometry$renderBound = geometry.renderBounds, min4 = _geometry$renderBound.min, max4 = _geometry$renderBound.max;
                var shadowBlur = parsedStyle.shadowBlur, shadowOffsetX = parsedStyle.shadowOffsetX, shadowOffsetY = parsedStyle.shadowOffsetY;
                var shadowBlurInPixels = shadowBlur || 0;
                var shadowOffsetXInPixels = shadowOffsetX || 0;
                var shadowOffsetYInPixels = shadowOffsetY || 0;
                var shadowLeft = min4[0] - shadowBlurInPixels + shadowOffsetXInPixels;
                var shadowRight = max4[0] + shadowBlurInPixels + shadowOffsetXInPixels;
                var shadowTop = min4[1] - shadowBlurInPixels + shadowOffsetYInPixels;
                var shadowBottom = max4[1] + shadowBlurInPixels + shadowOffsetYInPixels;
                min4[0] = Math.min(min4[0], shadowLeft);
                max4[0] = Math.max(max4[0], shadowRight);
                min4[1] = Math.min(min4[1], shadowTop);
                max4[1] = Math.max(max4[1], shadowBottom);
                geometry.renderBounds.setMinMax(min4, max4);
              }
              filter.forEach(function(_ref) {
                var name = _ref.name, params = _ref.params;
                if (name === "blur") {
                  var blurRadius = params[0].value;
                  geometry.renderBounds.update(geometry.renderBounds.center, glMatrix.vec3.add(geometry.renderBounds.halfExtents, geometry.renderBounds.halfExtents, [blurRadius, blurRadius, 0]));
                } else if (name === "drop-shadow") {
                  var _shadowOffsetX = params[0].value;
                  var _shadowOffsetY = params[1].value;
                  var _shadowBlur = params[2].value;
                  var _geometry$renderBound2 = geometry.renderBounds, _min = _geometry$renderBound2.min, _max = _geometry$renderBound2.max;
                  var _shadowLeft = _min[0] - _shadowBlur + _shadowOffsetX;
                  var _shadowRight = _max[0] + _shadowBlur + _shadowOffsetX;
                  var _shadowTop = _min[1] - _shadowBlur + _shadowOffsetY;
                  var _shadowBottom = _max[1] + _shadowBlur + _shadowOffsetY;
                  _min[0] = Math.min(_min[0], _shadowLeft);
                  _max[0] = Math.max(_max[0], _shadowRight);
                  _min[1] = Math.min(_min[1], _shadowTop);
                  _max[1] = Math.max(_max[1], _shadowBottom);
                  geometry.renderBounds.setMinMax(_min, _max);
                }
              });
              object.geometry.dirty = false;
              var flipY = hwidth < 0;
              var flipX = hheight < 0;
              var usedOriginXValue = (flipY ? -1 : 1) * (transformOrigin ? convertPercentUnit2(transformOrigin[0], 0, object, true) : 0);
              var usedOriginYValue = (flipX ? -1 : 1) * (transformOrigin ? convertPercentUnit2(transformOrigin[1], 1, object, true) : 0);
              if (usedOriginXValue || usedOriginYValue) {
                object.setOrigin(usedOriginXValue, usedOriginYValue);
              }
            }
          }
        }, {
          key: "updateSizeAttenuation",
          value: function updateSizeAttenuation(node, zoom) {
            if (node.style.isSizeAttenuation) {
              if (!node.style.rawLineWidth) {
                node.style.rawLineWidth = node.style.lineWidth;
              }
              node.style.lineWidth = (node.style.rawLineWidth || 1) / zoom;
              if (node.nodeName === Shape2.CIRCLE) {
                if (!node.style.rawR) {
                  node.style.rawR = node.style.r;
                }
                node.style.r = (node.style.rawR || 1) / zoom;
              }
            } else {
              if (node.style.rawLineWidth) {
                node.style.lineWidth = node.style.rawLineWidth;
                delete node.style.rawLineWidth;
              }
              if (node.nodeName === Shape2.CIRCLE) {
                if (node.style.rawR) {
                  node.style.r = node.style.rawR;
                  delete node.style.rawR;
                }
              }
            }
          }
        }]);
      })();
      function assignParsedStyle2(object, attributes) {
        var list = getParsedStyleListOf2(object);
        for (var key in attributes) {
          if (list.has(key)) {
            object.parsedStyle[key] = attributes[key];
          }
        }
      }
      function getParsedStyleListOf2(object) {
        return object.constructor.PARSED_STYLE_LIST;
      }
      var CSSPropertyAngle2 = /* @__PURE__ */ (function() {
        function CSSPropertyAngle3() {
          _classCallCheck2(this, CSSPropertyAngle3);
          this.mixer = mergeNumbers2;
        }
        return _createClass2(CSSPropertyAngle3, [{
          key: "calculator",
          value: function calculator(name, oldParsed, parsed, object) {
            return convertAngleUnit2(parsed);
          }
        }]);
      })();
      var CSSPropertyClipPath2 = /* @__PURE__ */ (function() {
        function CSSPropertyClipPath3() {
          _classCallCheck2(this, CSSPropertyClipPath3);
        }
        return _createClass2(CSSPropertyClipPath3, [{
          key: "calculator",
          value: function calculator(name, oldPath, newPath, object, runtime3) {
            if (newPath instanceof CSSKeywordValue2) {
              newPath = null;
            }
            runtime3.sceneGraphService.updateDisplayObjectDependency(name, oldPath, newPath, object);
            if (name === "clipPath") {
              object.forEach(function(leaf) {
                if (leaf.childNodes.length === 0) {
                  runtime3.sceneGraphService.dirtyToRoot(leaf);
                }
              });
            }
            return newPath;
          }
        }]);
      })();
      var CSSPropertyColor2 = /* @__PURE__ */ (function() {
        function CSSPropertyColor3() {
          _classCallCheck2(this, CSSPropertyColor3);
          this.parser = parseColor2;
          this.mixer = mergeColors2;
        }
        return _createClass2(CSSPropertyColor3, [{
          key: "calculator",
          value: function calculator(name, oldParsed, parsed, object) {
            if (parsed instanceof CSSKeywordValue2) {
              return parsed.value === "none" ? noneColor2 : transparentColor2;
            }
            return parsed;
          }
        }]);
      })();
      var CSSPropertyFilter2 = /* @__PURE__ */ (function() {
        function CSSPropertyFilter3() {
          _classCallCheck2(this, CSSPropertyFilter3);
        }
        return _createClass2(CSSPropertyFilter3, [{
          key: "calculator",
          value: function calculator(name, oldParsed, parsed) {
            if (parsed instanceof CSSKeywordValue2) {
              return [];
            }
            return parsed;
          }
        }]);
      })();
      function getFontSize2(object) {
        var _ref = object.parsedStyle, fontSize = _ref.fontSize;
        return util.isNil(fontSize) ? null : fontSize;
      }
      var CSSPropertyLengthOrPercentage2 = /* @__PURE__ */ (function() {
        function CSSPropertyLengthOrPercentage3() {
          _classCallCheck2(this, CSSPropertyLengthOrPercentage3);
          this.mixer = mergeNumbers2;
        }
        return _createClass2(CSSPropertyLengthOrPercentage3, [{
          key: "calculator",
          value: (
            /**
             * according to parent's bounds
             *
             * @example
             * CSS.percent(50) -> CSS.px(0.5 * parent.width)
             */
            function calculator(name, oldParsed, computed, object, runtime3) {
              if (util.isNumber(computed)) {
                return computed;
              }
              if (CSSUnitValue2.isRelativeUnit(computed.unit)) {
                if (computed.unit === UnitType2.kPercentage) {
                  return 0;
                }
                if (computed.unit === UnitType2.kEms) {
                  if (object.parentNode) {
                    var fontSize = getFontSize2(object.parentNode);
                    if (fontSize) {
                      fontSize *= computed.value;
                      return fontSize;
                    }
                  }
                  return 0;
                }
                if (computed.unit === UnitType2.kRems) {
                  var _object$ownerDocument;
                  if (object !== null && object !== void 0 && (_object$ownerDocument = object.ownerDocument) !== null && _object$ownerDocument !== void 0 && _object$ownerDocument.documentElement) {
                    var _fontSize = getFontSize2(object.ownerDocument.documentElement);
                    if (_fontSize) {
                      _fontSize *= computed.value;
                      return _fontSize;
                    }
                  }
                  return 0;
                }
              } else {
                return computed.value;
              }
            }
          )
        }]);
      })();
      var CSSPropertyLengthOrPercentage122 = /* @__PURE__ */ (function() {
        function CSSPropertyLengthOrPercentage123() {
          _classCallCheck2(this, CSSPropertyLengthOrPercentage123);
          this.mixer = mergeNumberLists2;
        }
        return _createClass2(CSSPropertyLengthOrPercentage123, [{
          key: "calculator",
          value: function calculator(name, oldParsed, computed) {
            return computed.map(function(c2) {
              return c2.value;
            });
          }
        }]);
      })();
      var CSSPropertyLengthOrPercentage142 = /* @__PURE__ */ (function() {
        function CSSPropertyLengthOrPercentage143() {
          _classCallCheck2(this, CSSPropertyLengthOrPercentage143);
          this.mixer = mergeNumberLists2;
        }
        return _createClass2(CSSPropertyLengthOrPercentage143, [{
          key: "calculator",
          value: function calculator(name, oldParsed, computed) {
            return computed.map(function(c2) {
              return c2.value;
            });
          }
        }]);
      })();
      var CSSPropertyMarker2 = /* @__PURE__ */ (function() {
        function CSSPropertyMarker3() {
          _classCallCheck2(this, CSSPropertyMarker3);
        }
        return _createClass2(CSSPropertyMarker3, [{
          key: "calculator",
          value: function calculator(name, oldMarker, newMarker, object) {
            var _newMarker;
            if (newMarker instanceof CSSKeywordValue2) {
              newMarker = null;
            }
            var cloned = (_newMarker = newMarker) === null || _newMarker === void 0 ? void 0 : _newMarker.cloneNode(true);
            if (cloned) {
              cloned.style.isMarker = true;
            }
            return cloned;
          }
        }]);
      })();
      var CSSPropertyNumber2 = /* @__PURE__ */ (function() {
        function CSSPropertyNumber3() {
          _classCallCheck2(this, CSSPropertyNumber3);
          this.mixer = mergeNumbers2;
        }
        return _createClass2(CSSPropertyNumber3, [{
          key: "calculator",
          value: function calculator(name, oldParsed, computed) {
            return computed.value;
          }
        }]);
      })();
      var CSSPropertyOffsetDistance2 = /* @__PURE__ */ (function() {
        function CSSPropertyOffsetDistance3() {
          _classCallCheck2(this, CSSPropertyOffsetDistance3);
          this.mixer = clampedMergeNumbers2(0, 1);
        }
        return _createClass2(CSSPropertyOffsetDistance3, [{
          key: "calculator",
          value: function calculator(name, oldParsed, computed) {
            return computed.value;
          }
        }, {
          key: "postProcessor",
          value: function postProcessor(object) {
            var _object$parsedStyle = object.parsedStyle, offsetPath = _object$parsedStyle.offsetPath, offsetDistance = _object$parsedStyle.offsetDistance;
            if (!offsetPath) {
              return;
            }
            var nodeName = offsetPath.nodeName;
            if (nodeName === Shape2.LINE || nodeName === Shape2.PATH || nodeName === Shape2.POLYLINE) {
              var point4 = offsetPath.getPoint(offsetDistance);
              if (point4) {
                object.setLocalPosition(point4.x, point4.y);
              }
            }
          }
        }]);
      })();
      var CSSPropertyOpacity2 = /* @__PURE__ */ (function() {
        function CSSPropertyOpacity3() {
          _classCallCheck2(this, CSSPropertyOpacity3);
          this.mixer = clampedMergeNumbers2(0, 1);
        }
        return _createClass2(CSSPropertyOpacity3, [{
          key: "calculator",
          value: function calculator(name, oldParsed, computed) {
            return computed.value;
          }
        }]);
      })();
      var CSSPropertyPath2 = /* @__PURE__ */ (function() {
        function CSSPropertyPath3() {
          _classCallCheck2(this, CSSPropertyPath3);
          this.parser = parsePath3;
          this.mixer = mergePaths2;
        }
        return _createClass2(CSSPropertyPath3, [{
          key: "calculator",
          value: function calculator(name, oldParsed, parsed) {
            if (parsed instanceof CSSKeywordValue2 && parsed.value === "unset") {
              return {
                absolutePath: [],
                hasArc: false,
                segments: [],
                polygons: [],
                polylines: [],
                curve: null,
                totalLength: 0,
                rect: new Rectangle3(0, 0, 0, 0)
              };
            }
            return parsed;
          }
        }]);
      })();
      var CSSPropertyPoints3 = /* @__PURE__ */ _createClass2(function CSSPropertyPoints4() {
        _classCallCheck2(this, CSSPropertyPoints4);
        this.mixer = mergePoints2;
      });
      var CSSPropertyShadowBlur2 = /* @__PURE__ */ (function(_CSSPropertyLengthOrP) {
        function CSSPropertyShadowBlur3() {
          var _this2;
          _classCallCheck2(this, CSSPropertyShadowBlur3);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this2 = _callSuper2(this, CSSPropertyShadowBlur3, [].concat(args));
          _this2.mixer = clampedMergeNumbers2(0, Infinity);
          return _this2;
        }
        _inherits2(CSSPropertyShadowBlur3, _CSSPropertyLengthOrP);
        return _createClass2(CSSPropertyShadowBlur3);
      })(CSSPropertyLengthOrPercentage2);
      var CSSPropertyText2 = /* @__PURE__ */ (function() {
        function CSSPropertyText3() {
          _classCallCheck2(this, CSSPropertyText3);
        }
        return _createClass2(CSSPropertyText3, [{
          key: "calculator",
          value: function calculator(name, oldParsed, parsed, object) {
            if (parsed instanceof CSSKeywordValue2) {
              if (parsed.value === "unset") {
                return "";
              }
              return parsed.value;
            }
            return "".concat(parsed);
          }
        }, {
          key: "postProcessor",
          value: function postProcessor(object) {
            object.nodeValue = "".concat(object.parsedStyle.text) || "";
          }
        }]);
      })();
      var CSSPropertyTextTransform2 = /* @__PURE__ */ (function() {
        function CSSPropertyTextTransform3() {
          _classCallCheck2(this, CSSPropertyTextTransform3);
        }
        return _createClass2(CSSPropertyTextTransform3, [{
          key: "calculator",
          value: function calculator(name, oldParsed, parsed, object) {
            var rawText = object.getAttribute("text");
            if (rawText) {
              var transformedText = rawText;
              if (parsed.value === "capitalize") {
                transformedText = rawText.charAt(0).toUpperCase() + rawText.slice(1);
              } else if (parsed.value === "lowercase") {
                transformedText = rawText.toLowerCase();
              } else if (parsed.value === "uppercase") {
                transformedText = rawText.toUpperCase();
              }
              object.parsedStyle.text = transformedText;
            }
            return parsed.value;
          }
        }]);
      })();
      var definedProps = function definedProps2(obj) {
        return Object.fromEntries(Object.entries(obj).filter(function(_ref) {
          var _ref2 = _slicedToArray2(_ref, 2), v = _ref2[1];
          return v !== void 0;
        }));
      };
      var CANVAS_Map2 = /* @__PURE__ */ new WeakMap();
      function cleanExistedCanvas2(container, canvas2, cleanUp) {
        if (container) {
          var $dom = typeof container === "string" ? document.getElementById(container) : container;
          if (CANVAS_Map2.has($dom)) CANVAS_Map2.get($dom).destroy(cleanUp);
          CANVAS_Map2.set($dom, canvas2);
        }
      }
      var isBrowser2 = typeof window !== "undefined" && typeof window.document !== "undefined";
      function isElement4(target) {
        return !!target.getAttribute;
      }
      function sortedIndex2(array, value) {
        var low = 0;
        var high = array.length;
        while (low < high) {
          var mid = low + high >>> 1;
          if (sortByZIndex2(array[mid], value) < 0) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return low;
      }
      function sortByZIndex2(o1, o2) {
        var zIndex1 = Number(o1.parsedStyle.zIndex || 0);
        var zIndex2 = Number(o2.parsedStyle.zIndex || 0);
        if (zIndex1 === zIndex2) {
          var parent = o1.parentNode;
          if (parent) {
            var children = parent.childNodes || [];
            return children.indexOf(o1) - children.indexOf(o2);
          }
        }
        return zIndex1 - zIndex2;
      }
      function findClosestClipPathTarget2(object) {
        var el = object;
        do {
          var _el$parsedStyle;
          var clipPath = (_el$parsedStyle = el.parsedStyle) === null || _el$parsedStyle === void 0 ? void 0 : _el$parsedStyle.clipPath;
          if (clipPath) return el;
          el = el.parentElement;
        } while (el !== null);
        return null;
      }
      var PX_SUFFIX2 = "px";
      function setDOMSize2($el, width2, height) {
        if (isBrowser2 && $el.style) {
          $el.style.width = width2 + PX_SUFFIX2;
          $el.style.height = height + PX_SUFFIX2;
        }
      }
      function getStyle2($el, property) {
        if (isBrowser2) {
          return document.defaultView.getComputedStyle($el, null).getPropertyValue(property);
        }
      }
      function getWidth2($el) {
        var width2 = getStyle2($el, "width");
        if (width2 === "auto") {
          return $el.offsetWidth;
        }
        return parseFloat(width2);
      }
      function getHeight2($el) {
        var height = getStyle2($el, "height");
        if (height === "auto") {
          return $el.offsetHeight;
        }
        return parseFloat(height);
      }
      var MOUSE_POINTER_ID2 = 1;
      var TOUCH_TO_POINTER2 = {
        touchstart: "pointerdown",
        touchend: "pointerup",
        touchendoutside: "pointerupoutside",
        touchmove: "pointermove",
        touchcancel: "pointercancel"
      };
      var clock3 = typeof performance === "object" && performance.now ? performance : Date;
      function isInFragment2(node) {
        if (node.nodeName === Shape2.FRAGMENT) return true;
        return node.getRootNode().nodeName === Shape2.FRAGMENT;
      }
      function isFillOrStrokeAffected2() {
        var pointerEvents = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "auto";
        var fill = arguments.length > 1 ? arguments[1] : void 0;
        var stroke = arguments.length > 2 ? arguments[2] : void 0;
        var hasFill = false;
        var hasStroke = false;
        var isFillOtherThanNone = !!fill && !fill.isNone;
        var isStrokeOtherThanNone = !!stroke && !stroke.isNone;
        if (pointerEvents === "visiblepainted" || pointerEvents === "painted" || pointerEvents === "auto") {
          hasFill = isFillOtherThanNone;
          hasStroke = isStrokeOtherThanNone;
        } else if (pointerEvents === "visiblefill" || pointerEvents === "fill") {
          hasFill = true;
        } else if (pointerEvents === "visiblestroke" || pointerEvents === "stroke") {
          hasStroke = true;
        } else if (pointerEvents === "visible" || pointerEvents === "all") {
          hasFill = true;
          hasStroke = true;
        }
        return [hasFill, hasStroke];
      }
      var uId2 = 1;
      var uniqueId5 = function uniqueId6() {
        return uId2++;
      };
      var root2 = (
        // eslint-disable-next-line no-nested-ternary
        typeof self === "object" && self.self === self ? self : (
          // @ts-ignore
          typeof global === "object" && global.global === global ? (
            // @ts-ignore
            global
          ) : {}
        )
      );
      var nowOffset2 = Date.now();
      var pnow3 = function pnow4() {
        if (root2.performance && typeof root2.performance.now === "function") {
          return root2.performance.now();
        }
        return Date.now() - nowOffset2;
      };
      var reservedCBs2 = {};
      var lastTime2 = Date.now();
      var polyfillRaf3 = function polyfillRaf4(callback) {
        if (typeof callback !== "function") {
          throw new TypeError("".concat(callback, " is not a function"));
        }
        var currentTime = Date.now();
        var gap = currentTime - lastTime2;
        var delay = gap > 16 ? 0 : 16 - gap;
        var id4 = uniqueId5();
        reservedCBs2[id4] = callback;
        if (Object.keys(reservedCBs2).length > 1) return id4;
        setTimeout(function() {
          lastTime2 = currentTime;
          var copied = reservedCBs2;
          reservedCBs2 = {};
          Object.keys(copied).forEach(function(key) {
            return copied[key](pnow3());
          });
        }, delay);
        return id4;
      };
      var polyfillCaf3 = function polyfillCaf4(id4) {
        delete reservedCBs2[id4];
      };
      var vendorPrefixes2 = ["", "webkit", "moz", "ms", "o"];
      var getRequestAnimationFrame3 = function getRequestAnimationFrame4(vp3) {
        if (typeof vp3 !== "string") return polyfillRaf3;
        if (vp3 === "") return root2.requestAnimationFrame;
        return root2["".concat(vp3, "RequestAnimationFrame")];
      };
      var getCancelAnimationFrame3 = function getCancelAnimationFrame4(vp3) {
        if (typeof vp3 !== "string") return polyfillCaf3;
        if (vp3 === "") return root2.cancelAnimationFrame;
        return root2["".concat(vp3, "CancelAnimationFrame")] || root2["".concat(vp3, "CancelRequestAnimationFrame")];
      };
      var find4 = function find5(arr, predicate) {
        var i = 0;
        while (arr[i] !== void 0) {
          if (predicate(arr[i])) return arr[i];
          i += 1;
        }
      };
      var vp2 = find4(vendorPrefixes2, function(vp3) {
        return !!getRequestAnimationFrame3(vp3);
      });
      var raf2 = getRequestAnimationFrame3(vp2);
      var caf2 = getCancelAnimationFrame3(vp2);
      root2.requestAnimationFrame = raf2;
      root2.cancelAnimationFrame = caf2;
      var AsyncParallelHook2 = /* @__PURE__ */ (function() {
        function AsyncParallelHook3() {
          _classCallCheck2(this, AsyncParallelHook3);
          this.callbacks = [];
        }
        return _createClass2(AsyncParallelHook3, [{
          key: "getCallbacksNum",
          value: function getCallbacksNum() {
            return this.callbacks.length;
          }
        }, {
          key: "tapPromise",
          value: function tapPromise(options, fn) {
            this.callbacks.push(fn);
          }
        }, {
          key: "promise",
          value: function promise() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return Promise.all(this.callbacks.map(function(callback) {
              return callback.apply(void 0, args);
            }));
          }
        }]);
      })();
      var AsyncSeriesWaterfallHook2 = /* @__PURE__ */ (function() {
        function AsyncSeriesWaterfallHook3() {
          _classCallCheck2(this, AsyncSeriesWaterfallHook3);
          this.callbacks = [];
        }
        return _createClass2(AsyncSeriesWaterfallHook3, [{
          key: "tapPromise",
          value: function tapPromise(options, fn) {
            this.callbacks.push(fn);
          }
        }, {
          key: "promise",
          value: (function() {
            var _promise = _asyncToGenerator2(/* @__PURE__ */ _regeneratorRuntime2().mark(function _callee() {
              var _this$callbacks, result, i, callback, _args = arguments;
              return _regeneratorRuntime2().wrap(function(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    if (!this.callbacks.length) {
                      _context.next = 6;
                      break;
                    }
                    _context.next = 1;
                    return (_this$callbacks = this.callbacks)[0].apply(_this$callbacks, _args);
                  case 1:
                    result = _context.sent;
                    i = 0;
                  case 2:
                    if (!(i < this.callbacks.length - 1)) {
                      _context.next = 5;
                      break;
                    }
                    callback = this.callbacks[i];
                    _context.next = 3;
                    return callback(result);
                  case 3:
                    result = _context.sent;
                  case 4:
                    i++;
                    _context.next = 2;
                    break;
                  case 5:
                    return _context.abrupt("return", result);
                  case 6:
                    return _context.abrupt("return", null);
                  case 7:
                  case "end":
                    return _context.stop();
                }
              }, _callee, this);
            }));
            function promise() {
              return _promise.apply(this, arguments);
            }
            return promise;
          })()
        }]);
      })();
      var SyncHook2 = /* @__PURE__ */ (function() {
        function SyncHook3() {
          _classCallCheck2(this, SyncHook3);
          this.callbacks = [];
        }
        return _createClass2(SyncHook3, [{
          key: "tap",
          value: function tap(options, fn) {
            this.callbacks.push(fn);
          }
        }, {
          key: "call",
          value: function call() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            var argsArr = arguments;
            this.callbacks.forEach(function(callback) {
              callback.apply(void 0, argsArr);
            });
          }
        }]);
      })();
      var SyncWaterfallHook2 = /* @__PURE__ */ (function() {
        function SyncWaterfallHook3() {
          _classCallCheck2(this, SyncWaterfallHook3);
          this.callbacks = [];
        }
        return _createClass2(SyncWaterfallHook3, [{
          key: "tap",
          value: function tap(options, fn) {
            this.callbacks.push(fn);
          }
        }, {
          key: "call",
          value: function call() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            if (this.callbacks.length) {
              var argsArr = arguments;
              var result = this.callbacks[0].apply(void 0, argsArr);
              for (var i = 0; i < this.callbacks.length - 1; i++) {
                var callback = this.callbacks[i];
                result = callback(result);
              }
              return result;
            }
            return null;
          }
        }]);
      })();
      var genericFontFamilies2 = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"];
      var stringRegExp2 = /([\"\'])[^\'\"]+\1/;
      function getFontAttr2(attributes) {
        var _attributes$fontSize = attributes.fontSize, fontSize = _attributes$fontSize === void 0 ? 16 : _attributes$fontSize, _attributes$fontFamil = attributes.fontFamily, fontFamily = _attributes$fontFamil === void 0 ? "sans-serif" : _attributes$fontFamil, _attributes$fontStyle = attributes.fontStyle, fontStyle = _attributes$fontStyle === void 0 ? "normal" : _attributes$fontStyle, _attributes$fontVaria = attributes.fontVariant, fontVariant = _attributes$fontVaria === void 0 ? "normal" : _attributes$fontVaria, _attributes$fontWeigh = attributes.fontWeight, fontWeight = _attributes$fontWeigh === void 0 ? "normal" : _attributes$fontWeigh;
        return {
          fontSize,
          fontFamily,
          fontStyle,
          fontVariant,
          fontWeight
        };
      }
      var toFontString2 = memoize4(function toFontStringRaw2(attributes) {
        var _getFontAttr = getFontAttr2(attributes), fontSize = _getFontAttr.fontSize, fontFamily = _getFontAttr.fontFamily, fontStyle = _getFontAttr.fontStyle, fontVariant = _getFontAttr.fontVariant, fontWeight = _getFontAttr.fontWeight;
        var fontSizeString = util.isNumber(fontSize) && "".concat(fontSize, "px") || "16px";
        var fontFamilies = fontFamily.split(",");
        for (var i = fontFamilies.length - 1; i >= 0; i--) {
          var _fontFamily = fontFamilies[i].trim();
          if (!stringRegExp2.test(_fontFamily) && genericFontFamilies2.indexOf(_fontFamily) < 0) {
            _fontFamily = '"'.concat(_fontFamily, '"');
          }
          fontFamilies[i] = _fontFamily;
        }
        return "".concat(fontStyle, " ").concat(fontVariant, " ").concat(fontWeight, " ").concat(fontSizeString, " ").concat(fontFamilies.join(","));
      }, function(attributes) {
        var _getFontAttr2 = getFontAttr2(attributes), fontSize = _getFontAttr2.fontSize, fontFamily = _getFontAttr2.fontFamily, fontStyle = _getFontAttr2.fontStyle, fontVariant = _getFontAttr2.fontVariant, fontWeight = _getFontAttr2.fontWeight;
        return "".concat(fontStyle, "_").concat(fontVariant, "_").concat(fontWeight, "_").concat(fontSize, "_").concat(fontFamily);
      });
      var MIN_SCALE2 = 1e-6;
      var clampScale3 = function clampScale4(item) {
        return Math.max(item, MIN_SCALE2);
      };
      function createSkewMatrix2(skewMatrix, skewX2, skewY2) {
        glMatrix.mat4.identity(skewMatrix);
        skewMatrix[4] = Math.tan(skewX2);
        skewMatrix[1] = Math.tan(skewY2);
        return skewMatrix;
      }
      var $mat4_12 = glMatrix.mat4.create();
      var $mat4_22 = glMatrix.mat4.create();
      var parser2 = {
        scale: function scale4(d2) {
          glMatrix.mat4.fromScaling($mat4_12, [d2[0].value, d2[1].value, 1].map(function(item) {
            return clampScale3(item);
          }));
        },
        scaleX: function scaleX2(d2) {
          glMatrix.mat4.fromScaling($mat4_12, [d2[0].value, 1, 1].map(function(item) {
            return clampScale3(item);
          }));
        },
        scaleY: function scaleY2(d2) {
          glMatrix.mat4.fromScaling($mat4_12, [1, d2[0].value, 1].map(function(item) {
            return clampScale3(item);
          }));
        },
        scaleZ: function scaleZ2(d2) {
          glMatrix.mat4.fromScaling($mat4_12, [1, 1, d2[0].value].map(function(item) {
            return clampScale3(item);
          }));
        },
        scale3d: function scale3d2(d2) {
          glMatrix.mat4.fromScaling($mat4_12, [d2[0].value, d2[1].value, d2[2].value].map(function(item) {
            return clampScale3(item);
          }));
        },
        translate: function translate3(d2) {
          glMatrix.mat4.fromTranslation($mat4_12, [d2[0].value, d2[1].value, 0]);
        },
        translateX: function translateX2(d2) {
          glMatrix.mat4.fromTranslation($mat4_12, [d2[0].value, 0, 0]);
        },
        translateY: function translateY2(d2) {
          glMatrix.mat4.fromTranslation($mat4_12, [0, d2[0].value, 0]);
        },
        translateZ: function translateZ2(d2) {
          glMatrix.mat4.fromTranslation($mat4_12, [0, 0, d2[0].value]);
        },
        translate3d: function translate3d2(d2) {
          glMatrix.mat4.fromTranslation($mat4_12, [d2[0].value, d2[1].value, d2[2].value]);
        },
        rotate: function rotate3(d2) {
          glMatrix.mat4.fromZRotation($mat4_12, deg2rad2(convertAngleUnit2(d2[0])));
        },
        rotateX: function rotateX2(d2) {
          glMatrix.mat4.fromXRotation($mat4_12, deg2rad2(convertAngleUnit2(d2[0])));
        },
        rotateY: function rotateY2(d2) {
          glMatrix.mat4.fromYRotation($mat4_12, deg2rad2(convertAngleUnit2(d2[0])));
        },
        rotateZ: function rotateZ2(d2) {
          glMatrix.mat4.fromZRotation($mat4_12, deg2rad2(convertAngleUnit2(d2[0])));
        },
        rotate3d: function rotate3d2(d2) {
          glMatrix.mat4.fromRotation($mat4_12, deg2rad2(convertAngleUnit2(d2[3])), [d2[0].value, d2[1].value, d2[2].value]);
        },
        skew: function skew2(d2) {
          createSkewMatrix2($mat4_12, deg2rad2(d2[0].value), deg2rad2(d2[1].value));
        },
        skewX: function skewX2(d2) {
          createSkewMatrix2($mat4_12, deg2rad2(d2[0].value), 0);
        },
        skewY: function skewY2(d2) {
          createSkewMatrix2($mat4_12, 0, deg2rad2(d2[0].value));
        },
        matrix: function matrix3(d2) {
          glMatrix.mat4.set($mat4_12, d2[0].value, d2[1].value, 0, 0, d2[2].value, d2[3].value, 0, 0, 0, 0, 1, 0, d2[4].value, d2[5].value, 0, 1);
        },
        matrix3d: function matrix3d2(d2) {
          glMatrix.mat4.set.apply(glMatrix.mat4, [$mat4_12].concat(_toConsumableArray2(d2.map(function(s) {
            return s.value;
          }))));
        }
      };
      var $vec3One$12 = glMatrix.vec3.fromValues(1, 1, 1);
      var $vec3Zero$12 = glMatrix.vec3.create();
      var optimizer2 = {
        translate: function translate3(object, d2) {
          runtime2.sceneGraphService.setLocalScale(object, $vec3One$12, false);
          runtime2.sceneGraphService.setLocalEulerAngles(object, $vec3Zero$12, void 0, void 0, false);
          runtime2.sceneGraphService.setLocalPosition(object, [d2[0].value, d2[1].value, 0], false);
          runtime2.sceneGraphService.dirtyLocalTransform(object, object.transformable);
        }
      };
      function parsedTransformToMat42(transform, object) {
        if (transform.length) {
          if (transform.length === 1 && optimizer2[transform[0].t]) {
            optimizer2[transform[0].t](object, transform[0].d);
            return;
          }
          var m2 = glMatrix.mat4.identity($mat4_22);
          for (var i = 0; i < transform.length; i++) {
            var _transform$i = transform[i], t = _transform$i.t, d2 = _transform$i.d;
            var p = parser2[t];
            if (p) {
              p(d2);
              glMatrix.mat4.mul(m2, m2, $mat4_12);
            }
          }
          object.setLocalTransform(m2);
        } else {
          object.resetLocalTransform();
        }
        return object.getLocalTransform();
      }
      var CSSPropertyTransform2 = /* @__PURE__ */ (function() {
        function CSSPropertyTransform3() {
          _classCallCheck2(this, CSSPropertyTransform3);
          this.parser = parseTransformUnmemoize2;
          this.mixer = mergeTransforms2;
        }
        return _createClass2(CSSPropertyTransform3, [{
          key: "calculator",
          value: function calculator(name, oldParsed, parsed, object) {
            if (parsed instanceof CSSKeywordValue2) {
              return [];
            }
            return parsed;
          }
        }, {
          key: "postProcessor",
          value: function postProcessor(object) {
            parsedTransformToMat42(object.parsedStyle.transform, object);
          }
        }]);
      })();
      var CSSPropertyTransformOrigin2 = /* @__PURE__ */ (function() {
        function CSSPropertyTransformOrigin3() {
          _classCallCheck2(this, CSSPropertyTransformOrigin3);
        }
        return _createClass2(CSSPropertyTransformOrigin3, [{
          key: "postProcessor",
          value: function postProcessor(object) {
            var transformOrigin = object.parsedStyle.transformOrigin;
            if (transformOrigin[0].unit === UnitType2.kPixels && transformOrigin[1].unit === UnitType2.kPixels) {
              object.setOrigin(transformOrigin[0].value, transformOrigin[1].value);
            } else {
              object.getGeometryBounds();
            }
          }
        }]);
      })();
      var CSSPropertyZIndex2 = /* @__PURE__ */ (function() {
        function CSSPropertyZIndex3() {
          _classCallCheck2(this, CSSPropertyZIndex3);
        }
        return _createClass2(CSSPropertyZIndex3, [{
          key: "calculator",
          value: function calculator(name, oldParsed, computed, object) {
            return computed.value;
          }
        }, {
          key: "postProcessor",
          value: function postProcessor(object) {
            if (object.parentNode) {
              var parentEntity = object.parentNode;
              var parentRenderable = parentEntity.renderable;
              var parentSortable = parentEntity.sortable;
              if (parentRenderable) {
                parentEntity.dirty();
              }
              if (parentSortable) {
                parentSortable.dirty = true;
                parentSortable.dirtyReason = SortReason2.Z_INDEX_CHANGED;
              }
            }
          }
        }]);
      })();
      var CircleUpdater2 = /* @__PURE__ */ (function() {
        function CircleUpdater3() {
          _classCallCheck2(this, CircleUpdater3);
        }
        return _createClass2(CircleUpdater3, [{
          key: "update",
          value: function update(parsedStyle, object) {
            var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, _parsedStyle$r = parsedStyle.r, r = _parsedStyle$r === void 0 ? 0 : _parsedStyle$r;
            return {
              cx,
              cy,
              hwidth: r,
              hheight: r
            };
          }
        }]);
      })();
      var EllipseUpdater2 = /* @__PURE__ */ (function() {
        function EllipseUpdater3() {
          _classCallCheck2(this, EllipseUpdater3);
        }
        return _createClass2(EllipseUpdater3, [{
          key: "update",
          value: function update(parsedStyle, object) {
            var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, _parsedStyle$rx = parsedStyle.rx, rx = _parsedStyle$rx === void 0 ? 0 : _parsedStyle$rx, _parsedStyle$ry = parsedStyle.ry, ry = _parsedStyle$ry === void 0 ? 0 : _parsedStyle$ry;
            return {
              cx,
              cy,
              hwidth: rx,
              hheight: ry
            };
          }
        }]);
      })();
      var LineUpdater2 = /* @__PURE__ */ (function() {
        function LineUpdater3() {
          _classCallCheck2(this, LineUpdater3);
        }
        return _createClass2(LineUpdater3, [{
          key: "update",
          value: function update(parsedStyle) {
            var x1 = parsedStyle.x1, y1 = parsedStyle.y1, x22 = parsedStyle.x2, y22 = parsedStyle.y2;
            var minX = Math.min(x1, x22);
            var maxX = Math.max(x1, x22);
            var minY = Math.min(y1, y22);
            var maxY = Math.max(y1, y22);
            var width2 = maxX - minX;
            var height = maxY - minY;
            var hwidth = width2 / 2;
            var hheight = height / 2;
            return {
              cx: minX + hwidth,
              cy: minY + hheight,
              hwidth,
              hheight
            };
          }
        }]);
      })();
      var PathUpdater2 = /* @__PURE__ */ (function() {
        function PathUpdater3() {
          _classCallCheck2(this, PathUpdater3);
        }
        return _createClass2(PathUpdater3, [{
          key: "update",
          value: function update(parsedStyle) {
            var d2 = parsedStyle.d;
            var _d$rect = d2.rect, x3 = _d$rect.x, y3 = _d$rect.y, width2 = _d$rect.width, height = _d$rect.height;
            var hwidth = width2 / 2;
            var hheight = height / 2;
            return {
              cx: x3 + hwidth,
              cy: y3 + hheight,
              hwidth,
              hheight
            };
          }
        }]);
      })();
      var PolylineUpdater2 = /* @__PURE__ */ (function() {
        function PolylineUpdater3() {
          _classCallCheck2(this, PolylineUpdater3);
        }
        return _createClass2(PolylineUpdater3, [{
          key: "update",
          value: function update(parsedStyle) {
            if (parsedStyle.points && util.isArray(parsedStyle.points.points)) {
              var points = parsedStyle.points.points;
              var minX = Math.min.apply(Math, _toConsumableArray2(points.map(function(point4) {
                return point4[0];
              })));
              var maxX = Math.max.apply(Math, _toConsumableArray2(points.map(function(point4) {
                return point4[0];
              })));
              var minY = Math.min.apply(Math, _toConsumableArray2(points.map(function(point4) {
                return point4[1];
              })));
              var maxY = Math.max.apply(Math, _toConsumableArray2(points.map(function(point4) {
                return point4[1];
              })));
              var width2 = maxX - minX;
              var height = maxY - minY;
              var hwidth = width2 / 2;
              var hheight = height / 2;
              return {
                cx: minX + hwidth,
                cy: minY + hheight,
                hwidth,
                hheight
              };
            }
            return {
              cx: 0,
              cy: 0,
              hwidth: 0,
              hheight: 0
            };
          }
        }]);
      })();
      var RectUpdater2 = /* @__PURE__ */ (function() {
        function RectUpdater3() {
          _classCallCheck2(this, RectUpdater3);
        }
        return _createClass2(RectUpdater3, [{
          key: "update",
          value: function update(parsedStyle, object) {
            var _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, src = parsedStyle.src, _parsedStyle$width = parsedStyle.width, width2 = _parsedStyle$width === void 0 ? 0 : _parsedStyle$width, _parsedStyle$height = parsedStyle.height, height = _parsedStyle$height === void 0 ? 0 : _parsedStyle$height;
            var contentWidth = width2;
            var contentHeight = height;
            if (src && !util.isString(src)) {
              if (!contentWidth) {
                contentWidth = src.width;
                parsedStyle.width = contentWidth;
              }
              if (!contentHeight) {
                contentHeight = src.height;
                parsedStyle.height = contentHeight;
              }
            }
            return {
              cx: x3 + contentWidth / 2,
              cy: y3 + contentHeight / 2,
              hwidth: contentWidth / 2,
              hheight: contentHeight / 2
            };
          }
        }]);
      })();
      var TextUpdater2 = /* @__PURE__ */ (function() {
        function TextUpdater3(globalRuntime) {
          _classCallCheck2(this, TextUpdater3);
          this.globalRuntime = globalRuntime;
        }
        return _createClass2(TextUpdater3, [{
          key: "isReadyToMeasure",
          value: function isReadyToMeasure(parsedStyle, object) {
            var text = parsedStyle.text;
            return text;
          }
        }, {
          key: "update",
          value: function update(parsedStyle, object) {
            var _object$ownerDocument;
            var text = parsedStyle.text, _parsedStyle$textAlig = parsedStyle.textAlign, textAlign = _parsedStyle$textAlig === void 0 ? "start" : _parsedStyle$textAlig, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$textBase = parsedStyle.textBaseline, textBaseline = _parsedStyle$textBase === void 0 ? "alphabetic" : _parsedStyle$textBase, _parsedStyle$dx = parsedStyle.dx, dx = _parsedStyle$dx === void 0 ? 0 : _parsedStyle$dx, _parsedStyle$dy = parsedStyle.dy, dy = _parsedStyle$dy === void 0 ? 0 : _parsedStyle$dy, _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y;
            if (!this.isReadyToMeasure(parsedStyle, object)) {
              parsedStyle.metrics = {
                font: "",
                width: 0,
                height: 0,
                lines: [],
                lineWidths: [],
                lineHeight: 0,
                maxLineWidth: 0,
                fontProperties: {
                  ascent: 0,
                  descent: 0,
                  fontSize: 0
                },
                lineMetrics: []
              };
              return {
                hwidth: 0,
                hheight: 0,
                cx: 0,
                cy: 0
              };
            }
            var _ref = (object === null || object === void 0 || (_object$ownerDocument = object.ownerDocument) === null || _object$ownerDocument === void 0 || (_object$ownerDocument = _object$ownerDocument.defaultView) === null || _object$ownerDocument === void 0 ? void 0 : _object$ownerDocument.getConfig()) || {}, offscreenCanvas = _ref.offscreenCanvas;
            var metrics = this.globalRuntime.textService.measureText(text, parsedStyle, offscreenCanvas);
            parsedStyle.metrics = metrics;
            var width2 = metrics.width, height = metrics.height;
            var hwidth = width2 / 2;
            var hheight = height / 2;
            var lineXOffset = x3 + hwidth;
            if (textAlign === "center" || textAlign === "middle") {
              lineXOffset += lineWidth / 2 - hwidth;
            } else if (textAlign === "right" || textAlign === "end") {
              lineXOffset += lineWidth - hwidth * 2;
            }
            var lineYOffset = y3 - hheight;
            if (textBaseline === "middle") {
              lineYOffset += hheight;
            } else if (textBaseline === "top" || textBaseline === "hanging") {
              lineYOffset += hheight * 2;
            } else if (textBaseline === "alphabetic") ;
            else if (textBaseline === "bottom" || textBaseline === "ideographic") {
              lineYOffset += 0;
            }
            if (dx) {
              lineXOffset += dx;
            }
            if (dy) {
              lineYOffset += dy;
            }
            return {
              cx: lineXOffset,
              cy: lineYOffset,
              hwidth,
              hheight
            };
          }
        }]);
      })();
      var GroupUpdater2 = /* @__PURE__ */ (function() {
        function GroupUpdater3() {
          _classCallCheck2(this, GroupUpdater3);
        }
        return _createClass2(GroupUpdater3, [{
          key: "update",
          value: function update(parsedStyle, object) {
            return {
              cx: 0,
              cy: 0,
              hwidth: 0,
              hheight: 0
            };
          }
        }]);
      })();
      var HTMLUpdater2 = /* @__PURE__ */ (function() {
        function HTMLUpdater3() {
          _classCallCheck2(this, HTMLUpdater3);
        }
        return _createClass2(HTMLUpdater3, [{
          key: "update",
          value: function update(parsedStyle, object) {
            var _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, _parsedStyle$width = parsedStyle.width, width2 = _parsedStyle$width === void 0 ? 0 : _parsedStyle$width, _parsedStyle$height = parsedStyle.height, height = _parsedStyle$height === void 0 ? 0 : _parsedStyle$height;
            return {
              cx: x3 + width2 / 2,
              cy: y3 + height / 2,
              hwidth: width2 / 2,
              hheight: height / 2
            };
          }
        }]);
      })();
      function isFederatedEvent(value) {
        return !!value.type;
      }
      var FederatedEvent2 = /* @__PURE__ */ (function() {
        function FederatedEvent3(manager) {
          _classCallCheck2(this, FederatedEvent3);
          this.eventPhase = FederatedEvent3.prototype.NONE;
          this.bubbles = true;
          this.cancelBubble = true;
          this.cancelable = false;
          this.defaultPrevented = false;
          this.propagationStopped = false;
          this.propagationImmediatelyStopped = false;
          this.layer = new Point2();
          this.page = new Point2();
          this.canvas = new Point2();
          this.viewport = new Point2();
          this.composed = false;
          this.NONE = 0;
          this.CAPTURING_PHASE = 1;
          this.AT_TARGET = 2;
          this.BUBBLING_PHASE = 3;
          this.manager = manager;
        }
        return _createClass2(FederatedEvent3, [{
          key: "name",
          get: (
            /**
             * The type of event, supports the following:
             * * pointerdown
             * * touchstart
             * * mousedown
             * * rightdown
             * * ...
             */
            /**
             * @deprecated
             */
            function get9() {
              return this.type;
            }
          )
        }, {
          key: "layerX",
          get: function get9() {
            return this.layer.x;
          }
        }, {
          key: "layerY",
          get: function get9() {
            return this.layer.y;
          }
        }, {
          key: "pageX",
          get: function get9() {
            return this.page.x;
          }
        }, {
          key: "pageY",
          get: function get9() {
            return this.page.y;
          }
        }, {
          key: "x",
          get: function get9() {
            return this.canvas.x;
          }
        }, {
          key: "y",
          get: function get9() {
            return this.canvas.y;
          }
        }, {
          key: "canvasX",
          get: function get9() {
            return this.canvas.x;
          }
        }, {
          key: "canvasY",
          get: function get9() {
            return this.canvas.y;
          }
        }, {
          key: "viewportX",
          get: function get9() {
            return this.viewport.x;
          }
        }, {
          key: "viewportY",
          get: function get9() {
            return this.viewport.y;
          }
        }, {
          key: "composedPath",
          value: (
            /**
             * The propagation path for this event
             * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/composedPath
             *
             * So composedPath()[0] represents the original target.
             * @see https://polymer-library.polymer-project.org/3.0/docs/devguide/events#retargeting
             */
            function composedPath() {
              if (this.manager && (!this.path || this.path[0] !== this.target)) {
                this.path = this.target ? this.manager.propagationPath(this.target) : [];
              }
              return this.path;
            }
          )
          /**
           * @deprecated
           */
        }, {
          key: "propagationPath",
          get: function get9() {
            return this.composedPath();
          }
          /**
           * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault
           */
        }, {
          key: "preventDefault",
          value: function preventDefault() {
            if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
              this.nativeEvent.preventDefault();
            }
            this.defaultPrevented = true;
          }
          /**
           * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopImmediatePropagation
           */
        }, {
          key: "stopImmediatePropagation",
          value: function stopImmediatePropagation() {
            this.propagationImmediatelyStopped = true;
          }
          /**
           * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation
           */
        }, {
          key: "stopPropagation",
          value: function stopPropagation() {
            this.propagationStopped = true;
          }
          /**
           * @see https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/view
           */
        }, {
          key: "initEvent",
          value: (
            /**
             * added for compatibility with DOM Event,
             * deprecated props and methods
             */
            function initEvent() {
            }
          )
        }, {
          key: "initUIEvent",
          value: function initUIEvent() {
          }
        }, {
          key: "clone",
          value: function clone8() {
            throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED2);
          }
        }]);
      })();
      var FederatedMouseEvent2 = /* @__PURE__ */ (function(_ref) {
        function FederatedMouseEvent3() {
          var _this2;
          _classCallCheck2(this, FederatedMouseEvent3);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this2 = _callSuper2(this, FederatedMouseEvent3, [].concat(args));
          _this2.client = new Point2();
          _this2.movement = new Point2();
          _this2.offset = new Point2();
          _this2.global = new Point2();
          _this2.screen = new Point2();
          return _this2;
        }
        _inherits2(FederatedMouseEvent3, _ref);
        return _createClass2(FederatedMouseEvent3, [{
          key: "clientX",
          get: function get9() {
            return this.client.x;
          }
        }, {
          key: "clientY",
          get: function get9() {
            return this.client.y;
          }
        }, {
          key: "movementX",
          get: function get9() {
            return this.movement.x;
          }
        }, {
          key: "movementY",
          get: function get9() {
            return this.movement.y;
          }
        }, {
          key: "offsetX",
          get: function get9() {
            return this.offset.x;
          }
        }, {
          key: "offsetY",
          get: function get9() {
            return this.offset.y;
          }
        }, {
          key: "globalX",
          get: function get9() {
            return this.global.x;
          }
        }, {
          key: "globalY",
          get: function get9() {
            return this.global.y;
          }
        }, {
          key: "screenX",
          get: function get9() {
            return this.screen.x;
          }
        }, {
          key: "screenY",
          get: function get9() {
            return this.screen.y;
          }
        }, {
          key: "getModifierState",
          value: function getModifierState(key) {
            return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
          }
        }, {
          key: "initMouseEvent",
          value: function initMouseEvent() {
            throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED2);
          }
        }]);
      })(FederatedEvent2);
      var FederatedPointerEvent2 = /* @__PURE__ */ (function(_FederatedMouseEvent) {
        function FederatedPointerEvent3() {
          var _this2;
          _classCallCheck2(this, FederatedPointerEvent3);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this2 = _callSuper2(this, FederatedPointerEvent3, [].concat(args));
          _this2.width = 0;
          _this2.height = 0;
          _this2.isPrimary = false;
          return _this2;
        }
        _inherits2(FederatedPointerEvent3, _FederatedMouseEvent);
        return _createClass2(FederatedPointerEvent3, [{
          key: "getCoalescedEvents",
          value: (
            /**
             * The type of pointer that triggered the event.
             *
             * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType
             */
            /**
             * Pressure applied by the pointing device during the event.
             *s
             * A Touch's force property will be represented by this value.
             *
             * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure
             */
            /**
             * Barrel pressure on a stylus pointer.
             *
             * @see https://w3c.github.io/pointerevents/#pointerevent-interface
             */
            /**
             * The angle, in degrees, between the pointer device and the screen.
             *
             * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX
             */
            /**
             * The angle, in degrees, between the pointer device and the screen.
             *
             * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY
             */
            /**
             * Twist of a stylus pointer.
             *
             * @see https://w3c.github.io/pointerevents/#pointerevent-interface
             */
            /**
             * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/getCoalescedEvents
             */
            function getCoalescedEvents() {
              if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
                return [this];
              }
              return [];
            }
          )
          /**
           * @see https://chromestatus.com/feature/5765569655603200
           */
        }, {
          key: "getPredictedEvents",
          value: function getPredictedEvents() {
            throw new Error("getPredictedEvents is not supported!");
          }
          /**
           * @see https://github.com/antvis/G/issues/1115
           * We currently reuses event objects in the event system,
           * avoiding the creation of a large number of event objects.
           * Reused objects are only used to carry different data,
           * such as coordinate information, native event objects,
           * and therefore the lifecycle is limited to the event handler,
           * which can lead to unintended consequences if an attempt is made to cache the entire event object.
           *
           * Therefore, while keeping the above performance considerations in mind, it is possible to provide a clone method that creates a new object when the user really wants to cache it, e.g.
           */
        }, {
          key: "clone",
          value: function clone8() {
            return this.manager.clonePointerEvent(this);
          }
        }]);
      })(FederatedMouseEvent2);
      var FederatedWheelEvent2 = /* @__PURE__ */ (function(_FederatedMouseEvent) {
        function FederatedWheelEvent3() {
          _classCallCheck2(this, FederatedWheelEvent3);
          return _callSuper2(this, FederatedWheelEvent3, arguments);
        }
        _inherits2(FederatedWheelEvent3, _FederatedMouseEvent);
        return _createClass2(FederatedWheelEvent3, [{
          key: "clone",
          value: (
            /**
             * The units of `deltaX`, `deltaY`, and `deltaZ`. This is one of `DOM_DELTA_LINE`,
             * `DOM_DELTA_PAGE`, `DOM_DELTA_PIXEL`.
             */
            /** Horizontal scroll amount */
            /** Vertical scroll amount */
            /** z-axis scroll amount. */
            function clone8() {
              return this.manager.cloneWheelEvent(this);
            }
          )
        }]);
      })(FederatedMouseEvent2);
      var CustomEvent2 = /* @__PURE__ */ (function(_FederatedEvent) {
        function CustomEvent3(eventName, object) {
          var _this2;
          _classCallCheck2(this, CustomEvent3);
          _this2 = _callSuper2(this, CustomEvent3, [null]);
          _this2.type = eventName;
          _this2.detail = object;
          Object.assign(_this2, object);
          return _this2;
        }
        _inherits2(CustomEvent3, _FederatedEvent);
        return _createClass2(CustomEvent3);
      })(FederatedEvent2);
      var EventTarget2 = /* @__PURE__ */ (function() {
        function EventTarget3() {
          _classCallCheck2(this, EventTarget3);
          this.emitter = new EventEmitter3();
        }
        return _createClass2(EventTarget3, [{
          key: "on",
          value: (
            /**
             * @deprecated
             * @alias addEventListener
             */
            function on(type, listener, options) {
              this.addEventListener(type, listener, options);
              return this;
            }
          )
          /**
           * support `capture` & `once` in options
           * @see https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener
           */
        }, {
          key: "addEventListener",
          value: function addEventListener(type, listener, options) {
            var capture = false;
            var once = false;
            if (util.isBoolean(options)) capture = options;
            else if (options) {
              var _options$capture = options.capture;
              capture = _options$capture === void 0 ? false : _options$capture;
              var _options$once = options.once;
              once = _options$once === void 0 ? false : _options$once;
            }
            if (capture) type += "capture";
            listener = util.isFunction(listener) ? listener : listener.handleEvent;
            var context = util.isFunction(listener) ? void 0 : listener;
            if (once) this.emitter.once(type, listener, context);
            else this.emitter.on(type, listener, context);
            return this;
          }
          /**
           * @deprecated
           * @alias removeEventListener
           */
        }, {
          key: "off",
          value: function off(type, listener, options) {
            if (type) {
              this.removeEventListener(type, listener, options);
            } else {
              this.removeAllEventListeners();
            }
            return this;
          }
        }, {
          key: "removeAllEventListeners",
          value: function removeAllEventListeners() {
            var _this$emitter;
            (_this$emitter = this.emitter) === null || _this$emitter === void 0 || _this$emitter.removeAllListeners();
          }
        }, {
          key: "removeEventListener",
          value: function removeEventListener(type, listener, options) {
            var _listener;
            if (!this.emitter) return this;
            var capture = util.isBoolean(options) ? options : options === null || options === void 0 ? void 0 : options.capture;
            if (capture) type += "capture";
            listener = util.isFunction(listener) ? listener : (_listener = listener) === null || _listener === void 0 ? void 0 : _listener.handleEvent;
            var context = util.isFunction(listener) ? void 0 : listener;
            this.emitter.off(type, listener, context);
            return this;
          }
          /**
           * @deprecated
           * @alias dispatchEvent
           */
        }, {
          key: "emit",
          value: function emit2(eventName, object) {
            this.dispatchEvent(new CustomEvent2(eventName, object));
          }
        }, {
          key: "dispatchEventToSelf",
          value: function dispatchEventToSelf(e) {
            e.target || (e.target = this);
            e.currentTarget = this;
            this.emitter.emit(e.type, e);
          }
        }, {
          key: "dispatchEvent",
          value: function dispatchEvent(e) {
            var skipPropagate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            var dispatchToSelf = arguments.length > 2 ? arguments[2] : void 0;
            if (dispatchToSelf) {
              this.dispatchEventToSelf(e);
              return true;
            }
            var canvas2;
            if (this.document) {
              canvas2 = this;
            } else if (this.defaultView) {
              canvas2 = this.defaultView;
            } else {
              var _ownerDocument;
              canvas2 = (_ownerDocument = this.ownerDocument) === null || _ownerDocument === void 0 ? void 0 : _ownerDocument.defaultView;
            }
            if (canvas2) {
              e.manager = canvas2.getEventService();
              if (!e.manager) return false;
              e.defaultPrevented = false;
              if (e.path) {
                e.path.length = 0;
              } else {
                e.page = [];
              }
              if (!skipPropagate) {
                e.target = this;
              }
              e.manager.dispatchEvent(e, e.type, skipPropagate);
            } else {
              this.dispatchEventToSelf(e);
            }
            return !e.defaultPrevented;
          }
        }]);
      })();
      var Node3 = /* @__PURE__ */ (function(_EventTarget) {
        function Node4() {
          var _this2;
          _classCallCheck2(this, Node4);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this2 = _callSuper2(this, Node4, [].concat(args));
          _this2.shadow = false;
          _this2.ownerDocument = null;
          _this2.isConnected = false;
          _this2.baseURI = "";
          _this2.childNodes = [];
          _this2.nodeType = 0;
          _this2.nodeName = "";
          _this2.nodeValue = null;
          _this2.parentNode = null;
          _this2.destroyed = false;
          return _this2;
        }
        _inherits2(Node4, _EventTarget);
        return _createClass2(Node4, [{
          key: "textContent",
          get: (
            /**
             * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent
             */
            function get9() {
              var out = "";
              if (this.nodeName === Shape2.TEXT) {
                out += this.style.text;
              }
              var _iterator = _createForOfIteratorHelper2(this.childNodes), _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                  var _child = _step.value;
                  if (_child.nodeName === Shape2.TEXT) {
                    out += _child.nodeValue;
                  } else {
                    out += _child.textContent;
                  }
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              return out;
            }
          ),
          set: function set6(content) {
            var _this2 = this;
            this.childNodes.slice().forEach(function(child) {
              _this2.removeChild(child);
            });
            if (this.nodeName === Shape2.TEXT) {
              this.style.text = "".concat(content);
            }
          }
          /**
           * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/getRootNode
           */
        }, {
          key: "getRootNode",
          value: function getRootNode() {
            var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            if (this.parentNode) {
              return this.parentNode.getRootNode(opts);
            }
            if (opts.composed && this.host) {
              return this.host.getRootNode(opts);
            }
            return this;
          }
        }, {
          key: "hasChildNodes",
          value: function hasChildNodes() {
            return this.childNodes.length > 0;
          }
        }, {
          key: "isDefaultNamespace",
          value: function isDefaultNamespace(namespace) {
            throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED2);
          }
        }, {
          key: "lookupNamespaceURI",
          value: function lookupNamespaceURI(prefix) {
            throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED2);
          }
        }, {
          key: "lookupPrefix",
          value: function lookupPrefix(namespace) {
            throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED2);
          }
        }, {
          key: "normalize",
          value: function normalize6() {
            throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED2);
          }
          /**
           * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/isEqualNode
           */
        }, {
          key: "isEqualNode",
          value: function isEqualNode(otherNode) {
            return this === otherNode;
          }
        }, {
          key: "isSameNode",
          value: function isSameNode2(otherNode) {
            return this.isEqualNode(otherNode);
          }
        }, {
          key: "parent",
          get: (
            /**
             * @deprecated
             * @alias parentNode
             */
            function get9() {
              return this.parentNode;
            }
          )
        }, {
          key: "parentElement",
          get: function get9() {
            return null;
          }
        }, {
          key: "nextSibling",
          get: function get9() {
            return null;
          }
        }, {
          key: "previousSibling",
          get: function get9() {
            return null;
          }
        }, {
          key: "firstChild",
          get: function get9() {
            return this.childNodes.length > 0 ? this.childNodes[0] : null;
          }
        }, {
          key: "lastChild",
          get: function get9() {
            return this.childNodes.length > 0 ? this.childNodes[this.childNodes.length - 1] : null;
          }
          /**
           * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
           * @see https://github.com/b-fuze/deno-dom/blob/master/src/dom/node.ts#L338
           */
        }, {
          key: "compareDocumentPosition",
          value: function compareDocumentPosition(other) {
            if (other === this) {
              return 0;
            }
            var node1Root = other;
            var node2Root = this;
            var node1Hierarchy = [node1Root];
            var node2Hierarchy = [node2Root];
            while ((_node1Root$parentNode = node1Root.parentNode) !== null && _node1Root$parentNode !== void 0 ? _node1Root$parentNode : node2Root.parentNode) {
              var _node1Root$parentNode;
              node1Root = node1Root.parentNode ? (node1Hierarchy.push(node1Root.parentNode), node1Root.parentNode) : node1Root;
              node2Root = node2Root.parentNode ? (node2Hierarchy.push(node2Root.parentNode), node2Root.parentNode) : node2Root;
            }
            if (node1Root !== node2Root) {
              return Node4.DOCUMENT_POSITION_DISCONNECTED | Node4.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node4.DOCUMENT_POSITION_PRECEDING;
            }
            var longerHierarchy = node1Hierarchy.length > node2Hierarchy.length ? node1Hierarchy : node2Hierarchy;
            var shorterHierarchy = longerHierarchy === node1Hierarchy ? node2Hierarchy : node1Hierarchy;
            if (longerHierarchy[longerHierarchy.length - shorterHierarchy.length] === shorterHierarchy[0]) {
              return longerHierarchy === node1Hierarchy ? (
                // other is a child of this
                Node4.DOCUMENT_POSITION_CONTAINED_BY | Node4.DOCUMENT_POSITION_FOLLOWING
              ) : (
                // this is a child of other
                Node4.DOCUMENT_POSITION_CONTAINS | Node4.DOCUMENT_POSITION_PRECEDING
              );
            }
            var longerStart = longerHierarchy.length - shorterHierarchy.length;
            for (var i = shorterHierarchy.length - 1; i >= 0; i--) {
              var shorterHierarchyNode = shorterHierarchy[i];
              var longerHierarchyNode = longerHierarchy[longerStart + i];
              if (longerHierarchyNode !== shorterHierarchyNode) {
                var siblings = shorterHierarchyNode.parentNode.childNodes;
                if (siblings.indexOf(shorterHierarchyNode) < siblings.indexOf(longerHierarchyNode)) {
                  if (shorterHierarchy === node1Hierarchy) {
                    return Node4.DOCUMENT_POSITION_PRECEDING;
                  }
                  return Node4.DOCUMENT_POSITION_FOLLOWING;
                }
                if (longerHierarchy === node1Hierarchy) {
                  return Node4.DOCUMENT_POSITION_PRECEDING;
                }
                return Node4.DOCUMENT_POSITION_FOLLOWING;
              }
            }
            return Node4.DOCUMENT_POSITION_FOLLOWING;
          }
          /**
           * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/cloneNode
           */
        }, {
          key: "contain",
          value: (
            /**
             * @deprecated
             * @alias contains
             */
            function contain2(other) {
              return this.contains(other);
            }
          )
        }, {
          key: "contains",
          value: function contains(other) {
            var tmp3 = other;
            while (tmp3 && this !== tmp3) {
              tmp3 = tmp3.parentNode;
            }
            return !!tmp3;
          }
        }, {
          key: "getAncestor",
          value: function getAncestor(n) {
            var temp = this;
            while (n > 0 && temp) {
              temp = temp.parentNode;
              n--;
            }
            return temp;
          }
        }, {
          key: "forEach",
          value: function forEach(callback) {
            var stack = [this];
            while (stack.length > 0) {
              var node = stack.pop();
              var result = callback(node);
              if (result === false) {
                break;
              }
              for (var i = node.childNodes.length - 1; i >= 0; i--) {
                stack.push(node.childNodes[i]);
              }
            }
          }
        }], [{
          key: "isNode",
          value: function isNode2(target) {
            return !!target.childNodes;
          }
        }]);
      })(EventTarget2);
      Node3.DOCUMENT_POSITION_DISCONNECTED = 1;
      Node3.DOCUMENT_POSITION_PRECEDING = 2;
      Node3.DOCUMENT_POSITION_FOLLOWING = 4;
      Node3.DOCUMENT_POSITION_CONTAINS = 8;
      Node3.DOCUMENT_POSITION_CONTAINED_BY = 16;
      Node3.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
      var PROPAGATION_LIMIT2 = 2048;
      var EventService2 = /* @__PURE__ */ (function() {
        function EventService3(globalRuntime, context) {
          var _this2 = this;
          _classCallCheck2(this, EventService3);
          this.nativeHTMLMap = /* @__PURE__ */ new WeakMap();
          this.cursor = "default";
          this.mappingTable = {};
          this.mappingState = {
            trackingData: {}
          };
          this.eventPool = /* @__PURE__ */ new Map();
          this.tmpMatrix = glMatrix.mat4.create();
          this.tmpVec3 = glMatrix.vec3.create();
          this.onPointerDown = function(from) {
            var e = _this2.createPointerEvent(from);
            _this2.dispatchEvent(e, "pointerdown");
            if (e.pointerType === "touch") {
              _this2.dispatchEvent(e, "touchstart");
            } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
              var isRightButton = e.button === 2;
              _this2.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");
            }
            var trackingData = _this2.trackingData(from.pointerId);
            trackingData.pressTargetsByButton[from.button] = e.composedPath();
            _this2.freeEvent(e);
          };
          this.onPointerUp = function(from) {
            var now2 = clock3.now();
            var e = _this2.createPointerEvent(from, void 0, void 0, _this2.context.config.alwaysTriggerPointerEventOnCanvas ? _this2.rootTarget : void 0);
            _this2.dispatchEvent(e, "pointerup");
            if (e.pointerType === "touch") {
              _this2.dispatchEvent(e, "touchend");
            } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
              var isRightButton = e.button === 2;
              _this2.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");
            }
            var trackingData = _this2.trackingData(from.pointerId);
            var pressTarget = _this2.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
            var clickTarget = pressTarget;
            if (pressTarget && !e.composedPath().includes(pressTarget)) {
              var currentTarget = pressTarget;
              while (currentTarget && !e.composedPath().includes(currentTarget)) {
                e.currentTarget = currentTarget;
                _this2.notifyTarget(e, "pointerupoutside");
                if (e.pointerType === "touch") {
                  _this2.notifyTarget(e, "touchendoutside");
                } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
                  var _isRightButton = e.button === 2;
                  _this2.notifyTarget(e, _isRightButton ? "rightupoutside" : "mouseupoutside");
                }
                if (Node3.isNode(currentTarget)) {
                  currentTarget = currentTarget.parentNode;
                }
              }
              delete trackingData.pressTargetsByButton[from.button];
              clickTarget = currentTarget;
            }
            if (clickTarget) {
              var _e$detail;
              var clickEvent = _this2.clonePointerEvent(e, "click");
              clickEvent.target = clickTarget;
              clickEvent.path = [];
              if (!trackingData.clicksByButton[from.button]) {
                trackingData.clicksByButton[from.button] = {
                  clickCount: 0,
                  target: clickEvent.target,
                  timeStamp: now2
                };
              }
              var canvas2 = _this2.context.renderingContext.root.ownerDocument.defaultView;
              var clickHistory = trackingData.clicksByButton[from.button];
              if (clickHistory.target === clickEvent.target && now2 - clickHistory.timeStamp < canvas2.getConfig().dblClickSpeed) {
                ++clickHistory.clickCount;
              } else {
                clickHistory.clickCount = 1;
              }
              clickHistory.target = clickEvent.target;
              clickHistory.timeStamp = now2;
              clickEvent.detail = clickHistory.clickCount;
              if (!((_e$detail = e.detail) !== null && _e$detail !== void 0 && _e$detail.preventClick)) {
                if (!_this2.context.config.useNativeClickEvent && (clickEvent.pointerType === "mouse" || clickEvent.pointerType === "touch")) {
                  _this2.dispatchEvent(clickEvent, "click");
                }
                _this2.dispatchEvent(clickEvent, "pointertap");
              }
              _this2.freeEvent(clickEvent);
            }
            _this2.freeEvent(e);
          };
          this.onPointerMove = function(from) {
            var e = _this2.createPointerEvent(from, void 0, void 0, _this2.context.config.alwaysTriggerPointerEventOnCanvas ? _this2.rootTarget : void 0);
            var isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
            var trackingData = _this2.trackingData(from.pointerId);
            var outTarget = _this2.findMountedTarget(trackingData.overTargets);
            if (trackingData.overTargets && outTarget !== e.target) {
              var outType = from.type === "mousemove" ? "mouseout" : "pointerout";
              var outEvent = _this2.createPointerEvent(from, outType, outTarget || void 0);
              _this2.dispatchEvent(outEvent, "pointerout");
              if (isMouse) _this2.dispatchEvent(outEvent, "mouseout");
              if (!e.composedPath().includes(outTarget)) {
                var leaveEvent = _this2.createPointerEvent(from, "pointerleave", outTarget || void 0);
                leaveEvent.eventPhase = leaveEvent.AT_TARGET;
                while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {
                  leaveEvent.currentTarget = leaveEvent.target;
                  _this2.notifyTarget(leaveEvent);
                  if (isMouse) {
                    _this2.notifyTarget(leaveEvent, "mouseleave");
                  }
                  if (Node3.isNode(leaveEvent.target)) {
                    leaveEvent.target = leaveEvent.target.parentNode;
                  }
                }
                _this2.freeEvent(leaveEvent);
              }
              _this2.freeEvent(outEvent);
            }
            if (outTarget !== e.target) {
              var overType = from.type === "mousemove" ? "mouseover" : "pointerover";
              var overEvent = _this2.clonePointerEvent(e, overType);
              _this2.dispatchEvent(overEvent, "pointerover");
              if (isMouse) _this2.dispatchEvent(overEvent, "mouseover");
              var overTargetAncestor = outTarget && Node3.isNode(outTarget) && outTarget.parentNode;
              while (overTargetAncestor && overTargetAncestor !== (Node3.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
                if (overTargetAncestor === e.target) break;
                overTargetAncestor = overTargetAncestor.parentNode;
              }
              var didPointerEnter = !overTargetAncestor || overTargetAncestor === (Node3.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode);
              if (didPointerEnter) {
                var enterEvent = _this2.clonePointerEvent(e, "pointerenter");
                enterEvent.eventPhase = enterEvent.AT_TARGET;
                while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== (Node3.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
                  enterEvent.currentTarget = enterEvent.target;
                  _this2.notifyTarget(enterEvent);
                  if (isMouse) _this2.notifyTarget(enterEvent, "mouseenter");
                  if (Node3.isNode(enterEvent.target)) {
                    enterEvent.target = enterEvent.target.parentNode;
                  }
                }
                _this2.freeEvent(enterEvent);
              }
              _this2.freeEvent(overEvent);
            }
            _this2.dispatchEvent(e, "pointermove");
            if (e.pointerType === "touch") _this2.dispatchEvent(e, "touchmove");
            if (isMouse) {
              _this2.dispatchEvent(e, "mousemove");
              _this2.cursor = _this2.getCursor(e.target);
            }
            trackingData.overTargets = e.composedPath();
            _this2.freeEvent(e);
          };
          this.onPointerOut = function(from) {
            var trackingData = _this2.trackingData(from.pointerId);
            if (trackingData.overTargets) {
              var isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
              var outTarget = _this2.findMountedTarget(trackingData.overTargets);
              var outEvent = _this2.createPointerEvent(from, "pointerout", outTarget || void 0);
              _this2.dispatchEvent(outEvent);
              if (isMouse) _this2.dispatchEvent(outEvent, "mouseout");
              var leaveEvent = _this2.createPointerEvent(from, "pointerleave", outTarget || void 0);
              leaveEvent.eventPhase = leaveEvent.AT_TARGET;
              while (leaveEvent.target && leaveEvent.target !== (Node3.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
                leaveEvent.currentTarget = leaveEvent.target;
                _this2.notifyTarget(leaveEvent);
                if (isMouse) {
                  _this2.notifyTarget(leaveEvent, "mouseleave");
                }
                if (Node3.isNode(leaveEvent.target)) {
                  leaveEvent.target = leaveEvent.target.parentNode;
                }
              }
              trackingData.overTargets = null;
              _this2.freeEvent(outEvent);
              _this2.freeEvent(leaveEvent);
            }
            _this2.cursor = null;
          };
          this.onPointerOver = function(from) {
            var trackingData = _this2.trackingData(from.pointerId);
            var e = _this2.createPointerEvent(from);
            var isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
            _this2.dispatchEvent(e, "pointerover");
            if (isMouse) _this2.dispatchEvent(e, "mouseover");
            if (e.pointerType === "mouse") _this2.cursor = _this2.getCursor(e.target);
            var enterEvent = _this2.clonePointerEvent(e, "pointerenter");
            enterEvent.eventPhase = enterEvent.AT_TARGET;
            while (enterEvent.target && enterEvent.target !== (Node3.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
              enterEvent.currentTarget = enterEvent.target;
              _this2.notifyTarget(enterEvent);
              if (isMouse) {
                _this2.notifyTarget(enterEvent, "mouseenter");
              }
              if (Node3.isNode(enterEvent.target)) {
                enterEvent.target = enterEvent.target.parentNode;
              }
            }
            trackingData.overTargets = e.composedPath();
            _this2.freeEvent(e);
            _this2.freeEvent(enterEvent);
          };
          this.onPointerUpOutside = function(from) {
            var trackingData = _this2.trackingData(from.pointerId);
            var pressTarget = _this2.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
            var e = _this2.createPointerEvent(from);
            if (pressTarget) {
              var currentTarget = pressTarget;
              while (currentTarget) {
                e.currentTarget = currentTarget;
                _this2.notifyTarget(e, "pointerupoutside");
                if (e.pointerType === "touch") ;
                else if (e.pointerType === "mouse" || e.pointerType === "pen") {
                  _this2.notifyTarget(e, e.button === 2 ? "rightupoutside" : "mouseupoutside");
                }
                if (Node3.isNode(currentTarget)) {
                  currentTarget = currentTarget.parentNode;
                }
              }
              delete trackingData.pressTargetsByButton[from.button];
            }
            _this2.freeEvent(e);
          };
          this.onWheel = function(from) {
            var wheelEvent = _this2.createWheelEvent(from);
            _this2.dispatchEvent(wheelEvent);
            _this2.freeEvent(wheelEvent);
          };
          this.onClick = function(from) {
            if (_this2.context.config.useNativeClickEvent) {
              var e = _this2.createPointerEvent(from);
              _this2.dispatchEvent(e);
              _this2.freeEvent(e);
            }
          };
          this.onPointerCancel = function(from) {
            var e = _this2.createPointerEvent(from, void 0, void 0, _this2.context.config.alwaysTriggerPointerEventOnCanvas ? _this2.rootTarget : void 0);
            _this2.dispatchEvent(e);
            _this2.freeEvent(e);
          };
          this.globalRuntime = globalRuntime;
          this.context = context;
        }
        return _createClass2(EventService3, [{
          key: "init",
          value: function init() {
            this.rootTarget = this.context.renderingContext.root.parentNode;
            this.addEventMapping("pointerdown", this.onPointerDown);
            this.addEventMapping("pointerup", this.onPointerUp);
            this.addEventMapping("pointermove", this.onPointerMove);
            this.addEventMapping("pointerout", this.onPointerOut);
            this.addEventMapping("pointerleave", this.onPointerOut);
            this.addEventMapping("pointercancel", this.onPointerCancel);
            this.addEventMapping("pointerover", this.onPointerOver);
            this.addEventMapping("pointerupoutside", this.onPointerUpOutside);
            this.addEventMapping("wheel", this.onWheel);
            this.addEventMapping("click", this.onClick);
          }
        }, {
          key: "destroy",
          value: function destroy() {
            this.mappingTable = {};
            this.mappingState = {};
            this.eventPool.clear();
          }
        }, {
          key: "getScale",
          value: function getScale() {
            var bbox = this.context.contextService.getBoundingClientRect();
            var scaleX2 = 1;
            var scaleY2 = 1;
            var $el = this.context.contextService.getDomElement();
            if ($el && bbox) {
              var offsetWidth = $el.offsetWidth, offsetHeight = $el.offsetHeight;
              if (offsetWidth && offsetHeight) {
                scaleX2 = bbox.width / offsetWidth;
                scaleY2 = bbox.height / offsetHeight;
              }
            }
            return {
              scaleX: scaleX2,
              scaleY: scaleY2,
              bbox
            };
          }
          /**
           * Should account for CSS Transform applied on container.
           * @see https://github.com/antvis/G/issues/1161
           * @see https://github.com/antvis/G/issues/1677
           * @see https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/offsetX
           */
        }, {
          key: "client2Viewport",
          value: function client2Viewport(client) {
            var _this$getScale = this.getScale(), scaleX2 = _this$getScale.scaleX, scaleY2 = _this$getScale.scaleY, bbox = _this$getScale.bbox;
            return new Point2((client.x - ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0)) / scaleX2, (client.y - ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0)) / scaleY2);
          }
        }, {
          key: "viewport2Client",
          value: function viewport2Client(canvas2) {
            var _this$getScale2 = this.getScale(), scaleX2 = _this$getScale2.scaleX, scaleY2 = _this$getScale2.scaleY, bbox = _this$getScale2.bbox;
            return new Point2((canvas2.x + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0)) * scaleX2, (canvas2.y + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0)) * scaleY2);
          }
        }, {
          key: "viewport2Canvas",
          value: function viewport2Canvas(_ref) {
            var x3 = _ref.x, y3 = _ref.y;
            var canvas2 = this.rootTarget.defaultView;
            var camera = canvas2.getCamera();
            var _this$context$config = this.context.config, width2 = _this$context$config.width, height = _this$context$config.height;
            var projectionMatrixInverse = camera.getPerspectiveInverse();
            var worldMatrix = camera.getWorldTransform();
            var vpMatrix = glMatrix.mat4.multiply(this.tmpMatrix, worldMatrix, projectionMatrixInverse);
            var viewport = glMatrix.vec3.set(this.tmpVec3, x3 / width2 * 2 - 1, (1 - y3 / height) * 2 - 1, 0);
            glMatrix.vec3.transformMat4(viewport, viewport, vpMatrix);
            return new Point2(viewport[0], viewport[1]);
          }
        }, {
          key: "canvas2Viewport",
          value: function canvas2Viewport(canvasP) {
            var canvas2 = this.rootTarget.defaultView;
            var camera = canvas2.getCamera();
            var projectionMatrix = camera.getPerspective();
            var viewMatrix = camera.getViewTransform();
            var vpMatrix = glMatrix.mat4.multiply(this.tmpMatrix, projectionMatrix, viewMatrix);
            var clip = glMatrix.vec3.set(this.tmpVec3, canvasP.x, canvasP.y, 0);
            glMatrix.vec3.transformMat4(this.tmpVec3, this.tmpVec3, vpMatrix);
            var _this$context$config2 = this.context.config, width2 = _this$context$config2.width, height = _this$context$config2.height;
            return new Point2((clip[0] + 1) / 2 * width2, (1 - (clip[1] + 1) / 2) * height);
          }
        }, {
          key: "setPickHandler",
          value: function setPickHandler(pickHandler) {
            this.pickHandler = pickHandler;
          }
        }, {
          key: "addEventMapping",
          value: function addEventMapping(type, fn) {
            if (!this.mappingTable[type]) {
              this.mappingTable[type] = [];
            }
            this.mappingTable[type].push({
              fn,
              priority: 0
            });
            this.mappingTable[type].sort(function(a2, b) {
              return a2.priority - b.priority;
            });
          }
        }, {
          key: "mapEvent",
          value: function mapEvent(e) {
            if (!this.rootTarget) {
              return;
            }
            var mappers = this.mappingTable[e.type];
            if (mappers) {
              for (var i = 0, j = mappers.length; i < j; i++) {
                mappers[i].fn(e);
              }
            } else {
              console.warn("[EventService]: Event mapping not defined for ".concat(e.type));
            }
          }
        }, {
          key: "dispatchEvent",
          value: function dispatchEvent(e, type, skipPropagate) {
            if (!skipPropagate) {
              e.propagationStopped = false;
              e.propagationImmediatelyStopped = false;
              this.propagate(e, type);
            } else {
              e.eventPhase = e.AT_TARGET;
              var canvas2 = this.rootTarget.defaultView || null;
              e.currentTarget = canvas2;
              this.notifyListeners(e, type);
            }
          }
        }, {
          key: "propagate",
          value: function propagate(e, type) {
            if (!e.target) {
              return;
            }
            var composedPath = e.composedPath();
            e.eventPhase = e.CAPTURING_PHASE;
            for (var i = composedPath.length - 1; i >= 1; i--) {
              e.currentTarget = composedPath[i];
              this.notifyTarget(e, type);
              if (e.propagationStopped || e.propagationImmediatelyStopped) return;
            }
            e.eventPhase = e.AT_TARGET;
            e.currentTarget = e.target;
            this.notifyTarget(e, type);
            if (e.propagationStopped || e.propagationImmediatelyStopped) return;
            var index2 = composedPath.indexOf(e.currentTarget);
            e.eventPhase = e.BUBBLING_PHASE;
            for (var _i = index2 + 1; _i < composedPath.length; _i++) {
              e.currentTarget = composedPath[_i];
              this.notifyTarget(e, type);
              if (e.propagationStopped || e.propagationImmediatelyStopped) return;
            }
          }
        }, {
          key: "propagationPath",
          value: function propagationPath(target) {
            var propagationPath2 = [target];
            var canvas2 = this.rootTarget.defaultView || null;
            if (canvas2 && canvas2 === target) {
              propagationPath2.unshift(canvas2.document);
              return propagationPath2;
            }
            for (var i = 0; i < PROPAGATION_LIMIT2 && target !== this.rootTarget; i++) {
              if (Node3.isNode(target) && target.parentNode) {
                propagationPath2.push(target.parentNode);
                target = target.parentNode;
              }
            }
            if (canvas2) {
              propagationPath2.push(canvas2);
            }
            return propagationPath2;
          }
        }, {
          key: "hitTest",
          value: function hitTest(position2) {
            var viewportX = position2.viewportX, viewportY = position2.viewportY;
            var _this$context$config3 = this.context.config, width2 = _this$context$config3.width, height = _this$context$config3.height, disableHitTesting = _this$context$config3.disableHitTesting;
            if (viewportX < 0 || viewportY < 0 || viewportX > width2 || viewportY > height) {
              return null;
            }
            return !disableHitTesting && this.pickHandler(position2) || this.rootTarget || // return Document
            null;
          }
          /**
           * whether the native event trigger came from Canvas,
           * should account for HTML shape
           */
        }, {
          key: "isNativeEventFromCanvas",
          value: function isNativeEventFromCanvas($el, nativeEvent) {
            var _target;
            var target = nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.target;
            if ((_target = target) !== null && _target !== void 0 && _target.shadowRoot) {
              target = nativeEvent.composedPath()[0];
            }
            if (target) {
              if (target === $el) {
                return true;
              }
              if ($el && $el.contains) {
                return $el.contains(target);
              }
            }
            if (nativeEvent !== null && nativeEvent !== void 0 && nativeEvent.composedPath) {
              return nativeEvent.composedPath().indexOf($el) > -1;
            }
            return false;
          }
          /**
           * Find HTML from composed path in native UI event.
           */
        }, {
          key: "getExistedHTML",
          value: function getExistedHTML(event) {
            if (event.nativeEvent.composedPath) {
              for (var _i2 = 0, _arr = event.nativeEvent.composedPath(); _i2 < _arr.length; _i2++) {
                var eventTarget = _arr[_i2];
                var existed = this.nativeHTMLMap.get(eventTarget);
                if (existed) {
                  return existed;
                }
              }
            }
            return null;
          }
        }, {
          key: "pickTarget",
          value: function pickTarget(event) {
            return this.hitTest({
              clientX: event.clientX,
              clientY: event.clientY,
              viewportX: event.viewportX,
              viewportY: event.viewportY,
              x: event.canvasX,
              y: event.canvasY
            });
          }
        }, {
          key: "createPointerEvent",
          value: function createPointerEvent(from, type, target, fallbackTarget) {
            var event = this.allocateEvent(FederatedPointerEvent2);
            this.copyPointerData(from, event);
            this.copyMouseData(from, event);
            this.copyData(from, event);
            event.nativeEvent = from.nativeEvent;
            event.originalEvent = from;
            var existedHTML = this.getExistedHTML(event);
            var $el = this.context.contextService.getDomElement();
            event.target = target !== null && target !== void 0 ? target : existedHTML || this.isNativeEventFromCanvas($el, event.nativeEvent) && this.pickTarget(event) || fallbackTarget;
            if (typeof type === "string") {
              event.type = type;
            }
            return event;
          }
        }, {
          key: "createWheelEvent",
          value: function createWheelEvent(from) {
            var event = this.allocateEvent(FederatedWheelEvent2);
            this.copyWheelData(from, event);
            this.copyMouseData(from, event);
            this.copyData(from, event);
            event.nativeEvent = from.nativeEvent;
            event.originalEvent = from;
            var existedHTML = this.getExistedHTML(event);
            var $el = this.context.contextService.getDomElement();
            event.target = existedHTML || this.isNativeEventFromCanvas($el, event.nativeEvent) && this.pickTarget(event);
            return event;
          }
        }, {
          key: "trackingData",
          value: function trackingData(id4) {
            if (!this.mappingState.trackingData[id4]) {
              this.mappingState.trackingData[id4] = {
                pressTargetsByButton: {},
                clicksByButton: {},
                overTarget: null
              };
            }
            return this.mappingState.trackingData[id4];
          }
        }, {
          key: "cloneWheelEvent",
          value: function cloneWheelEvent(from) {
            var event = this.allocateEvent(FederatedWheelEvent2);
            event.nativeEvent = from.nativeEvent;
            event.originalEvent = from.originalEvent;
            this.copyWheelData(from, event);
            this.copyMouseData(from, event);
            this.copyData(from, event);
            event.target = from.target;
            event.path = from.composedPath().slice();
            event.type = from.type;
            return event;
          }
        }, {
          key: "clonePointerEvent",
          value: function clonePointerEvent(from, type) {
            var event = this.allocateEvent(FederatedPointerEvent2);
            event.nativeEvent = from.nativeEvent;
            event.originalEvent = from.originalEvent;
            this.copyPointerData(from, event);
            this.copyMouseData(from, event);
            this.copyData(from, event);
            event.target = from.target;
            event.path = from.composedPath().slice();
            event.type = type !== null && type !== void 0 ? type : event.type;
            return event;
          }
        }, {
          key: "copyPointerData",
          value: function copyPointerData(from, to) {
            to.pointerId = from.pointerId;
            to.width = from.width;
            to.height = from.height;
            to.isPrimary = from.isPrimary;
            to.pointerType = from.pointerType;
            to.pressure = from.pressure;
            to.tangentialPressure = from.tangentialPressure;
            to.tiltX = from.tiltX;
            to.tiltY = from.tiltY;
            to.twist = from.twist;
          }
        }, {
          key: "copyMouseData",
          value: function copyMouseData(from, to) {
            to.altKey = from.altKey;
            to.button = from.button;
            to.buttons = from.buttons;
            to.ctrlKey = from.ctrlKey;
            to.metaKey = from.metaKey;
            to.shiftKey = from.shiftKey;
            to.client.copyFrom(from.client);
            to.movement.copyFrom(from.movement);
            to.canvas.copyFrom(from.canvas);
            to.screen.copyFrom(from.screen);
            to.global.copyFrom(from.global);
            to.offset.copyFrom(from.offset);
          }
        }, {
          key: "copyWheelData",
          value: function copyWheelData(from, to) {
            to.deltaMode = from.deltaMode;
            to.deltaX = from.deltaX;
            to.deltaY = from.deltaY;
            to.deltaZ = from.deltaZ;
          }
        }, {
          key: "copyData",
          value: function copyData(from, to) {
            to.isTrusted = from.isTrusted;
            to.timeStamp = clock3.now();
            to.type = from.type;
            to.detail = from.detail;
            to.view = from.view;
            to.page.copyFrom(from.page);
            to.viewport.copyFrom(from.viewport);
          }
        }, {
          key: "allocateEvent",
          value: function allocateEvent(constructor) {
            if (!this.eventPool.has(constructor)) {
              this.eventPool.set(constructor, []);
            }
            var event = this.eventPool.get(constructor).pop() || new constructor(this);
            event.eventPhase = event.NONE;
            event.currentTarget = null;
            event.path = [];
            event.target = null;
            return event;
          }
        }, {
          key: "freeEvent",
          value: function freeEvent(event) {
            if (event.manager !== this) throw new Error("It is illegal to free an event not managed by this EventBoundary!");
            var constructor = event.constructor;
            if (!this.eventPool.has(constructor)) {
              this.eventPool.set(constructor, []);
            }
            this.eventPool.get(constructor).push(event);
          }
        }, {
          key: "notifyTarget",
          value: function notifyTarget(e, type) {
            type = type !== null && type !== void 0 ? type : e.type;
            var key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? "".concat(type, "capture") : type;
            this.notifyListeners(e, key);
            if (e.eventPhase === e.AT_TARGET) {
              this.notifyListeners(e, type);
            }
          }
        }, {
          key: "notifyListeners",
          value: function notifyListeners(e, type) {
            var emitter = e.currentTarget.emitter;
            var listeners = emitter._events[type];
            if (!listeners) return;
            if ("fn" in listeners) {
              if (listeners.once) {
                emitter.removeListener(type, listeners.fn, void 0, true);
              }
              listeners.fn.call(e.currentTarget || listeners.context, e);
            } else {
              for (var i = 0; i < listeners.length && !e.propagationImmediatelyStopped; i++) {
                if (listeners[i].once) {
                  emitter.removeListener(type, listeners[i].fn, void 0, true);
                }
                listeners[i].fn.call(e.currentTarget || listeners[i].context, e);
              }
            }
          }
          /**
           * some detached nodes may exist in propagation path, need to skip them
           */
        }, {
          key: "findMountedTarget",
          value: function findMountedTarget(propagationPath) {
            if (!propagationPath) {
              return null;
            }
            var currentTarget = propagationPath[propagationPath.length - 1];
            for (var i = propagationPath.length - 2; i >= 0; i--) {
              var target = propagationPath[i];
              if (target === this.rootTarget || Node3.isNode(target) && target.parentNode === currentTarget) {
                currentTarget = propagationPath[i];
              } else {
                break;
              }
            }
            return currentTarget;
          }
        }, {
          key: "getCursor",
          value: function getCursor(target) {
            var tmp3 = target;
            while (tmp3) {
              var cursor = isElement4(tmp3) && tmp3.getAttribute("cursor");
              if (cursor) {
                return cursor;
              }
              tmp3 = Node3.isNode(tmp3) && tmp3.parentNode;
            }
          }
        }]);
      })();
      var OffscreenCanvasCreator2 = /* @__PURE__ */ (function() {
        function OffscreenCanvasCreator3() {
          _classCallCheck2(this, OffscreenCanvasCreator3);
        }
        return _createClass2(OffscreenCanvasCreator3, [{
          key: "getOrCreateCanvas",
          value: function getOrCreateCanvas(offscreenCanvas, contextAttributes) {
            if (this.canvas) {
              return this.canvas;
            }
            if (offscreenCanvas || runtime2.offscreenCanvas) {
              this.canvas = offscreenCanvas || runtime2.offscreenCanvas;
              this.context = this.canvas.getContext("2d", _objectSpread({
                willReadFrequently: true
              }, contextAttributes));
            } else {
              try {
                this.canvas = new window.OffscreenCanvas(0, 0);
                this.context = this.canvas.getContext("2d", _objectSpread({
                  willReadFrequently: true
                }, contextAttributes));
                if (!this.context || !this.context.measureText) {
                  this.canvas = document.createElement("canvas");
                  this.context = this.canvas.getContext("2d");
                }
              } catch (_unused) {
                this.canvas = document.createElement("canvas");
                this.context = this.canvas.getContext("2d", _objectSpread({
                  willReadFrequently: true
                }, contextAttributes));
              }
            }
            this.canvas.width = 10;
            this.canvas.height = 10;
            return this.canvas;
          }
        }, {
          key: "getOrCreateContext",
          value: function getOrCreateContext(offscreenCanvas, contextAttributes) {
            if (this.context) {
              return this.context;
            }
            this.getOrCreateCanvas(offscreenCanvas, contextAttributes);
            return this.context;
          }
        }], [{
          key: "createCanvas",
          value: (
            /**
             * @returns new canvas instance
             */
            function createCanvas2() {
              try {
                return new window.OffscreenCanvas(0, 0);
              } catch (_unused2) {
              }
              try {
                return document.createElement("canvas");
              } catch (_unused3) {
              }
              return null;
            }
          )
        }]);
      })();
      var RenderReason2 = /* @__PURE__ */ (function(RenderReason3) {
        RenderReason3[RenderReason3["CAMERA_CHANGED"] = 0] = "CAMERA_CHANGED";
        RenderReason3[RenderReason3["DISPLAY_OBJECT_CHANGED"] = 1] = "DISPLAY_OBJECT_CHANGED";
        RenderReason3[RenderReason3["NONE"] = 2] = "NONE";
        return RenderReason3;
      })({});
      var RenderingService2 = /* @__PURE__ */ (function() {
        function RenderingService3(globalRuntime, context) {
          _classCallCheck2(this, RenderingService3);
          this.inited = false;
          this.stats = {
            /**
             * total display objects in scenegraph
             */
            total: 0,
            /**
             * number of display objects need to render in current frame
             */
            rendered: 0
          };
          this.zIndexCounter = 0;
          this.hooks = {
            /**
             * called before any frame rendered
             */
            init: new SyncHook2(),
            initAsync: new AsyncParallelHook2(),
            /**
             * only dirty object which has sth changed will be rendered
             */
            dirtycheck: new SyncWaterfallHook2(),
            /**
             * do culling
             */
            cull: new SyncWaterfallHook2(),
            /**
             * called at beginning of each frame, won't get called if nothing to re-render
             */
            beginFrame: new SyncHook2(),
            /**
             * called before every dirty object get rendered
             */
            beforeRender: new SyncHook2(),
            /**
             * called when every dirty object rendering even it's culled
             */
            render: new SyncHook2(),
            /**
             * called after every dirty object get rendered
             */
            afterRender: new SyncHook2(),
            /**
             * commit - draw the result on the canvas
             */
            endFrame: new SyncHook2(),
            destroy: new SyncHook2(),
            /**
             * use async but faster method such as GPU-based picking in `g-plugin-device-renderer`
             */
            pick: new AsyncSeriesWaterfallHook2(),
            /**
             * Unsafe but sync version of pick.
             */
            pickSync: new SyncWaterfallHook2(),
            /**
             * used in event system
             */
            pointerDown: new SyncHook2(),
            pointerUp: new SyncHook2(),
            pointerMove: new SyncHook2(),
            pointerOut: new SyncHook2(),
            pointerOver: new SyncHook2(),
            pointerWheel: new SyncHook2(),
            pointerCancel: new SyncHook2(),
            click: new SyncHook2()
          };
          this.globalRuntime = globalRuntime;
          this.context = context;
        }
        return _createClass2(RenderingService3, [{
          key: "init",
          value: function init(callback) {
            var _this2 = this;
            var context = _objectSpread(_objectSpread({}, this.globalRuntime), this.context);
            this.context.renderingPlugins.forEach(function(plugin) {
              plugin.apply(context, _this2.globalRuntime);
            });
            this.hooks.init.call();
            if (this.hooks.initAsync.getCallbacksNum() === 0) {
              this.inited = true;
              callback();
            } else {
              this.hooks.initAsync.promise().then(function() {
                _this2.inited = true;
                callback();
              })["catch"](function(err) {
              });
            }
          }
        }, {
          key: "getStats",
          value: function getStats() {
            return this.stats;
          }
          /**
           * Meet the following conditions:
           * * disable DirtyRectangleRendering
           * * camera changed
           */
        }, {
          key: "disableDirtyRectangleRendering",
          value: function disableDirtyRectangleRendering() {
            var renderer = this.context.config.renderer;
            var _renderer$getConfig = renderer.getConfig(), enableDirtyRectangleRendering = _renderer$getConfig.enableDirtyRectangleRendering;
            return !enableDirtyRectangleRendering || this.context.renderingContext.renderReasons.has(RenderReason2.CAMERA_CHANGED);
          }
        }, {
          key: "render",
          value: function render(canvasConfig, frame2, rerenderCallback) {
            var _this2 = this;
            this.stats.total = 0;
            this.stats.rendered = 0;
            this.zIndexCounter = 0;
            var renderingContext = this.context.renderingContext;
            this.globalRuntime.sceneGraphService.syncHierarchy(renderingContext.root);
            this.globalRuntime.sceneGraphService.triggerPendingEvents();
            if (renderingContext.renderReasons.size && this.inited) {
              renderingContext.dirtyRectangleRenderingDisabled = this.disableDirtyRectangleRendering();
              var onlyCameraChanged = renderingContext.renderReasons.size === 1 && renderingContext.renderReasons.has(RenderReason2.CAMERA_CHANGED);
              var shouldTriggerRenderHooks = !canvasConfig.disableRenderHooks || !onlyCameraChanged;
              if (shouldTriggerRenderHooks) {
                this.renderDisplayObject(renderingContext.root, canvasConfig, renderingContext);
              }
              this.hooks.beginFrame.call(frame2);
              if (shouldTriggerRenderHooks) {
                renderingContext.renderListCurrentFrame.forEach(function(object) {
                  _this2.hooks.beforeRender.call(object);
                  _this2.hooks.render.call(object);
                  _this2.hooks.afterRender.call(object);
                });
              }
              this.hooks.endFrame.call(frame2);
              renderingContext.renderListCurrentFrame = [];
              renderingContext.renderReasons.clear();
              rerenderCallback();
            }
          }
        }, {
          key: "renderDisplayObject",
          value: function renderDisplayObject(displayObject, canvasConfig, renderingContext) {
            var self2 = this;
            var _canvasConfig$rendere = canvasConfig.renderer.getConfig(), enableDirtyCheck = _canvasConfig$rendere.enableDirtyCheck, enableCulling = _canvasConfig$rendere.enableCulling;
            function internalRenderSingleDisplayObject(object) {
              var renderable = object.renderable, sortable = object.sortable;
              var objectChanged = enableDirtyCheck ? (
                // @ts-ignore
                renderable.dirty || renderingContext.dirtyRectangleRenderingDisabled ? object : null
              ) : object;
              var objectToRender = null;
              if (objectChanged) {
                objectToRender = enableCulling ? self2.hooks.cull.call(objectChanged, self2.context.camera) : objectChanged;
                if (objectToRender) {
                  self2.stats.rendered += 1;
                  renderingContext.renderListCurrentFrame.push(objectToRender);
                }
              }
              object.dirty(false);
              sortable.renderOrder = self2.zIndexCounter;
              self2.zIndexCounter += 1;
              self2.stats.total += 1;
              if (sortable.dirty) {
                self2.sort(object, sortable);
                sortable.dirty = false;
                sortable.dirtyChildren = [];
                sortable.dirtyReason = void 0;
              }
            }
            var stack = [displayObject];
            while (stack.length > 0) {
              var _currentObject$sortab;
              var currentObject = stack.pop();
              internalRenderSingleDisplayObject(currentObject);
              var objects = ((_currentObject$sortab = currentObject.sortable) === null || _currentObject$sortab === void 0 || (_currentObject$sortab = _currentObject$sortab.sorted) === null || _currentObject$sortab === void 0 ? void 0 : _currentObject$sortab.length) > 0 ? currentObject.sortable.sorted : currentObject.childNodes;
              for (var i = objects.length - 1; i >= 0; i--) {
                stack.push(objects[i]);
              }
            }
          }
        }, {
          key: "sort",
          value: function sort2(displayObject, sortable) {
            var _sortable$sorted, _sortable$sorted2;
            if ((sortable === null || sortable === void 0 || (_sortable$sorted = sortable.sorted) === null || _sortable$sorted === void 0 ? void 0 : _sortable$sorted.length) > 0 && sortable.dirtyReason !== SortReason2.Z_INDEX_CHANGED) {
              sortable.dirtyChildren.forEach(function(child) {
                var sortIndex = sortable.sorted.indexOf(child);
                if (sortIndex > -1) {
                  sortable.sorted.splice(sortIndex, 1);
                }
                var index2 = displayObject.childNodes.indexOf(child);
                if (index2 > -1) {
                  if (sortable.sorted.length === 0) {
                    sortable.sorted.push(child);
                  } else {
                    var _index = sortedIndex2(sortable.sorted, child);
                    sortable.sorted.splice(_index, 0, child);
                  }
                }
              });
            } else {
              sortable.sorted = displayObject.childNodes.slice().sort(sortByZIndex2);
            }
            if (((_sortable$sorted2 = sortable.sorted) === null || _sortable$sorted2 === void 0 ? void 0 : _sortable$sorted2.length) > 0 && displayObject.childNodes.filter(function(child) {
              return child.parsedStyle.zIndex;
            }).length === 0) {
              sortable.sorted = [];
            }
          }
        }, {
          key: "destroy",
          value: function destroy() {
            this.inited = false;
            this.hooks.destroy.call();
            this.globalRuntime.sceneGraphService.clearPendingEvents();
          }
        }, {
          key: "dirtify",
          value: function dirtify() {
            this.context.renderingContext.renderReasons.add(RenderReason2.DISPLAY_OBJECT_CHANGED);
          }
        }]);
      })();
      var ATTRIBUTE_REGEXP2 = /\[\s*(.*)=(.*)\s*\]/;
      var DefaultSceneGraphSelector2 = /* @__PURE__ */ (function() {
        function DefaultSceneGraphSelector3() {
          _classCallCheck2(this, DefaultSceneGraphSelector3);
        }
        return _createClass2(DefaultSceneGraphSelector3, [{
          key: "selectOne",
          value: function selectOne(query, root3) {
            var _this2 = this;
            if (query.startsWith(".")) {
              return root3.find(function(node) {
                return ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this2.getIdOrClassname(query)) > -1;
              });
            }
            if (query.startsWith("#")) {
              return root3.find(function(node) {
                return node.id === _this2.getIdOrClassname(query);
              });
            }
            if (query.startsWith("[")) {
              var _this$getAttribute = this.getAttribute(query), name = _this$getAttribute.name, value = _this$getAttribute.value;
              if (name) {
                return root3.find(function(node) {
                  return root3 !== node && (name === "name" ? node.name === value : _this2.attributeToString(node, name) === value);
                });
              }
              return null;
            }
            return root3.find(function(node) {
              return root3 !== node && node.nodeName === query;
            });
          }
        }, {
          key: "selectAll",
          value: function selectAll(query, root3) {
            var _this2 = this;
            if (query.startsWith(".")) {
              return root3.findAll(function(node) {
                return root3 !== node && ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this2.getIdOrClassname(query)) > -1;
              });
            }
            if (query.startsWith("#")) {
              return root3.findAll(function(node) {
                return root3 !== node && node.id === _this2.getIdOrClassname(query);
              });
            }
            if (query.startsWith("[")) {
              var _this$getAttribute2 = this.getAttribute(query), name = _this$getAttribute2.name, value = _this$getAttribute2.value;
              if (name) {
                return root3.findAll(function(node) {
                  return root3 !== node && (name === "name" ? node.name === value : _this2.attributeToString(node, name) === value);
                });
              }
              return [];
            }
            return root3.findAll(function(node) {
              return root3 !== node && node.nodeName === query;
            });
          }
        }, {
          key: "is",
          value: function is(query, node) {
            if (query.startsWith(".")) {
              return node.className === this.getIdOrClassname(query);
            }
            if (query.startsWith("#")) {
              return node.id === this.getIdOrClassname(query);
            }
            if (query.startsWith("[")) {
              var _this$getAttribute3 = this.getAttribute(query), name = _this$getAttribute3.name, value = _this$getAttribute3.value;
              return name === "name" ? node.name === value : this.attributeToString(node, name) === value;
            }
            return node.nodeName === query;
          }
        }, {
          key: "getIdOrClassname",
          value: function getIdOrClassname(query) {
            return query.substring(1);
          }
        }, {
          key: "getAttribute",
          value: function getAttribute(query) {
            var matches = query.match(ATTRIBUTE_REGEXP2);
            var name = "";
            var value = "";
            if (matches && matches.length > 2) {
              name = matches[1].replace(/"/g, "");
              value = matches[2].replace(/"/g, "");
            }
            return {
              name,
              value
            };
          }
        }, {
          key: "attributeToString",
          value: function attributeToString(node, name) {
            if (!node.getAttribute) {
              return "";
            }
            var value = node.getAttribute(name);
            if (util.isNil(value)) {
              return "";
            }
            if (value.toString) {
              return value.toString();
            }
            return "";
          }
        }]);
      })();
      var ElementEvent2 = /* @__PURE__ */ (function(ElementEvent3) {
        ElementEvent3["ATTR_MODIFIED"] = "DOMAttrModified";
        ElementEvent3["INSERTED"] = "DOMNodeInserted";
        ElementEvent3["MOUNTED"] = "DOMNodeInsertedIntoDocument";
        ElementEvent3["REMOVED"] = "removed";
        ElementEvent3["UNMOUNTED"] = "DOMNodeRemovedFromDocument";
        ElementEvent3["REPARENT"] = "reparent";
        ElementEvent3["DESTROY"] = "destroy";
        ElementEvent3["BOUNDS_CHANGED"] = "bounds-changed";
        ElementEvent3["CULLED"] = "culled";
        return ElementEvent3;
      })({});
      var MutationEvent2 = /* @__PURE__ */ (function(_FederatedEvent) {
        function MutationEvent3(typeArg, relatedNode, prevValue, newValue, attrName, attrChange, prevParsedValue, newParsedValue) {
          var _this2;
          _classCallCheck2(this, MutationEvent3);
          _this2 = _callSuper2(this, MutationEvent3, [null]);
          _this2.relatedNode = relatedNode;
          _this2.prevValue = prevValue;
          _this2.newValue = newValue;
          _this2.attrName = attrName;
          _this2.attrChange = attrChange;
          _this2.prevParsedValue = prevParsedValue;
          _this2.newParsedValue = newParsedValue;
          _this2.type = typeArg;
          return _this2;
        }
        _inherits2(MutationEvent3, _FederatedEvent);
        return _createClass2(MutationEvent3);
      })(FederatedEvent2);
      MutationEvent2.ADDITION = 2;
      MutationEvent2.MODIFICATION = 1;
      MutationEvent2.REMOVAL = 3;
      var reparentEvent2 = new MutationEvent2(ElementEvent2.REPARENT, null, "", "", "", 0, "", "");
      var $vec2Zero2 = glMatrix.vec2.create();
      var $vec3Zero2 = glMatrix.vec3.create();
      var $vec3One2 = glMatrix.vec3.fromValues(1, 1, 1);
      var $mat4Identity2 = glMatrix.mat4.create();
      var $vec22 = glMatrix.vec2.create();
      var $vec3$12 = glMatrix.vec3.create();
      var $mat42 = glMatrix.mat4.create();
      var $quat$12 = glMatrix.quat.create();
      var $setLocalTransform_12 = glMatrix.vec3.create();
      var $setLocalTransform_22 = glMatrix.quat.create();
      var $setLocalTransform_32 = glMatrix.vec3.create();
      var $setLocalPosition2 = glMatrix.vec3.create();
      var $setPosition_12 = glMatrix.vec3.create();
      var $setPosition_ParentInvertMatrix2 = glMatrix.mat4.create();
      var $setEulerAngles_InvParentRot2 = glMatrix.quat.create();
      var $rotateLocal2 = glMatrix.quat.create();
      var $rotate_ParentInvertRotation2 = glMatrix.quat.create();
      var $triggerPendingEvents_detail2 = {
        affectChildren: true
      };
      var DefaultSceneGraphService2 = /* @__PURE__ */ (function() {
        function DefaultSceneGraphService3(runtime3) {
          _classCallCheck2(this, DefaultSceneGraphService3);
          this.pendingEvents = /* @__PURE__ */ new Map();
          this.boundsChangedEvent = new CustomEvent2(ElementEvent2.BOUNDS_CHANGED);
          this.displayObjectDependencyMap = /* @__PURE__ */ new WeakMap();
          this.runtime = runtime3;
        }
        return _createClass2(DefaultSceneGraphService3, [{
          key: "matches",
          value: function matches(query, root3) {
            return this.runtime.sceneGraphSelector.is(query, root3);
          }
        }, {
          key: "querySelector",
          value: function querySelector(query, root3) {
            return this.runtime.sceneGraphSelector.selectOne(query, root3);
          }
        }, {
          key: "querySelectorAll",
          value: function querySelectorAll(query, root3) {
            return this.runtime.sceneGraphSelector.selectAll(query, root3);
          }
        }, {
          key: "attach",
          value: function attach(child, parent, index2) {
            var _sortable$sorted;
            var detached = false;
            if (child.parentNode) {
              detached = child.parentNode !== parent;
              this.detach(child);
            }
            var isChildFragment = child.nodeName === Shape2.FRAGMENT;
            var isAttachToFragment = isInFragment2(parent);
            child.parentNode = parent;
            var nodes = isChildFragment ? child.childNodes : [child];
            if (util.isNumber(index2)) {
              nodes.forEach(function(node) {
                parent.childNodes.splice(index2, 0, node);
                node.parentNode = parent;
              });
            } else {
              nodes.forEach(function(node) {
                parent.childNodes.push(node);
                node.parentNode = parent;
              });
            }
            var _ref = parent, sortable = _ref.sortable;
            if (sortable !== null && sortable !== void 0 && (_sortable$sorted = sortable.sorted) !== null && _sortable$sorted !== void 0 && _sortable$sorted.length || sortable.dirty || child.parsedStyle.zIndex) {
              if (sortable.dirtyChildren.indexOf(child) === -1) {
                sortable.dirtyChildren.push(child);
              }
              sortable.dirty = true;
              sortable.dirtyReason = SortReason2.ADDED;
            }
            if (isAttachToFragment) return;
            if (isChildFragment) {
              this.dirtifyFragment(child);
            } else {
              var transform = child.transformable;
              if (transform) {
                this.dirtyWorldTransform(child, transform);
              }
            }
            if (detached) {
              var _parent$ownerDocument;
              var enableCancelEventPropagation = ((_parent$ownerDocument = parent.ownerDocument) === null || _parent$ownerDocument === void 0 || (_parent$ownerDocument = _parent$ownerDocument.defaultView) === null || _parent$ownerDocument === void 0 || (_parent$ownerDocument = _parent$ownerDocument.getConfig()) === null || _parent$ownerDocument === void 0 || (_parent$ownerDocument = _parent$ownerDocument.future) === null || _parent$ownerDocument === void 0 ? void 0 : _parent$ownerDocument.experimentalCancelEventPropagation) === true;
              child.dispatchEvent(reparentEvent2, enableCancelEventPropagation, enableCancelEventPropagation);
            }
          }
        }, {
          key: "detach",
          value: function detach(child) {
            var _sortable$sorted2, _style;
            if (!child.parentNode) {
              return;
            }
            var transform = child.transformable;
            var _ref2 = child.parentNode, sortable = _ref2.sortable;
            if (sortable !== null && sortable !== void 0 && (_sortable$sorted2 = sortable.sorted) !== null && _sortable$sorted2 !== void 0 && _sortable$sorted2.length || (_style = child.style) !== null && _style !== void 0 && _style.zIndex) {
              if (sortable.dirtyChildren.indexOf(child) === -1) {
                sortable.dirtyChildren.push(child);
              }
              sortable.dirty = true;
              sortable.dirtyReason = SortReason2.REMOVED;
            }
            var index2 = child.parentNode.childNodes.indexOf(child);
            if (index2 > -1) {
              child.parentNode.childNodes.splice(index2, 1);
            }
            if (transform) {
              this.dirtyWorldTransform(child, transform);
            }
            child.parentNode = null;
          }
          // #region local-transform ----------------------------------------------------------------
        }, {
          key: "getLocalPosition",
          value: function getLocalPosition(element) {
            return element.transformable.localPosition;
          }
        }, {
          key: "getLocalRotation",
          value: function getLocalRotation(element) {
            return element.transformable.localRotation;
          }
        }, {
          key: "getLocalScale",
          value: function getLocalScale(element) {
            return element.transformable.localScale;
          }
        }, {
          key: "getLocalSkew",
          value: function getLocalSkew(element) {
            return element.transformable.localSkew;
          }
        }, {
          key: "getLocalTransform",
          value: function getLocalTransform(element) {
            var transform = element.transformable;
            updateLocalTransform2(transform);
            return transform.localTransform;
          }
          /**
           * move to position in local space
           */
        }, {
          key: "setLocalPosition",
          value: function setLocalPosition(element, position2) {
            var _position$;
            var dirtify = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
            var transform = element.transformable;
            $setLocalPosition2[0] = position2[0];
            $setLocalPosition2[1] = position2[1];
            $setLocalPosition2[2] = (_position$ = position2[2]) !== null && _position$ !== void 0 ? _position$ : 0;
            if (glMatrix.vec3.equals(transform.localPosition, $setLocalPosition2)) {
              return;
            }
            glMatrix.vec3.copy(transform.localPosition, $setLocalPosition2);
            if (dirtify) {
              this.dirtyLocalTransform(element, transform);
            }
          }
          /**
           * translate in local space
           *
           * @example
           * ```
           * translateLocal(x, y, z)
           * translateLocal(vec3(x, y, z))
           * ```
           */
        }, {
          key: "translateLocal",
          value: function translateLocal(element, translation) {
            var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
            if (typeof translation === "number") {
              translation = glMatrix.vec3.fromValues(translation, y3, z);
            }
            var transform = element.transformable;
            if (glMatrix.vec3.equals(translation, $vec3Zero2)) return;
            glMatrix.vec3.transformQuat(translation, translation, transform.localRotation);
            glMatrix.vec3.add(transform.localPosition, transform.localPosition, translation);
            this.dirtyLocalTransform(element, transform);
          }
        }, {
          key: "setLocalRotation",
          value: function setLocalRotation(element, rotation, y3, z, w) {
            var dirtify = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
            if (typeof rotation === "number") {
              rotation = glMatrix.quat.set($quat$12, rotation, y3, z, w);
            }
            var transform = element.transformable;
            glMatrix.quat.copy(transform.localRotation, rotation);
            if (dirtify) {
              this.dirtyLocalTransform(element, transform);
            }
          }
          /**
           * rotate in local space
           * @see @see https://docs.microsoft.com/en-us/windows/win32/api/directxmath/nf-directxmath-xmquaternionrotationrollpitchyaw
           */
        }, {
          key: "rotateLocal",
          value: function rotateLocal(element, degrees) {
            var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
            if (typeof degrees === "number") {
              degrees = glMatrix.vec3.fromValues(degrees, y3, z);
            }
            var transform = element.transformable;
            glMatrix.quat.fromEuler($rotateLocal2, degrees[0], degrees[1], degrees[2]);
            glMatrix.quat.mul(transform.localRotation, transform.localRotation, $rotateLocal2);
            this.dirtyLocalTransform(element, transform);
          }
        }, {
          key: "setLocalScale",
          value: function setLocalScale(element, scaling) {
            var _scaling$;
            var dirtify = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
            var transform = element.transformable;
            glMatrix.vec3.set($vec3$12, scaling[0], scaling[1], (_scaling$ = scaling[2]) !== null && _scaling$ !== void 0 ? _scaling$ : transform.localScale[2]);
            if (glMatrix.vec3.equals($vec3$12, transform.localScale)) {
              return;
            }
            glMatrix.vec3.copy(transform.localScale, $vec3$12);
            if (dirtify) {
              this.dirtyLocalTransform(element, transform);
            }
          }
          /**
           * scale in local space
           */
        }, {
          key: "scaleLocal",
          value: function scaleLocal(element, scaling) {
            var _scaling$2;
            var transform = element.transformable;
            glMatrix.vec3.multiply(transform.localScale, transform.localScale, glMatrix.vec3.set($vec3$12, scaling[0], scaling[1], (_scaling$2 = scaling[2]) !== null && _scaling$2 !== void 0 ? _scaling$2 : 1));
            this.dirtyLocalTransform(element, transform);
          }
        }, {
          key: "setLocalSkew",
          value: function setLocalSkew(element, skew2, y3) {
            var dirtify = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
            if (typeof skew2 === "number") {
              skew2 = glMatrix.vec2.set($vec22, skew2, y3);
            }
            var transform = element.transformable;
            glMatrix.vec2.copy(transform.localSkew, skew2);
            if (dirtify) {
              this.dirtyLocalTransform(element, transform);
            }
          }
          /**
           * set euler angles(degrees) in local space
           */
        }, {
          key: "setLocalEulerAngles",
          value: function setLocalEulerAngles(element, degrees) {
            var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
            var dirtify = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
            if (typeof degrees === "number") {
              degrees = glMatrix.vec3.fromValues(degrees, y3, z);
            }
            var transform = element.transformable;
            glMatrix.quat.fromEuler(transform.localRotation, degrees[0], degrees[1], degrees[2]);
            if (dirtify) {
              this.dirtyLocalTransform(element, transform);
            }
          }
        }, {
          key: "setLocalTransform",
          value: function setLocalTransform(element, transform) {
            var t = glMatrix.mat4.getTranslation($setLocalTransform_12, transform);
            var r = glMatrix.mat4.getRotation($setLocalTransform_22, transform);
            var s = glMatrix.mat4.getScaling($setLocalTransform_32, transform);
            this.setLocalScale(element, s, false);
            this.setLocalPosition(element, t, false);
            this.setLocalRotation(element, r, void 0, void 0, void 0, false);
            this.dirtyLocalTransform(element, element.transformable);
          }
        }, {
          key: "resetLocalTransform",
          value: function resetLocalTransform(element) {
            this.setLocalScale(element, $vec3One2, false);
            this.setLocalPosition(element, $vec3Zero2, false);
            this.setLocalEulerAngles(element, $vec3Zero2, void 0, void 0, false);
            this.setLocalSkew(element, $vec2Zero2, void 0, false);
            this.dirtyLocalTransform(element, element.transformable);
          }
          // #endregion local-transform
          // #region transform ----------------------------------------------------------------
        }, {
          key: "getPosition",
          value: function getPosition(element) {
            var transform = element.transformable;
            return glMatrix.mat4.getTranslation(transform.position, this.getWorldTransform(element, transform));
          }
        }, {
          key: "getRotation",
          value: function getRotation(element) {
            var transform = element.transformable;
            return glMatrix.mat4.getRotation(transform.rotation, this.getWorldTransform(element, transform));
          }
        }, {
          key: "getScale",
          value: function getScale(element) {
            var transform = element.transformable;
            return glMatrix.mat4.getScaling(transform.scaling, this.getWorldTransform(element, transform));
          }
        }, {
          key: "getOrigin",
          value: function getOrigin(element) {
            element.getGeometryBounds();
            return element.transformable.origin;
          }
        }, {
          key: "getWorldTransform",
          value: function getWorldTransform(element) {
            var transform = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : element.transformable;
            if (!transform.localDirtyFlag && !transform.dirtyFlag) {
              return transform.worldTransform;
            }
            if (element.parentNode && element.parentNode.transformable) {
              this.getWorldTransform(element.parentNode);
            }
            this.internalUpdateTransform(element);
            return transform.worldTransform;
          }
          /**
           * move to position in world space
           *
           * 对应 g 原版的 move/moveTo
           * @see https://github.com/antvis/g/blob/master/packages/g-base/src/abstract/element.ts#L684-L689
           */
        }, {
          key: "setPosition",
          value: function setPosition(element, position2) {
            var _position$2;
            var transform = element.transformable;
            $setPosition_12[0] = position2[0];
            $setPosition_12[1] = position2[1];
            $setPosition_12[2] = (_position$2 = position2[2]) !== null && _position$2 !== void 0 ? _position$2 : 0;
            if (glMatrix.vec3.equals(this.getPosition(element), $setPosition_12)) {
              return;
            }
            glMatrix.vec3.copy(transform.position, $setPosition_12);
            if (element.parentNode === null || !element.parentNode.transformable) {
              glMatrix.vec3.copy(transform.localPosition, $setPosition_12);
            } else {
              var parentTransform = element.parentNode.transformable;
              glMatrix.mat4.copy($setPosition_ParentInvertMatrix2, parentTransform.worldTransform);
              glMatrix.mat4.invert($setPosition_ParentInvertMatrix2, $setPosition_ParentInvertMatrix2);
              glMatrix.vec3.transformMat4(transform.localPosition, $setPosition_12, $setPosition_ParentInvertMatrix2);
            }
            this.dirtyLocalTransform(element, transform);
          }
          /**
           * translate in world space
           *
           * @example
           * ```
           * translate(x, y, z)
           * translate(vec3(x, y, z))
           * ```
           *
           * 对应 g 原版的 translate 2D
           * @see https://github.com/antvis/g/blob/master/packages/g-base/src/abstract/element.ts#L665-L676
           */
        }, {
          key: "translate",
          value: function translate3(element, translation) {
            var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
            if (typeof translation === "number") {
              translation = glMatrix.vec3.set($vec3$12, translation, y3, z);
            }
            if (glMatrix.vec3.equals(translation, $vec3Zero2)) return;
            glMatrix.vec3.add($vec3$12, this.getPosition(element), translation);
            this.setPosition(element, $vec3$12);
          }
        }, {
          key: "setRotation",
          value: function setRotation(element, rotation, y3, z, w) {
            var transform = element.transformable;
            if (typeof rotation === "number") {
              rotation = glMatrix.quat.fromValues(rotation, y3, z, w);
            }
            if (element.parentNode === null || !element.parentNode.transformable) {
              this.setLocalRotation(element, rotation);
            } else {
              var parentRot = this.getRotation(element.parentNode);
              glMatrix.quat.copy($quat$12, parentRot);
              glMatrix.quat.invert($quat$12, $quat$12);
              glMatrix.quat.multiply(transform.localRotation, $quat$12, rotation);
              glMatrix.quat.normalize(transform.localRotation, transform.localRotation);
              this.dirtyLocalTransform(element, transform);
            }
          }
          /**
           * rotate in world space
           */
        }, {
          key: "rotate",
          value: function rotate3(element, degrees) {
            var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
            if (typeof degrees === "number") {
              degrees = glMatrix.vec3.fromValues(degrees, y3, z);
            }
            var transform = element.transformable;
            if (element.parentNode === null || !element.parentNode.transformable) {
              this.rotateLocal(element, degrees);
            } else {
              var rotation = $quat$12;
              glMatrix.quat.fromEuler(rotation, degrees[0], degrees[1], degrees[2]);
              var rot = this.getRotation(element);
              var parentRot = this.getRotation(element.parentNode);
              glMatrix.quat.copy($rotate_ParentInvertRotation2, parentRot);
              glMatrix.quat.invert($rotate_ParentInvertRotation2, $rotate_ParentInvertRotation2);
              glMatrix.quat.multiply(rotation, $rotate_ParentInvertRotation2, rotation);
              glMatrix.quat.multiply(transform.localRotation, rotation, rot);
              glMatrix.quat.normalize(transform.localRotation, transform.localRotation);
              this.dirtyLocalTransform(element, transform);
            }
          }
          /**
           * same as pivot in Pixi.js
           *
           * @see https://stackoverflow.com/questions/40748452/how-to-change-css-transform-origin-but-preserve-transformation
           */
        }, {
          key: "setOrigin",
          value: function setOrigin(element, origin) {
            var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
            if (typeof origin === "number") {
              origin = [origin, y3, z];
            }
            var transform = element.transformable;
            if (origin[0] === transform.origin[0] && origin[1] === transform.origin[1] && origin[2] === transform.origin[2]) {
              return;
            }
            var originVec = transform.origin;
            originVec[0] = origin[0];
            originVec[1] = origin[1];
            originVec[2] = origin[2] || 0;
            this.dirtyLocalTransform(element, transform);
          }
          /**
           * set euler angles(degrees) in world space
           */
        }, {
          key: "setEulerAngles",
          value: function setEulerAngles(element, degrees) {
            var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
            if (typeof degrees === "number") {
              degrees = glMatrix.vec3.fromValues(degrees, y3, z);
            }
            var transform = element.transformable;
            if (element.parentNode === null || !element.parentNode.transformable) {
              this.setLocalEulerAngles(element, degrees);
            } else {
              glMatrix.quat.fromEuler(transform.localRotation, degrees[0], degrees[1], degrees[2]);
              var parentRotation = this.getRotation(element.parentNode);
              glMatrix.quat.copy($setEulerAngles_InvParentRot2, glMatrix.quat.invert($quat$12, parentRotation));
              glMatrix.quat.mul(transform.localRotation, transform.localRotation, $setEulerAngles_InvParentRot2);
              this.dirtyLocalTransform(element, transform);
            }
          }
          // #endregion transform
          // #region bbox ----------------------------------------------------------------
        }, {
          key: "getTransformedGeometryBounds",
          value: function getTransformedGeometryBounds(element) {
            var render = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            var existedAABB = arguments.length > 2 ? arguments[2] : void 0;
            var bounds = this.getGeometryBounds(element, render);
            if (!AABB2.isEmpty(bounds)) {
              var aabb = existedAABB || new AABB2();
              aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
              return aabb;
            }
            return null;
          }
          /**
           * won't account for children
           */
        }, {
          key: "getGeometryBounds",
          value: function getGeometryBounds(element) {
            var render = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            var _ref3 = element, geometry = _ref3.geometry;
            if (geometry.dirty) {
              runtime2.styleValueRegistry.updateGeometry(element);
            }
            var bounds = render ? geometry.renderBounds : geometry.contentBounds || null;
            return bounds || new AABB2();
          }
          /**
           * account for children in world space
           */
        }, {
          key: "getBounds",
          value: function getBounds2(element) {
            var _this2 = this;
            var render = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            var _ref4 = element, renderable = _ref4.renderable;
            if (!renderable.boundsDirty && !render && renderable.bounds) {
              return renderable.bounds;
            }
            if (!renderable.renderBoundsDirty && render && renderable.renderBounds) {
              return renderable.renderBounds;
            }
            var existedAABB = render ? renderable.renderBounds : renderable.bounds;
            var aabb = this.getTransformedGeometryBounds(element, render, existedAABB);
            var children = element.childNodes;
            children.forEach(function(child) {
              var childBounds = _this2.getBounds(child, render);
              if (childBounds) {
                if (!aabb) {
                  aabb = existedAABB || new AABB2();
                  aabb.update(childBounds.center, childBounds.halfExtents);
                } else {
                  aabb.add(childBounds);
                }
              }
            });
            if (!aabb) {
              aabb = new AABB2();
            }
            if (render) {
              var clipped = findClosestClipPathTarget2(element);
              if (clipped) {
                var clipPathBounds = clipped.parsedStyle.clipPath.getBounds(render);
                if (!aabb) {
                  aabb.update(clipPathBounds.center, clipPathBounds.halfExtents);
                } else if (clipPathBounds) {
                  aabb = clipPathBounds.intersection(aabb);
                }
              }
            }
            if (render) {
              renderable.renderBounds = aabb;
              renderable.renderBoundsDirty = false;
            } else {
              renderable.bounds = aabb;
              renderable.boundsDirty = false;
            }
            return aabb;
          }
          /**
           * account for children in local space
           */
        }, {
          key: "getLocalBounds",
          value: function getLocalBounds(element) {
            if (element.parentNode) {
              var parentInvert = $mat4Identity2;
              if (element.parentNode.transformable) {
                parentInvert = glMatrix.mat4.invert($mat42, this.getWorldTransform(element.parentNode));
              }
              var bounds = this.getBounds(element);
              if (!AABB2.isEmpty(bounds)) {
                var localBounds = new AABB2();
                localBounds.setFromTransformedAABB(bounds, parentInvert);
                return localBounds;
              }
            }
            return this.getBounds(element);
          }
        }, {
          key: "getBoundingClientRect",
          value: function getBoundingClientRect(element) {
            var _element$ownerDocumen;
            var aabb;
            var bounds = this.getGeometryBounds(element);
            if (!AABB2.isEmpty(bounds)) {
              aabb = new AABB2();
              aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
            }
            var bbox = (_element$ownerDocumen = element.ownerDocument) === null || _element$ownerDocumen === void 0 || (_element$ownerDocumen = _element$ownerDocumen.defaultView) === null || _element$ownerDocumen === void 0 ? void 0 : _element$ownerDocumen.getContextService().getBoundingClientRect();
            if (aabb) {
              var _aabb$getMin = aabb.getMin(), _aabb$getMin2 = _slicedToArray2(_aabb$getMin, 2), left = _aabb$getMin2[0], top = _aabb$getMin2[1];
              var _aabb$getMax = aabb.getMax(), _aabb$getMax2 = _slicedToArray2(_aabb$getMax, 2), right = _aabb$getMax2[0], bottom = _aabb$getMax2[1];
              return new Rectangle3(left + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), top + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0), right - left, bottom - top);
            }
            return new Rectangle3((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0, (bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0, 0, 0);
          }
          // #endregion bbox
          // #region other ----------------------------------------------------------------
        }, {
          key: "internalUpdateTransform",
          value: function internalUpdateTransform(element) {
            var _element$parentNode;
            var parentTransform = (_element$parentNode = element.parentNode) === null || _element$parentNode === void 0 ? void 0 : _element$parentNode.transformable;
            updateLocalTransform2(element.transformable);
            updateWorldTransform2(element.transformable, parentTransform);
          }
        }, {
          key: "internalUpdateElement",
          value: function internalUpdateElement(element, ancestors) {
            var _element$ownerDocumen2, _element$transformabl, _element$renderable, _element$renderable2;
            var enableAttributeUpdateOptimization = ((_element$ownerDocumen2 = element.ownerDocument) === null || _element$ownerDocumen2 === void 0 || (_element$ownerDocumen2 = _element$ownerDocumen2.defaultView) === null || _element$ownerDocumen2 === void 0 || (_element$ownerDocumen2 = _element$ownerDocumen2.getConfig()) === null || _element$ownerDocumen2 === void 0 || (_element$ownerDocumen2 = _element$ownerDocumen2.future) === null || _element$ownerDocumen2 === void 0 ? void 0 : _element$ownerDocumen2.experimentalAttributeUpdateOptimization) === true;
            var parent = ancestors[ancestors.length - 1];
            var transformDirty = (parent === null || parent === void 0 ? void 0 : parent.transformDirty) || ((_element$transformabl = element.transformable) === null || _element$transformabl === void 0 ? void 0 : _element$transformabl.localDirtyFlag);
            if (element.transformable) {
              var _element$transformabl2;
              (_element$transformabl2 = element.transformable).dirtyFlag || (_element$transformabl2.dirtyFlag = transformDirty);
            }
            this.internalUpdateTransform(element);
            if (transformDirty) {
              var _element$dirty;
              (_element$dirty = element.dirty) === null || _element$dirty === void 0 || _element$dirty.call(element, true, true);
            }
            var shapeUpdated = ((_element$renderable = element.renderable) === null || _element$renderable === void 0 ? void 0 : _element$renderable.boundsDirty) || ((_element$renderable2 = element.renderable) === null || _element$renderable2 === void 0 ? void 0 : _element$renderable2.renderBoundsDirty);
            if ((transformDirty || shapeUpdated) && (parent === null || parent === void 0 ? void 0 : parent.shapeUpdated) === false && enableAttributeUpdateOptimization) {
              var tempElIndex = ancestors.length - 1;
              while (tempElIndex >= 0) {
                var _dirty, _ref5;
                var tempEl = ancestors[tempElIndex];
                if (tempEl.shapeUpdated) {
                  break;
                }
                (_dirty = (_ref5 = tempEl.node).dirty) === null || _dirty === void 0 || _dirty.call(_ref5, true, true);
                tempEl.shapeUpdated = true;
                tempElIndex -= 1;
              }
            }
            return transformDirty;
          }
        }, {
          key: "syncHierarchy",
          value: function syncHierarchy(rootNode) {
            var _transformable, _transformable2;
            var stack = [rootNode];
            var ancestors = rootNode.parentNode ? [{
              node: rootNode.parentNode,
              transformDirty: ((_transformable = rootNode.parentNode.transformable) === null || _transformable === void 0 ? void 0 : _transformable.localDirtyFlag) || ((_transformable2 = rootNode.parentNode.transformable) === null || _transformable2 === void 0 ? void 0 : _transformable2.dirtyFlag),
              shapeUpdated: false
            }] : [];
            while (stack.length > 0) {
              var node = stack.pop();
              var parent = ancestors[ancestors.length - 1];
              while (ancestors.length > 0 && node.parentNode !== parent.node) {
                parent = ancestors.pop();
              }
              var transformDirty = this.internalUpdateElement(node, ancestors);
              if (node.childNodes.length > 0) {
                for (var i = node.childNodes.length - 1; i >= 0; i--) {
                  stack.push(node.childNodes[i]);
                }
                ancestors.push({
                  node,
                  transformDirty,
                  shapeUpdated: false
                });
              }
            }
          }
        }, {
          key: "dirtyLocalTransform",
          value: function dirtyLocalTransform(element, transform) {
            if (isInFragment2(element)) return;
            if (!transform.localDirtyFlag) {
              transform.localDirtyFlag = true;
              if (!transform.dirtyFlag) {
                this.dirtyWorldTransform(element, transform);
              }
            }
          }
        }, {
          key: "dirtyWorldTransform",
          value: function dirtyWorldTransform(element, transform) {
            this.dirtifyWorldInternal(element, transform);
            this.dirtyToRoot(element, true);
          }
        }, {
          key: "dirtifyWorldInternal",
          value: function dirtifyWorldInternal(element, transform) {
            var _element$ownerDocumen3, _this2 = this;
            var enableAttributeUpdateOptimization = ((_element$ownerDocumen3 = element.ownerDocument) === null || _element$ownerDocumen3 === void 0 || (_element$ownerDocumen3 = _element$ownerDocumen3.defaultView) === null || _element$ownerDocumen3 === void 0 || (_element$ownerDocumen3 = _element$ownerDocumen3.getConfig()) === null || _element$ownerDocumen3 === void 0 || (_element$ownerDocumen3 = _element$ownerDocumen3.future) === null || _element$ownerDocumen3 === void 0 ? void 0 : _element$ownerDocumen3.experimentalAttributeUpdateOptimization) === true;
            if (!transform.dirtyFlag) {
              transform.dirtyFlag = true;
              element.dirty(true, true);
              if (!enableAttributeUpdateOptimization) {
                element.childNodes.forEach(function(child) {
                  var childTransform = child.transformable;
                  _this2.dirtifyWorldInternal(child, childTransform);
                });
              }
            }
          }
        }, {
          key: "dirtyToRoot",
          value: function dirtyToRoot(element) {
            var _element$ownerDocumen4;
            var affectChildren = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            var p = element;
            var enableAttributeUpdateOptimization = ((_element$ownerDocumen4 = element.ownerDocument) === null || _element$ownerDocumen4 === void 0 || (_element$ownerDocumen4 = _element$ownerDocumen4.defaultView) === null || _element$ownerDocumen4 === void 0 || (_element$ownerDocumen4 = _element$ownerDocumen4.getConfig()) === null || _element$ownerDocumen4 === void 0 || (_element$ownerDocumen4 = _element$ownerDocumen4.future) === null || _element$ownerDocumen4 === void 0 ? void 0 : _element$ownerDocumen4.experimentalAttributeUpdateOptimization) === true;
            while (p) {
              var _dirty2, _ref6;
              (_dirty2 = (_ref6 = p).dirty) === null || _dirty2 === void 0 || _dirty2.call(_ref6, true, true);
              if (enableAttributeUpdateOptimization) {
                break;
              } else {
                p = p.parentNode;
              }
            }
            if (affectChildren) {
              element.forEach(function(e) {
                var _e$dirty;
                (_e$dirty = e.dirty) === null || _e$dirty === void 0 || _e$dirty.call(e, true, true);
              });
            }
            this.informDependentDisplayObjects(element);
            this.pendingEvents.set(element, affectChildren);
          }
        }, {
          key: "dirtifyFragment",
          value: function dirtifyFragment(element) {
            var _dirty3, _ref7;
            var transform = element.transformable;
            if (transform) {
              transform.dirtyFlag = true;
              transform.localDirtyFlag = true;
            }
            (_dirty3 = (_ref7 = element).dirty) === null || _dirty3 === void 0 || _dirty3.call(_ref7, true, true);
            var length = element.childNodes.length;
            for (var i = 0; i < length; i++) {
              this.dirtifyFragment(element.childNodes[i]);
            }
            if (element.nodeName === Shape2.FRAGMENT) {
              this.pendingEvents.set(element, false);
            }
          }
        }, {
          key: "triggerPendingEvents",
          value: function triggerPendingEvents() {
            var _this3 = this;
            var triggered = /* @__PURE__ */ new Set();
            var enableCancelEventPropagation;
            var enableAttributeUpdateOptimization;
            var trigger = function trigger2(element, detail) {
              if (!element.isConnected || triggered.has(element) || element.nodeName === Shape2.FRAGMENT) {
                return;
              }
              _this3.boundsChangedEvent.detail = detail;
              _this3.boundsChangedEvent.target = element;
              if (element.isMutationObserved) {
                element.dispatchEvent(_this3.boundsChangedEvent);
              } else {
                if (enableCancelEventPropagation === void 0) {
                  var _element$ownerDocumen5;
                  enableCancelEventPropagation = ((_element$ownerDocumen5 = element.ownerDocument.defaultView) === null || _element$ownerDocumen5 === void 0 || (_element$ownerDocumen5 = _element$ownerDocumen5.getConfig()) === null || _element$ownerDocumen5 === void 0 || (_element$ownerDocumen5 = _element$ownerDocumen5.future) === null || _element$ownerDocumen5 === void 0 ? void 0 : _element$ownerDocumen5.experimentalCancelEventPropagation) === true;
                }
                element.ownerDocument.defaultView.dispatchEvent(_this3.boundsChangedEvent, true, enableCancelEventPropagation);
              }
              triggered.add(element);
            };
            this.pendingEvents.forEach(function(affectChildren, element) {
              if (element.nodeName === Shape2.FRAGMENT) {
                return;
              }
              if (enableAttributeUpdateOptimization === void 0) {
                var _element$ownerDocumen6;
                enableAttributeUpdateOptimization = ((_element$ownerDocumen6 = element.ownerDocument) === null || _element$ownerDocumen6 === void 0 || (_element$ownerDocumen6 = _element$ownerDocumen6.defaultView) === null || _element$ownerDocumen6 === void 0 || (_element$ownerDocumen6 = _element$ownerDocumen6.getConfig()) === null || _element$ownerDocumen6 === void 0 || (_element$ownerDocumen6 = _element$ownerDocumen6.future) === null || _element$ownerDocumen6 === void 0 ? void 0 : _element$ownerDocumen6.experimentalAttributeUpdateOptimization) === true;
              }
              $triggerPendingEvents_detail2.affectChildren = affectChildren;
              if (enableAttributeUpdateOptimization) {
                trigger(element, $triggerPendingEvents_detail2);
              } else {
                if (affectChildren) {
                  element.forEach(function(e) {
                    trigger(e, $triggerPendingEvents_detail2);
                  });
                } else {
                  trigger(element, $triggerPendingEvents_detail2);
                }
              }
            });
            triggered.clear();
            this.clearPendingEvents();
          }
        }, {
          key: "clearPendingEvents",
          value: function clearPendingEvents() {
            this.pendingEvents.clear();
          }
        }, {
          key: "updateDisplayObjectDependency",
          value: function updateDisplayObjectDependency(name, oldPath, newPath, object) {
            if (oldPath && oldPath !== newPath) {
              var oldDependencyMap = this.displayObjectDependencyMap.get(oldPath);
              if (oldDependencyMap && oldDependencyMap[name]) {
                var index2 = oldDependencyMap[name].indexOf(object);
                oldDependencyMap[name].splice(index2, 1);
              }
            }
            if (newPath) {
              var newDependencyMap = this.displayObjectDependencyMap.get(newPath);
              if (!newDependencyMap) {
                this.displayObjectDependencyMap.set(newPath, {});
                newDependencyMap = this.displayObjectDependencyMap.get(newPath);
              }
              if (!newDependencyMap[name]) {
                newDependencyMap[name] = [];
              }
              newDependencyMap[name].push(object);
            }
          }
        }, {
          key: "informDependentDisplayObjects",
          value: function informDependentDisplayObjects(object) {
            var _object$ownerDocument, _this4 = this;
            var dependencyMap = this.displayObjectDependencyMap.get(object);
            if (!dependencyMap) {
              return;
            }
            var enableCancelEventPropagation = (_object$ownerDocument = object.ownerDocument) === null || _object$ownerDocument === void 0 || (_object$ownerDocument = _object$ownerDocument.defaultView) === null || _object$ownerDocument === void 0 || (_object$ownerDocument = _object$ownerDocument.getConfig()) === null || _object$ownerDocument === void 0 || (_object$ownerDocument = _object$ownerDocument.future) === null || _object$ownerDocument === void 0 ? void 0 : _object$ownerDocument.experimentalCancelEventPropagation;
            Object.keys(dependencyMap).forEach(function(name) {
              dependencyMap[name].forEach(function(target) {
                _this4.dirtyToRoot(target, true);
                target.dispatchEvent(new MutationEvent2(ElementEvent2.ATTR_MODIFIED, target, _this4, _this4, name, MutationEvent2.MODIFICATION, _this4, _this4), enableCancelEventPropagation, enableCancelEventPropagation);
                if (target.isCustomElement && target.isConnected) {
                  if (target.attributeChangedCallback) {
                    target.attributeChangedCallback(name, _this4, _this4);
                  }
                }
              });
            });
          }
        }]);
      })();
      var LRU2 = /* @__PURE__ */ (function() {
        function LRU3(capacity) {
          _classCallCheck2(this, LRU3);
          if (capacity <= 0) {
            throw new Error("LRU capacity must be a positive number.");
          }
          this.capacity = capacity;
          this.cache = /* @__PURE__ */ new Map();
        }
        return _createClass2(LRU3, [{
          key: "get",
          value: function get9(key) {
            if (!this.cache.has(key)) {
              return void 0;
            }
            var value = this.cache.get(key);
            this.cache["delete"](key);
            this.cache.set(key, value);
            return value;
          }
          /**
           * Adds or updates an item in the cache. Marks the item as recently used.
           * If the cache is full, it removes the least recently used item.
           * @param key The key of the item.
           * @param value The value of the item.
           */
        }, {
          key: "put",
          value: function put(key, value) {
            if (this.cache.has(key)) {
              this.cache["delete"](key);
            }
            this.cache.set(key, value);
            if (this.cache.size > this.capacity) {
              var leastRecentlyUsedKey = this.cache.keys().next().value;
              this.cache["delete"](leastRecentlyUsedKey);
            }
          }
          /**
           * Returns the current number of items in the cache.
           */
        }, {
          key: "len",
          value: function len() {
            return this.cache.size;
          }
          /**
           * Clears all items from the cache.
           */
        }, {
          key: "clear",
          value: function clear() {
            this.cache.clear();
          }
        }]);
      })();
      var TEXT_METRICS2 = {
        MetricsString: "|\xC9q\xC5",
        BaselineSymbol: "M",
        BaselineMultiplier: 1.4,
        HeightMultiplier: 2,
        Newlines: [
          10,
          // line feed
          13
          // carriage return
        ],
        BreakingSpaces: [
          9,
          // character tabulation
          32,
          // space
          8192,
          // en quad
          8193,
          // em quad
          8194,
          // en space
          8195,
          // em space
          8196,
          // three-per-em space
          8197,
          // four-per-em space
          8198,
          // six-per-em space
          8200,
          // punctuation space
          8201,
          // thin space
          8202,
          // hair space
          8287,
          // medium mathematical space
          12288
          // ideographic space
        ]
      };
      var LATIN_REGEX2 = /[a-zA-Z0-9\u00C0-\u00D6\u00D8-\u00f6\u00f8-\u00ff!"#$%&'()*+,-./:;]/;
      var regexCannotStartZhCn2 = /[!%),.:;?\]}¢°·'""†‡›℃∶、。〃〆〕〗〞﹚﹜！＂％＇），．：；？！］｝～]/;
      var regexCannotEndZhCn2 = /[$(£¥·'"〈《「『【〔〖〝﹙﹛＄（．［｛￡￥]/;
      var regexCannotStartZhTw2 = /[!),.:;?\]}¢·–—'"•"、。〆〞〕〉》」︰︱︲︳﹐﹑﹒﹓﹔﹕﹖﹘﹚﹜！），．：；？︶︸︺︼︾﹀﹂﹗］｜｝､]/;
      var regexCannotEndZhTw2 = /[([{£¥'"‵〈《「『〔〝︴﹙﹛（｛︵︷︹︻︽︿﹁﹃﹏]/;
      var regexCannotStartJaJp2 = /[)\]｝〕〉》」』】〙〗〟'"｠»ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻‐゠–〜?!‼⁇⁈⁉・、:;,。.]/;
      var regexCannotEndJaJp2 = /[([｛〔〈《「『【〘〖〝'"｟«—...‥〳〴〵]/;
      var regexCannotStartKoKr2 = /[!%),.:;?\]}¢°'"†‡℃〆〈《「『〕！％），．：；？］｝]/;
      var regexCannotEndKoKr2 = /[$([{£¥'"々〇〉》」〔＄（［｛｠￥￦#]/;
      var regexCannotStart2 = new RegExp("".concat(regexCannotStartZhCn2.source, "|").concat(regexCannotStartZhTw2.source, "|").concat(regexCannotStartJaJp2.source, "|").concat(regexCannotStartKoKr2.source));
      var regexCannotEnd2 = new RegExp("".concat(regexCannotEndZhCn2.source, "|").concat(regexCannotEndZhTw2.source, "|").concat(regexCannotEndJaJp2.source, "|").concat(regexCannotEndKoKr2.source));
      var TextService2 = /* @__PURE__ */ (function() {
        function TextService3(runtime3) {
          var _this2 = this;
          _classCallCheck2(this, TextService3);
          this.fontMetricsCache = {};
          this.shouldBreakByKinsokuShorui = function(_char, nextChar) {
            if (_this2.isBreakingSpace(nextChar)) return false;
            if (_char) {
              if (regexCannotEnd2.exec(nextChar) || regexCannotStart2.exec(_char)) {
                return true;
              }
            }
            return false;
          };
          this.trimByKinsokuShorui = function(prev) {
            var next = _toConsumableArray2(prev);
            var prevLine = next[next.length - 2];
            if (!prevLine) {
              return prev;
            }
            var lastChar = prevLine[prevLine.length - 1];
            next[next.length - 2] = prevLine.slice(0, -1);
            next[next.length - 1] = lastChar + next[next.length - 1];
            return next;
          };
          this.runtime = runtime3;
          this.charWidthCache = new LRU2(100);
        }
        return _createClass2(TextService3, [{
          key: "measureFont",
          value: (
            /**
             * A global cache for character widths, keyed by font string.
             * e.g. { '16px Arial': { 'a': 8, 'b': 9 } }
             */
            /**
             * Calculates the ascent, descent and fontSize of a given font-style.
             */
            function measureFont(font, offscreenCanvas) {
              if (this.fontMetricsCache[font]) {
                return this.fontMetricsCache[font];
              }
              var properties = {
                ascent: 0,
                descent: 0,
                fontSize: 0
              };
              var canvas2 = this.runtime.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
              var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas, {
                willReadFrequently: true
              });
              context.font = font;
              var metricsString = TEXT_METRICS2.MetricsString + TEXT_METRICS2.BaselineSymbol;
              var width2 = Math.ceil(context.measureText(metricsString).width);
              var baseline = Math.ceil(context.measureText(TEXT_METRICS2.BaselineSymbol).width);
              var height = TEXT_METRICS2.HeightMultiplier * baseline;
              baseline = baseline * TEXT_METRICS2.BaselineMultiplier | 0;
              canvas2.width = width2;
              canvas2.height = height;
              context.fillStyle = "#f00";
              context.fillRect(0, 0, width2, height);
              context.font = font;
              context.textBaseline = "alphabetic";
              context.fillStyle = "#000";
              context.fillText(metricsString, 0, baseline);
              var imagedata = context.getImageData(0, 0, width2 || 1, height || 1).data;
              var pixels = imagedata.length;
              var line2 = width2 * 4;
              var i = 0;
              var idx = 0;
              var stop = false;
              for (i = 0; i < baseline; ++i) {
                for (var j = 0; j < line2; j += 4) {
                  if (imagedata[idx + j] !== 255) {
                    stop = true;
                    break;
                  }
                }
                if (!stop) {
                  idx += line2;
                } else {
                  break;
                }
              }
              properties.ascent = baseline - i;
              idx = pixels - line2;
              stop = false;
              for (i = height; i > baseline; --i) {
                for (var _j = 0; _j < line2; _j += 4) {
                  if (imagedata[idx + _j] !== 255) {
                    stop = true;
                    break;
                  }
                }
                if (!stop) {
                  idx -= line2;
                } else {
                  break;
                }
              }
              properties.descent = i - baseline;
              properties.fontSize = properties.ascent + properties.descent;
              this.fontMetricsCache[font] = properties;
              return properties;
            }
          )
        }, {
          key: "measureText",
          value: function measureText(text, parsedStyle, offscreenCanvas) {
            var _parsedStyle$fontSize = parsedStyle.fontSize, fontSize = _parsedStyle$fontSize === void 0 ? 16 : _parsedStyle$fontSize, _parsedStyle$wordWrap = parsedStyle.wordWrap, wordWrap = _parsedStyle$wordWrap === void 0 ? false : _parsedStyle$wordWrap, strokeHeight = parsedStyle.lineHeight, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$textBase = parsedStyle.textBaseline, textBaseline = _parsedStyle$textBase === void 0 ? "alphabetic" : _parsedStyle$textBase, _parsedStyle$textAlig = parsedStyle.textAlign, textAlign = _parsedStyle$textAlig === void 0 ? "start" : _parsedStyle$textAlig, _parsedStyle$letterSp = parsedStyle.letterSpacing, letterSpacing = _parsedStyle$letterSp === void 0 ? 0 : _parsedStyle$letterSp, textPath = parsedStyle.textPath;
            parsedStyle.textPathSide;
            parsedStyle.textPathStartOffset;
            var _parsedStyle$leading = parsedStyle.leading, leading = _parsedStyle$leading === void 0 ? 0 : _parsedStyle$leading;
            var font = toFontString2(parsedStyle);
            var fontProperties = this.measureFont(font, offscreenCanvas);
            if (fontProperties.fontSize === 0) {
              fontProperties.fontSize = fontSize;
              fontProperties.ascent = fontSize;
            }
            var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
            context.font = font;
            parsedStyle.isOverflowing = false;
            var outputText = wordWrap ? this.wordWrap(text, parsedStyle, offscreenCanvas) : text;
            var lines = outputText.split(/(?:\r\n|\r|\n)/);
            var lineWidths = new Array(lines.length);
            var maxLineWidth = 0;
            if (textPath) {
              textPath.getTotalLength();
              for (var i = 0; i < lines.length; i++) {
                context.measureText(lines[i]).width + (lines[i].length - 1) * letterSpacing;
              }
            } else {
              for (var _i = 0; _i < lines.length; _i++) {
                var _lineWidth = context.measureText(lines[_i]).width + (lines[_i].length - 1) * letterSpacing;
                lineWidths[_i] = _lineWidth;
                maxLineWidth = Math.max(maxLineWidth, _lineWidth);
              }
              var _width = maxLineWidth + lineWidth;
              var lineHeight = strokeHeight || fontProperties.fontSize + lineWidth;
              var height = Math.max(lineHeight, fontProperties.fontSize + lineWidth) + (lines.length - 1) * (lineHeight + leading);
              lineHeight += leading;
              var offsetY = 0;
              if (textBaseline === "middle") {
                offsetY = -height / 2;
              } else if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
                offsetY = -height;
              } else if (textBaseline === "top" || textBaseline === "hanging") {
                offsetY = 0;
              }
              return {
                font,
                width: _width,
                height,
                lines,
                lineWidths,
                lineHeight,
                maxLineWidth,
                fontProperties,
                lineMetrics: lineWidths.map(function(width2, i2) {
                  var offsetX = 0;
                  if (textAlign === "center" || textAlign === "middle") {
                    offsetX -= width2 / 2;
                  } else if (textAlign === "right" || textAlign === "end") {
                    offsetX -= width2;
                  }
                  return new Rectangle3(offsetX - lineWidth / 2, offsetY + i2 * lineHeight, width2 + lineWidth, lineHeight);
                })
              };
            }
          }
        }, {
          key: "wordWrap",
          value: function wordWrap(text, parsedStyle, offscreenCanvas) {
            var _this2 = this;
            var chars = Array.from(text);
            if (chars.length === 0) {
              return "";
            }
            var self2 = this;
            var _parsedStyle$wordWrap2 = parsedStyle.wordWrapWidth, wordWrapWidth = _parsedStyle$wordWrap2 === void 0 ? 0 : _parsedStyle$wordWrap2, _parsedStyle$letterSp2 = parsedStyle.letterSpacing, letterSpacing = _parsedStyle$letterSp2 === void 0 ? 0 : _parsedStyle$letterSp2, _parsedStyle$maxLines = parsedStyle.maxLines, maxLines = _parsedStyle$maxLines === void 0 ? Infinity : _parsedStyle$maxLines, textOverflow = parsedStyle.textOverflow;
            var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
            var maxWidth = wordWrapWidth + letterSpacing;
            var ellipsis = "";
            if (textOverflow === "ellipsis") {
              ellipsis = "...";
            } else if (textOverflow && textOverflow !== "clip") {
              ellipsis = textOverflow;
            }
            var lines = [""];
            var currentLineIndex = 0;
            var currentLineWidth = 0;
            var prevLineLastCharIndex = -1;
            var font = toFontString2(parsedStyle);
            var charCache = this.charWidthCache.get(font);
            if (!charCache) {
              charCache = new LRU2(500);
              this.charWidthCache.put(font, charCache);
            }
            var calcWidth = function calcWidth2(_char2) {
              return _this2.getFromCache(_char2, letterSpacing, charCache, context);
            };
            var ellipsisWidth = calcWidth(ellipsis);
            function findCharIndexClosestWidthThreshold(lineTxt, txtLastCharIndex, txtStartCharIndex, widthThreshold) {
              while (calcWidth(lineTxt) < widthThreshold && txtLastCharIndex < chars.length - 1) {
                if (self2.isNewline(chars[txtLastCharIndex + 1])) {
                  break;
                }
                txtLastCharIndex += 1;
                lineTxt += chars[txtLastCharIndex];
              }
              while (calcWidth(lineTxt) > widthThreshold && // @see https://github.com/antvis/G/issues/1932
              txtLastCharIndex >= txtStartCharIndex) {
                txtLastCharIndex -= 1;
                lineTxt = lineTxt.slice(0, -1);
              }
              return {
                lineTxt,
                txtLastCharIndex
              };
            }
            function appendEllipsis(lineIndex, textCharIndex) {
              if (ellipsisWidth <= 0 || ellipsisWidth > maxWidth) {
                return;
              }
              if (!lines[lineIndex]) {
                lines[lineIndex] = ellipsis;
                return;
              }
              var result2 = findCharIndexClosestWidthThreshold(lines[lineIndex], textCharIndex, prevLineLastCharIndex + 1, maxWidth - ellipsisWidth);
              lines[lineIndex] = result2.lineTxt + ellipsis;
            }
            for (var i = 0; i < chars.length; i++) {
              var _char3 = chars[i];
              var prevChar = chars[i - 1];
              var nextChar = chars[i + 1];
              var charWidth = calcWidth(_char3);
              if (this.isNewline(_char3)) {
                if (currentLineIndex + 1 >= maxLines) {
                  if (i < chars.length - 1) {
                    appendEllipsis(currentLineIndex, i - 1);
                  }
                  parsedStyle.isOverflowing = true;
                  break;
                }
                prevLineLastCharIndex = i - 1;
                currentLineIndex += 1;
                currentLineWidth = 0;
                lines[currentLineIndex] = "";
                continue;
              }
              if (charWidth > maxWidth) {
                appendEllipsis(currentLineIndex, i - 1);
                parsedStyle.isOverflowing = true;
                break;
              }
              if (currentLineWidth > 0 && currentLineWidth + charWidth > maxWidth) {
                var result = findCharIndexClosestWidthThreshold(lines[currentLineIndex], i - 1, prevLineLastCharIndex + 1, maxWidth);
                if (result.txtLastCharIndex !== i - 1) {
                  lines[currentLineIndex] = result.lineTxt;
                  if (result.txtLastCharIndex === chars.length - 1) {
                    break;
                  }
                  i = result.txtLastCharIndex + 1;
                  _char3 = chars[i];
                  prevChar = chars[i - 1];
                  nextChar = chars[i + 1];
                  charWidth = calcWidth(_char3);
                }
                if (currentLineIndex + 1 >= maxLines) {
                  appendEllipsis(currentLineIndex, i - 1);
                  parsedStyle.isOverflowing = true;
                  break;
                }
                prevLineLastCharIndex = i - 1;
                currentLineIndex += 1;
                currentLineWidth = 0;
                lines[currentLineIndex] = "";
                if (this.isBreakingSpace(_char3)) {
                  continue;
                }
                if (!this.canBreakInLastChar(_char3)) {
                  lines = this.trimToBreakable(lines);
                  currentLineWidth = this.sumTextWidthByCache(lines[currentLineIndex] || "", calcWidth);
                }
                if (this.shouldBreakByKinsokuShorui(_char3, nextChar)) {
                  lines = this.trimByKinsokuShorui(lines);
                  currentLineWidth += calcWidth(prevChar || "");
                }
              }
              currentLineWidth += charWidth;
              lines[currentLineIndex] += _char3;
            }
            return lines.join("\n");
          }
        }, {
          key: "isBreakingSpace",
          value: function isBreakingSpace(_char4) {
            if (typeof _char4 !== "string") {
              return false;
            }
            return TEXT_METRICS2.BreakingSpaces.indexOf(_char4.charCodeAt(0)) >= 0;
          }
        }, {
          key: "isNewline",
          value: function isNewline(_char5) {
            if (typeof _char5 !== "string") {
              return false;
            }
            return TEXT_METRICS2.Newlines.indexOf(_char5.charCodeAt(0)) >= 0;
          }
        }, {
          key: "trimToBreakable",
          value: function trimToBreakable(prev) {
            var next = _toConsumableArray2(prev);
            var prevLine = next[next.length - 2];
            var index2 = this.findBreakableIndex(prevLine);
            if (index2 === -1 || !prevLine) return next;
            var trimmedChar = prevLine.slice(index2, index2 + 1);
            var isTrimmedWithSpace = this.isBreakingSpace(trimmedChar);
            var trimFrom = index2 + 1;
            var trimTo = index2 + (isTrimmedWithSpace ? 0 : 1);
            next[next.length - 1] += prevLine.slice(trimFrom, prevLine.length);
            next[next.length - 2] = prevLine.slice(0, trimTo);
            return next;
          }
        }, {
          key: "canBreakInLastChar",
          value: function canBreakInLastChar(_char6) {
            if (_char6 && LATIN_REGEX2.test(_char6)) return false;
            return true;
          }
        }, {
          key: "sumTextWidthByCache",
          value: function sumTextWidthByCache(text, calcWidthWithCache) {
            return text.split("").reduce(function(sum, c2) {
              return sum + calcWidthWithCache(c2);
            }, 0);
          }
        }, {
          key: "findBreakableIndex",
          value: function findBreakableIndex(line2) {
            for (var i = line2.length - 1; i >= 0; i--) {
              if (!LATIN_REGEX2.test(line2[i])) return i;
            }
            return -1;
          }
        }, {
          key: "getFromCache",
          value: function getFromCache(key, letterSpacing, cache, context) {
            var width2 = cache.get(key);
            if (typeof width2 !== "number") {
              var spacing = key.length * letterSpacing;
              var metrics = context.measureText(key);
              width2 = metrics.width + spacing;
              cache.put(key, width2);
            }
            return width2;
          }
        }, {
          key: "clearCache",
          value: function clearCache() {
            this.fontMetricsCache = {};
            this.charWidthCache.clear();
          }
        }]);
      })();
      var runtime2 = {};
      var geometryUpdaterFactory2 = (function(_ref) {
        var rectUpdater = new RectUpdater2();
        var polylineUpdater = new PolylineUpdater2();
        return _ref = {}, _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_ref, Shape2.FRAGMENT, null), Shape2.CIRCLE, new CircleUpdater2()), Shape2.ELLIPSE, new EllipseUpdater2()), Shape2.RECT, rectUpdater), Shape2.IMAGE, rectUpdater), Shape2.GROUP, new GroupUpdater2()), Shape2.LINE, new LineUpdater2()), Shape2.TEXT, new TextUpdater2(runtime2)), Shape2.POLYLINE, polylineUpdater), Shape2.POLYGON, polylineUpdater), _defineProperty2(_defineProperty2(_defineProperty2(_ref, Shape2.PATH, new PathUpdater2()), Shape2.HTML, new HTMLUpdater2()), Shape2.MESH, null);
      })();
      var CSSPropertySyntaxFactory2 = (function(_ref2) {
        var color3 = new CSSPropertyColor2();
        var length = new CSSPropertyLengthOrPercentage2();
        return _ref2 = {}, _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_ref2, PropertySyntax2.PERCENTAGE, null), PropertySyntax2.NUMBER, new CSSPropertyNumber2()), PropertySyntax2.ANGLE, new CSSPropertyAngle2()), PropertySyntax2.DEFINED_PATH, new CSSPropertyClipPath2()), PropertySyntax2.PAINT, color3), PropertySyntax2.COLOR, color3), PropertySyntax2.FILTER, new CSSPropertyFilter2()), PropertySyntax2.LENGTH, length), PropertySyntax2.LENGTH_PERCENTAGE, length), PropertySyntax2.LENGTH_PERCENTAGE_12, new CSSPropertyLengthOrPercentage122()), _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_ref2, PropertySyntax2.LENGTH_PERCENTAGE_14, new CSSPropertyLengthOrPercentage142()), PropertySyntax2.COORDINATE, new CSSPropertyLengthOrPercentage2()), PropertySyntax2.OFFSET_DISTANCE, new CSSPropertyOffsetDistance2()), PropertySyntax2.OPACITY_VALUE, new CSSPropertyOpacity2()), PropertySyntax2.PATH, new CSSPropertyPath2()), PropertySyntax2.LIST_OF_POINTS, new CSSPropertyPoints3()), PropertySyntax2.SHADOW_BLUR, new CSSPropertyShadowBlur2()), PropertySyntax2.TEXT, new CSSPropertyText2()), PropertySyntax2.TEXT_TRANSFORM, new CSSPropertyTextTransform2()), PropertySyntax2.TRANSFORM, new CSSPropertyTransform2()), _defineProperty2(_defineProperty2(_defineProperty2(_ref2, PropertySyntax2.TRANSFORM_ORIGIN, new CSSPropertyTransformOrigin2()), PropertySyntax2.Z_INDEX, new CSSPropertyZIndex2()), PropertySyntax2.MARKER, new CSSPropertyMarker2());
      })();
      var getGlobalThis3 = function getGlobalThis4() {
        if (typeof globalThis !== "undefined") return globalThis;
        if (typeof self !== "undefined") return self;
        if (typeof window !== "undefined") return window;
        if (typeof global !== "undefined") return global;
        return {};
      };
      runtime2.CameraContribution = Camera2;
      runtime2.AnimationTimeline = null;
      runtime2.EasingFunction = null;
      runtime2.offscreenCanvasCreator = new OffscreenCanvasCreator2();
      runtime2.sceneGraphSelector = new DefaultSceneGraphSelector2();
      runtime2.sceneGraphService = new DefaultSceneGraphService2(runtime2);
      runtime2.textService = new TextService2(runtime2);
      runtime2.geometryUpdaterFactory = geometryUpdaterFactory2;
      runtime2.CSSPropertySyntaxFactory = CSSPropertySyntaxFactory2;
      runtime2.styleValueRegistry = new DefaultStyleValueRegistry2(runtime2);
      runtime2.layoutRegistry = null;
      runtime2.globalThis = getGlobalThis3();
      runtime2.enableStyleSyntax = true;
      runtime2.enableSizeAttenuation = false;
      var entityCounter2 = 0;
      function resetEntityCounter() {
        entityCounter2 = 0;
      }
      var insertedEvent2 = new MutationEvent2(ElementEvent2.INSERTED, null, "", "", "", 0, "", "");
      var removedEvent2 = new MutationEvent2(ElementEvent2.REMOVED, null, "", "", "", 0, "", "");
      var destroyEvent2 = new CustomEvent2(ElementEvent2.DESTROY);
      var Element3 = /* @__PURE__ */ (function(_Node) {
        function Element4() {
          var _this2;
          _classCallCheck2(this, Element4);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this2 = _callSuper2(this, Element4, [].concat(args));
          _this2.entity = entityCounter2++;
          _this2.transformable = {
            dirtyFlag: false,
            localDirtyFlag: false,
            localPosition: [0, 0, 0],
            localRotation: [0, 0, 0, 1],
            localScale: [1, 1, 1],
            localTransform: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            localSkew: [0, 0],
            position: [0, 0, 0],
            rotation: [0, 0, 0, 1],
            scaling: [1, 1, 1],
            worldTransform: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            origin: [0, 0, 0]
          };
          _this2.renderable = {
            bounds: void 0,
            boundsDirty: true,
            renderBounds: void 0,
            renderBoundsDirty: true,
            dirtyRenderBounds: void 0,
            dirty: false
          };
          _this2.geometry = {
            contentBounds: void 0,
            renderBounds: void 0,
            dirty: true
          };
          _this2.cullable = {
            strategy: Strategy2.Standard,
            visibilityPlaneMask: -1,
            visible: true,
            enable: true
          };
          _this2.sortable = {
            dirty: false,
            sorted: void 0,
            renderOrder: 0,
            dirtyChildren: [],
            dirtyReason: void 0
          };
          _this2.rBushNode = {
            aabb: void 0
          };
          _this2.namespaceURI = "g";
          _this2.scrollLeft = 0;
          _this2.scrollTop = 0;
          _this2.clientTop = 0;
          _this2.clientLeft = 0;
          _this2.style = {};
          _this2.computedStyle = {};
          _this2.parsedStyle = {
            // opacity: '',
            // fillOpacity: '',
            // strokeOpacity: '',
            // transformOrigin: '',
            // visibility: '',
            // pointerEvents: '',
            // lineWidth: '',
            // lineCap: '',
            // lineJoin: '',
            // increasedLineWidthForHitTesting: '',
            // fontSize: '',
            // fontFamily: '',
            // fontStyle: '',
            // fontWeight: '',
            // fontVariant: '',
            // textAlign: '',
            // textBaseline: '',
            // textTransform: '',
          };
          _this2.attributes = {};
          return _this2;
        }
        _inherits2(Element4, _Node);
        return _createClass2(Element4, [{
          key: "dirty",
          value: (
            /**
             * @param flag - default `true`, whether the object needs to be updated
             * @param updateShape - default `false`, whether the bounding box of the object is updated
             */
            function dirty() {
              var flag = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
              var updateShape = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              this.renderable.dirty = flag;
              if (updateShape) {
                this.renderable.boundsDirty = flag;
                this.renderable.renderBoundsDirty = flag;
              }
            }
          )
        }, {
          key: "className",
          get: (
            /**
             * used with `getElementById()`
             * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/id
             */
            /**
             * used in `getElementsByClassName`
             * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
             */
            function get9() {
              return this.getAttribute("class") || "";
            }
          ),
          set: function set6(className) {
            this.setAttribute("class", className);
          }
          /**
           * used in `getElementsByName`
           * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByName
           */
        }, {
          key: "classList",
          get: (
            /**
             * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/classList
             */
            function get9() {
              return this.className.split(" ").filter(function(c2) {
                return c2 !== "";
              });
            }
          )
        }, {
          key: "tagName",
          get: function get9() {
            return this.nodeName;
          }
        }, {
          key: "children",
          get: function get9() {
            return this.childNodes;
          }
        }, {
          key: "childElementCount",
          get: function get9() {
            return this.childNodes.length;
          }
        }, {
          key: "firstElementChild",
          get: function get9() {
            return this.firstChild;
          }
        }, {
          key: "lastElementChild",
          get: function get9() {
            return this.lastChild;
          }
        }, {
          key: "parentElement",
          get: function get9() {
            return this.parentNode;
          }
        }, {
          key: "nextSibling",
          get: function get9() {
            if (this.parentNode) {
              var index2 = this.parentNode.childNodes.indexOf(this);
              return this.parentNode.childNodes[index2 + 1] || null;
            }
            return null;
          }
        }, {
          key: "previousSibling",
          get: function get9() {
            if (this.parentNode) {
              var index2 = this.parentNode.childNodes.indexOf(this);
              return this.parentNode.childNodes[index2 - 1] || null;
            }
            return null;
          }
        }, {
          key: "cloneNode",
          value: function cloneNode(deep2) {
            throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED2);
          }
        }, {
          key: "appendChild",
          value: function appendChild(child, index2) {
            var _this$ownerDocument;
            if (child.destroyed) {
              throw new Error(ERROR_MSG_APPEND_DESTROYED_ELEMENT2);
            }
            runtime2.sceneGraphService.attach(child, this, index2);
            if ((_this$ownerDocument = this.ownerDocument) !== null && _this$ownerDocument !== void 0 && _this$ownerDocument.defaultView) {
              if (!isInFragment2(this) && child.nodeName === Shape2.FRAGMENT) {
                this.ownerDocument.defaultView.mountFragment(child);
              } else {
                this.ownerDocument.defaultView.mountChildren(child);
              }
            }
            if (this.isMutationObserved) {
              insertedEvent2.relatedNode = this;
              child.dispatchEvent(insertedEvent2);
            }
            return child;
          }
        }, {
          key: "insertBefore",
          value: function insertBefore(newChild, refChild) {
            if (!refChild) {
              this.appendChild(newChild);
            } else {
              if (newChild.parentElement) {
                newChild.parentElement.removeChild(newChild);
              }
              var index2 = this.childNodes.indexOf(refChild);
              if (index2 === -1) {
                this.appendChild(newChild);
              } else {
                this.appendChild(newChild, index2);
              }
            }
            return newChild;
          }
        }, {
          key: "replaceChild",
          value: function replaceChild(newChild, oldChild) {
            var index2 = this.childNodes.indexOf(oldChild);
            this.removeChild(oldChild);
            this.appendChild(newChild, index2);
            return oldChild;
          }
        }, {
          key: "removeChild",
          value: function removeChild(child) {
            var _this$ownerDocument2, _child$ownerDocument;
            var enableCancelEventPropagation = ((_this$ownerDocument2 = this.ownerDocument) === null || _this$ownerDocument2 === void 0 || (_this$ownerDocument2 = _this$ownerDocument2.defaultView) === null || _this$ownerDocument2 === void 0 || (_this$ownerDocument2 = _this$ownerDocument2.getConfig().future) === null || _this$ownerDocument2 === void 0 ? void 0 : _this$ownerDocument2.experimentalCancelEventPropagation) === true;
            removedEvent2.relatedNode = this;
            child.dispatchEvent(removedEvent2, enableCancelEventPropagation, enableCancelEventPropagation);
            if ((_child$ownerDocument = child.ownerDocument) !== null && _child$ownerDocument !== void 0 && _child$ownerDocument.defaultView) {
              child.ownerDocument.defaultView.unmountChildren(child);
            }
            runtime2.sceneGraphService.detach(child);
            return child;
          }
          /**
           * Remove all children which can be appended to its original parent later again.
           */
        }, {
          key: "removeChildren",
          value: function removeChildren() {
            for (var i = this.childNodes.length - 1; i >= 0; i--) {
              var child = this.childNodes[i];
              this.removeChild(child);
            }
          }
          /**
           * Recursively destroy all children which can not be appended to its original parent later again.
           */
        }, {
          key: "destroyChildren",
          value: function destroyChildren() {
            for (var i = this.childNodes.length - 1; i >= 0; i--) {
              var child = this.childNodes[i];
              if (child.childNodes.length > 0) {
                child.destroyChildren();
              }
              child.destroy();
            }
          }
          /**
           * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/matches
           */
        }, {
          key: "matches",
          value: function matches(selector) {
            return runtime2.sceneGraphService.matches(selector, this);
          }
        }, {
          key: "getElementById",
          value: function getElementById(id4) {
            return runtime2.sceneGraphService.querySelector("#".concat(id4), this);
          }
        }, {
          key: "getElementsByName",
          value: function getElementsByName(name) {
            return runtime2.sceneGraphService.querySelectorAll('[name="'.concat(name, '"]'), this);
          }
        }, {
          key: "getElementsByClassName",
          value: function getElementsByClassName(className) {
            return runtime2.sceneGraphService.querySelectorAll(".".concat(className), this);
          }
        }, {
          key: "getElementsByTagName",
          value: function getElementsByTagName(tagName) {
            return runtime2.sceneGraphService.querySelectorAll(tagName, this);
          }
        }, {
          key: "querySelector",
          value: function querySelector(selectors) {
            return runtime2.sceneGraphService.querySelector(selectors, this);
          }
        }, {
          key: "querySelectorAll",
          value: function querySelectorAll(selectors) {
            return runtime2.sceneGraphService.querySelectorAll(selectors, this);
          }
          /**
           * should traverses the element and its parents (heading toward the document root)
           * until it finds a node that matches the specified CSS selector.
           * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/closest
           * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#polyfill
           */
        }, {
          key: "closest",
          value: function closest(selectors) {
            var el = this;
            do {
              if (runtime2.sceneGraphService.matches(selectors, el)) return el;
              el = el.parentElement;
            } while (el !== null);
            return null;
          }
          /**
           * search in scene group, but should not include itself
           */
        }, {
          key: "find",
          value: function find5(filter) {
            var _this2 = this;
            var target = null;
            this.forEach(function(object) {
              if (object !== _this2 && filter(object)) {
                target = object;
                return false;
              }
              return true;
            });
            return target;
          }
        }, {
          key: "findAll",
          value: function findAll(filter) {
            var _this3 = this;
            var objects = [];
            this.forEach(function(object) {
              if (object !== _this3 && filter(object)) {
                objects.push(object);
              }
            });
            return objects;
          }
          /**
           * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/after
           */
        }, {
          key: "after",
          value: function after() {
            var _this4 = this;
            if (this.parentNode) {
              var index2 = this.parentNode.childNodes.indexOf(this);
              for (var _len2 = arguments.length, nodes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                nodes[_key2] = arguments[_key2];
              }
              nodes.forEach(function(node, i) {
                var _this4$parentNode;
                return (_this4$parentNode = _this4.parentNode) === null || _this4$parentNode === void 0 ? void 0 : _this4$parentNode.appendChild(node, index2 + i + 1);
              });
            }
          }
          /**
           * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/before
           */
        }, {
          key: "before",
          value: function before() {
            if (this.parentNode) {
              var _ref;
              var index2 = this.parentNode.childNodes.indexOf(this);
              for (var _len3 = arguments.length, nodes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                nodes[_key3] = arguments[_key3];
              }
              var first = nodes[0], rest = nodes.slice(1);
              this.parentNode.appendChild(first, index2);
              (_ref = first).after.apply(_ref, _toConsumableArray2(rest));
            }
          }
          /**
           * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/replaceWith
           */
        }, {
          key: "replaceWith",
          value: function replaceWith() {
            this.after.apply(this, arguments);
            this.remove();
          }
          /**
           * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/append
           */
        }, {
          key: "append",
          value: function append() {
            var _this5 = this;
            for (var _len4 = arguments.length, nodes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              nodes[_key4] = arguments[_key4];
            }
            nodes.forEach(function(node) {
              return _this5.appendChild(node);
            });
          }
          /**
           * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/prepend
           */
        }, {
          key: "prepend",
          value: function prepend() {
            var _this6 = this;
            for (var _len5 = arguments.length, nodes = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
              nodes[_key5] = arguments[_key5];
            }
            nodes.forEach(function(node, i) {
              return _this6.appendChild(node, i);
            });
          }
          /**
           * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/replaceChildren
           */
        }, {
          key: "replaceChildren",
          value: function replaceChildren2() {
            while (this.childNodes.length && this.firstChild) {
              this.removeChild(this.firstChild);
            }
            this.append.apply(this, arguments);
          }
          /**
           * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/remove
           */
        }, {
          key: "remove",
          value: function remove() {
            if (this.parentNode) {
              return this.parentNode.removeChild(this);
            }
            return this;
          }
        }, {
          key: "destroy",
          value: function destroy() {
            var _this$ownerDocument3;
            var enableCancelEventPropagation = ((_this$ownerDocument3 = this.ownerDocument) === null || _this$ownerDocument3 === void 0 || (_this$ownerDocument3 = _this$ownerDocument3.defaultView) === null || _this$ownerDocument3 === void 0 || (_this$ownerDocument3 = _this$ownerDocument3.getConfig().future) === null || _this$ownerDocument3 === void 0 ? void 0 : _this$ownerDocument3.experimentalCancelEventPropagation) === true;
            this.destroyChildren();
            this.dispatchEvent(destroyEvent2, enableCancelEventPropagation, enableCancelEventPropagation);
            this.remove();
            this.emitter.removeAllListeners();
            this.destroyed = true;
          }
        }, {
          key: "getGeometryBounds",
          value: function getGeometryBounds() {
            return runtime2.sceneGraphService.getGeometryBounds(this);
          }
        }, {
          key: "getRenderBounds",
          value: function getRenderBounds() {
            return runtime2.sceneGraphService.getBounds(this, true);
          }
          /**
           * get bounds in world space, account for children
           */
        }, {
          key: "getBounds",
          value: function getBounds2() {
            return runtime2.sceneGraphService.getBounds(this);
          }
          /**
           * get bounds in local space, account for children
           */
        }, {
          key: "getLocalBounds",
          value: function getLocalBounds() {
            return runtime2.sceneGraphService.getLocalBounds(this);
          }
          /**
           * account for context's bounds in client space,
           * but not accounting for children
           * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
           */
        }, {
          key: "getBoundingClientRect",
          value: function getBoundingClientRect() {
            return runtime2.sceneGraphService.getBoundingClientRect(this);
          }
          /**
           * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getClientRects
           */
        }, {
          key: "getClientRects",
          value: function getClientRects() {
            return [this.getBoundingClientRect()];
          }
        }, {
          key: "computedStyleMap",
          value: (
            /**
             * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/computedStyleMap
             * eg. circle.computedStyleMap().get('fill');
             */
            function computedStyleMap() {
              return new Map(Object.entries(this.computedStyle));
            }
          )
        }, {
          key: "getAttributeNames",
          value: (
            /**
             * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNames
             */
            function getAttributeNames() {
              return Object.keys(this.attributes);
            }
          )
          /**
           * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute
           */
        }, {
          key: "getAttribute",
          value: function getAttribute(name) {
            if (typeof name === "symbol") {
              return void 0;
            }
            var value = this.attributes[name];
            if (value === void 0) {
              return value;
            }
            return value;
          }
          /**
           * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/hasAttribute
           */
        }, {
          key: "hasAttribute",
          value: function hasAttribute(qualifiedName) {
            return this.getAttributeNames().includes(qualifiedName);
          }
          /**
           * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/hasAttributes
           */
        }, {
          key: "hasAttributes",
          value: function hasAttributes() {
            return !!this.getAttributeNames().length;
          }
          /**
           * should use removeAttribute() instead of setting the attribute value to null either directly or using setAttribute(). Many attributes will not behave as expected if you set them to null.
           * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute
           */
        }, {
          key: "removeAttribute",
          value: function removeAttribute(attributeName) {
            this.setAttribute(attributeName, null);
            delete this.attributes[attributeName];
          }
          /**
           * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute
           */
        }, {
          key: "setAttribute",
          value: function setAttribute(attributeName, value, force, memoize5) {
            this.attributes[attributeName] = value;
          }
        }, {
          key: "getAttributeNS",
          value: function getAttributeNS(namespace, localName) {
            throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED2);
          }
        }, {
          key: "getAttributeNode",
          value: function getAttributeNode(qualifiedName) {
            throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED2);
          }
        }, {
          key: "getAttributeNodeNS",
          value: function getAttributeNodeNS(namespace, localName) {
            throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED2);
          }
        }, {
          key: "hasAttributeNS",
          value: function hasAttributeNS(namespace, localName) {
            throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED2);
          }
        }, {
          key: "removeAttributeNS",
          value: function removeAttributeNS(namespace, localName) {
            throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED2);
          }
        }, {
          key: "removeAttributeNode",
          value: function removeAttributeNode(attr2) {
            throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED2);
          }
        }, {
          key: "setAttributeNS",
          value: function setAttributeNS(namespace, qualifiedName, value) {
            throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED2);
          }
        }, {
          key: "setAttributeNode",
          value: function setAttributeNode(attr2) {
            throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED2);
          }
        }, {
          key: "setAttributeNodeNS",
          value: function setAttributeNodeNS(attr2) {
            throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED2);
          }
        }, {
          key: "toggleAttribute",
          value: function toggleAttribute(qualifiedName, force) {
            throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED2);
          }
        }]);
      })(Node3);
      function isDisplayObject2(value) {
        return !!(value !== null && value !== void 0 && value.nodeName);
      }
      var Proxy3 = runtime2.globalThis.Proxy ? runtime2.globalThis.Proxy : function() {
      };
      var attrModifiedEvent2 = new MutationEvent2(ElementEvent2.ATTR_MODIFIED, null, null, null, null, MutationEvent2.MODIFICATION, null, null);
      var $vec32 = glMatrix.vec3.create();
      var $quat2 = glMatrix.quat.create();
      var DisplayObject2 = /* @__PURE__ */ (function(_Element) {
        function DisplayObject3(config) {
          var _this2;
          _classCallCheck2(this, DisplayObject3);
          _this2 = _callSuper2(this, DisplayObject3);
          _this2.isCustomElement = false;
          _this2.isMutationObserved = false;
          _this2.activeAnimations = [];
          _this2.config = config;
          _this2.id = config.id || "";
          _this2.name = config.name || "";
          if (config.className || config["class"]) {
            _this2.className = config.className || config["class"];
          }
          _this2.nodeName = config.type || Shape2.GROUP;
          if (config.initialParsedStyle) {
            Object.assign(_this2.parsedStyle, config.initialParsedStyle);
          }
          _this2.initAttributes(config.style);
          if (runtime2.enableStyleSyntax) {
            _this2.style = new Proxy3(
              // @ts-ignore
              {
                // ...this.attributes,
                setProperty: function setProperty(propertyName, value) {
                  _this2.setAttribute(propertyName, value);
                },
                getPropertyValue: function getPropertyValue(propertyName) {
                  return _this2.getAttribute(propertyName);
                },
                removeProperty: function removeProperty(propertyName) {
                  _this2.removeAttribute(propertyName);
                },
                item: function item() {
                  return "";
                }
              },
              {
                get: function get9(target, name) {
                  if (target[name] !== void 0) {
                    return target[name];
                  }
                  return _this2.getAttribute(name);
                },
                set: function set6(_3, prop, value) {
                  _this2.setAttribute(prop, value);
                  return true;
                }
              }
            );
          }
          return _this2;
        }
        _inherits2(DisplayObject3, _Element);
        return _createClass2(DisplayObject3, [{
          key: "destroy",
          value: function destroy() {
            _superPropGet2(DisplayObject3, "destroy", this, 3)([]);
            this.getAnimations().forEach(function(animation) {
              animation.cancel();
            });
          }
        }, {
          key: "cloneNode",
          value: function cloneNode(deep2, customCloneFunc) {
            var clonedStyle = _objectSpread({}, this.attributes);
            for (var attributeName in clonedStyle) {
              var attribute = clonedStyle[attributeName];
              if (isDisplayObject2(attribute) && // share the same clipPath if possible
              attributeName !== "clipPath" && attributeName !== "offsetPath" && attributeName !== "textPath") {
                clonedStyle[attributeName] = attribute.cloneNode(deep2);
              }
              if (customCloneFunc) {
                clonedStyle[attributeName] = customCloneFunc(attributeName, attribute);
              }
            }
            var cloned = new this.constructor(_objectSpread(_objectSpread({}, this.config), {}, {
              style: clonedStyle
            }));
            cloned.setLocalTransform(this.getLocalTransform());
            if (deep2) {
              this.children.forEach(function(child) {
                if (!child.style.isMarker) {
                  var clonedChild = child.cloneNode(deep2);
                  cloned.appendChild(clonedChild);
                }
              });
            }
            return cloned;
          }
        }, {
          key: "initAttributes",
          value: function initAttributes() {
            var attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            var options = {
              forceUpdateGeometry: true
            };
            runtime2.styleValueRegistry.processProperties(this, attributes, options);
            this.dirty();
          }
        }, {
          key: "setAttribute",
          value: function setAttribute(name, value) {
            var force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            var memoize5 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
            if (util.isUndefined(value)) {
              return;
            }
            if (force || value !== this.attributes[name]) {
              this.internalSetAttribute(name, value, {
                memoize: memoize5
              });
              _superPropGet2(DisplayObject3, "setAttribute", this, 3)([name, value]);
            }
          }
          /**
           * called when attributes get changed or initialized
           */
        }, {
          key: "internalSetAttribute",
          value: function internalSetAttribute(name, value) {
            var parseOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            var oldValue = this.attributes[name];
            var oldParsedValue = this.parsedStyle[name];
            runtime2.styleValueRegistry.processProperties(this, _defineProperty2({}, name, value), parseOptions);
            this.dirty();
            var newParsedValue = this.parsedStyle[name];
            if (this.isConnected) {
              attrModifiedEvent2.relatedNode = this;
              attrModifiedEvent2.prevValue = oldValue;
              attrModifiedEvent2.newValue = value;
              attrModifiedEvent2.attrName = name;
              attrModifiedEvent2.prevParsedValue = oldParsedValue;
              attrModifiedEvent2.newParsedValue = newParsedValue;
              if (this.isMutationObserved) {
                this.dispatchEvent(attrModifiedEvent2);
              } else {
                var _this$ownerDocument$d;
                var enableCancelEventPropagation = ((_this$ownerDocument$d = this.ownerDocument.defaultView.getConfig().future) === null || _this$ownerDocument$d === void 0 ? void 0 : _this$ownerDocument$d.experimentalCancelEventPropagation) === true;
                attrModifiedEvent2.target = this;
                this.ownerDocument.defaultView.dispatchEvent(attrModifiedEvent2, true, enableCancelEventPropagation);
              }
            }
            if (this.isCustomElement && this.isConnected || !this.isCustomElement) {
              var _attributeChangedCall, _ref;
              (_attributeChangedCall = (_ref = this).attributeChangedCallback) === null || _attributeChangedCall === void 0 || _attributeChangedCall.call(_ref, name, oldValue, value, oldParsedValue, newParsedValue);
            }
          }
          // #region transformable
          /**
           * returns different values than getBoundingClientRect(), as the latter returns value relative to the viewport
           * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement/getBBox
           *
           * FIXME: It is worth noting that getBBox responds to original untransformed values of a drawn object.
           * @see https://www.w3.org/Graphics/SVG/IG/resources/svgprimer.html#getBBox
           */
        }, {
          key: "getBBox",
          value: function getBBox2() {
            var aabb = this.getBounds();
            var _aabb$getMin = aabb.getMin(), _aabb$getMin2 = _slicedToArray2(_aabb$getMin, 2), left = _aabb$getMin2[0], top = _aabb$getMin2[1];
            var _aabb$getMax = aabb.getMax(), _aabb$getMax2 = _slicedToArray2(_aabb$getMax, 2), right = _aabb$getMax2[0], bottom = _aabb$getMax2[1];
            return new Rectangle3(left, top, right - left, bottom - top);
          }
        }, {
          key: "setOrigin",
          value: function setOrigin(position2) {
            var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            runtime2.sceneGraphService.setOrigin(this, createVec32(position2, y3, z, false));
            return this;
          }
        }, {
          key: "getOrigin",
          value: function getOrigin() {
            return runtime2.sceneGraphService.getOrigin(this);
          }
          /**
           * set position in world space
           */
        }, {
          key: "setPosition",
          value: function setPosition(position2) {
            var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            runtime2.sceneGraphService.setPosition(this, createVec32(position2, y3, z, false));
            return this;
          }
          /**
           * set position in local space
           */
        }, {
          key: "setLocalPosition",
          value: function setLocalPosition(position2) {
            var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            runtime2.sceneGraphService.setLocalPosition(this, createVec32(position2, y3, z, false));
            return this;
          }
          /**
           * translate in world space
           */
        }, {
          key: "translate",
          value: function translate3(position2) {
            var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            runtime2.sceneGraphService.translate(this, createVec32(position2, y3, z, false));
            return this;
          }
          /**
           * translate in local space
           */
        }, {
          key: "translateLocal",
          value: function translateLocal(position2) {
            var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            runtime2.sceneGraphService.translateLocal(this, createVec32(position2, y3, z, false));
            return this;
          }
        }, {
          key: "getPosition",
          value: function getPosition() {
            return runtime2.sceneGraphService.getPosition(this);
          }
        }, {
          key: "getLocalPosition",
          value: function getLocalPosition() {
            return runtime2.sceneGraphService.getLocalPosition(this);
          }
          /**
           * compatible with G 3.0
           *
           * scaling in local space
           * scale(10) = scale(10, 10, 10)
           *
           * we can't set scale in world space
           */
        }, {
          key: "scale",
          value: function scale4(scaling, y3, z) {
            return this.scaleLocal(scaling, y3, z);
          }
        }, {
          key: "scaleLocal",
          value: function scaleLocal(scaling, y3, z) {
            if (typeof scaling === "number") {
              y3 = y3 || scaling;
              z = z || scaling;
              scaling = createVec32(scaling, y3, z, false);
            }
            runtime2.sceneGraphService.scaleLocal(this, scaling);
            return this;
          }
          /**
           * set scaling in local space
           */
        }, {
          key: "setLocalScale",
          value: function setLocalScale(scaling, y3, z) {
            if (typeof scaling === "number") {
              y3 = y3 || scaling;
              z = z || scaling;
              scaling = createVec32(scaling, y3, z, false);
            }
            runtime2.sceneGraphService.setLocalScale(this, scaling);
            return this;
          }
          /**
           * get scaling in local space
           */
        }, {
          key: "getLocalScale",
          value: function getLocalScale() {
            return runtime2.sceneGraphService.getLocalScale(this);
          }
          /**
           * get scaling in world space
           */
        }, {
          key: "getScale",
          value: function getScale() {
            return runtime2.sceneGraphService.getScale(this);
          }
          /**
           * only return degrees of Z axis in world space
           */
        }, {
          key: "getEulerAngles",
          value: function getEulerAngles() {
            var _getEuler = getEuler2($vec32, runtime2.sceneGraphService.getWorldTransform(this)), _getEuler2 = _slicedToArray2(_getEuler, 3), ez = _getEuler2[2];
            return rad2deg2(ez);
          }
          /**
           * only return degrees of Z axis in local space
           */
        }, {
          key: "getLocalEulerAngles",
          value: function getLocalEulerAngles() {
            var _getEuler3 = getEuler2($vec32, runtime2.sceneGraphService.getLocalRotation(this)), _getEuler4 = _slicedToArray2(_getEuler3, 3), ez = _getEuler4[2];
            return rad2deg2(ez);
          }
          /**
           * set euler angles(degrees) in world space
           */
        }, {
          key: "setEulerAngles",
          value: function setEulerAngles(z) {
            runtime2.sceneGraphService.setEulerAngles(this, 0, 0, z);
            return this;
          }
          /**
           * set euler angles(degrees) in local space
           */
        }, {
          key: "setLocalEulerAngles",
          value: function setLocalEulerAngles(z) {
            runtime2.sceneGraphService.setLocalEulerAngles(this, 0, 0, z);
            return this;
          }
        }, {
          key: "rotateLocal",
          value: function rotateLocal(x3, y3, z) {
            if (util.isNil(y3) && util.isNil(z)) {
              runtime2.sceneGraphService.rotateLocal(this, 0, 0, x3);
            } else {
              runtime2.sceneGraphService.rotateLocal(this, x3, y3, z);
            }
            return this;
          }
        }, {
          key: "rotate",
          value: function rotate3(x3, y3, z) {
            if (util.isNil(y3) && util.isNil(z)) {
              runtime2.sceneGraphService.rotate(this, 0, 0, x3);
            } else {
              runtime2.sceneGraphService.rotate(this, x3, y3, z);
            }
            return this;
          }
        }, {
          key: "setRotation",
          value: function setRotation(rotation, y3, z, w) {
            runtime2.sceneGraphService.setRotation(this, rotation, y3, z, w);
            return this;
          }
        }, {
          key: "setLocalRotation",
          value: function setLocalRotation(rotation, y3, z, w) {
            runtime2.sceneGraphService.setLocalRotation(this, rotation, y3, z, w);
            return this;
          }
        }, {
          key: "setLocalSkew",
          value: function setLocalSkew(skew2, y3) {
            runtime2.sceneGraphService.setLocalSkew(this, skew2, y3);
            return this;
          }
        }, {
          key: "getRotation",
          value: function getRotation() {
            return runtime2.sceneGraphService.getRotation(this);
          }
        }, {
          key: "getLocalRotation",
          value: function getLocalRotation() {
            return runtime2.sceneGraphService.getLocalRotation(this);
          }
        }, {
          key: "getLocalSkew",
          value: function getLocalSkew() {
            return runtime2.sceneGraphService.getLocalSkew(this);
          }
        }, {
          key: "getLocalTransform",
          value: function getLocalTransform() {
            return runtime2.sceneGraphService.getLocalTransform(this);
          }
        }, {
          key: "getWorldTransform",
          value: function getWorldTransform() {
            return runtime2.sceneGraphService.getWorldTransform(this);
          }
        }, {
          key: "setLocalTransform",
          value: function setLocalTransform(transform) {
            runtime2.sceneGraphService.setLocalTransform(this, transform);
            return this;
          }
        }, {
          key: "resetLocalTransform",
          value: function resetLocalTransform() {
            runtime2.sceneGraphService.resetLocalTransform(this);
          }
          // #endregion transformable
          // #region animatable
          /**
           * returns an array of all Animation objects affecting this element
           * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAnimations
           */
        }, {
          key: "getAnimations",
          value: function getAnimations() {
            return this.activeAnimations;
          }
          /**
           * create an animation with WAAPI
           * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/animate
           */
        }, {
          key: "animate",
          value: function animate2(keyframes, options) {
            var _this$ownerDocument;
            var timeline = (_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : _this$ownerDocument.timeline;
            if (timeline) {
              return timeline.play(this, keyframes, options);
            }
            return null;
          }
          // #endregion animatable
          // #region visible
          /**
           * shortcut for Used value of `visibility`
           */
        }, {
          key: "isVisible",
          value: function isVisible2() {
            var _this$parsedStyle;
            return ((_this$parsedStyle = this.parsedStyle) === null || _this$parsedStyle === void 0 ? void 0 : _this$parsedStyle.visibility) !== "hidden";
          }
        }, {
          key: "interactive",
          get: function get9() {
            return this.isInteractive();
          },
          set: function set6(b) {
            this.style.pointerEvents = b ? "auto" : "none";
          }
        }, {
          key: "isInteractive",
          value: function isInteractive() {
            var _this$parsedStyle2;
            return ((_this$parsedStyle2 = this.parsedStyle) === null || _this$parsedStyle2 === void 0 ? void 0 : _this$parsedStyle2.pointerEvents) !== "none";
          }
        }, {
          key: "isCulled",
          value: function isCulled() {
            return !!(this.cullable && this.cullable.enable && !this.cullable.visible);
          }
          /**
           * bring to front in current group
           */
        }, {
          key: "toFront",
          value: function toFront() {
            if (this.parentNode) {
              this.style.zIndex = Math.max.apply(Math, _toConsumableArray2(this.parentNode.children.map(function(child) {
                return Number(child.style.zIndex);
              }))) + 1;
            }
            return this;
          }
          /**
           * send to back in current group
           */
        }, {
          key: "toBack",
          value: function toBack() {
            if (this.parentNode) {
              this.style.zIndex = Math.min.apply(Math, _toConsumableArray2(this.parentNode.children.map(function(child) {
                return Number(child.style.zIndex);
              }))) - 1;
            }
            return this;
          }
          // #endregion visible
          // #region deprecated
          /**
           * compatible with G 3.0
           * @alias object.config
           * @deprecated
           */
        }, {
          key: "getConfig",
          value: function getConfig() {
            return this.config;
          }
          /**
           * @alias style
           * @example
           * circle.style.r = 10;
           * const r = circle.style;
           * @deprecated
           */
        }, {
          key: "attr",
          value: function attr2() {
            var _this2 = this;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            var name = args[0], value = args[1];
            if (!name) {
              return this.attributes;
            }
            if (util.isObject(name)) {
              Object.keys(name).forEach(function(key) {
                _this2.setAttribute(key, name[key]);
              });
              return this;
            }
            if (args.length === 2) {
              this.setAttribute(name, value);
              return this;
            }
            return this.attributes[name];
          }
          /**
           * return 3x3 matrix in world space
           * @deprecated
           */
        }, {
          key: "getMatrix",
          value: function getMatrix(transformMat4) {
            var transform = transformMat4 || this.getWorldTransform();
            var _mat4$getTranslation = glMatrix.mat4.getTranslation($vec32, transform), _mat4$getTranslation2 = _slicedToArray2(_mat4$getTranslation, 2), tx = _mat4$getTranslation2[0], ty = _mat4$getTranslation2[1];
            var _mat4$getScaling = glMatrix.mat4.getScaling($vec32, transform), _mat4$getScaling2 = _slicedToArray2(_mat4$getScaling, 2), sx = _mat4$getScaling2[0], sy = _mat4$getScaling2[1];
            var rotation = glMatrix.mat4.getRotation($quat2, transform);
            var _getEuler5 = getEuler2($vec32, rotation), _getEuler6 = _slicedToArray2(_getEuler5, 3), eux = _getEuler6[0], euz = _getEuler6[2];
            return fromRotationTranslationScale2(eux || euz, tx, ty, sx, sy);
          }
          /**
           * return 3x3 matrix in local space
           * @deprecated
           */
        }, {
          key: "getLocalMatrix",
          value: function getLocalMatrix() {
            return this.getMatrix(this.getLocalTransform());
          }
          /**
           * set 3x3 matrix in world space
           * @deprecated
           */
        }, {
          key: "setMatrix",
          value: function setMatrix(mat) {
            var _decompose = decompose2(mat), _decompose2 = _slicedToArray2(_decompose, 5), tx = _decompose2[0], ty = _decompose2[1], scalingX = _decompose2[2], scalingY = _decompose2[3], angle2 = _decompose2[4];
            this.setEulerAngles(angle2).setPosition(tx, ty).setLocalScale(scalingX, scalingY);
          }
          /**
           * set 3x3 matrix in local space
           * @deprecated
           */
        }, {
          key: "setLocalMatrix",
          value: function setLocalMatrix(mat) {
            var _decompose3 = decompose2(mat), _decompose4 = _slicedToArray2(_decompose3, 5), tx = _decompose4[0], ty = _decompose4[1], scalingX = _decompose4[2], scalingY = _decompose4[3], angle2 = _decompose4[4];
            this.setLocalEulerAngles(angle2).setLocalPosition(tx, ty).setLocalScale(scalingX, scalingY);
          }
          /**
           * Use `visibility: visible` instead.
           * @deprecated
           */
        }, {
          key: "show",
          value: function show2() {
            this.forEach(function(object) {
              object.style.visibility = "visible";
            });
          }
          /**
           * Use `visibility: hidden` instead.
           * @deprecated
           */
        }, {
          key: "hide",
          value: function hide2() {
            this.forEach(function(object) {
              object.style.visibility = "hidden";
            });
          }
          /**
           * Use `childElementCount` instead.
           * @deprecated
           */
        }, {
          key: "getCount",
          value: function getCount() {
            return this.childElementCount;
          }
          /**
           * Use `parentElement` instead.
           * @deprecated
           */
        }, {
          key: "getParent",
          value: function getParent() {
            return this.parentElement;
          }
          /**
           * Use `children` instead.
           * @deprecated
           */
        }, {
          key: "getChildren",
          value: function getChildren() {
            return this.children;
          }
          /**
           * Use `firstElementChild` instead.
           * @deprecated
           */
        }, {
          key: "getFirst",
          value: function getFirst() {
            return this.firstElementChild;
          }
          /**
           * Use `lastElementChild` instead.
           * @deprecated
           */
        }, {
          key: "getLast",
          value: function getLast() {
            return this.lastElementChild;
          }
          /**
           * Use `this.children[index]` instead.
           * @deprecated
           */
        }, {
          key: "getChildByIndex",
          value: function getChildByIndex(index2) {
            return this.children[index2] || null;
          }
          /**
           * Use `appendChild` instead.
           * @deprecated
           */
        }, {
          key: "add",
          value: function add5(child, index2) {
            return this.appendChild(child, index2);
          }
          /**
           * @deprecated
           */
        }, {
          key: "set",
          value: function set6(name, value) {
            this.config[name] = value;
          }
          /**
           * @deprecated
           */
        }, {
          key: "get",
          value: function get9(name) {
            return this.config[name];
          }
          /**
           * Use `setPosition` instead.
           * @deprecated
           */
        }, {
          key: "moveTo",
          value: function moveTo2(position2) {
            var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            this.setPosition(position2, y3, z);
            return this;
          }
          /**
           * Use `setPosition` instead.
           * @deprecated
           */
        }, {
          key: "move",
          value: function move(position2) {
            var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            this.setPosition(position2, y3, z);
            return this;
          }
          /**
           * Use `this.style.zIndex` instead.
           * @deprecated
           */
        }, {
          key: "setZIndex",
          value: function setZIndex(zIndex) {
            this.style.zIndex = zIndex;
            return this;
          }
          // #endregion deprecated
        }]);
      })(Element3);
      DisplayObject2.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className", "clipPath", "cursor", "display", "draggable", "droppable", "fill", "fillOpacity", "fillRule", "filter", "increasedLineWidthForHitTesting", "lineCap", "lineDash", "lineDashOffset", "lineJoin", "lineWidth", "miterLimit", "hitArea", "offsetDistance", "offsetPath", "offsetX", "offsetY", "opacity", "pointerEvents", "shadowColor", "shadowType", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "stroke", "strokeOpacity", "strokeWidth", "strokeLinecap", "strokeLineJoin", "strokeDasharray", "strokeDashoffset", "transform", "transformOrigin", "textTransform", "visibility", "zIndex"]);
      var Circle4 = /* @__PURE__ */ (function(_DisplayObject) {
        function Circle5() {
          var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          _classCallCheck2(this, Circle5);
          return _callSuper2(this, Circle5, [_objectSpread({
            type: Shape2.CIRCLE
          }, options)]);
        }
        _inherits2(Circle5, _DisplayObject);
        return _createClass2(Circle5);
      })(DisplayObject2);
      Circle4.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray2(DisplayObject2.PARSED_STYLE_LIST), ["cx", "cy", "cz", "r", "isBillboard", "isSizeAttenuation"]));
      var _excluded$62 = ["style"];
      var CustomElement2 = /* @__PURE__ */ (function(_DisplayObject) {
        function CustomElement3() {
          var _this2;
          var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties2(_ref, _excluded$62);
          _classCallCheck2(this, CustomElement3);
          _this2 = _callSuper2(this, CustomElement3, [_objectSpread({
            style
          }, rest)]);
          _this2.isCustomElement = true;
          return _this2;
        }
        _inherits2(CustomElement3, _DisplayObject);
        return _createClass2(CustomElement3);
      })(DisplayObject2);
      CustomElement2.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className", "clipPath", "cursor", "draggable", "droppable", "opacity", "pointerEvents", "transform", "transformOrigin", "zIndex", "visibility"]);
      var Ellipse3 = /* @__PURE__ */ (function(_DisplayObject) {
        function Ellipse4() {
          var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          _classCallCheck2(this, Ellipse4);
          return _callSuper2(this, Ellipse4, [_objectSpread({
            type: Shape2.ELLIPSE
          }, options)]);
        }
        _inherits2(Ellipse4, _DisplayObject);
        return _createClass2(Ellipse4);
      })(DisplayObject2);
      Ellipse3.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray2(DisplayObject2.PARSED_STYLE_LIST), ["cx", "cy", "cz", "rx", "ry", "isBillboard", "isSizeAttenuation"]));
      var Fragment2 = /* @__PURE__ */ (function(_DisplayObject) {
        function Fragment3() {
          _classCallCheck2(this, Fragment3);
          return _callSuper2(this, Fragment3, [{
            type: Shape2.FRAGMENT
          }]);
        }
        _inherits2(Fragment3, _DisplayObject);
        return _createClass2(Fragment3);
      })(DisplayObject2);
      Fragment2.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className"]);
      var Group2 = /* @__PURE__ */ (function(_DisplayObject) {
        function Group3() {
          var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          _classCallCheck2(this, Group3);
          return _callSuper2(this, Group3, [_objectSpread({
            type: Shape2.GROUP
          }, options)]);
        }
        _inherits2(Group3, _DisplayObject);
        return _createClass2(Group3);
      })(DisplayObject2);
      Group2.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className", "clipPath", "cursor", "draggable", "droppable", "opacity", "pointerEvents", "transform", "transformOrigin", "zIndex", "visibility"]);
      var _excluded$52 = ["style"];
      var HTML3 = /* @__PURE__ */ (function(_DisplayObject) {
        function HTML4() {
          var _this2;
          var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties2(_ref, _excluded$52);
          _classCallCheck2(this, HTML4);
          _this2 = _callSuper2(this, HTML4, [_objectSpread({
            type: Shape2.HTML,
            style
          }, rest)]);
          _this2.cullable.enable = false;
          return _this2;
        }
        _inherits2(HTML4, _DisplayObject);
        return _createClass2(HTML4, [{
          key: "getDomElement",
          value: function getDomElement() {
            return this.parsedStyle.$el;
          }
          /**
           * override with $el.getBoundingClientRect
           * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect
           *
           * ! The calculation logic of the html element should be consistent with that of the canvas element
           */
          // getBoundingClientRect(): Rectangle {
          //   if (this.parsedStyle.$el) {
          //     return this.parsedStyle.$el.getBoundingClientRect();
          //   } else {
          //     const { x, y, width, height } = this.parsedStyle;
          //     return new Rectangle(x, y, width, height);
          //   }
          // }
        }, {
          key: "getClientRects",
          value: function getClientRects() {
            return [this.getBoundingClientRect()];
          }
          // getBounds() {
          //   const clientRect = this.getBoundingClientRect();
          //   // calc context's offset
          //   // @ts-ignore
          //   const canvasRect = this.ownerDocument?.defaultView
          //     ?.getContextService()
          //     .getBoundingClientRect();
          //   const aabb = new AABB();
          //   const minX = clientRect.left - (canvasRect?.left || 0);
          //   const minY = clientRect.top - (canvasRect?.top || 0);
          //   aabb.setMinMax(
          //     [minX, minY, 0],
          //     [minX + clientRect.width, minY + clientRect.height, 0],
          //   );
          //   return aabb;
          // }
        }, {
          key: "getLocalBounds",
          value: function getLocalBounds() {
            if (this.parentNode) {
              var parentInvert = glMatrix.mat4.invert(glMatrix.mat4.create(), this.parentNode.getWorldTransform());
              var bounds = this.getBounds();
              if (!AABB2.isEmpty(bounds)) {
                var localBounds = new AABB2();
                localBounds.setFromTransformedAABB(bounds, parentInvert);
                return localBounds;
              }
            }
            return this.getBounds();
          }
        }]);
      })(DisplayObject2);
      HTML3.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray2(DisplayObject2.PARSED_STYLE_LIST), ["x", "y", "$el", "innerHTML", "width", "height"]));
      var Image6 = /* @__PURE__ */ (function(_DisplayObject) {
        function Image7() {
          var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          _classCallCheck2(this, Image7);
          return _callSuper2(this, Image7, [_objectSpread({
            type: Shape2.IMAGE
          }, options)]);
        }
        _inherits2(Image7, _DisplayObject);
        return _createClass2(Image7);
      })(DisplayObject2);
      Image6.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray2(DisplayObject2.PARSED_STYLE_LIST), ["x", "y", "z", "src", "width", "height", "isBillboard", "billboardRotation", "isSizeAttenuation", "keepAspectRatio"]));
      var _excluded$42 = ["style"];
      var Line4 = /* @__PURE__ */ (function(_DisplayObject) {
        function Line5() {
          var _this2;
          var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties2(_ref, _excluded$42);
          _classCallCheck2(this, Line5);
          _this2 = _callSuper2(this, Line5, [_objectSpread({
            type: Shape2.LINE,
            style: _objectSpread({
              x1: 0,
              y1: 0,
              x2: 0,
              y2: 0,
              z1: 0,
              z2: 0
            }, style)
          }, rest)]);
          _this2.markerStartAngle = 0;
          _this2.markerEndAngle = 0;
          var _this$parsedStyle = _this2.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd;
          if (markerStart && isDisplayObject2(markerStart)) {
            _this2.markerStartAngle = markerStart.getLocalEulerAngles();
            _this2.appendChild(markerStart);
          }
          if (markerEnd && isDisplayObject2(markerEnd)) {
            _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
            _this2.appendChild(markerEnd);
          }
          _this2.transformMarker(true);
          _this2.transformMarker(false);
          return _this2;
        }
        _inherits2(Line5, _DisplayObject);
        return _createClass2(Line5, [{
          key: "attributeChangedCallback",
          value: function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
            if (attrName === "x1" || attrName === "y1" || attrName === "x2" || attrName === "y2" || attrName === "markerStartOffset" || attrName === "markerEndOffset") {
              this.transformMarker(true);
              this.transformMarker(false);
            } else if (attrName === "markerStart") {
              if (prevParsedValue && isDisplayObject2(prevParsedValue)) {
                this.markerStartAngle = 0;
                prevParsedValue.remove();
              }
              if (newParsedValue && isDisplayObject2(newParsedValue)) {
                this.markerStartAngle = newParsedValue.getLocalEulerAngles();
                this.appendChild(newParsedValue);
                this.transformMarker(true);
              }
            } else if (attrName === "markerEnd") {
              if (prevParsedValue && isDisplayObject2(prevParsedValue)) {
                this.markerEndAngle = 0;
                prevParsedValue.remove();
              }
              if (newParsedValue && isDisplayObject2(newParsedValue)) {
                this.markerEndAngle = newParsedValue.getLocalEulerAngles();
                this.appendChild(newParsedValue);
                this.transformMarker(false);
              }
            }
          }
        }, {
          key: "transformMarker",
          value: function transformMarker(isStart) {
            var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset, x1 = _this$parsedStyle2.x1, x22 = _this$parsedStyle2.x2, y1 = _this$parsedStyle2.y1, y22 = _this$parsedStyle2.y2;
            var marker = isStart ? markerStart : markerEnd;
            if (!marker || !isDisplayObject2(marker)) {
              return;
            }
            var rad2 = 0;
            var x3;
            var y3;
            var ox;
            var oy;
            var offset;
            var originalAngle;
            if (isStart) {
              ox = x1;
              oy = y1;
              x3 = x22 - x1;
              y3 = y22 - y1;
              offset = markerStartOffset || 0;
              originalAngle = this.markerStartAngle;
            } else {
              ox = x22;
              oy = y22;
              x3 = x1 - x22;
              y3 = y1 - y22;
              offset = markerEndOffset || 0;
              originalAngle = this.markerEndAngle;
            }
            rad2 = Math.atan2(y3, x3);
            marker.setLocalEulerAngles(rad2 * 180 / Math.PI + originalAngle);
            marker.setLocalPosition(ox + Math.cos(rad2) * offset, oy + Math.sin(rad2) * offset);
          }
        }, {
          key: "getPoint",
          value: function getPoint(ratio) {
            var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            var _this$parsedStyle3 = this.parsedStyle, x1 = _this$parsedStyle3.x1, y1 = _this$parsedStyle3.y1, x22 = _this$parsedStyle3.x2, y22 = _this$parsedStyle3.y2;
            var _linePointAt = gMath.linePointAt(x1, y1, x22, y22, ratio), x3 = _linePointAt.x, y3 = _linePointAt.y;
            var transformed = glMatrix.vec3.transformMat4(glMatrix.vec3.create(), glMatrix.vec3.fromValues(x3, y3, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
            return new Point2(transformed[0], transformed[1]);
          }
        }, {
          key: "getPointAtLength",
          value: function getPointAtLength2(distance6) {
            var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            return this.getPoint(distance6 / this.getTotalLength(), inWorldSpace);
          }
        }, {
          key: "getTotalLength",
          value: function getTotalLength2() {
            var _this$parsedStyle4 = this.parsedStyle, x1 = _this$parsedStyle4.x1, y1 = _this$parsedStyle4.y1, x22 = _this$parsedStyle4.x2, y22 = _this$parsedStyle4.y2;
            return gMath.lineLength(x1, y1, x22, y22);
          }
        }]);
      })(DisplayObject2);
      Line4.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray2(DisplayObject2.PARSED_STYLE_LIST), ["x1", "y1", "x2", "y2", "z1", "z2", "isBillboard", "isSizeAttenuation", "markerStart", "markerEnd", "markerStartOffset", "markerEndOffset"]));
      var _excluded$32 = ["style"];
      var Path2 = /* @__PURE__ */ (function(_DisplayObject) {
        function Path3() {
          var _this2;
          var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties2(_ref, _excluded$32);
          _classCallCheck2(this, Path3);
          _this2 = _callSuper2(this, Path3, [_objectSpread({
            type: Shape2.PATH,
            style,
            initialParsedStyle: {
              miterLimit: 4,
              d: _objectSpread({}, EMPTY_PARSED_PATH2)
            }
          }, rest)]);
          _this2.markerStartAngle = 0;
          _this2.markerEndAngle = 0;
          _this2.markerMidList = [];
          var _this$parsedStyle = _this2.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd, markerMid = _this$parsedStyle.markerMid;
          if (markerStart && isDisplayObject2(markerStart)) {
            _this2.markerStartAngle = markerStart.getLocalEulerAngles();
            _this2.appendChild(markerStart);
          }
          if (markerMid && isDisplayObject2(markerMid)) {
            _this2.placeMarkerMid(markerMid);
          }
          if (markerEnd && isDisplayObject2(markerEnd)) {
            _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
            _this2.appendChild(markerEnd);
          }
          _this2.transformMarker(true);
          _this2.transformMarker(false);
          return _this2;
        }
        _inherits2(Path3, _DisplayObject);
        return _createClass2(Path3, [{
          key: "attributeChangedCallback",
          value: function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
            if (attrName === "d") {
              this.transformMarker(true);
              this.transformMarker(false);
              this.placeMarkerMid(this.parsedStyle.markerMid);
            } else if (attrName === "markerStartOffset" || attrName === "markerEndOffset") {
              this.transformMarker(true);
              this.transformMarker(false);
            } else if (attrName === "markerStart") {
              if (prevParsedValue && isDisplayObject2(prevParsedValue)) {
                this.markerStartAngle = 0;
                prevParsedValue.remove();
              }
              if (newParsedValue && isDisplayObject2(newParsedValue)) {
                this.markerStartAngle = newParsedValue.getLocalEulerAngles();
                this.appendChild(newParsedValue);
                this.transformMarker(true);
              }
            } else if (attrName === "markerEnd") {
              if (prevParsedValue && isDisplayObject2(prevParsedValue)) {
                this.markerEndAngle = 0;
                prevParsedValue.remove();
              }
              if (newParsedValue && isDisplayObject2(newParsedValue)) {
                this.markerEndAngle = newParsedValue.getLocalEulerAngles();
                this.appendChild(newParsedValue);
                this.transformMarker(false);
              }
            } else if (attrName === "markerMid") {
              this.placeMarkerMid(newParsedValue);
            }
          }
        }, {
          key: "transformMarker",
          value: function transformMarker(isStart) {
            var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset;
            var marker = isStart ? markerStart : markerEnd;
            if (!marker || !isDisplayObject2(marker)) {
              return;
            }
            var rad2 = 0;
            var x3;
            var y3;
            var ox;
            var oy;
            var offset;
            var originalAngle;
            if (isStart) {
              var _this$getStartTangent = this.getStartTangent(), _this$getStartTangent2 = _slicedToArray2(_this$getStartTangent, 2), p1 = _this$getStartTangent2[0], p2 = _this$getStartTangent2[1];
              ox = p2[0];
              oy = p2[1];
              x3 = p1[0] - p2[0];
              y3 = p1[1] - p2[1];
              offset = markerStartOffset || 0;
              originalAngle = this.markerStartAngle;
            } else {
              var _this$getEndTangent = this.getEndTangent(), _this$getEndTangent2 = _slicedToArray2(_this$getEndTangent, 2), _p = _this$getEndTangent2[0], _p2 = _this$getEndTangent2[1];
              ox = _p2[0];
              oy = _p2[1];
              x3 = _p[0] - _p2[0];
              y3 = _p[1] - _p2[1];
              offset = markerEndOffset || 0;
              originalAngle = this.markerEndAngle;
            }
            rad2 = Math.atan2(y3, x3);
            marker.setLocalEulerAngles(rad2 * 180 / Math.PI + originalAngle);
            marker.setLocalPosition(ox + Math.cos(rad2) * offset, oy + Math.sin(rad2) * offset);
          }
        }, {
          key: "placeMarkerMid",
          value: function placeMarkerMid(marker) {
            var segments = this.parsedStyle.d.segments;
            this.markerMidList.forEach(function(marker2) {
              marker2.remove();
            });
            if (marker && isDisplayObject2(marker)) {
              for (var i = 1; i < segments.length - 1; i++) {
                var _segments$i$currentPo = _slicedToArray2(segments[i].currentPoint, 2), ox = _segments$i$currentPo[0], oy = _segments$i$currentPo[1];
                var cloned = i === 1 ? marker : marker.cloneNode(true);
                this.markerMidList.push(cloned);
                this.appendChild(cloned);
                cloned.setLocalPosition(ox, oy);
              }
            }
          }
          /**
           * Returns the total length of the path.
           * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getTotalLength
           */
        }, {
          key: "getTotalLength",
          value: function getTotalLength2() {
            return getOrCalculatePathTotalLength2(this);
          }
          /**
           * Returns the point at a given distance along the path.
           * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getPointAtLength
           */
        }, {
          key: "getPointAtLength",
          value: function getPointAtLength2(distance6) {
            var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            var absolutePath = this.parsedStyle.d.absolutePath;
            var _getPointAtLength2 = util.getPointAtLength(absolutePath, distance6), x3 = _getPointAtLength2.x, y3 = _getPointAtLength2.y;
            var transformed = glMatrix.vec3.transformMat4(glMatrix.vec3.create(), glMatrix.vec3.fromValues(x3, y3, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
            return new Point2(transformed[0], transformed[1]);
          }
          /**
           * Returns the point at a given ratio of the total length in path.
           */
        }, {
          key: "getPoint",
          value: function getPoint(ratio) {
            var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            return this.getPointAtLength(ratio * getOrCalculatePathTotalLength2(this), inWorldSpace);
          }
          /**
           * Get start tangent vector
           */
        }, {
          key: "getStartTangent",
          value: function getStartTangent() {
            var segments = this.parsedStyle.d.segments;
            var result = [];
            if (segments.length > 1) {
              var startPoint = segments[0].currentPoint;
              var endPoint = segments[1].currentPoint;
              var tangent = segments[1].startTangent;
              result = [];
              if (tangent) {
                result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
                result.push([startPoint[0], startPoint[1]]);
              } else {
                result.push([endPoint[0], endPoint[1]]);
                result.push([startPoint[0], startPoint[1]]);
              }
            }
            return result;
          }
          /**
           * Get end tangent vector
           */
        }, {
          key: "getEndTangent",
          value: function getEndTangent() {
            var segments = this.parsedStyle.d.segments;
            var length = segments.length;
            var result = [];
            if (length > 1) {
              var startPoint = segments[length - 2].currentPoint;
              var endPoint = segments[length - 1].currentPoint;
              var tangent = segments[length - 1].endTangent;
              result = [];
              if (tangent) {
                result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
                result.push([endPoint[0], endPoint[1]]);
              } else {
                result.push([startPoint[0], startPoint[1]]);
                result.push([endPoint[0], endPoint[1]]);
              }
            }
            return result;
          }
        }]);
      })(DisplayObject2);
      Path2.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray2(DisplayObject2.PARSED_STYLE_LIST), ["d", "markerStart", "markerMid", "markerEnd", "markerStartOffset", "markerEndOffset", "isBillboard", "isSizeAttenuation"]));
      var _excluded$22 = ["style"];
      var Polygon3 = /* @__PURE__ */ (function(_DisplayObject) {
        function Polygon4() {
          var _this2;
          var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties2(_ref, _excluded$22);
          _classCallCheck2(this, Polygon4);
          _this2 = _callSuper2(this, Polygon4, [_objectSpread({
            type: Shape2.POLYGON,
            style,
            initialParsedStyle: {
              points: {
                points: [],
                totalLength: 0,
                segments: []
              },
              miterLimit: 4,
              isClosed: true
            }
          }, rest)]);
          _this2.markerStartAngle = 0;
          _this2.markerEndAngle = 0;
          _this2.markerMidList = [];
          var _this$parsedStyle = _this2.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd, markerMid = _this$parsedStyle.markerMid;
          if (markerStart && isDisplayObject2(markerStart)) {
            _this2.markerStartAngle = markerStart.getLocalEulerAngles();
            _this2.appendChild(markerStart);
          }
          if (markerMid && isDisplayObject2(markerMid)) {
            _this2.placeMarkerMid(markerMid);
          }
          if (markerEnd && isDisplayObject2(markerEnd)) {
            _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
            _this2.appendChild(markerEnd);
          }
          _this2.transformMarker(true);
          _this2.transformMarker(false);
          return _this2;
        }
        _inherits2(Polygon4, _DisplayObject);
        return _createClass2(Polygon4, [{
          key: "attributeChangedCallback",
          value: function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
            if (attrName === "points") {
              this.transformMarker(true);
              this.transformMarker(false);
              this.placeMarkerMid(this.parsedStyle.markerMid);
            } else if (attrName === "markerStartOffset" || attrName === "markerEndOffset") {
              this.transformMarker(true);
              this.transformMarker(false);
            } else if (attrName === "markerStart") {
              if (prevParsedValue && isDisplayObject2(prevParsedValue)) {
                this.markerStartAngle = 0;
                prevParsedValue.remove();
              }
              if (newParsedValue && isDisplayObject2(newParsedValue)) {
                this.markerStartAngle = newParsedValue.getLocalEulerAngles();
                this.appendChild(newParsedValue);
                this.transformMarker(true);
              }
            } else if (attrName === "markerEnd") {
              if (prevParsedValue && isDisplayObject2(prevParsedValue)) {
                this.markerEndAngle = 0;
                prevParsedValue.remove();
              }
              if (newParsedValue && isDisplayObject2(newParsedValue)) {
                this.markerEndAngle = newParsedValue.getLocalEulerAngles();
                this.appendChild(newParsedValue);
                this.transformMarker(false);
              }
            } else if (attrName === "markerMid") {
              this.placeMarkerMid(newParsedValue);
            }
          }
        }, {
          key: "transformMarker",
          value: function transformMarker(isStart) {
            var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset, P = _this$parsedStyle2.points;
            var _ref2 = P || {}, points = _ref2.points;
            var marker = isStart ? markerStart : markerEnd;
            if (!marker || !isDisplayObject2(marker) || !points) {
              return;
            }
            var rad2 = 0;
            var x3;
            var y3;
            var ox;
            var oy;
            var offset;
            var originalAngle;
            ox = points[0][0];
            oy = points[0][1];
            if (isStart) {
              x3 = points[1][0] - points[0][0];
              y3 = points[1][1] - points[0][1];
              offset = markerStartOffset || 0;
              originalAngle = this.markerStartAngle;
            } else {
              var length = points.length;
              if (!this.parsedStyle.isClosed) {
                ox = points[length - 1][0];
                oy = points[length - 1][1];
                x3 = points[length - 2][0] - points[length - 1][0];
                y3 = points[length - 2][1] - points[length - 1][1];
              } else {
                x3 = points[length - 1][0] - points[0][0];
                y3 = points[length - 1][1] - points[0][1];
              }
              offset = markerEndOffset || 0;
              originalAngle = this.markerEndAngle;
            }
            rad2 = Math.atan2(y3, x3);
            marker.setLocalEulerAngles(rad2 * 180 / Math.PI + originalAngle);
            marker.setLocalPosition(ox + Math.cos(rad2) * offset, oy + Math.sin(rad2) * offset);
          }
        }, {
          key: "placeMarkerMid",
          value: function placeMarkerMid(marker) {
            var P = this.parsedStyle.points;
            var _ref3 = P || {}, points = _ref3.points;
            this.markerMidList.forEach(function(marker2) {
              marker2.remove();
            });
            this.markerMidList = [];
            if (marker && isDisplayObject2(marker) && points) {
              for (var i = 1; i < (this.parsedStyle.isClosed ? points.length : points.length - 1); i++) {
                var ox = points[i][0];
                var oy = points[i][1];
                var cloned = i === 1 ? marker : marker.cloneNode(true);
                this.markerMidList.push(cloned);
                this.appendChild(cloned);
                cloned.setLocalPosition(ox, oy);
              }
            }
          }
        }]);
      })(DisplayObject2);
      Polygon3.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray2(DisplayObject2.PARSED_STYLE_LIST), ["points", "markerStart", "markerMid", "markerEnd", "markerStartOffset", "markerEndOffset", "isClosed", "isBillboard", "isSizeAttenuation"]));
      var _excluded$12 = ["style"];
      var Polyline3 = /* @__PURE__ */ (function(_Polygon) {
        function Polyline4() {
          var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties2(_ref, _excluded$12);
          _classCallCheck2(this, Polyline4);
          return _callSuper2(this, Polyline4, [_objectSpread({
            type: Shape2.POLYLINE,
            style,
            initialParsedStyle: {
              points: {
                points: [],
                totalLength: 0,
                segments: []
              },
              miterLimit: 4,
              isClosed: false
            }
          }, rest)]);
        }
        _inherits2(Polyline4, _Polygon);
        return _createClass2(Polyline4, [{
          key: "getTotalLength",
          value: function getTotalLength2() {
            return getOrCalculatePolylineTotalLength2(this);
          }
        }, {
          key: "getPointAtLength",
          value: function getPointAtLength2(distance6) {
            var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            return this.getPoint(distance6 / this.getTotalLength(), inWorldSpace);
          }
        }, {
          key: "getPoint",
          value: function getPoint(ratio) {
            var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            var points = this.parsedStyle.points.points;
            if (this.parsedStyle.points.segments.length === 0) {
              var segments = [];
              var tempLength = 0;
              var segmentT;
              var segmentL;
              var totalLength = this.getTotalLength();
              points.forEach(function(p, i) {
                if (points[i + 1]) {
                  segmentT = [0, 0];
                  segmentT[0] = tempLength / totalLength;
                  segmentL = gMath.lineLength(p[0], p[1], points[i + 1][0], points[i + 1][1]);
                  tempLength += segmentL;
                  segmentT[1] = tempLength / totalLength;
                  segments.push(segmentT);
                }
              });
              this.parsedStyle.points.segments = segments;
            }
            var subt = 0;
            var index2 = 0;
            this.parsedStyle.points.segments.forEach(function(v, i) {
              if (ratio >= v[0] && ratio <= v[1]) {
                subt = (ratio - v[0]) / (v[1] - v[0]);
                index2 = i;
              }
            });
            var _linePointAt = gMath.linePointAt(points[index2][0], points[index2][1], points[index2 + 1][0], points[index2 + 1][1], subt), x3 = _linePointAt.x, y3 = _linePointAt.y;
            var transformed = glMatrix.vec3.transformMat4(glMatrix.vec3.create(), glMatrix.vec3.fromValues(x3, y3, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
            return new Point2(transformed[0], transformed[1]);
          }
        }, {
          key: "getStartTangent",
          value: function getStartTangent() {
            var points = this.parsedStyle.points.points;
            var result = [];
            result.push([points[1][0], points[1][1]]);
            result.push([points[0][0], points[0][1]]);
            return result;
          }
        }, {
          key: "getEndTangent",
          value: function getEndTangent() {
            var points = this.parsedStyle.points.points;
            var l = points.length - 1;
            var result = [];
            result.push([points[l - 1][0], points[l - 1][1]]);
            result.push([points[l][0], points[l][1]]);
            return result;
          }
        }]);
      })(Polygon3);
      Polyline3.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray2(Polygon3.PARSED_STYLE_LIST), ["points", "markerStart", "markerMid", "markerEnd", "markerStartOffset", "markerEndOffset", "isBillboard"]));
      var Rect3 = /* @__PURE__ */ (function(_DisplayObject) {
        function Rect4() {
          var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          _classCallCheck2(this, Rect4);
          return _callSuper2(this, Rect4, [_objectSpread({
            type: Shape2.RECT
          }, options)]);
        }
        _inherits2(Rect4, _DisplayObject);
        return _createClass2(Rect4);
      })(DisplayObject2);
      Rect3.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray2(DisplayObject2.PARSED_STYLE_LIST), ["x", "y", "z", "width", "height", "isBillboard", "isSizeAttenuation", "radius"]));
      var _excluded2 = ["style"];
      var Text3 = /* @__PURE__ */ (function(_DisplayObject) {
        function Text4() {
          var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties2(_ref, _excluded2);
          _classCallCheck2(this, Text4);
          return _callSuper2(this, Text4, [_objectSpread({
            type: Shape2.TEXT,
            style: _objectSpread({
              fill: "black"
            }, style)
          }, rest)]);
        }
        _inherits2(Text4, _DisplayObject);
        return _createClass2(Text4, [{
          key: "getComputedTextLength",
          value: function getComputedTextLength() {
            var _this$parsedStyle$met;
            this.getGeometryBounds();
            return ((_this$parsedStyle$met = this.parsedStyle.metrics) === null || _this$parsedStyle$met === void 0 ? void 0 : _this$parsedStyle$met.maxLineWidth) || 0;
          }
        }, {
          key: "getLineBoundingRects",
          value: function getLineBoundingRects() {
            var _this$parsedStyle$met2;
            this.getGeometryBounds();
            return ((_this$parsedStyle$met2 = this.parsedStyle.metrics) === null || _this$parsedStyle$met2 === void 0 ? void 0 : _this$parsedStyle$met2.lineMetrics) || [];
          }
        }, {
          key: "isOverflowing",
          value: function isOverflowing() {
            this.getGeometryBounds();
            return !!this.parsedStyle.isOverflowing;
          }
        }]);
      })(DisplayObject2);
      Text3.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray2(DisplayObject2.PARSED_STYLE_LIST), ["x", "y", "z", "isBillboard", "billboardRotation", "isSizeAttenuation", "text", "textAlign", "textBaseline", "fontStyle", "fontSize", "fontFamily", "fontWeight", "fontVariant", "lineHeight", "letterSpacing", "leading", "wordWrap", "wordWrapWidth", "maxLines", "textOverflow", "isOverflowing", "textPath", "textDecorationLine", "textDecorationColor", "textDecorationStyle", "textPathSide", "textPathStartOffset", "metrics", "dx", "dy"]));
      var CustomElementRegistry2 = /* @__PURE__ */ (function() {
        function CustomElementRegistry3() {
          _classCallCheck2(this, CustomElementRegistry3);
          this.registry = {};
          this.define(Shape2.CIRCLE, Circle4);
          this.define(Shape2.ELLIPSE, Ellipse3);
          this.define(Shape2.RECT, Rect3);
          this.define(Shape2.IMAGE, Image6);
          this.define(Shape2.LINE, Line4);
          this.define(Shape2.GROUP, Group2);
          this.define(Shape2.PATH, Path2);
          this.define(Shape2.POLYGON, Polygon3);
          this.define(Shape2.POLYLINE, Polyline3);
          this.define(Shape2.TEXT, Text3);
          this.define(Shape2.HTML, HTML3);
        }
        return _createClass2(CustomElementRegistry3, [{
          key: "define",
          value: function define4(name, constructor) {
            this.registry[name] = constructor;
          }
          /**
           * @see https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/get
           */
        }, {
          key: "get",
          value: function get9(name) {
            return this.registry[name];
          }
        }]);
      })();
      var CSS = {
        /**
         * <number>
         * @see https://drafts.csswg.org/css-values-4/#number-value
         */
        number: function number(n) {
          return new CSSUnitValue2(n);
        },
        /**
         * <percentage>
         * @see https://drafts.csswg.org/css-values-4/#percentage-value
         */
        percent: function percent(n) {
          return new CSSUnitValue2(n, "%");
        },
        /**
         * <length>
         */
        px: function px(n) {
          return new CSSUnitValue2(n, "px");
        },
        /**
         * <length>
         */
        em: function em(n) {
          return new CSSUnitValue2(n, "em");
        },
        rem: function rem(n) {
          return new CSSUnitValue2(n, "rem");
        },
        /**
         * <angle>
         */
        deg: function deg(n) {
          return new CSSUnitValue2(n, "deg");
        },
        /**
         * <angle>
         */
        grad: function grad(n) {
          return new CSSUnitValue2(n, "grad");
        },
        /**
         * <angle>
         */
        rad: function rad2(n) {
          return new CSSUnitValue2(n, "rad");
        },
        /**
         * <angle>
         */
        turn: function turn(n) {
          return new CSSUnitValue2(n, "turn");
        },
        /**
         * <time>
         */
        s: function s(n) {
          return new CSSUnitValue2(n, "s");
        },
        /**
         * <time>
         */
        ms: function ms(n) {
          return new CSSUnitValue2(n, "ms");
        },
        /**
         * CSS Properties & Values API
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS_Properties_and_Values_API
         * @see https://drafts.css-houdini.org/css-properties-values-api/#registering-custom-properties
         * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS/RegisterProperty
         */
        registerProperty: function registerProperty(definition) {
          var name = definition.name, inherits = definition.inherits, interpolable = definition.interpolable, initialValue = definition.initialValue, syntax = definition.syntax;
          runtime2.styleValueRegistry.registerMetadata({
            n: name,
            inh: inherits,
            "int": interpolable,
            d: initialValue,
            syntax
          });
        },
        /**
         * CSS Layout API
         * register layout
         *
         * @see https://github.com/w3c/css-houdini-drafts/blob/main/css-layout-api/EXPLAINER.md
         * @see https://developer.mozilla.org/en-US/docs/Web/Guide/Houdini#css_layout_api
         */
        registerLayout: function registerLayout(name, clazz) {
          runtime2.layoutRegistry.registerLayout(name, clazz);
        }
      };
      var Document3 = /* @__PURE__ */ (function(_Node) {
        function Document4() {
          var _this2;
          _classCallCheck2(this, Document4);
          _this2 = _callSuper2(this, Document4);
          _this2.defaultView = null;
          _this2.ownerDocument = null;
          _this2.nodeName = "document";
          try {
            _this2.timeline = new runtime2.AnimationTimeline(_this2);
          } catch (_unused) {
          }
          var initialStyle = {};
          BUILT_IN_PROPERTIES2.forEach(function(_ref) {
            var n = _ref.n, inh = _ref.inh, d2 = _ref.d;
            if (inh && d2) {
              initialStyle[n] = util.isFunction(d2) ? d2(Shape2.GROUP) : d2;
            }
          });
          _this2.documentElement = new Group2({
            id: "g-root",
            style: initialStyle
          });
          _this2.documentElement.ownerDocument = _this2;
          _this2.documentElement.parentNode = _this2;
          _this2.childNodes = [_this2.documentElement];
          return _this2;
        }
        _inherits2(Document4, _Node);
        return _createClass2(Document4, [{
          key: "children",
          get: function get9() {
            return this.childNodes;
          }
        }, {
          key: "childElementCount",
          get: function get9() {
            return this.childNodes.length;
          }
        }, {
          key: "firstElementChild",
          get: function get9() {
            return this.firstChild;
          }
        }, {
          key: "lastElementChild",
          get: function get9() {
            return this.lastChild;
          }
        }, {
          key: "createElement",
          value: (
            /**
             * @example const circle = document.createElement('circle', { style: { r: 10 } });
             */
            function createElement2(tagName, options) {
              if (tagName === "svg") {
                return this.documentElement;
              }
              var clazz = this.defaultView.customElements.get(tagName);
              if (!clazz) {
                console.warn("Unsupported tagName: ", tagName);
                clazz = tagName === "tspan" ? Text3 : Group2;
              }
              var shape = new clazz(options);
              shape.ownerDocument = this;
              return shape;
            }
          )
        }, {
          key: "createElementNS",
          value: function createElementNS(namespaceURI, tagName, options) {
            return this.createElement(tagName, options);
          }
        }, {
          key: "cloneNode",
          value: function cloneNode(deep2) {
            throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED2);
          }
        }, {
          key: "destroy",
          value: function destroy() {
            try {
              this.documentElement.destroyChildren();
              this.timeline.destroy();
            } catch (_unused2) {
            }
          }
          /**
           * Picking 2D graphics with RBush based on BBox, fast but inaccurate.
           */
        }, {
          key: "elementsFromBBox",
          value: function elementsFromBBox(minX, minY, maxX, maxY) {
            var rBush = this.defaultView.context.rBushRoot;
            var rBushNodes = rBush.search({
              minX,
              minY,
              maxX,
              maxY
            });
            var hitTestList = [];
            rBushNodes.forEach(function(_ref2) {
              var displayObject = _ref2.displayObject;
              var _displayObject$parsed = displayObject.parsedStyle.pointerEvents, pointerEvents = _displayObject$parsed === void 0 ? "auto" : _displayObject$parsed;
              var isVisibilityAffected = ["auto", "visiblepainted", "visiblefill", "visiblestroke", "visible"].includes(pointerEvents);
              if ((!isVisibilityAffected || isVisibilityAffected && displayObject.isVisible()) && !displayObject.isCulled() && displayObject.isInteractive()) {
                hitTestList.push(displayObject);
              }
            });
            hitTestList.sort(function(a2, b) {
              return b.sortable.renderOrder - a2.sortable.renderOrder;
            });
            return hitTestList;
          }
        }, {
          key: "elementFromPointSync",
          value: function elementFromPointSync(x3, y3) {
            var _this$defaultView$can = this.defaultView.canvas2Viewport({
              x: x3,
              y: y3
            }), viewportX = _this$defaultView$can.x, viewportY = _this$defaultView$can.y;
            var _this$defaultView$get = this.defaultView.getConfig(), width2 = _this$defaultView$get.width, height = _this$defaultView$get.height;
            if (viewportX < 0 || viewportY < 0 || viewportX > width2 || viewportY > height) {
              return null;
            }
            var _this$defaultView$vie = this.defaultView.viewport2Client({
              x: viewportX,
              y: viewportY
            }), clientX = _this$defaultView$vie.x, clientY = _this$defaultView$vie.y;
            var _this$defaultView$get2 = this.defaultView.getRenderingService().hooks.pickSync.call({
              topmost: true,
              position: {
                x: x3,
                y: y3,
                viewportX,
                viewportY,
                clientX,
                clientY
              },
              picked: []
            }), picked = _this$defaultView$get2.picked;
            return picked && picked[0] || this.documentElement;
          }
          /**
           * Do picking with API instead of triggering interactive events.
           *
           * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementFromPoint
           */
        }, {
          key: "elementFromPoint",
          value: (function() {
            var _elementFromPoint = _asyncToGenerator2(/* @__PURE__ */ _regeneratorRuntime2().mark(function _callee(x3, y3) {
              var _this$defaultView$can2, viewportX, viewportY, _this$defaultView$get3, width2, height, _this$defaultView$vie2, clientX, clientY, _yield$this$defaultVi, picked;
              return _regeneratorRuntime2().wrap(function(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    _this$defaultView$can2 = this.defaultView.canvas2Viewport({
                      x: x3,
                      y: y3
                    }), viewportX = _this$defaultView$can2.x, viewportY = _this$defaultView$can2.y;
                    _this$defaultView$get3 = this.defaultView.getConfig(), width2 = _this$defaultView$get3.width, height = _this$defaultView$get3.height;
                    if (!(viewportX < 0 || viewportY < 0 || viewportX > width2 || viewportY > height)) {
                      _context.next = 1;
                      break;
                    }
                    return _context.abrupt("return", null);
                  case 1:
                    _this$defaultView$vie2 = this.defaultView.viewport2Client({
                      x: viewportX,
                      y: viewportY
                    }), clientX = _this$defaultView$vie2.x, clientY = _this$defaultView$vie2.y;
                    _context.next = 2;
                    return this.defaultView.getRenderingService().hooks.pick.promise({
                      topmost: true,
                      position: {
                        x: x3,
                        y: y3,
                        viewportX,
                        viewportY,
                        clientX,
                        clientY
                      },
                      picked: []
                    });
                  case 2:
                    _yield$this$defaultVi = _context.sent;
                    picked = _yield$this$defaultVi.picked;
                    return _context.abrupt("return", picked && picked[0] || this.documentElement);
                  case 3:
                  case "end":
                    return _context.stop();
                }
              }, _callee, this);
            }));
            function elementFromPoint(_x, _x2) {
              return _elementFromPoint.apply(this, arguments);
            }
            return elementFromPoint;
          })()
        }, {
          key: "elementsFromPointSync",
          value: function elementsFromPointSync(x3, y3) {
            var _this$defaultView$can3 = this.defaultView.canvas2Viewport({
              x: x3,
              y: y3
            }), viewportX = _this$defaultView$can3.x, viewportY = _this$defaultView$can3.y;
            var _this$defaultView$get4 = this.defaultView.getConfig(), width2 = _this$defaultView$get4.width, height = _this$defaultView$get4.height;
            if (viewportX < 0 || viewportY < 0 || viewportX > width2 || viewportY > height) {
              return [];
            }
            var _this$defaultView$vie3 = this.defaultView.viewport2Client({
              x: viewportX,
              y: viewportY
            }), clientX = _this$defaultView$vie3.x, clientY = _this$defaultView$vie3.y;
            var _this$defaultView$get5 = this.defaultView.getRenderingService().hooks.pickSync.call({
              topmost: false,
              position: {
                x: x3,
                y: y3,
                viewportX,
                viewportY,
                clientX,
                clientY
              },
              picked: []
            }), picked = _this$defaultView$get5.picked;
            if (picked[picked.length - 1] !== this.documentElement) {
              picked.push(this.documentElement);
            }
            return picked;
          }
          /**
           * Do picking with API instead of triggering interactive events.
           *
           * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementsFromPoint
           */
        }, {
          key: "elementsFromPoint",
          value: (function() {
            var _elementsFromPoint = _asyncToGenerator2(/* @__PURE__ */ _regeneratorRuntime2().mark(function _callee2(x3, y3) {
              var _this$defaultView$can4, viewportX, viewportY, _this$defaultView$get6, width2, height, _this$defaultView$vie4, clientX, clientY, _yield$this$defaultVi2, picked;
              return _regeneratorRuntime2().wrap(function(_context2) {
                while (1) switch (_context2.prev = _context2.next) {
                  case 0:
                    _this$defaultView$can4 = this.defaultView.canvas2Viewport({
                      x: x3,
                      y: y3
                    }), viewportX = _this$defaultView$can4.x, viewportY = _this$defaultView$can4.y;
                    _this$defaultView$get6 = this.defaultView.getConfig(), width2 = _this$defaultView$get6.width, height = _this$defaultView$get6.height;
                    if (!(viewportX < 0 || viewportY < 0 || viewportX > width2 || viewportY > height)) {
                      _context2.next = 1;
                      break;
                    }
                    return _context2.abrupt("return", []);
                  case 1:
                    _this$defaultView$vie4 = this.defaultView.viewport2Client({
                      x: viewportX,
                      y: viewportY
                    }), clientX = _this$defaultView$vie4.x, clientY = _this$defaultView$vie4.y;
                    _context2.next = 2;
                    return this.defaultView.getRenderingService().hooks.pick.promise({
                      topmost: false,
                      position: {
                        x: x3,
                        y: y3,
                        viewportX,
                        viewportY,
                        clientX,
                        clientY
                      },
                      picked: []
                    });
                  case 2:
                    _yield$this$defaultVi2 = _context2.sent;
                    picked = _yield$this$defaultVi2.picked;
                    if (picked[picked.length - 1] !== this.documentElement) {
                      picked.push(this.documentElement);
                    }
                    return _context2.abrupt("return", picked);
                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }, _callee2, this);
            }));
            function elementsFromPoint(_x3, _x4) {
              return _elementsFromPoint.apply(this, arguments);
            }
            return elementsFromPoint;
          })()
        }, {
          key: "appendChild",
          value: function appendChild(newChild, index2) {
            throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT2);
          }
        }, {
          key: "insertBefore",
          value: function insertBefore(newChild, refChild) {
            throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT2);
          }
        }, {
          key: "removeChild",
          value: function removeChild(oldChild, destroy) {
            throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT2);
          }
        }, {
          key: "replaceChild",
          value: function replaceChild(newChild, oldChild, destroy) {
            throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT2);
          }
        }, {
          key: "append",
          value: function append() {
            throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT2);
          }
        }, {
          key: "prepend",
          value: function prepend() {
            throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT2);
          }
          /**
           * Execute query on documentElement.
           */
        }, {
          key: "getElementById",
          value: function getElementById(id4) {
            return this.documentElement.getElementById(id4);
          }
        }, {
          key: "getElementsByName",
          value: function getElementsByName(name) {
            return this.documentElement.getElementsByName(name);
          }
        }, {
          key: "getElementsByTagName",
          value: function getElementsByTagName(tagName) {
            return this.documentElement.getElementsByTagName(tagName);
          }
        }, {
          key: "getElementsByClassName",
          value: function getElementsByClassName(className) {
            return this.documentElement.getElementsByClassName(className);
          }
        }, {
          key: "querySelector",
          value: function querySelector(selectors) {
            return this.documentElement.querySelector(selectors);
          }
        }, {
          key: "querySelectorAll",
          value: function querySelectorAll(selectors) {
            return this.documentElement.querySelectorAll(selectors);
          }
        }, {
          key: "find",
          value: function find5(filter) {
            return this.documentElement.find(filter);
          }
        }, {
          key: "findAll",
          value: function findAll(filter) {
            return this.documentElement.findAll(filter);
          }
        }]);
      })(Node3);
      var CullingPlugin2 = /* @__PURE__ */ (function() {
        function CullingPlugin3(strategies) {
          _classCallCheck2(this, CullingPlugin3);
          this.strategies = strategies;
        }
        return _createClass2(CullingPlugin3, [{
          key: "apply",
          value: function apply3(context) {
            var config = context.config, camera = context.camera, renderingService = context.renderingService, renderingContext = context.renderingContext;
            var strategies = this.strategies;
            renderingService.hooks.cull.tap(CullingPlugin3.tag, function(object) {
              if (object) {
                var _config$future;
                var cullable = object.cullable;
                if (strategies.length === 0) {
                  cullable.visible = renderingContext.unculledEntities.indexOf(object.entity) > -1;
                } else {
                  cullable.visible = strategies.every(function(strategy) {
                    return strategy.isVisible(camera, object);
                  });
                }
                if (!object.isCulled() && object.isVisible()) {
                  return object;
                }
                var enableCancelEventPropagation = ((_config$future = config.future) === null || _config$future === void 0 ? void 0 : _config$future.experimentalCancelEventPropagation) === true;
                object.dispatchEvent(new CustomEvent2(ElementEvent2.CULLED), enableCancelEventPropagation, enableCancelEventPropagation);
                return null;
              }
              return object;
            });
            renderingService.hooks.afterRender.tap(CullingPlugin3.tag, function(object) {
              object.cullable.visibilityPlaneMask = -1;
            });
          }
        }]);
      })();
      CullingPlugin2.tag = "Culling";
      var EventPlugin2 = /* @__PURE__ */ (function() {
        function EventPlugin3() {
          var _this2 = this;
          _classCallCheck2(this, EventPlugin3);
          this.autoPreventDefault = false;
          this.rootPointerEvent = new FederatedPointerEvent2(null);
          this.rootWheelEvent = new FederatedWheelEvent2(null);
          this.onPointerMove = function(nativeEvent) {
            var _this$context$renderi;
            var canvas2 = (_this$context$renderi = _this2.context.renderingContext.root) === null || _this$context$renderi === void 0 || (_this$context$renderi = _this$context$renderi.ownerDocument) === null || _this$context$renderi === void 0 ? void 0 : _this$context$renderi.defaultView;
            if (canvas2.supportsTouchEvents && nativeEvent.pointerType === "touch") return;
            var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas2);
            var _iterator = _createForOfIteratorHelper2(normalizedEvents), _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                var normalizedEvent = _step.value;
                var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas2, nativeEvent);
                _this2.context.eventService.mapEvent(event);
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
            _this2.setCursor(_this2.context.eventService.cursor);
          };
          this.onClick = function(nativeEvent) {
            var _this$context$renderi2;
            var canvas2 = (_this$context$renderi2 = _this2.context.renderingContext.root) === null || _this$context$renderi2 === void 0 || (_this$context$renderi2 = _this$context$renderi2.ownerDocument) === null || _this$context$renderi2 === void 0 ? void 0 : _this$context$renderi2.defaultView;
            var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas2);
            var _iterator2 = _createForOfIteratorHelper2(normalizedEvents), _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                var normalizedEvent = _step2.value;
                var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas2, nativeEvent);
                _this2.context.eventService.mapEvent(event);
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
            _this2.setCursor(_this2.context.eventService.cursor);
          };
        }
        return _createClass2(EventPlugin3, [{
          key: "apply",
          value: function apply3(context) {
            var _this2 = this;
            this.context = context;
            var renderingService = context.renderingService;
            var canvas2 = this.context.renderingContext.root.ownerDocument.defaultView;
            this.context.eventService.setPickHandler(function(position2) {
              var _this2$context$render = _this2.context.renderingService.hooks.pickSync.call({
                position: position2,
                picked: [],
                topmost: true
                // we only concern the topmost element
              }), picked = _this2$context$render.picked;
              return picked[0] || null;
            });
            renderingService.hooks.pointerWheel.tap(EventPlugin3.tag, function(nativeEvent) {
              var wheelEvent = _this2.normalizeWheelEvent(nativeEvent);
              _this2.context.eventService.mapEvent(wheelEvent);
            });
            renderingService.hooks.pointerDown.tap(EventPlugin3.tag, function(nativeEvent) {
              if (canvas2.supportsTouchEvents && nativeEvent.pointerType === "touch") return;
              var events = _this2.normalizeToPointerEvent(nativeEvent, canvas2);
              if (_this2.autoPreventDefault && events[0].isNormalized) {
                var cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
                if (cancelable) {
                  nativeEvent.preventDefault();
                }
              }
              var _iterator3 = _createForOfIteratorHelper2(events), _step3;
              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                  var event = _step3.value;
                  var federatedEvent = _this2.bootstrapEvent(_this2.rootPointerEvent, event, canvas2, nativeEvent);
                  _this2.context.eventService.mapEvent(federatedEvent);
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
              _this2.setCursor(_this2.context.eventService.cursor);
            });
            renderingService.hooks.pointerUp.tap(EventPlugin3.tag, function(nativeEvent) {
              if (canvas2.supportsTouchEvents && nativeEvent.pointerType === "touch") return;
              var $element = _this2.context.contextService.getDomElement();
              var isNativeEventFromCanvas = _this2.context.eventService.isNativeEventFromCanvas($element, nativeEvent);
              var outside = !isNativeEventFromCanvas ? "outside" : "";
              var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas2);
              var _iterator4 = _createForOfIteratorHelper2(normalizedEvents), _step4;
              try {
                for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                  var normalizedEvent = _step4.value;
                  var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas2, nativeEvent);
                  event.type += outside;
                  _this2.context.eventService.mapEvent(event);
                }
              } catch (err) {
                _iterator4.e(err);
              } finally {
                _iterator4.f();
              }
              _this2.setCursor(_this2.context.eventService.cursor);
            });
            renderingService.hooks.pointerMove.tap(EventPlugin3.tag, this.onPointerMove);
            renderingService.hooks.pointerOver.tap(EventPlugin3.tag, this.onPointerMove);
            renderingService.hooks.pointerOut.tap(EventPlugin3.tag, this.onPointerMove);
            renderingService.hooks.click.tap(EventPlugin3.tag, this.onClick);
            renderingService.hooks.pointerCancel.tap(EventPlugin3.tag, function(nativeEvent) {
              var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas2);
              var _iterator5 = _createForOfIteratorHelper2(normalizedEvents), _step5;
              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                  var normalizedEvent = _step5.value;
                  var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas2, nativeEvent);
                  _this2.context.eventService.mapEvent(event);
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
              _this2.setCursor(_this2.context.eventService.cursor);
            });
          }
        }, {
          key: "bootstrapEvent",
          value: function bootstrapEvent(event, normalizedEvent, view, nativeEvent) {
            event.view = view;
            event.originalEvent = null;
            event.nativeEvent = nativeEvent;
            event.pointerId = normalizedEvent.pointerId;
            event.width = normalizedEvent.width;
            event.height = normalizedEvent.height;
            event.isPrimary = normalizedEvent.isPrimary;
            event.pointerType = normalizedEvent.pointerType;
            event.pressure = normalizedEvent.pressure;
            event.tangentialPressure = normalizedEvent.tangentialPressure;
            event.tiltX = normalizedEvent.tiltX;
            event.tiltY = normalizedEvent.tiltY;
            event.twist = normalizedEvent.twist;
            this.transferMouseData(event, normalizedEvent);
            var _this$context$eventSe = this.context.eventService.client2Viewport({
              x: normalizedEvent.clientX,
              y: normalizedEvent.clientY
            }), x3 = _this$context$eventSe.x, y3 = _this$context$eventSe.y;
            event.viewport.x = x3;
            event.viewport.y = y3;
            var _this$context$eventSe2 = this.context.eventService.viewport2Canvas(event.viewport), canvasX = _this$context$eventSe2.x, canvasY = _this$context$eventSe2.y;
            event.canvas.x = canvasX;
            event.canvas.y = canvasY;
            event.global.copyFrom(event.canvas);
            event.offset.copyFrom(event.canvas);
            event.isTrusted = nativeEvent.isTrusted;
            if (event.type === "pointerleave") {
              event.type = "pointerout";
            }
            if (event.type.startsWith("mouse")) {
              event.type = event.type.replace("mouse", "pointer");
            }
            if (event.type.startsWith("touch")) {
              event.type = TOUCH_TO_POINTER2[event.type] || event.type;
            }
            return event;
          }
        }, {
          key: "normalizeWheelEvent",
          value: function normalizeWheelEvent(nativeEvent) {
            var event = this.rootWheelEvent;
            this.transferMouseData(event, nativeEvent);
            event.deltaMode = nativeEvent.deltaMode;
            event.deltaX = nativeEvent.deltaX;
            event.deltaY = nativeEvent.deltaY;
            event.deltaZ = nativeEvent.deltaZ;
            var _this$context$eventSe3 = this.context.eventService.client2Viewport({
              x: nativeEvent.clientX,
              y: nativeEvent.clientY
            }), x3 = _this$context$eventSe3.x, y3 = _this$context$eventSe3.y;
            event.viewport.x = x3;
            event.viewport.y = y3;
            var _this$context$eventSe4 = this.context.eventService.viewport2Canvas(event.viewport), canvasX = _this$context$eventSe4.x, canvasY = _this$context$eventSe4.y;
            event.canvas.x = canvasX;
            event.canvas.y = canvasY;
            event.global.copyFrom(event.canvas);
            event.offset.copyFrom(event.canvas);
            event.nativeEvent = nativeEvent;
            event.type = nativeEvent.type;
            return event;
          }
          /**
           * Transfers base & mouse event data from the nativeEvent to the federated event.
           */
        }, {
          key: "transferMouseData",
          value: function transferMouseData(event, nativeEvent) {
            event.isTrusted = nativeEvent.isTrusted;
            event.srcElement = nativeEvent.srcElement;
            event.timeStamp = clock3.now();
            event.type = nativeEvent.type;
            event.altKey = nativeEvent.altKey;
            event.metaKey = nativeEvent.metaKey;
            event.shiftKey = nativeEvent.shiftKey;
            event.ctrlKey = nativeEvent.ctrlKey;
            event.button = nativeEvent.button;
            event.buttons = nativeEvent.buttons;
            event.client.x = nativeEvent.clientX;
            event.client.y = nativeEvent.clientY;
            event.movement.x = nativeEvent.movementX;
            event.movement.y = nativeEvent.movementY;
            event.page.x = nativeEvent.pageX;
            event.page.y = nativeEvent.pageY;
            event.screen.x = nativeEvent.screenX;
            event.screen.y = nativeEvent.screenY;
            event.relatedTarget = null;
          }
        }, {
          key: "setCursor",
          value: function setCursor(cursor) {
            this.context.contextService.applyCursorStyle(cursor || this.context.config.cursor || "default");
          }
        }, {
          key: "normalizeToPointerEvent",
          value: function normalizeToPointerEvent(event, canvas2) {
            var normalizedEvents = [];
            if (canvas2.isTouchEvent(event)) {
              for (var i = 0; i < event.changedTouches.length; i++) {
                var touch = event.changedTouches[i];
                if (util.isUndefined(touch.button)) touch.button = 0;
                if (util.isUndefined(touch.buttons)) touch.buttons = 1;
                if (util.isUndefined(touch.isPrimary)) {
                  touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
                }
                if (util.isUndefined(touch.width)) touch.width = touch.radiusX || 1;
                if (util.isUndefined(touch.height)) touch.height = touch.radiusY || 1;
                if (util.isUndefined(touch.tiltX)) touch.tiltX = 0;
                if (util.isUndefined(touch.tiltY)) touch.tiltY = 0;
                if (util.isUndefined(touch.pointerType)) touch.pointerType = "touch";
                if (util.isUndefined(touch.pointerId)) touch.pointerId = touch.identifier || 0;
                if (util.isUndefined(touch.pressure)) touch.pressure = touch.force || 0.5;
                if (util.isUndefined(touch.twist)) touch.twist = 0;
                if (util.isUndefined(touch.tangentialPressure)) touch.tangentialPressure = 0;
                touch.isNormalized = true;
                touch.type = event.type;
                normalizedEvents.push(touch);
              }
            } else if (canvas2.isMouseEvent(event)) {
              var tempEvent = event;
              if (util.isUndefined(tempEvent.isPrimary)) tempEvent.isPrimary = true;
              if (util.isUndefined(tempEvent.width)) tempEvent.width = 1;
              if (util.isUndefined(tempEvent.height)) tempEvent.height = 1;
              if (util.isUndefined(tempEvent.tiltX)) tempEvent.tiltX = 0;
              if (util.isUndefined(tempEvent.tiltY)) tempEvent.tiltY = 0;
              if (util.isUndefined(tempEvent.pointerType)) tempEvent.pointerType = "mouse";
              if (util.isUndefined(tempEvent.pointerId)) tempEvent.pointerId = MOUSE_POINTER_ID2;
              if (util.isUndefined(tempEvent.pressure)) tempEvent.pressure = 0.5;
              if (util.isUndefined(tempEvent.twist)) tempEvent.twist = 0;
              if (util.isUndefined(tempEvent.tangentialPressure)) tempEvent.tangentialPressure = 0;
              tempEvent.isNormalized = true;
              normalizedEvents.push(tempEvent);
            } else {
              normalizedEvents.push(event);
            }
            return normalizedEvents;
          }
        }]);
      })();
      EventPlugin2.tag = "Event";
      var shape2D2 = [Shape2.CIRCLE, Shape2.ELLIPSE, Shape2.IMAGE, Shape2.RECT, Shape2.LINE, Shape2.POLYLINE, Shape2.POLYGON, Shape2.TEXT, Shape2.PATH, Shape2.HTML];
      var FrustumCullingStrategy2 = /* @__PURE__ */ (function() {
        function FrustumCullingStrategy3() {
          _classCallCheck2(this, FrustumCullingStrategy3);
        }
        return _createClass2(FrustumCullingStrategy3, [{
          key: "isVisible",
          value: function isVisible2(camera, object) {
            var _object$parentNode;
            var cullable = object.cullable;
            if (!cullable.enable) {
              return true;
            }
            var renderBounds = object.getRenderBounds();
            if (AABB2.isEmpty(renderBounds)) {
              return false;
            }
            var frustum = camera.getFrustum();
            var parentVisibilityPlaneMask = (_object$parentNode = object.parentNode) === null || _object$parentNode === void 0 || (_object$parentNode = _object$parentNode.cullable) === null || _object$parentNode === void 0 ? void 0 : _object$parentNode.visibilityPlaneMask;
            cullable.visibilityPlaneMask = this.computeVisibilityWithPlaneMask(object, renderBounds, parentVisibilityPlaneMask || Mask2.INDETERMINATE, frustum.planes);
            cullable.visible = cullable.visibilityPlaneMask !== Mask2.OUTSIDE;
            return cullable.visible;
          }
          /**
           *
           * @see「Optimized View Frustum Culling Algorithms for Bounding Boxes」
           * @see https://github.com/antvis/GWebGPUEngine/issues/3
           *
           * * 基础相交测试 the basic intersection test
           * * 标记 masking @see https://cesium.com/blog/2015/08/04/fast-hierarchical-culling/
           * * TODO: 平面一致性测试 the plane-coherency test
           * * TODO: 支持 mesh 指定自身的剔除策略，参考 Babylon.js @see https://doc.babylonjs.com/how_to/optimizing_your_scene#changing-mesh-culling-strategy
           *
           * @param aabb aabb
           * @param parentPlaneMask mask of parent
           * @param planes planes of frustum
           */
        }, {
          key: "computeVisibilityWithPlaneMask",
          value: function computeVisibilityWithPlaneMask(object, aabb, parentPlaneMask, planes) {
            if (parentPlaneMask === Mask2.OUTSIDE || parentPlaneMask === Mask2.INSIDE) {
              return parentPlaneMask;
            }
            var mask = Mask2.INSIDE;
            var isShape2D = shape2D2.indexOf(object.nodeName) > -1;
            for (var k = 0, len = planes.length; k < len; ++k) {
              var flag = 1 << k;
              if ((parentPlaneMask & flag) === 0) {
                continue;
              }
              if (isShape2D && (k === 4 || k === 5)) {
                continue;
              }
              var _planes$k = planes[k], normal = _planes$k.normal, distance6 = _planes$k.distance;
              if (glMatrix.vec3.dot(normal, aabb.getPositiveFarPoint(planes[k])) + distance6 < 0) {
                return Mask2.OUTSIDE;
              }
              if (glMatrix.vec3.dot(normal, aabb.getNegativeFarPoint(planes[k])) + distance6 < 0) {
                mask |= flag;
              }
            }
            return mask;
          }
        }]);
      })();
      var PrepareRendererPlugin2 = /* @__PURE__ */ (function() {
        function PrepareRendererPlugin3() {
          _classCallCheck2(this, PrepareRendererPlugin3);
          this.syncTasks = /* @__PURE__ */ new Map();
          this.isFirstTimeRendering = true;
          this.syncing = false;
          this.isFirstTimeRenderingFinished = false;
        }
        return _createClass2(PrepareRendererPlugin3, [{
          key: "apply",
          value: function apply3(context) {
            var _this2 = this, _runtime$globalThis$r, _config$future;
            var config = context.config, renderingService = context.renderingService, renderingContext = context.renderingContext, rBushRoot = context.rBushRoot;
            var canvas2 = renderingContext.root.ownerDocument.defaultView;
            this.rBush = rBushRoot;
            var handleAttributeChanged = function handleAttributeChanged2(e) {
              renderingService.dirtify();
            };
            var handleBoundsChanged = function handleBoundsChanged2(e) {
              _this2.syncTasks.set(e.target, e.detail.affectChildren);
              renderingService.dirtify();
            };
            var handleMounted = function handleMounted2(e) {
              var object = e.target;
              if (runtime2.enableSizeAttenuation) {
                runtime2.styleValueRegistry.updateSizeAttenuation(object, canvas2.getCamera().getZoom());
              }
            };
            var handleUnmounted = function handleUnmounted2(e) {
              var object = e.target;
              var rBushNode = object.rBushNode;
              if (rBushNode !== null && rBushNode !== void 0 && rBushNode.aabb) {
                _this2.rBush.remove(rBushNode.aabb);
              }
              _this2.syncTasks["delete"](object);
              runtime2.sceneGraphService.dirtyToRoot(object);
              renderingService.dirtify();
            };
            renderingService.hooks.init.tap(PrepareRendererPlugin3.tag, function() {
              canvas2.addEventListener(ElementEvent2.MOUNTED, handleMounted);
              canvas2.addEventListener(ElementEvent2.UNMOUNTED, handleUnmounted);
              canvas2.addEventListener(ElementEvent2.ATTR_MODIFIED, handleAttributeChanged);
              canvas2.addEventListener(ElementEvent2.BOUNDS_CHANGED, handleBoundsChanged);
            });
            renderingService.hooks.destroy.tap(PrepareRendererPlugin3.tag, function() {
              canvas2.removeEventListener(ElementEvent2.MOUNTED, handleMounted);
              canvas2.removeEventListener(ElementEvent2.UNMOUNTED, handleUnmounted);
              canvas2.removeEventListener(ElementEvent2.ATTR_MODIFIED, handleAttributeChanged);
              canvas2.removeEventListener(ElementEvent2.BOUNDS_CHANGED, handleBoundsChanged);
              _this2.syncTasks.clear();
            });
            var ric = (_runtime$globalThis$r = runtime2.globalThis.requestIdleCallback) !== null && _runtime$globalThis$r !== void 0 ? _runtime$globalThis$r : raf2.bind(runtime2.globalThis);
            var enableRICSyncRTree = ((_config$future = config.future) === null || _config$future === void 0 ? void 0 : _config$future.experimentalRICSyncRTree) === true;
            renderingService.hooks.endFrame.tap(PrepareRendererPlugin3.tag, function() {
              if (_this2.isFirstTimeRendering) {
                _this2.isFirstTimeRendering = false;
                _this2.syncing = true;
                ric(function() {
                  _this2.syncRTree(true);
                  _this2.isFirstTimeRenderingFinished = true;
                });
              } else if (enableRICSyncRTree && runtime2.globalThis.requestIdleCallback && runtime2.globalThis.cancelIdleCallback) {
                runtime2.globalThis.cancelIdleCallback(_this2.ricSyncRTreeId);
                _this2.ricSyncRTreeId = runtime2.globalThis.requestIdleCallback(function() {
                  return _this2.syncRTree();
                });
              } else {
                _this2.syncRTree();
              }
            });
          }
        }, {
          key: "syncNode",
          value: function syncNode(node) {
            var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            if (!node.isConnected) return;
            var rBushNode = node.rBushNode;
            if (rBushNode.aabb) this.rBush.remove(rBushNode.aabb);
            var renderBounds = node.getRenderBounds();
            if (renderBounds) {
              var renderable = node.renderable;
              if (force) {
                if (!renderable.dirtyRenderBounds) {
                  renderable.dirtyRenderBounds = new AABB2();
                }
                renderable.dirtyRenderBounds.update(renderBounds.center, renderBounds.halfExtents);
              }
              var _renderBounds$getMin = renderBounds.getMin(), _renderBounds$getMin2 = _slicedToArray2(_renderBounds$getMin, 2), minX = _renderBounds$getMin2[0], minY = _renderBounds$getMin2[1];
              var _renderBounds$getMax = renderBounds.getMax(), _renderBounds$getMax2 = _slicedToArray2(_renderBounds$getMax, 2), maxX = _renderBounds$getMax2[0], maxY = _renderBounds$getMax2[1];
              if (!rBushNode.aabb) {
                rBushNode.aabb = {};
              }
              rBushNode.aabb.displayObject = node;
              rBushNode.aabb.minX = minX;
              rBushNode.aabb.minY = minY;
              rBushNode.aabb.maxX = maxX;
              rBushNode.aabb.maxY = maxY;
            }
            if (rBushNode.aabb) {
              if (!isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.minX) && !isNaN(rBushNode.aabb.minY)) {
                return rBushNode.aabb;
              }
            }
          }
        }, {
          key: "syncRTree",
          value: function syncRTree() {
            var _this2 = this;
            var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
            if (!force && (this.syncing || this.syncTasks.size === 0)) {
              return;
            }
            this.syncing = true;
            var bulk = [];
            var synced = /* @__PURE__ */ new Set();
            var sync = function sync2(node) {
              if (!synced.has(node) && node.renderable) {
                var aabb = _this2.syncNode(node, force);
                if (aabb) {
                  bulk.push(aabb);
                  synced.add(node);
                }
              }
            };
            this.syncTasks.forEach(function(affectChildren, node) {
              if (affectChildren) {
                node.forEach(sync);
              }
              var parent = node;
              while (parent) {
                sync(parent);
                parent = parent.parentElement;
              }
            });
            this.rBush.load(bulk);
            bulk.length = 0;
            this.syncing = false;
          }
        }]);
      })();
      PrepareRendererPlugin2.tag = "Prepare";
      function isCanvas(value) {
        return !!value.document;
      }
      var CanvasEvent3 = /* @__PURE__ */ (function(CanvasEvent4) {
        CanvasEvent4["READY"] = "ready";
        CanvasEvent4["BEFORE_RENDER"] = "beforerender";
        CanvasEvent4["RERENDER"] = "rerender";
        CanvasEvent4["AFTER_RENDER"] = "afterrender";
        CanvasEvent4["BEFORE_DESTROY"] = "beforedestroy";
        CanvasEvent4["AFTER_DESTROY"] = "afterdestroy";
        CanvasEvent4["RESIZE"] = "resize";
        CanvasEvent4["DIRTY_RECTANGLE"] = "dirtyrectangle";
        CanvasEvent4["RENDERER_CHANGED"] = "rendererchanged";
        return CanvasEvent4;
      })({});
      var DEFAULT_CAMERA_Z2 = 500;
      var DEFAULT_CAMERA_NEAR2 = 0.1;
      var DEFAULT_CAMERA_FAR2 = 1e3;
      var mountedEvent2 = new CustomEvent2(ElementEvent2.MOUNTED);
      var unmountedEvent2 = new CustomEvent2(ElementEvent2.UNMOUNTED);
      var beforeRenderEvent2 = new CustomEvent2(CanvasEvent3.BEFORE_RENDER);
      var rerenderEvent2 = new CustomEvent2(CanvasEvent3.RERENDER);
      var afterRenderEvent2 = new CustomEvent2(CanvasEvent3.AFTER_RENDER);
      var Canvas3 = /* @__PURE__ */ (function(_EventTarget) {
        function Canvas4(config) {
          var _this2;
          _classCallCheck2(this, Canvas4);
          _this2 = _callSuper2(this, Canvas4);
          _this2.Element = DisplayObject2;
          _this2.inited = false;
          _this2.context = {};
          var container = config.container, canvas2 = config.canvas, renderer = config.renderer, width2 = config.width, height = config.height, background = config.background, cursor = config.cursor, supportsMutipleCanvasesInOneContainer = config.supportsMutipleCanvasesInOneContainer, _config$cleanUpOnDest = config.cleanUpOnDestroy, cleanUpOnDestroy = _config$cleanUpOnDest === void 0 ? true : _config$cleanUpOnDest, offscreenCanvas = config.offscreenCanvas, devicePixelRatio = config.devicePixelRatio, requestAnimationFrame2 = config.requestAnimationFrame, cancelAnimationFrame2 = config.cancelAnimationFrame, createImage = config.createImage, supportsTouchEvents = config.supportsTouchEvents, supportsPointerEvents = config.supportsPointerEvents, isTouchEvent = config.isTouchEvent, isMouseEvent = config.isMouseEvent, dblClickSpeed = config.dblClickSpeed;
          var canvasWidth = width2;
          var canvasHeight = height;
          var dpr = devicePixelRatio || isBrowser2 && window.devicePixelRatio || 1;
          dpr = dpr >= 1 ? Math.ceil(dpr) : 1;
          if (canvas2) {
            canvasWidth = width2 || getWidth2(canvas2) || canvas2.width / dpr;
            canvasHeight = height || getHeight2(canvas2) || canvas2.height / dpr;
          }
          _this2.customElements = new CustomElementRegistry2();
          _this2.devicePixelRatio = dpr;
          _this2.requestAnimationFrame = requestAnimationFrame2 !== null && requestAnimationFrame2 !== void 0 ? requestAnimationFrame2 : raf2.bind(runtime2.globalThis);
          _this2.cancelAnimationFrame = cancelAnimationFrame2 !== null && cancelAnimationFrame2 !== void 0 ? cancelAnimationFrame2 : caf2.bind(runtime2.globalThis);
          _this2.createImage = createImage !== null && createImage !== void 0 ? createImage : function() {
            return new window.Image();
          };
          _this2.supportsTouchEvents = supportsTouchEvents !== null && supportsTouchEvents !== void 0 ? supportsTouchEvents : "ontouchstart" in runtime2.globalThis;
          _this2.supportsPointerEvents = supportsPointerEvents !== null && supportsPointerEvents !== void 0 ? supportsPointerEvents : !!runtime2.globalThis.PointerEvent;
          _this2.isTouchEvent = isTouchEvent !== null && isTouchEvent !== void 0 ? isTouchEvent : function(event) {
            return _this2.supportsTouchEvents && event instanceof runtime2.globalThis.TouchEvent;
          };
          _this2.isMouseEvent = isMouseEvent !== null && isMouseEvent !== void 0 ? isMouseEvent : function(event) {
            return !runtime2.globalThis.MouseEvent || event instanceof runtime2.globalThis.MouseEvent && (!_this2.supportsPointerEvents || !(event instanceof runtime2.globalThis.PointerEvent));
          };
          if (offscreenCanvas) {
            runtime2.offscreenCanvas = offscreenCanvas;
          }
          _this2.document = new Document3();
          _this2.document.defaultView = _this2;
          if (!supportsMutipleCanvasesInOneContainer) {
            cleanExistedCanvas2(container, _this2, cleanUpOnDestroy);
          }
          _this2.initRenderingContext(_objectSpread(_objectSpread({}, config), {}, {
            width: canvasWidth,
            height: canvasHeight,
            background: background !== null && background !== void 0 ? background : "transparent",
            cursor: cursor !== null && cursor !== void 0 ? cursor : "default",
            cleanUpOnDestroy,
            devicePixelRatio: dpr,
            requestAnimationFrame: _this2.requestAnimationFrame,
            cancelAnimationFrame: _this2.cancelAnimationFrame,
            createImage: _this2.createImage,
            supportsTouchEvents: _this2.supportsTouchEvents,
            supportsPointerEvents: _this2.supportsPointerEvents,
            isTouchEvent: _this2.isTouchEvent,
            isMouseEvent: _this2.isMouseEvent,
            dblClickSpeed: dblClickSpeed !== null && dblClickSpeed !== void 0 ? dblClickSpeed : 200
          }));
          _this2.initDefaultCamera(canvasWidth, canvasHeight, renderer.clipSpaceNearZ);
          _this2.initRenderer(renderer, true);
          return _this2;
        }
        _inherits2(Canvas4, _EventTarget);
        return _createClass2(Canvas4, [{
          key: "initRenderingContext",
          value: function initRenderingContext(mergedConfig) {
            this.context.config = mergedConfig;
            this.context.renderingContext = {
              /**
               * the root node in scene graph
               */
              root: this.document.documentElement,
              unculledEntities: [],
              renderListCurrentFrame: [],
              renderReasons: /* @__PURE__ */ new Set(),
              force: false,
              dirty: false
            };
          }
        }, {
          key: "initDefaultCamera",
          value: function initDefaultCamera(width2, height, clipSpaceNearZ) {
            var _this2 = this;
            var camera = new runtime2.CameraContribution();
            camera.clipSpaceNearZ = clipSpaceNearZ;
            camera.setType(CameraType2.EXPLORING, CameraTrackingMode2.DEFAULT).setPosition(width2 / 2, height / 2, DEFAULT_CAMERA_Z2).setFocalPoint(width2 / 2, height / 2, 0).setOrthographic(width2 / -2, width2 / 2, height / 2, height / -2, DEFAULT_CAMERA_NEAR2, DEFAULT_CAMERA_FAR2);
            camera.canvas = this;
            camera.eventEmitter.on(CameraEvent2.UPDATED, function() {
              _this2.context.renderingContext.renderReasons.add(RenderReason2.CAMERA_CHANGED);
              if (runtime2.enableSizeAttenuation && _this2.getConfig().renderer.getConfig().enableSizeAttenuation) {
                _this2.updateSizeAttenuation();
              }
            });
            this.context.camera = camera;
          }
        }, {
          key: "updateSizeAttenuation",
          value: function updateSizeAttenuation() {
            var zoom = this.getCamera().getZoom();
            this.document.documentElement.forEach(function(node) {
              runtime2.styleValueRegistry.updateSizeAttenuation(node, zoom);
            });
          }
        }, {
          key: "getConfig",
          value: function getConfig() {
            return this.context.config;
          }
          /**
           * get the root displayObject in scenegraph
           * @alias this.document.documentElement
           */
        }, {
          key: "getRoot",
          value: function getRoot() {
            return this.document.documentElement;
          }
          /**
           * get the camera of canvas
           */
        }, {
          key: "getCamera",
          value: function getCamera() {
            return this.context.camera;
          }
        }, {
          key: "getContextService",
          value: function getContextService() {
            return this.context.contextService;
          }
        }, {
          key: "getEventService",
          value: function getEventService() {
            return this.context.eventService;
          }
        }, {
          key: "getRenderingService",
          value: function getRenderingService() {
            return this.context.renderingService;
          }
        }, {
          key: "getRenderingContext",
          value: function getRenderingContext() {
            return this.context.renderingContext;
          }
        }, {
          key: "getStats",
          value: function getStats() {
            return this.getRenderingService().getStats();
          }
          // /**
          //  * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle
          //  */
          // getComputedStyle(node: DisplayObject) {
          //   return node.computedStyle;
          // }
        }, {
          key: "ready",
          get: function get9() {
            var _this3 = this;
            if (!this.readyPromise) {
              this.readyPromise = new Promise(function(resolve) {
                _this3.resolveReadyPromise = function() {
                  resolve(_this3);
                };
              });
              if (this.inited) {
                this.resolveReadyPromise();
              }
            }
            return this.readyPromise;
          }
          /**
           * @param cleanUp - whether to clean up all the internal services of Canvas
           * @param skipTriggerEvent - whether to skip trigger destroy event
           */
        }, {
          key: "destroy",
          value: function destroy() {
            var _this$getConfig$futur;
            var cleanUp = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
            var skipTriggerEvent = arguments.length > 1 ? arguments[1] : void 0;
            memoize4.clearCache();
            var enableCancelEventPropagation = ((_this$getConfig$futur = this.getConfig().future) === null || _this$getConfig$futur === void 0 ? void 0 : _this$getConfig$futur.experimentalCancelEventPropagation) === true;
            if (!skipTriggerEvent) {
              this.dispatchEvent(new CustomEvent2(CanvasEvent3.BEFORE_DESTROY), enableCancelEventPropagation, enableCancelEventPropagation);
            }
            if (this.frameId) {
              this.cancelAnimationFrame(this.frameId);
            }
            var root3 = this.getRoot();
            if (cleanUp) {
              this.unmountChildren(root3);
              this.document.destroy();
              this.getEventService().destroy();
            }
            this.getRenderingService().destroy();
            this.getContextService().destroy();
            if (this.context.rBushRoot) {
              this.context.rBushRoot.clear();
            }
            if (!skipTriggerEvent) {
              this.dispatchEvent(new CustomEvent2(CanvasEvent3.AFTER_DESTROY), enableCancelEventPropagation, enableCancelEventPropagation);
            }
            var clearEventRetain = function clearEventRetain2(event) {
              event.currentTarget = null;
              event.manager = null;
              event.target = null;
              event.relatedNode = null;
            };
            clearEventRetain(mountedEvent2);
            clearEventRetain(unmountedEvent2);
            clearEventRetain(beforeRenderEvent2);
            clearEventRetain(rerenderEvent2);
            clearEventRetain(afterRenderEvent2);
            clearEventRetain(attrModifiedEvent2);
            clearEventRetain(insertedEvent2);
            clearEventRetain(removedEvent2);
            clearEventRetain(destroyEvent2);
            runtime2.textService.clearCache();
          }
          /**
           * compatible with G 3.0
           * @deprecated
           * @alias resize
           */
        }, {
          key: "changeSize",
          value: function changeSize(width2, height) {
            this.resize(width2, height);
          }
        }, {
          key: "resize",
          value: function resize(width2, height) {
            var _canvasConfig$future;
            var canvasConfig = this.context.config;
            canvasConfig.width = width2;
            canvasConfig.height = height;
            this.getContextService().resize(width2, height);
            var camera = this.context.camera;
            var projectionMode = camera.getProjectionMode();
            camera.setPosition(width2 / 2, height / 2, DEFAULT_CAMERA_Z2).setFocalPoint(width2 / 2, height / 2, 0);
            if (projectionMode === CameraProjectionMode2.ORTHOGRAPHIC) {
              camera.setOrthographic(width2 / -2, width2 / 2, height / 2, height / -2, camera.getNear(), camera.getFar());
            } else {
              camera.setAspect(width2 / height);
            }
            var enableCancelEventPropagation = ((_canvasConfig$future = canvasConfig.future) === null || _canvasConfig$future === void 0 ? void 0 : _canvasConfig$future.experimentalCancelEventPropagation) === true;
            this.dispatchEvent(new CustomEvent2(CanvasEvent3.RESIZE, {
              width: width2,
              height
            }), enableCancelEventPropagation, enableCancelEventPropagation);
          }
          // proxy to document.documentElement
        }, {
          key: "appendChild",
          value: function appendChild(child, index2) {
            return this.document.documentElement.appendChild(child, index2);
          }
        }, {
          key: "insertBefore",
          value: function insertBefore(newChild, refChild) {
            return this.document.documentElement.insertBefore(newChild, refChild);
          }
        }, {
          key: "removeChild",
          value: function removeChild(child) {
            return this.document.documentElement.removeChild(child);
          }
          /**
           * Remove all children which can be appended to its original parent later again.
           */
        }, {
          key: "removeChildren",
          value: function removeChildren() {
            this.document.documentElement.removeChildren();
          }
          /**
           * Recursively destroy all children which can not be appended to its original parent later again.
           * But the canvas remains running which means display objects can be appended later.
           */
        }, {
          key: "destroyChildren",
          value: function destroyChildren() {
            this.document.documentElement.destroyChildren();
          }
        }, {
          key: "render",
          value: function render(frame2) {
            var _this$getConfig$futur2, _this4 = this;
            if (frame2) {
              beforeRenderEvent2.detail = frame2;
              afterRenderEvent2.detail = frame2;
            }
            var enableCancelEventPropagation = ((_this$getConfig$futur2 = this.getConfig().future) === null || _this$getConfig$futur2 === void 0 ? void 0 : _this$getConfig$futur2.experimentalCancelEventPropagation) === true;
            this.dispatchEvent(beforeRenderEvent2, enableCancelEventPropagation, enableCancelEventPropagation);
            var renderingService = this.getRenderingService();
            renderingService.render(this.getConfig(), frame2, function() {
              _this4.dispatchEvent(rerenderEvent2, enableCancelEventPropagation, enableCancelEventPropagation);
            });
            this.dispatchEvent(afterRenderEvent2, enableCancelEventPropagation, enableCancelEventPropagation);
          }
        }, {
          key: "run",
          value: function run4() {
            var _this5 = this;
            var _tick = function tick2(time, frame2) {
              _this5.render(frame2);
              _this5.frameId = _this5.requestAnimationFrame(_tick);
            };
            _tick();
          }
        }, {
          key: "initRenderer",
          value: function initRenderer(renderer) {
            var _this6 = this;
            var firstContentfullPaint = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            if (!renderer) {
              throw new Error("Renderer is required.");
            }
            this.inited = false;
            this.readyPromise = void 0;
            this.context.rBushRoot = new RBush2();
            this.context.renderingPlugins = [];
            this.context.renderingPlugins.push(
              new EventPlugin2(),
              new PrepareRendererPlugin2(),
              // new DirtyCheckPlugin(),
              new CullingPlugin2([new FrustumCullingStrategy2()])
            );
            this.loadRendererContainerModule(renderer);
            this.context.contextService = new this.context.ContextService(_objectSpread(_objectSpread({}, runtime2), this.context));
            this.context.renderingService = new RenderingService2(runtime2, this.context);
            this.context.eventService = new EventService2(runtime2, this.context);
            this.context.eventService.init();
            if (this.context.contextService.init) {
              this.context.contextService.init();
              this.initRenderingService(renderer, firstContentfullPaint, true);
            } else {
              this.context.contextService.initAsync().then(function() {
                _this6.initRenderingService(renderer, firstContentfullPaint);
              })["catch"](function(err) {
                console.error(err);
              });
            }
          }
        }, {
          key: "initRenderingService",
          value: function initRenderingService(renderer) {
            var _this7 = this;
            var firstContentfullPaint = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            var async = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            this.context.renderingService.init(function() {
              var _this7$getConfig$futu;
              _this7.inited = true;
              var enableCancelEventPropagation = ((_this7$getConfig$futu = _this7.getConfig().future) === null || _this7$getConfig$futu === void 0 ? void 0 : _this7$getConfig$futu.experimentalCancelEventPropagation) === true;
              if (firstContentfullPaint) {
                if (async) {
                  _this7.requestAnimationFrame(function() {
                    _this7.dispatchEvent(new CustomEvent2(CanvasEvent3.READY), enableCancelEventPropagation, enableCancelEventPropagation);
                  });
                } else {
                  _this7.dispatchEvent(new CustomEvent2(CanvasEvent3.READY), enableCancelEventPropagation, enableCancelEventPropagation);
                }
              } else {
                _this7.dispatchEvent(new CustomEvent2(CanvasEvent3.RENDERER_CHANGED), enableCancelEventPropagation, enableCancelEventPropagation);
              }
              if (_this7.readyPromise) {
                _this7.resolveReadyPromise();
              }
              if (!firstContentfullPaint) {
                _this7.getRoot().forEach(function(node) {
                  var _dirty, _ref;
                  (_dirty = (_ref = node).dirty) === null || _dirty === void 0 || _dirty.call(_ref, true, true);
                });
              }
              _this7.mountChildren(_this7.getRoot());
              if (renderer.getConfig().enableAutoRendering) {
                _this7.run();
              }
            });
          }
        }, {
          key: "loadRendererContainerModule",
          value: function loadRendererContainerModule(renderer) {
            var _this8 = this;
            var plugins = renderer.getPlugins();
            plugins.forEach(function(plugin) {
              plugin.context = _this8.context;
              plugin.init(runtime2);
            });
          }
        }, {
          key: "setRenderer",
          value: function setRenderer(renderer) {
            var canvasConfig = this.getConfig();
            if (canvasConfig.renderer === renderer) {
              return;
            }
            var oldRenderer = canvasConfig.renderer;
            canvasConfig.renderer = renderer;
            this.destroy(false, true);
            _toConsumableArray2((oldRenderer === null || oldRenderer === void 0 ? void 0 : oldRenderer.getPlugins()) || []).reverse().forEach(function(plugin) {
              plugin.destroy(runtime2);
            });
            this.initRenderer(renderer);
          }
        }, {
          key: "setCursor",
          value: function setCursor(cursor) {
            var canvasConfig = this.getConfig();
            canvasConfig.cursor = cursor;
            this.getContextService().applyCursorStyle(cursor);
          }
        }, {
          key: "unmountChildren",
          value: function unmountChildren(parent) {
            var _this9 = this;
            parent.childNodes.forEach(function(child) {
              _this9.unmountChildren(child);
            });
            if (this.inited) {
              if (parent.isMutationObserved) {
                parent.dispatchEvent(unmountedEvent2);
              } else {
                var _this$getConfig$futur3;
                var enableCancelEventPropagation = ((_this$getConfig$futur3 = this.getConfig().future) === null || _this$getConfig$futur3 === void 0 ? void 0 : _this$getConfig$futur3.experimentalCancelEventPropagation) === true;
                unmountedEvent2.target = parent;
                this.dispatchEvent(unmountedEvent2, true, enableCancelEventPropagation);
              }
              if (parent !== this.document.documentElement) {
                parent.ownerDocument = null;
              }
              parent.isConnected = false;
            }
            if (parent.isCustomElement) {
              if (parent.disconnectedCallback) {
                parent.disconnectedCallback();
              }
            }
          }
        }, {
          key: "mountChildren",
          value: function mountChildren(child) {
            var _this0 = this;
            var skipTriggerEvent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : isInFragment2(child);
            if (this.inited) {
              if (!child.isConnected) {
                child.ownerDocument = this.document;
                child.isConnected = true;
                if (!skipTriggerEvent) {
                  if (child.isMutationObserved) {
                    child.dispatchEvent(mountedEvent2);
                  } else {
                    var _this$getConfig$futur4;
                    var enableCancelEventPropagation = ((_this$getConfig$futur4 = this.getConfig().future) === null || _this$getConfig$futur4 === void 0 ? void 0 : _this$getConfig$futur4.experimentalCancelEventPropagation) === true;
                    mountedEvent2.target = child;
                    this.dispatchEvent(mountedEvent2, true, enableCancelEventPropagation);
                  }
                }
              }
            } else {
              console.warn("[g]: You are trying to call `canvas.appendChild` before canvas' initialization finished. You can either await `canvas.ready` or listen to `CanvasEvent.READY` manually.", "appended child: ", child.nodeName);
            }
            child.childNodes.forEach(function(c2) {
              _this0.mountChildren(c2, skipTriggerEvent);
            });
            if (child.isCustomElement) {
              if (child.connectedCallback) {
                child.connectedCallback();
              }
            }
          }
        }, {
          key: "mountFragment",
          value: function mountFragment(child) {
            this.mountChildren(child, false);
          }
        }, {
          key: "client2Viewport",
          value: function client2Viewport(client) {
            return this.getEventService().client2Viewport(client);
          }
        }, {
          key: "viewport2Client",
          value: function viewport2Client(canvas2) {
            return this.getEventService().viewport2Client(canvas2);
          }
        }, {
          key: "viewport2Canvas",
          value: function viewport2Canvas(viewport) {
            return this.getEventService().viewport2Canvas(viewport);
          }
        }, {
          key: "canvas2Viewport",
          value: function canvas2Viewport(canvas2) {
            return this.getEventService().canvas2Viewport(canvas2);
          }
          /**
           * @deprecated
           * @alias client2Viewport
           */
        }, {
          key: "getPointByClient",
          value: function getPointByClient(clientX, clientY) {
            return this.client2Viewport({
              x: clientX,
              y: clientY
            });
          }
          /**
           * @deprecated
           * @alias viewport2Client
           */
        }, {
          key: "getClientByPoint",
          value: function getClientByPoint(x3, y3) {
            return this.viewport2Client({
              x: x3,
              y: y3
            });
          }
        }]);
      })(EventTarget2);
      exports.AABB = AABB2;
      exports.AbstractRenderer = AbstractRenderer2;
      exports.AbstractRendererPlugin = AbstractRendererPlugin2;
      exports.BUILT_IN_PROPERTIES = BUILT_IN_PROPERTIES2;
      exports.CSS = CSS;
      exports.CSSGradientValue = CSSGradientValue2;
      exports.CSSKeywordValue = CSSKeywordValue2;
      exports.CSSRGB = CSSRGB2;
      exports.CSSStyleValue = CSSStyleValue2;
      exports.CSSUnitValue = CSSUnitValue2;
      exports.Camera = Camera2;
      exports.CameraEvent = CameraEvent2;
      exports.CameraProjectionMode = CameraProjectionMode2;
      exports.CameraTrackingMode = CameraTrackingMode2;
      exports.CameraType = CameraType2;
      exports.Canvas = Canvas3;
      exports.CanvasEvent = CanvasEvent3;
      exports.Circle = Circle4;
      exports.CircleUpdater = CircleUpdater2;
      exports.ClipSpaceNearZ = ClipSpaceNearZ2;
      exports.CustomElement = CustomElement2;
      exports.CustomElementRegistry = CustomElementRegistry2;
      exports.CustomEvent = CustomEvent2;
      exports.DefaultSceneGraphSelector = DefaultSceneGraphSelector2;
      exports.DefaultSceneGraphService = DefaultSceneGraphService2;
      exports.DisplayObject = DisplayObject2;
      exports.Document = Document3;
      exports.ERROR_MSG_METHOD_NOT_IMPLEMENTED = ERROR_MSG_METHOD_NOT_IMPLEMENTED2;
      exports.Element = Element3;
      exports.ElementEvent = ElementEvent2;
      exports.Ellipse = Ellipse3;
      exports.EllipseUpdater = EllipseUpdater2;
      exports.EventService = EventService2;
      exports.EventTarget = EventTarget2;
      exports.FederatedEvent = FederatedEvent2;
      exports.FederatedMouseEvent = FederatedMouseEvent2;
      exports.FederatedPointerEvent = FederatedPointerEvent2;
      exports.FederatedWheelEvent = FederatedWheelEvent2;
      exports.Fragment = Fragment2;
      exports.Frustum = Frustum2;
      exports.GradientType = GradientType2;
      exports.Group = Group2;
      exports.GroupUpdater = GroupUpdater2;
      exports.HTML = HTML3;
      exports.HTMLUpdater = HTMLUpdater2;
      exports.Image = Image6;
      exports.Line = Line4;
      exports.LineUpdater = LineUpdater2;
      exports.Mask = Mask2;
      exports.MutationEvent = MutationEvent2;
      exports.Node = Node3;
      exports.OffscreenCanvasCreator = OffscreenCanvasCreator2;
      exports.Path = Path2;
      exports.PathUpdater = PathUpdater2;
      exports.Plane = Plane2;
      exports.Point = Point2;
      exports.Polygon = Polygon3;
      exports.Polyline = Polyline3;
      exports.PolylineUpdater = PolylineUpdater2;
      exports.PropertySyntax = PropertySyntax2;
      exports.RBush = RBush2;
      exports.Rect = Rect3;
      exports.RectUpdater = RectUpdater2;
      exports.Rectangle = Rectangle3;
      exports.RenderReason = RenderReason2;
      exports.RenderingService = RenderingService2;
      exports.Shape = Shape2;
      exports.SortReason = SortReason2;
      exports.Strategy = Strategy2;
      exports.Text = Text3;
      exports.TextService = TextService2;
      exports.TextUpdater = TextUpdater2;
      exports.UnitType = UnitType2;
      exports.attrModifiedEvent = attrModifiedEvent2;
      exports.computeLinearGradient = computeLinearGradient2;
      exports.computeRadialGradient = computeRadialGradient2;
      exports.convertToPath = convertToPath;
      exports.createVec3 = createVec32;
      exports.decompose = decompose2;
      exports.definedProps = definedProps;
      exports.deg2rad = deg2rad2;
      exports.deg2turn = deg2turn;
      exports.destroyEvent = destroyEvent2;
      exports.findClosestClipPathTarget = findClosestClipPathTarget2;
      exports.fromRotationTranslationScale = fromRotationTranslationScale2;
      exports.getAngle = getAngle3;
      exports.getEuler = getEuler2;
      exports.getOrCalculatePathTotalLength = getOrCalculatePathTotalLength2;
      exports.grad2deg = grad2deg;
      exports.insertedEvent = insertedEvent2;
      exports.isBrowser = isBrowser2;
      exports.isCSSGradientValue = isCSSGradientValue;
      exports.isCSSRGB = isCSSRGB2;
      exports.isCanvas = isCanvas;
      exports.isDisplayObject = isDisplayObject2;
      exports.isFederatedEvent = isFederatedEvent;
      exports.isFillOrStrokeAffected = isFillOrStrokeAffected2;
      exports.isPattern = isPattern2;
      exports.mergeColors = mergeColors2;
      exports.parseColor = parseColor2;
      exports.parseLength = parseLength2;
      exports.parsePath = parsePath3;
      exports.parseTransform = parseTransform2;
      exports.parsedTransformToMat4 = parsedTransformToMat42;
      exports.propertyMetadataCache = propertyMetadataCache2;
      exports.rad2deg = rad2deg2;
      exports.removedEvent = removedEvent2;
      exports.resetEntityCounter = resetEntityCounter;
      exports.runtime = runtime2;
      exports.setDOMSize = setDOMSize2;
      exports.translatePathToString = translatePathToString;
      exports.turn2deg = turn2deg2;
      exports.updateLocalTransform = updateLocalTransform2;
      exports.updateWorldTransform = updateWorldTransform2;
    }
  });

  // node_modules/@antv/g-camera-api/dist/index.js
  var require_dist3 = __commonJS({
    "node_modules/@antv/g-camera-api/dist/index.js"(exports) {
      "use strict";
      var gLite = require_dist2();
      var _classCallCheck2 = require_classCallCheck();
      var _createClass2 = require_createClass();
      var _callSuper2 = require_callSuper();
      var _inherits2 = require_inherits();
      var util = require_lib();
      var glMatrix = require_cjs();
      var AdvancedCamera2 = /* @__PURE__ */ (function(_Camera) {
        function AdvancedCamera3() {
          var _this2;
          _classCallCheck2(this, AdvancedCamera3);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this2 = _callSuper2(this, AdvancedCamera3, [].concat(args));
          _this2.landmarks = [];
          return _this2;
        }
        _inherits2(AdvancedCamera3, _Camera);
        return _createClass2(AdvancedCamera3, [{
          key: "rotate",
          value: (
            /**
             * Changes the azimuth and elevation with respect to the current camera axes
             * @param {Number} azimuth the relative azimuth
             * @param {Number} elevation the relative elevation
             * @param {Number} roll the relative roll
             */
            function rotate3(azimuth, elevation, roll) {
              this.relElevation = gLite.getAngle(elevation);
              this.relAzimuth = gLite.getAngle(azimuth);
              this.relRoll = gLite.getAngle(roll);
              this.elevation += this.relElevation;
              this.azimuth += this.relAzimuth;
              this.roll += this.relRoll;
              if (this.type === gLite.CameraType.EXPLORING) {
                var rotX = glMatrix.quat.setAxisAngle(glMatrix.quat.create(), [1, 0, 0], gLite.deg2rad((this.rotateWorld ? 1 : -1) * this.relElevation));
                var rotY = glMatrix.quat.setAxisAngle(glMatrix.quat.create(), [0, 1, 0], gLite.deg2rad((this.rotateWorld ? 1 : -1) * this.relAzimuth));
                var rotZ = glMatrix.quat.setAxisAngle(glMatrix.quat.create(), [0, 0, 1], gLite.deg2rad(this.relRoll));
                var rotQ = glMatrix.quat.multiply(glMatrix.quat.create(), rotY, rotX);
                rotQ = glMatrix.quat.multiply(glMatrix.quat.create(), rotQ, rotZ);
                var rotMatrix = glMatrix.mat4.fromQuat(glMatrix.mat4.create(), rotQ);
                glMatrix.mat4.translate(this.matrix, this.matrix, [0, 0, -this.distance]);
                glMatrix.mat4.multiply(this.matrix, this.matrix, rotMatrix);
                glMatrix.mat4.translate(this.matrix, this.matrix, [0, 0, this.distance]);
              } else {
                if (Math.abs(this.elevation) > 90) {
                  return this;
                }
                this.computeMatrix();
              }
              this._getAxes();
              if (this.type === gLite.CameraType.ORBITING || this.type === gLite.CameraType.EXPLORING) {
                this._getPosition();
              } else if (this.type === gLite.CameraType.TRACKING) {
                this._getFocalPoint();
              }
              this._update();
              return this;
            }
          )
          /**
           * 沿水平(right) & 垂直(up)平移相机
           */
        }, {
          key: "pan",
          value: function pan(tx, ty) {
            var coords = gLite.createVec3(tx, ty, 0);
            var pos = glMatrix.vec3.clone(this.position);
            glMatrix.vec3.add(pos, pos, glMatrix.vec3.scale(glMatrix.vec3.create(), this.right, coords[0]));
            glMatrix.vec3.add(pos, pos, glMatrix.vec3.scale(glMatrix.vec3.create(), this.up, coords[1]));
            this._setPosition(pos);
            this.triggerUpdate();
            return this;
          }
          /**
           * 沿 n 轴移动，当距离视点远时移动速度较快，离视点越近速度越慢
           */
        }, {
          key: "dolly",
          value: function dolly(value) {
            var n = this.forward;
            var pos = glMatrix.vec3.clone(this.position);
            var step2 = value * this.dollyingStep;
            var updatedDistance = this.distance + value * this.dollyingStep;
            step2 = Math.max(Math.min(updatedDistance, this.maxDistance), this.minDistance) - this.distance;
            pos[0] += step2 * n[0];
            pos[1] += step2 * n[1];
            pos[2] += step2 * n[2];
            this._setPosition(pos);
            if (this.type === gLite.CameraType.ORBITING || this.type === gLite.CameraType.EXPLORING) {
              this._getDistance();
            } else if (this.type === gLite.CameraType.TRACKING) {
              glMatrix.vec3.add(this.focalPoint, pos, this.distanceVector);
            }
            this.triggerUpdate();
            return this;
          }
        }, {
          key: "cancelLandmarkAnimation",
          value: function cancelLandmarkAnimation() {
            if (this.landmarkAnimationID !== void 0) {
              this.canvas.cancelAnimationFrame(this.landmarkAnimationID);
            }
          }
        }, {
          key: "createLandmark",
          value: function createLandmark(name) {
            var _position$, _position$2, _focalPoint$, _focalPoint$2;
            var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var _params$position = params.position, position2 = _params$position === void 0 ? this.position : _params$position, _params$focalPoint = params.focalPoint, focalPoint = _params$focalPoint === void 0 ? this.focalPoint : _params$focalPoint, roll = params.roll, zoom = params.zoom;
            var camera = new gLite.runtime.CameraContribution();
            camera.setType(this.type, void 0);
            camera.setPosition(position2[0], (_position$ = position2[1]) !== null && _position$ !== void 0 ? _position$ : this.position[1], (_position$2 = position2[2]) !== null && _position$2 !== void 0 ? _position$2 : this.position[2]);
            camera.setFocalPoint(focalPoint[0], (_focalPoint$ = focalPoint[1]) !== null && _focalPoint$ !== void 0 ? _focalPoint$ : this.focalPoint[1], (_focalPoint$2 = focalPoint[2]) !== null && _focalPoint$2 !== void 0 ? _focalPoint$2 : this.focalPoint[2]);
            camera.setRoll(roll !== null && roll !== void 0 ? roll : this.roll);
            camera.setZoom(zoom !== null && zoom !== void 0 ? zoom : this.zoom);
            var landmark = {
              name,
              matrix: glMatrix.mat4.clone(camera.getWorldTransform()),
              right: glMatrix.vec3.clone(camera.right),
              up: glMatrix.vec3.clone(camera.up),
              forward: glMatrix.vec3.clone(camera.forward),
              position: glMatrix.vec3.clone(camera.getPosition()),
              focalPoint: glMatrix.vec3.clone(camera.getFocalPoint()),
              distanceVector: glMatrix.vec3.clone(camera.getDistanceVector()),
              distance: camera.getDistance(),
              dollyingStep: camera.getDollyingStep(),
              azimuth: camera.getAzimuth(),
              elevation: camera.getElevation(),
              roll: camera.getRoll(),
              relAzimuth: camera.relAzimuth,
              relElevation: camera.relElevation,
              relRoll: camera.relRoll,
              zoom: camera.getZoom()
            };
            this.landmarks.push(landmark);
            return landmark;
          }
        }, {
          key: "gotoLandmark",
          value: function gotoLandmark(name) {
            var _this2 = this;
            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var landmark = util.isString(name) ? this.landmarks.find(function(l) {
              return l.name === name;
            }) : name;
            if (landmark) {
              var _ref = util.isNumber(options) ? {
                duration: options
              } : options, _ref$easing = _ref.easing, easing = _ref$easing === void 0 ? "linear" : _ref$easing, _ref$duration = _ref.duration, duration = _ref$duration === void 0 ? 100 : _ref$duration, _ref$easingFunction = _ref.easingFunction, easingFunction = _ref$easingFunction === void 0 ? void 0 : _ref$easingFunction, _ref$onfinish = _ref.onfinish, onfinish = _ref$onfinish === void 0 ? void 0 : _ref$onfinish, _ref$onframe = _ref.onframe, onframe = _ref$onframe === void 0 ? void 0 : _ref$onframe;
              var epsilon2 = 0.01;
              this.cancelLandmarkAnimation();
              var destPosition = landmark.position;
              var destFocalPoint = landmark.focalPoint;
              var destZoom = landmark.zoom;
              var destRoll = landmark.roll;
              var easingFunc = easingFunction || gLite.runtime.EasingFunction(easing);
              var timeStart;
              var end = function end2() {
                _this2.setFocalPoint(destFocalPoint);
                _this2.setPosition(destPosition);
                _this2.setRoll(destRoll);
                _this2.setZoom(destZoom);
                _this2.computeMatrix();
                _this2.triggerUpdate();
                onfinish === null || onfinish === void 0 || onfinish();
              };
              if (duration === 0) return end();
              var _animate = function animate2(timestamp) {
                if (timeStart === void 0) {
                  timeStart = timestamp;
                }
                var elapsed = timestamp - timeStart;
                if (elapsed >= duration) {
                  end();
                  return;
                }
                var t = easingFunc(elapsed / duration);
                var interFocalPoint = glMatrix.vec3.create();
                var interPosition = glMatrix.vec3.create();
                var interZoom = 1;
                var interRoll = 0;
                glMatrix.vec3.lerp(interFocalPoint, _this2.focalPoint, destFocalPoint, t);
                glMatrix.vec3.lerp(interPosition, _this2.position, destPosition, t);
                interRoll = _this2.roll * (1 - t) + destRoll * t;
                interZoom = _this2.zoom * (1 - t) + destZoom * t;
                _this2.setFocalPoint(interFocalPoint);
                _this2.setPosition(interPosition);
                _this2.setRoll(interRoll);
                _this2.setZoom(interZoom);
                var dist = glMatrix.vec3.dist(interFocalPoint, destFocalPoint) + glMatrix.vec3.dist(interPosition, destPosition);
                if (dist <= epsilon2 && destZoom === void 0 && destRoll === void 0) {
                  return end();
                }
                _this2.computeMatrix();
                _this2.triggerUpdate();
                if (elapsed < duration) {
                  onframe === null || onframe === void 0 || onframe(t);
                  _this2.landmarkAnimationID = _this2.canvas.requestAnimationFrame(_animate);
                }
              };
              this.canvas.requestAnimationFrame(_animate);
            }
          }
          /**
           * Sets the camera to a distance such that the area covered by the bounding box is viewed.
           */
          // shot(displayObject: DisplayObject) {
          //   const aabb = displayObject.getBounds();
          //   if (!AABB.isEmpty(aabb)) {
          //     this.setElevation(0);
          //     this.setAzimuth(0);
          //     this.setRoll(0);
          //     const { halfExtents, center } = aabb;
          //     const maxDim = Math.max(halfExtents[0] * 2, halfExtents[1] * 2);
          //     const cc = center.map((c: number) => Math.round(c * 1000) / 1000) as [number, number, number];
          //     if (maxDim !== 0) {
          //       const d = (1.5 * maxDim) / Math.tan(this.fov * DEG_2_RAD);
          //       this.setPosition([cc[0], cc[1], cc[2] + d]);
          //     }
          //     this.setFocalPoint(cc);
          //   }
          // }
        }]);
      })(gLite.Camera);
      gLite.runtime.CameraContribution = AdvancedCamera2;
      exports.AdvancedCamera = AdvancedCamera2;
    }
  });

  // node_modules/@antv/g-dom-mutation-observer-api/dist/index.js
  var require_dist4 = __commonJS({
    "node_modules/@antv/g-dom-mutation-observer-api/dist/index.js"(exports) {
      "use strict";
      var _classCallCheck2 = require_classCallCheck();
      var _createClass2 = require_createClass();
      var gLite = require_dist2();
      var MutationRecord = /* @__PURE__ */ (function() {
        function MutationRecord2(type, target) {
          _classCallCheck2(this, MutationRecord2);
          this.addedNodes = [];
          this.attributeName = null;
          this.attributeNamespace = null;
          this.nextSibling = null;
          this.oldValue = null;
          this.previousSibling = null;
          this.removedNodes = [];
          this.type = type;
          this.target = target;
        }
        return _createClass2(MutationRecord2, null, [{
          key: "copy",
          value: function copy(original) {
            var record = new MutationRecord2(original.type, original.target);
            record.addedNodes = original.addedNodes.slice();
            record.removedNodes = original.removedNodes.slice();
            record.previousSibling = original.previousSibling;
            record.nextSibling = original.nextSibling;
            record.attributeName = original.attributeName;
            record.attributeNamespace = original.attributeNamespace;
            record.oldValue = original.oldValue;
            return record;
          }
        }]);
      })();
      var uidCounter = 0;
      var registrationsTable = /* @__PURE__ */ new WeakMap();
      var Registration = /* @__PURE__ */ (function() {
        function Registration2(observer, target, options) {
          _classCallCheck2(this, Registration2);
          this.transientObservedNodes = [];
          this.observer = observer;
          this.target = target;
          this.options = options;
        }
        return _createClass2(Registration2, [{
          key: "enqueue",
          value: function enqueue(record) {
            var records = this.observer.records;
            var length = records.length;
            if (records.length > 0) {
              var lastRecord = records[length - 1];
              var recordToReplaceLast = selectRecord(lastRecord, record);
              if (recordToReplaceLast) {
                records[length - 1] = recordToReplaceLast;
                return;
              }
            } else {
              scheduleCallback(this.observer);
            }
            records[length] = record;
          }
        }, {
          key: "addListeners",
          value: function addListeners() {
            this.addListeners_(this.target);
          }
        }, {
          key: "addListeners_",
          value: function addListeners_(node) {
            var options = this.options;
            if (options.attributes) node.addEventListener(gLite.ElementEvent.ATTR_MODIFIED, this, true);
            if (options.childList) node.addEventListener(gLite.ElementEvent.INSERTED, this, true);
            if (options.childList || options.subtree) node.addEventListener(gLite.ElementEvent.REMOVED, this, true);
          }
        }, {
          key: "removeListeners",
          value: function removeListeners() {
            this.removeListeners_(this.target);
          }
        }, {
          key: "removeListeners_",
          value: function removeListeners_(node) {
            var options = this.options;
            if (options.attributes) node.removeEventListener(gLite.ElementEvent.ATTR_MODIFIED, this, true);
            if (options.childList) node.removeEventListener(gLite.ElementEvent.INSERTED, this, true);
            if (options.childList || options.subtree) node.removeEventListener(gLite.ElementEvent.REMOVED, this, true);
          }
          /**
           * Adds a transient observer on node. The transient observer gets removed
           * next time we deliver the change records.
           */
          // addTransientObserver(node: IElement) {
          //   // Don't add transient observers on the target itself. We already have all
          //   // the required listeners set up on the target.
          //   if (node === this.target) return;
          //   this.addListeners_(node);
          //   this.transientObservedNodes.push(node);
          //   let registrations = registrationsTable.get(node);
          //   if (!registrations) registrationsTable.set(node, (registrations = []));
          //   // We know that registrations does not contain this because we already
          //   // checked if node === this.target.
          //   registrations.push(this);
          // }
        }, {
          key: "removeTransientObservers",
          value: function removeTransientObservers() {
            var transientObservedNodes = this.transientObservedNodes;
            this.transientObservedNodes = [];
            transientObservedNodes.forEach(function(node) {
              this.removeListeners_(node);
              var registrations = registrationsTable.get(node);
              for (var i = 0; i < registrations.length; i++) {
                if (registrations[i] === this) {
                  registrations.splice(i, 1);
                  break;
                }
              }
            }, this);
          }
        }, {
          key: "handleEvent",
          value: function handleEvent(e) {
            e.stopImmediatePropagation();
            var record;
            var target;
            switch (e.type) {
              case gLite.ElementEvent.ATTR_MODIFIED:
                var name = e.attrName;
                var namespace = e.relatedNode.namespaceURI;
                target = e.target;
                record = getRecord("attributes", target);
                record.attributeName = name;
                record.attributeNamespace = namespace;
                var oldValue = e.attrChange === gLite.MutationEvent.ADDITION ? null : e.prevValue;
                forEachAncestorAndObserverEnqueueRecord(target, function(options) {
                  if (!options.attributes) return;
                  if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
                    return;
                  }
                  if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
                  return record;
                });
                break;
              // case 'DOMCharacterDataModified':
              //   // http://dom.spec.whatwg.org/#concept-mo-queue-characterdata
              //   var target = e.target;
              //   // 1.
              //   var record = getRecord('characterData', target);
              //   // 2.
              //   var oldValue = e.prevValue;
              //   forEachAncestorAndObserverEnqueueRecord(target, function(options) {
              //     // 3.1, 4.2
              //     if (!options.characterData)
              //       return;
              //     // 3.2, 4.3
              //     if (options.characterDataOldValue)
              //       return getRecordWithOldValue(oldValue);
              //     // 3.3, 4.4
              //     return record;
              //   });
              //   break;
              case gLite.ElementEvent.REMOVED:
              // this.addTransientObserver(e.target as IElement);
              // Fall through.
              case gLite.ElementEvent.INSERTED:
                target = e.relatedNode;
                var changedNode = e.target;
                var addedNodes;
                var removedNodes;
                if (e.type === gLite.ElementEvent.INSERTED) {
                  addedNodes = [changedNode];
                  removedNodes = [];
                } else {
                  addedNodes = [];
                  removedNodes = [changedNode];
                }
                var previousSibling = changedNode.previousSibling;
                var nextSibling = changedNode.nextSibling;
                record = getRecord("childList", target);
                record.addedNodes = addedNodes;
                record.removedNodes = removedNodes;
                record.previousSibling = previousSibling;
                record.nextSibling = nextSibling;
                forEachAncestorAndObserverEnqueueRecord(target, function(options) {
                  if (!options.childList) return;
                  return record;
                });
            }
            clearRecords();
          }
        }]);
      })();
      var MutationObserver = /* @__PURE__ */ (function() {
        function MutationObserver2(callback) {
          _classCallCheck2(this, MutationObserver2);
          this.nodes = [];
          this.records = [];
          this.uid = uidCounter++;
          this.callback = callback;
        }
        return _createClass2(MutationObserver2, [{
          key: "observe",
          value: function observe(target, options) {
            if (!options.childList && !options.attributes && !options.characterData || // 1.2
            options.attributeOldValue && !options.attributes || // 1.3
            options.attributeFilter && options.attributeFilter.length && !options.attributes || // 1.4
            options.characterDataOldValue && !options.characterData) {
              throw new SyntaxError();
            }
            var registrations = registrationsTable.get(target);
            if (!registrations) registrationsTable.set(target, registrations = []);
            var registration;
            for (var i = 0; i < registrations.length; i++) {
              if (registrations[i].observer === this) {
                registration = registrations[i];
                registration.removeListeners();
                registration.options = options;
                break;
              }
            }
            if (!registration) {
              registration = new Registration(this, target, options);
              registrations.push(registration);
              this.nodes.push(target);
            }
            registration.addListeners();
          }
        }, {
          key: "disconnect",
          value: function disconnect() {
            var _this2 = this;
            this.nodes.forEach(function(node) {
              var registrations = registrationsTable.get(node);
              for (var i = 0; i < registrations.length; i++) {
                var registration = registrations[i];
                if (registration.observer === _this2) {
                  registration.removeListeners();
                  registrations.splice(i, 1);
                  break;
                }
              }
            }, this);
            this.records = [];
          }
        }, {
          key: "takeRecords",
          value: function takeRecords() {
            var copyOfRecords = this.records;
            this.records = [];
            return copyOfRecords;
          }
        }]);
      })();
      var currentRecord;
      var recordWithOldValue;
      function getRecord(type, target) {
        return currentRecord = new MutationRecord(type, target);
      }
      function getRecordWithOldValue(oldValue) {
        if (recordWithOldValue) return recordWithOldValue;
        recordWithOldValue = MutationRecord.copy(currentRecord);
        recordWithOldValue.oldValue = oldValue;
        return recordWithOldValue;
      }
      function clearRecords() {
        currentRecord = recordWithOldValue = void 0;
      }
      function recordRepresentsCurrentMutation(record) {
        return record === recordWithOldValue || record === currentRecord;
      }
      function selectRecord(lastRecord, newRecord) {
        if (lastRecord === newRecord) return lastRecord;
        if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
        return null;
      }
      function removeTransientObserversFor(observer) {
        observer.nodes.forEach(function(node) {
          var registrations = registrationsTable.get(node);
          if (!registrations) return;
          registrations.forEach(function(registration) {
            if (registration.observer === observer) registration.removeTransientObservers();
          });
        });
      }
      function forEachAncestorAndObserverEnqueueRecord(target, callback) {
        for (var node = target; node; node = node.parentNode) {
          var registrations = registrationsTable.get(node);
          if (registrations) {
            for (var j = 0; j < registrations.length; j++) {
              var registration = registrations[j];
              var _options = registration.options;
              if (node !== target && !_options.subtree) continue;
              var record = callback(_options);
              if (record) registration.enqueue(record);
            }
          }
        }
      }
      var isScheduled = false;
      var scheduledObservers = [];
      function scheduleCallback(observer) {
        scheduledObservers.push(observer);
        if (!isScheduled) {
          isScheduled = true;
          if (typeof gLite.runtime.globalThis !== "undefined") {
            gLite.runtime.globalThis.setTimeout(dispatchCallbacks);
          } else {
            dispatchCallbacks();
          }
        }
      }
      function dispatchCallbacks() {
        isScheduled = false;
        var observers = scheduledObservers;
        scheduledObservers = [];
        observers.sort(function(o1, o2) {
          return o1.uid - o2.uid;
        });
        var anyNonEmpty = false;
        observers.forEach(function(observer) {
          var queue = observer.takeRecords();
          removeTransientObserversFor(observer);
          if (queue.length) {
            observer.callback(queue, observer);
            anyNonEmpty = true;
          }
        });
        if (anyNonEmpty) dispatchCallbacks();
      }
      exports.MutationObserver = MutationObserver;
      exports.MutationRecord = MutationRecord;
      exports.Registration = Registration;
    }
  });

  // node_modules/@antv/g-web-animations-api/dist/index.js
  var require_dist5 = __commonJS({
    "node_modules/@antv/g-web-animations-api/dist/index.js"(exports) {
      "use strict";
      var gLite = require_dist2();
      var _classCallCheck2 = require_classCallCheck();
      var _createClass2 = require_createClass();
      var _callSuper2 = require_callSuper();
      var _inherits2 = require_inherits();
      var _toConsumableArray2 = require_toConsumableArray();
      var _slicedToArray2 = require_slicedToArray();
      var util = require_lib();
      var AnimationEvent2 = /* @__PURE__ */ (function(_FederatedEvent) {
        function AnimationEvent3(manager, target, currentTime, timelineTime) {
          var _this2;
          _classCallCheck2(this, AnimationEvent3);
          _this2 = _callSuper2(this, AnimationEvent3, [manager]);
          _this2.currentTime = currentTime;
          _this2.timelineTime = timelineTime;
          _this2.target = target;
          _this2.type = "finish";
          _this2.bubbles = false;
          _this2.currentTarget = target;
          _this2.defaultPrevented = false;
          _this2.eventPhase = _this2.AT_TARGET;
          _this2.timeStamp = Date.now();
          _this2.currentTime = currentTime;
          _this2.timelineTime = timelineTime;
          return _this2;
        }
        _inherits2(AnimationEvent3, _FederatedEvent);
        return _createClass2(AnimationEvent3);
      })(gLite.FederatedEvent);
      var sequenceNumber2 = 0;
      var Animation3 = /* @__PURE__ */ (function() {
        function Animation4(effect2, timeline) {
          var _this$effect;
          _classCallCheck2(this, Animation4);
          this.currentTimePending = false;
          this._idle = true;
          this._paused = false;
          this._finishedFlag = true;
          this._currentTime = 0;
          this._playbackRate = 1;
          this._inTimeline = true;
          this.effect = effect2;
          effect2.animation = this;
          this.timeline = timeline;
          this.id = "".concat(sequenceNumber2++);
          this._inEffect = !!this.effect.update(0);
          this._totalDuration = Number((_this$effect = this.effect) === null || _this$effect === void 0 ? void 0 : _this$effect.getComputedTiming().endTime);
          this._holdTime = 0;
          this._paused = false;
          this.oldPlayState = "idle";
          this.updatePromises();
        }
        return _createClass2(Animation4, [{
          key: "pending",
          get: (
            /**
             * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/effect
             */
            /**
             * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/timeline
             */
            /**
             * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/id
             */
            // animation: InternalAnimation | null;
            /**
             * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/pending
             */
            function get9() {
              return this._startTime === null && !this._paused && this.playbackRate !== 0 || this.currentTimePending;
            }
          )
        }, {
          key: "playState",
          get: function get9() {
            if (this._idle) return "idle";
            if (this._isFinished) return "finished";
            if (this._paused) return "paused";
            return "running";
          }
          /**
           * record previos state
           */
        }, {
          key: "ready",
          get: (
            /**
             * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/ready
             * @example
              animation.pause();
              animation.ready.then(function() {
                // Displays 'running'
                alert(animation.playState);
              });
              animation.play();
             */
            function get9() {
              var _this2 = this;
              if (!this.readyPromise) {
                if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
                  this.timeline.animationsWithPromises.push(this);
                }
                this.readyPromise = new Promise(function(resolve, reject) {
                  _this2.resolveReadyPromise = function() {
                    resolve(_this2);
                  };
                  _this2.rejectReadyPromise = function() {
                    reject(new Error());
                  };
                });
                if (!this.pending) {
                  this.resolveReadyPromise();
                }
              }
              return this.readyPromise;
            }
          )
          /**
           * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/finished
           * @example
            Promise.all(
              elem.getAnimations().map(
                function(animation) {
                  return animation.finished
                }
              )
            ).then(
              function() {
                return elem.remove();
              }
            );
           */
        }, {
          key: "finished",
          get: function get9() {
            var _this2 = this;
            if (!this.finishedPromise) {
              if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
                this.timeline.animationsWithPromises.push(this);
              }
              this.finishedPromise = new Promise(function(resolve, reject) {
                _this2.resolveFinishedPromise = function() {
                  resolve(_this2);
                };
                _this2.rejectFinishedPromise = function() {
                  reject(new Error());
                };
              });
              if (this.playState === "finished") {
                this.resolveFinishedPromise();
              }
            }
            return this.finishedPromise;
          }
          /**
           * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/onfinish
           */
          /**
           * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/oncancel
           */
          /**
           * get called after each frame when running
           */
        }, {
          key: "currentTime",
          get: function get9() {
            this.updatePromises();
            return this._idle || this.currentTimePending ? null : this._currentTime;
          },
          set: function set6(newTime) {
            newTime = Number(newTime);
            if (isNaN(newTime)) return;
            this.timeline.restart();
            if (!this._paused && this._startTime !== null) {
              var _this$timeline;
              this._startTime = Number((_this$timeline = this.timeline) === null || _this$timeline === void 0 ? void 0 : _this$timeline.currentTime) - newTime / this.playbackRate;
            }
            this.currentTimePending = false;
            if (this._currentTime === newTime) {
              return;
            }
            if (this._idle) {
              this._idle = false;
              this._paused = true;
            }
            this.tickCurrentTime(newTime, true);
            this.timeline.applyDirtiedAnimation(this);
          }
          /**
           * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/startTime
           */
        }, {
          key: "startTime",
          get: function get9() {
            return this._startTime;
          },
          set: function set6(newTime) {
            if (newTime !== null) {
              this.updatePromises();
              newTime = Number(newTime);
              if (isNaN(newTime)) return;
              if (this._paused || this._idle) return;
              this._startTime = newTime;
              this.tickCurrentTime((Number(this.timeline.currentTime) - this._startTime) * this.playbackRate);
              this.timeline.applyDirtiedAnimation(this);
              this.updatePromises();
            }
          }
        }, {
          key: "playbackRate",
          get: function get9() {
            return this._playbackRate;
          },
          set: function set6(value) {
            if (value === this._playbackRate) {
              return;
            }
            this.updatePromises();
            var oldCurrentTime = this.currentTime;
            this._playbackRate = value;
            this.startTime = null;
            if (this.playState !== "paused" && this.playState !== "idle") {
              this._finishedFlag = false;
              this._idle = false;
              this.ensureAlive();
              this.timeline.applyDirtiedAnimation(this);
            }
            if (oldCurrentTime !== null) {
              this.currentTime = oldCurrentTime;
            }
            this.updatePromises();
          }
        }, {
          key: "_isFinished",
          get: function get9() {
            return !this._idle && (this._playbackRate > 0 && Number(this._currentTime) >= this._totalDuration || this._playbackRate < 0 && Number(this._currentTime) <= 0);
          }
        }, {
          key: "totalDuration",
          get: function get9() {
            return this._totalDuration;
          }
        }, {
          key: "_needsTick",
          get: function get9() {
            return this.pending || this.playState === "running" || !this._finishedFlag;
          }
        }, {
          key: "updatePromises",
          value: function updatePromises() {
            var _this$effect$target;
            if ((_this$effect$target = this.effect.target) !== null && _this$effect$target !== void 0 && _this$effect$target.destroyed) {
              this.readyPromise = void 0;
              this.finishedPromise = void 0;
              return false;
            }
            var oldPlayState = this.oldPlayState;
            var newPlayState = this.pending ? "pending" : this.playState;
            if (this.readyPromise && newPlayState !== oldPlayState) {
              if (newPlayState === "idle") {
                this.rejectReadyPromise();
                this.readyPromise = void 0;
              } else if (oldPlayState === "pending") {
                this.resolveReadyPromise();
              } else if (newPlayState === "pending") {
                this.readyPromise = void 0;
              }
            }
            if (this.finishedPromise && newPlayState !== oldPlayState) {
              if (newPlayState === "idle") {
                this.rejectFinishedPromise();
                this.finishedPromise = void 0;
              } else if (newPlayState === "finished") {
                this.resolveFinishedPromise();
              } else if (oldPlayState === "finished") {
                this.finishedPromise = void 0;
              }
            }
            this.oldPlayState = newPlayState;
            return this.readyPromise || this.finishedPromise;
          }
        }, {
          key: "play",
          value: function play() {
            this.updatePromises();
            this._paused = false;
            if (this._isFinished || this._idle) {
              this.rewind();
              this._startTime = null;
            }
            this._finishedFlag = false;
            this._idle = false;
            this.ensureAlive();
            this.timeline.applyDirtiedAnimation(this);
            if (this.timeline.animations.indexOf(this) === -1) {
              this.timeline.animations.push(this);
            }
            this.updatePromises();
          }
        }, {
          key: "pause",
          value: function pause() {
            this.updatePromises();
            if (this.currentTime) {
              this._holdTime = this.currentTime;
            }
            if (!this._isFinished && !this._paused && !this._idle) {
              this.currentTimePending = true;
            } else if (this._idle) {
              this.rewind();
              this._idle = false;
            }
            this._startTime = null;
            this._paused = true;
            this.updatePromises();
          }
        }, {
          key: "finish",
          value: function finish() {
            this.updatePromises();
            if (this._idle) return;
            this.currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
            this._startTime = this._totalDuration - this.currentTime;
            this.currentTimePending = false;
            this.timeline.applyDirtiedAnimation(this);
            this.updatePromises();
          }
        }, {
          key: "cancel",
          value: function cancel() {
            var _this3 = this;
            this.updatePromises();
            if (!this._inEffect) return;
            this._inEffect = false;
            this._idle = true;
            this._paused = false;
            this._finishedFlag = true;
            this._currentTime = 0;
            this._startTime = null;
            this.effect.update(null);
            this.timeline.applyDirtiedAnimation(this);
            this.updatePromises();
            if (this.oncancel) {
              var event = new AnimationEvent2(null, this, this.currentTime, null);
              setTimeout(function() {
                _this3.oncancel(event);
              });
            }
          }
        }, {
          key: "reverse",
          value: function reverse() {
            this.updatePromises();
            var oldCurrentTime = this.currentTime;
            this.playbackRate *= -1;
            this.play();
            if (oldCurrentTime !== null) {
              this.currentTime = oldCurrentTime;
            }
            this.updatePromises();
          }
          /**
           * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/updatePlaybackRate
           */
        }, {
          key: "updatePlaybackRate",
          value: function updatePlaybackRate(playbackRate) {
            this.playbackRate = playbackRate;
          }
        }, {
          key: "targetAnimations",
          value: function targetAnimations() {
            var _this$effect2;
            var target = (_this$effect2 = this.effect) === null || _this$effect2 === void 0 ? void 0 : _this$effect2.target;
            return target.getAnimations();
          }
        }, {
          key: "markTarget",
          value: function markTarget() {
            var animations = this.targetAnimations();
            if (animations.indexOf(this) === -1) {
              animations.push(this);
            }
          }
        }, {
          key: "unmarkTarget",
          value: function unmarkTarget() {
            var animations = this.targetAnimations();
            var index2 = animations.indexOf(this);
            if (index2 !== -1) {
              animations.splice(index2, 1);
            }
          }
        }, {
          key: "tick",
          value: function tick2(timelineTime, isAnimationFrame) {
            if (!this._idle && !this._paused) {
              if (this._startTime === null) {
                if (isAnimationFrame) {
                  this.startTime = timelineTime - this._currentTime / this.playbackRate;
                }
              } else if (!this._isFinished) {
                this.tickCurrentTime((timelineTime - this._startTime) * this.playbackRate);
              }
            }
            if (isAnimationFrame) {
              this.currentTimePending = false;
              this.fireEvents(timelineTime);
            }
          }
        }, {
          key: "rewind",
          value: function rewind() {
            if (this.playbackRate >= 0) {
              this.currentTime = 0;
            } else if (this._totalDuration < Infinity) {
              this.currentTime = this._totalDuration;
            } else {
              throw new Error("Unable to rewind negative playback rate animation with infinite duration");
            }
          }
        }, {
          key: "persist",
          value: function persist() {
            throw new Error(gLite.ERROR_MSG_METHOD_NOT_IMPLEMENTED);
          }
        }, {
          key: "addEventListener",
          value: function addEventListener(type, listener, options) {
            throw new Error(gLite.ERROR_MSG_METHOD_NOT_IMPLEMENTED);
          }
        }, {
          key: "removeEventListener",
          value: function removeEventListener(type, listener, options) {
            throw new Error(gLite.ERROR_MSG_METHOD_NOT_IMPLEMENTED);
          }
        }, {
          key: "dispatchEvent",
          value: function dispatchEvent(event) {
            throw new Error(gLite.ERROR_MSG_METHOD_NOT_IMPLEMENTED);
          }
        }, {
          key: "commitStyles",
          value: (
            // replaceState: AnimationReplaceState;
            function commitStyles() {
              throw new Error(gLite.ERROR_MSG_METHOD_NOT_IMPLEMENTED);
            }
          )
        }, {
          key: "ensureAlive",
          value: function ensureAlive() {
            if (this.playbackRate < 0 && this.currentTime === 0) {
              var _this$effect3;
              this._inEffect = !!((_this$effect3 = this.effect) !== null && _this$effect3 !== void 0 && _this$effect3.update(-1));
            } else {
              var _this$effect4;
              this._inEffect = !!((_this$effect4 = this.effect) !== null && _this$effect4 !== void 0 && _this$effect4.update(this.currentTime));
            }
            if (!this._inTimeline && (this._inEffect || !this._finishedFlag)) {
              this._inTimeline = true;
              this.timeline.animations.push(this);
            }
          }
        }, {
          key: "tickCurrentTime",
          value: function tickCurrentTime(newTime, ignoreLimit) {
            if (newTime !== this._currentTime) {
              this._currentTime = newTime;
              if (this._isFinished && !ignoreLimit) {
                this._currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
              }
              this.ensureAlive();
            }
          }
        }, {
          key: "fireEvents",
          value: function fireEvents(baseTime) {
            var _this4 = this;
            if (this._isFinished) {
              if (!this._finishedFlag) {
                if (this.onfinish) {
                  var event = new AnimationEvent2(null, this, this.currentTime, baseTime);
                  setTimeout(function() {
                    if (_this4.onfinish) {
                      _this4.onfinish(event);
                    }
                  });
                }
                this._finishedFlag = true;
              }
            } else {
              if (this.onframe && this.playState === "running") {
                var _event = new AnimationEvent2(null, this, this.currentTime, baseTime);
                this.onframe(_event);
              }
              this._finishedFlag = false;
            }
          }
        }]);
      })();
      var NEWTON_ITERATIONS2 = 4;
      var NEWTON_MIN_SLOPE2 = 1e-3;
      var SUBDIVISION_PRECISION2 = 1e-7;
      var SUBDIVISION_MAX_ITERATIONS2 = 10;
      var kSplineTableSize2 = 11;
      var kSampleStepSize2 = 1 / (kSplineTableSize2 - 1);
      var float32ArraySupported2 = typeof Float32Array === "function";
      var A3 = function A4(aA1, aA2) {
        return 1 - 3 * aA2 + 3 * aA1;
      };
      var B3 = function B4(aA1, aA2) {
        return 3 * aA2 - 6 * aA1;
      };
      var C3 = function C4(aA1) {
        return 3 * aA1;
      };
      var calcBezier3 = function calcBezier4(aT, aA1, aA2) {
        return ((A3(aA1, aA2) * aT + B3(aA1, aA2)) * aT + C3(aA1)) * aT;
      };
      var getSlope3 = function getSlope4(aT, aA1, aA2) {
        return 3 * A3(aA1, aA2) * aT * aT + 2 * B3(aA1, aA2) * aT + C3(aA1);
      };
      var binarySubdivide3 = function binarySubdivide4(aX, aA, aB, mX1, mX2) {
        var currentX;
        var currentT;
        var i = 0;
        do {
          currentT = aA + (aB - aA) / 2;
          currentX = calcBezier3(currentT, mX1, mX2) - aX;
          if (currentX > 0) aB = currentT;
          else aA = currentT;
        } while (Math.abs(currentX) > SUBDIVISION_PRECISION2 && ++i < SUBDIVISION_MAX_ITERATIONS2);
        return currentT;
      };
      var newtonRaphsonIterate3 = function newtonRaphsonIterate4(aX, aGuessT, mX1, mX2) {
        for (var i = 0; i < NEWTON_ITERATIONS2; ++i) {
          var currentSlope = getSlope3(aGuessT, mX1, mX2);
          if (currentSlope === 0) return aGuessT;
          var currentX = calcBezier3(aGuessT, mX1, mX2) - aX;
          aGuessT -= currentX / currentSlope;
        }
        return aGuessT;
      };
      var bezier3 = function bezier4(mX1, mY1, mX2, mY2) {
        if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) throw new Error("bezier x values must be in [0, 1] range");
        if (mX1 === mY1 && mX2 === mY2) return function(t) {
          return t;
        };
        var sampleValues = float32ArraySupported2 ? new Float32Array(kSplineTableSize2) : new Array(kSplineTableSize2);
        for (var i = 0; i < kSplineTableSize2; ++i) {
          sampleValues[i] = calcBezier3(i * kSampleStepSize2, mX1, mX2);
        }
        var getTForX = function getTForX2(aX) {
          var intervalStart = 0;
          var currentSample = 1;
          var lastSample = kSplineTableSize2 - 1;
          for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) intervalStart += kSampleStepSize2;
          --currentSample;
          var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
          var guessForT = intervalStart + dist * kSampleStepSize2;
          var initialSlope = getSlope3(guessForT, mX1, mX2);
          if (initialSlope >= NEWTON_MIN_SLOPE2) return newtonRaphsonIterate3(aX, guessForT, mX1, mX2);
          if (initialSlope === 0) return guessForT;
          return binarySubdivide3(aX, intervalStart, intervalStart + kSampleStepSize2, mX1, mX2);
        };
        return function(t) {
          if (t === 0 || t === 1) return t;
          return calcBezier3(getTForX(t), mY1, mY2);
        };
      };
      var convertToDash3 = function convertToDash4(str) {
        str = str.replace(/([A-Z])/g, function(letter) {
          return "-".concat(letter.toLowerCase());
        });
        return str.charAt(0) === "-" ? str.substring(1) : str;
      };
      var Quad4 = function Quad5(t) {
        return Math.pow(t, 2);
      };
      var Cubic4 = function Cubic5(t) {
        return Math.pow(t, 3);
      };
      var Quart3 = function Quart4(t) {
        return Math.pow(t, 4);
      };
      var Quint3 = function Quint4(t) {
        return Math.pow(t, 5);
      };
      var Expo3 = function Expo4(t) {
        return Math.pow(t, 6);
      };
      var Sine3 = function Sine4(t) {
        return 1 - Math.cos(t * Math.PI / 2);
      };
      var Circ3 = function Circ4(t) {
        return 1 - Math.sqrt(1 - t * t);
      };
      var Back3 = function Back4(t) {
        return t * t * (3 * t - 2);
      };
      var Bounce3 = function Bounce4(t) {
        var pow2;
        var b = 4;
        while (t < ((pow2 = Math.pow(2, --b)) - 1) / 11) {
        }
        return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);
      };
      var Elastic3 = function Elastic4(t) {
        var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        var _params = _slicedToArray2(params, 2), _params$ = _params[0], amplitude = _params$ === void 0 ? 1 : _params$, _params$2 = _params[1], period = _params$2 === void 0 ? 0.5 : _params$2;
        var a2 = util.clamp(Number(amplitude), 1, 10);
        var p = util.clamp(Number(period), 0.1, 2);
        if (t === 0 || t === 1) return t;
        return -a2 * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p / (Math.PI * 2) * Math.asin(1 / a2)) * (Math.PI * 2) / p);
      };
      var Spring3 = function Spring4(t) {
        var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        var duration = arguments.length > 2 ? arguments[2] : void 0;
        var _params2 = _slicedToArray2(params, 4), _params2$ = _params2[0], mass = _params2$ === void 0 ? 1 : _params2$, _params2$2 = _params2[1], stiffness = _params2$2 === void 0 ? 100 : _params2$2, _params2$3 = _params2[2], damping = _params2$3 === void 0 ? 10 : _params2$3, _params2$4 = _params2[3], velocity = _params2$4 === void 0 ? 0 : _params2$4;
        mass = util.clamp(mass, 0.1, 1e3);
        stiffness = util.clamp(stiffness, 0.1, 1e3);
        damping = util.clamp(damping, 0.1, 1e3);
        velocity = util.clamp(velocity, 0.1, 1e3);
        var w0 = Math.sqrt(stiffness / mass);
        var zeta = damping / (2 * Math.sqrt(stiffness * mass));
        var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
        var a2 = 1;
        var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;
        var progress = duration ? duration * t / 1e3 : t;
        if (zeta < 1) {
          progress = Math.exp(-progress * zeta * w0) * (a2 * Math.cos(wd * progress) + b * Math.sin(wd * progress));
        } else {
          progress = (a2 + b * progress) * Math.exp(-progress * w0);
        }
        if (t === 0 || t === 1) return t;
        return 1 - progress;
      };
      var Steps3 = function Steps4(t) {
        var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        var _ref = params, _ref2 = _slicedToArray2(_ref, 2), _ref2$ = _ref2[0], steps = _ref2$ === void 0 ? 10 : _ref2$, type = _ref2[1];
        var trunc = type === "start" ? Math.ceil : Math.floor;
        return trunc(util.clamp(t, 0, 1) * steps) / steps;
      };
      var Bezier3 = function Bezier4(t) {
        var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        var _params3 = _slicedToArray2(params, 4), mX1 = _params3[0], mY1 = _params3[1], mX2 = _params3[2], mY2 = _params3[3];
        return bezier3(mX1, mY1, mX2, mY2)(t);
      };
      var easein2 = bezier3(0.42, 0, 1, 1);
      var EaseOut3 = function EaseOut4(ease2) {
        return function(t) {
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
          var duration = arguments.length > 2 ? arguments[2] : void 0;
          return 1 - ease2(1 - t, params, duration);
        };
      };
      var EaseInOut3 = function EaseInOut4(ease2) {
        return function(t) {
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
          var duration = arguments.length > 2 ? arguments[2] : void 0;
          return t < 0.5 ? ease2(t * 2, params, duration) / 2 : 1 - ease2(t * -2 + 2, params, duration) / 2;
        };
      };
      var EaseOutIn3 = function EaseOutIn4(ease2) {
        return function(t) {
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
          var duration = arguments.length > 2 ? arguments[2] : void 0;
          return t < 0.5 ? (1 - ease2(1 - t * 2, params, duration)) / 2 : (ease2(t * 2 - 1, params, duration) + 1) / 2;
        };
      };
      var EasingFunctions2 = {
        steps: Steps3,
        "step-start": function stepStart2(t) {
          return Steps3(t, [1, "start"]);
        },
        "step-end": function stepEnd2(t) {
          return Steps3(t, [1, "end"]);
        },
        linear: function linear6(t) {
          return t;
        },
        "cubic-bezier": Bezier3,
        ease: function ease2(t) {
          return Bezier3(t, [0.25, 0.1, 0.25, 1]);
        },
        "in": easein2,
        out: EaseOut3(easein2),
        "in-out": EaseInOut3(easein2),
        "out-in": EaseOutIn3(easein2),
        "in-quad": Quad4,
        "out-quad": EaseOut3(Quad4),
        "in-out-quad": EaseInOut3(Quad4),
        "out-in-quad": EaseOutIn3(Quad4),
        "in-cubic": Cubic4,
        "out-cubic": EaseOut3(Cubic4),
        "in-out-cubic": EaseInOut3(Cubic4),
        "out-in-cubic": EaseOutIn3(Cubic4),
        "in-quart": Quart3,
        "out-quart": EaseOut3(Quart3),
        "in-out-quart": EaseInOut3(Quart3),
        "out-in-quart": EaseOutIn3(Quart3),
        "in-quint": Quint3,
        "out-quint": EaseOut3(Quint3),
        "in-out-quint": EaseInOut3(Quint3),
        "out-in-quint": EaseOutIn3(Quint3),
        "in-expo": Expo3,
        "out-expo": EaseOut3(Expo3),
        "in-out-expo": EaseInOut3(Expo3),
        "out-in-expo": EaseOutIn3(Expo3),
        "in-sine": Sine3,
        "out-sine": EaseOut3(Sine3),
        "in-out-sine": EaseInOut3(Sine3),
        "out-in-sine": EaseOutIn3(Sine3),
        "in-circ": Circ3,
        "out-circ": EaseOut3(Circ3),
        "in-out-circ": EaseInOut3(Circ3),
        "out-in-circ": EaseOutIn3(Circ3),
        "in-back": Back3,
        "out-back": EaseOut3(Back3),
        "in-out-back": EaseInOut3(Back3),
        "out-in-back": EaseOutIn3(Back3),
        "in-bounce": Bounce3,
        "out-bounce": EaseOut3(Bounce3),
        "in-out-bounce": EaseInOut3(Bounce3),
        "out-in-bounce": EaseOutIn3(Bounce3),
        "in-elastic": Elastic3,
        "out-elastic": EaseOut3(Elastic3),
        "in-out-elastic": EaseInOut3(Elastic3),
        "out-in-elastic": EaseOutIn3(Elastic3),
        spring: Spring3,
        "spring-in": Spring3,
        "spring-out": EaseOut3(Spring3),
        "spring-in-out": EaseInOut3(Spring3),
        "spring-out-in": EaseOutIn3(Spring3)
      };
      var complexEasingSyntax3 = function complexEasingSyntax4(ease2) {
        return convertToDash3(ease2).replace(/^ease-/, "").replace(/(\(|\s).+/, "").toLowerCase().trim();
      };
      var getEasingFunction3 = function getEasingFunction4(ease2) {
        return EasingFunctions2[complexEasingSyntax3(ease2)] || EasingFunctions2.linear;
      };
      var linear5 = function linear6(x3) {
        return x3;
      };
      var Start2 = 1;
      var Middle2 = 0.5;
      var End2 = 0;
      function step2(count, pos) {
        return function(x3) {
          if (x3 >= 1) {
            return 1;
          }
          var stepSize = 1 / count;
          x3 += pos * stepSize;
          return x3 - x3 % stepSize;
        };
      }
      var numberString2 = "\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*";
      var cubicBezierRe2 = new RegExp("cubic-bezier\\(".concat(numberString2, ",").concat(numberString2, ",").concat(numberString2, ",").concat(numberString2, "\\)"));
      var step1Re2 = /steps\(\s*(\d+)\s*\)/;
      var step2Re2 = /steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/;
      function parseEasingFunction2(normalizedEasing) {
        var cubicData = cubicBezierRe2.exec(normalizedEasing);
        if (cubicData) {
          return bezier3.apply(void 0, _toConsumableArray2(cubicData.slice(1).map(Number)));
        }
        var step1Data = step1Re2.exec(normalizedEasing);
        if (step1Data) {
          return step2(Number(step1Data[1]), End2);
        }
        var step2Data = step2Re2.exec(normalizedEasing);
        if (step2Data) {
          return step2(Number(step2Data[1]), {
            start: Start2,
            middle: Middle2,
            end: End2
          }[step2Data[2]]);
        }
        return getEasingFunction3(normalizedEasing);
      }
      function calculateActiveDuration2(timing) {
        return Math.abs(repeatedDuration2(timing) / (timing.playbackRate || 1));
      }
      function repeatedDuration2(timing) {
        var _timing$iterations;
        if (timing.duration === 0 || timing.iterations === 0) {
          return 0;
        }
        return (timing.duration === "auto" ? 0 : Number(timing.duration)) * ((_timing$iterations = timing.iterations) !== null && _timing$iterations !== void 0 ? _timing$iterations : 1);
      }
      var PhaseNone2 = 0;
      var PhaseBefore2 = 1;
      var PhaseAfter2 = 2;
      var PhaseActive2 = 3;
      function calculatePhase2(activeDuration, localTime, timing) {
        if (localTime === null) {
          return PhaseNone2;
        }
        var endTime = timing.endTime;
        if (localTime < Math.min(timing.delay, endTime)) {
          return PhaseBefore2;
        }
        if (localTime >= Math.min(timing.delay + activeDuration + timing.endDelay, endTime)) {
          return PhaseAfter2;
        }
        return PhaseActive2;
      }
      function calculateActiveTime2(activeDuration, fillMode, localTime, phase, delay) {
        switch (phase) {
          case PhaseBefore2:
            if (fillMode === "backwards" || fillMode === "both") return 0;
            return null;
          case PhaseActive2:
            return localTime - delay;
          case PhaseAfter2:
            if (fillMode === "forwards" || fillMode === "both") return activeDuration;
            return null;
          case PhaseNone2:
            return null;
        }
      }
      function calculateOverallProgress2(iterationDuration, phase, iterations, activeTime, iterationStart) {
        var overallProgress = iterationStart;
        if (iterationDuration === 0) {
          if (phase !== PhaseBefore2) {
            overallProgress += iterations;
          }
        } else {
          overallProgress += activeTime / iterationDuration;
        }
        return overallProgress;
      }
      function calculateSimpleIterationProgress2(overallProgress, iterationStart, phase, iterations, activeTime, iterationDuration) {
        var simpleIterationProgress = overallProgress === Infinity ? iterationStart % 1 : overallProgress % 1;
        if (simpleIterationProgress === 0 && phase === PhaseAfter2 && iterations !== 0 && (activeTime !== 0 || iterationDuration === 0)) {
          simpleIterationProgress = 1;
        }
        return simpleIterationProgress;
      }
      function calculateCurrentIteration2(phase, iterations, simpleIterationProgress, overallProgress) {
        if (phase === PhaseAfter2 && iterations === Infinity) {
          return Infinity;
        }
        if (simpleIterationProgress === 1) {
          return Math.floor(overallProgress) - 1;
        }
        return Math.floor(overallProgress);
      }
      function calculateDirectedProgress2(playbackDirection, currentIteration, simpleIterationProgress) {
        var currentDirection = playbackDirection;
        if (playbackDirection !== "normal" && playbackDirection !== "reverse") {
          var d2 = currentIteration;
          if (playbackDirection === "alternate-reverse") {
            d2 += 1;
          }
          currentDirection = "normal";
          if (d2 !== Infinity && d2 % 2 !== 0) {
            currentDirection = "reverse";
          }
        }
        if (currentDirection === "normal") {
          return simpleIterationProgress;
        }
        return 1 - simpleIterationProgress;
      }
      function calculateIterationProgress2(activeDuration, localTime, timing) {
        var phase = calculatePhase2(activeDuration, localTime, timing);
        var activeTime = calculateActiveTime2(activeDuration, timing.fill, localTime, phase, timing.delay);
        if (activeTime === null) return null;
        var duration = timing.duration === "auto" ? 0 : timing.duration;
        var overallProgress = calculateOverallProgress2(duration, phase, timing.iterations, activeTime, timing.iterationStart);
        var simpleIterationProgress = calculateSimpleIterationProgress2(overallProgress, timing.iterationStart, phase, timing.iterations, activeTime, duration);
        var currentIteration = calculateCurrentIteration2(phase, timing.iterations, simpleIterationProgress, overallProgress);
        var directedProgress = calculateDirectedProgress2(timing.direction, currentIteration, simpleIterationProgress);
        timing.currentIteration = currentIteration;
        timing.progress = directedProgress;
        return timing.easingFunction(directedProgress);
      }
      function convertEffectInput2(keyframes, timing, target) {
        var propertySpecificKeyframeGroups = makePropertySpecificKeyframeGroups2(keyframes, timing);
        var interpolations = makeInterpolations2(propertySpecificKeyframeGroups, target);
        return function(target2, fraction) {
          if (fraction !== null) {
            interpolations.filter(function(interpolation) {
              return fraction >= interpolation.applyFrom && fraction < interpolation.applyTo;
            }).forEach(function(interpolation) {
              var offsetFraction = fraction - interpolation.startOffset;
              var localDuration = interpolation.endOffset - interpolation.startOffset;
              var scaledLocalTime = localDuration === 0 ? 0 : offsetFraction / localDuration;
              target2.setAttribute(
                interpolation.property,
                interpolation.interpolation(scaledLocalTime),
                false,
                false
                // disable memoize
              );
            });
          } else {
            for (var property in propertySpecificKeyframeGroups) if (isNotReservedWord2(property)) {
              target2.setAttribute(property, null);
            }
          }
        };
      }
      function isNotReservedWord2(member) {
        return member !== "offset" && member !== "easing" && member !== "composite" && member !== "computedOffset";
      }
      function makePropertySpecificKeyframeGroups2(keyframes, timing) {
        var propertySpecificKeyframeGroups = {};
        for (var i = 0; i < keyframes.length; i++) {
          for (var member in keyframes[i]) {
            if (isNotReservedWord2(member)) {
              var propertySpecificKeyframe = {
                offset: keyframes[i].offset,
                computedOffset: keyframes[i].computedOffset,
                easing: keyframes[i].easing,
                easingFunction: parseEasingFunction2(keyframes[i].easing) || timing.easingFunction,
                value: keyframes[i][member]
              };
              propertySpecificKeyframeGroups[member] = propertySpecificKeyframeGroups[member] || [];
              propertySpecificKeyframeGroups[member].push(propertySpecificKeyframe);
            }
          }
        }
        return propertySpecificKeyframeGroups;
      }
      function makeInterpolations2(propertySpecificKeyframeGroups, target) {
        var interpolations = [];
        for (var groupName in propertySpecificKeyframeGroups) {
          var keyframes = propertySpecificKeyframeGroups[groupName];
          for (var i = 0; i < keyframes.length - 1; i++) {
            var startIndex = i;
            var endIndex = i + 1;
            var startOffset = keyframes[startIndex].computedOffset;
            var endOffset = keyframes[endIndex].computedOffset;
            var applyFrom = startOffset;
            var applyTo = endOffset;
            if (i === 0) {
              applyFrom = -Infinity;
              if (endOffset === 0) {
                endIndex = startIndex;
              }
            }
            if (i === keyframes.length - 2) {
              applyTo = Infinity;
              if (startOffset === 1) {
                startIndex = endIndex;
              }
            }
            interpolations.push({
              applyFrom,
              applyTo,
              startOffset: keyframes[startIndex].computedOffset,
              endOffset: keyframes[endIndex].computedOffset,
              easingFunction: keyframes[startIndex].easingFunction,
              property: groupName,
              interpolation: propertyInterpolation2(groupName, keyframes[startIndex].value, keyframes[endIndex].value, target)
            });
          }
        }
        interpolations.sort(function(leftInterpolation, rightInterpolation) {
          return leftInterpolation.startOffset - rightInterpolation.startOffset;
        });
        return interpolations;
      }
      var InterpolationFactory3 = function InterpolationFactory4(from, to, convertToString) {
        return function(f) {
          var interpolated = interpolate3(from, to, f);
          return util.isNumber(interpolated) ? interpolated : convertToString(interpolated);
        };
      };
      function propertyInterpolation2(property, left, right, target) {
        var metadata = gLite.propertyMetadataCache[property];
        if (metadata && metadata.syntax && metadata["int"]) {
          var propertyHandler = gLite.runtime.styleValueRegistry.getPropertySyntax(metadata.syntax);
          if (propertyHandler) {
            var parser2 = propertyHandler.parser;
            var usedLeft = parser2 ? parser2(left, target) : left;
            var usedRight = parser2 ? parser2(right, target) : right;
            var interpolationArgs = propertyHandler.mixer(usedLeft, usedRight, target);
            if (interpolationArgs) {
              var interp = InterpolationFactory3.apply(void 0, _toConsumableArray2(interpolationArgs));
              return function(t) {
                if (t === 0) return left;
                if (t === 1) return right;
                return interp(t);
              };
            }
          }
        }
        return InterpolationFactory3(false, true, function(bool) {
          return bool ? right : left;
        });
      }
      function interpolate3(from, to, f) {
        if (typeof from === "number" && typeof to === "number") {
          return from * (1 - f) + to * f;
        }
        if (typeof from === "boolean" && typeof to === "boolean" || typeof from === "string" && typeof to === "string") {
          return f < 0.5 ? from : to;
        }
        if (Array.isArray(from) && Array.isArray(to)) {
          var fromLength = from.length;
          var toLength = to.length;
          var length = Math.max(fromLength, toLength);
          var r = [];
          for (var i = 0; i < length; i++) {
            r.push(interpolate3(from[i < fromLength ? i : fromLength - 1], to[i < toLength ? i : toLength - 1], f));
          }
          return r;
        }
        throw new Error("Mismatched interpolation arguments ".concat(from, ":").concat(to));
      }
      var AnimationEffectTiming2 = /* @__PURE__ */ (function() {
        function AnimationEffectTiming3() {
          _classCallCheck2(this, AnimationEffectTiming3);
          this.delay = 0;
          this.direction = "normal";
          this.duration = "auto";
          this._easing = "linear";
          this.easingFunction = linear5;
          this.endDelay = 0;
          this.fill = "auto";
          this.iterationStart = 0;
          this.iterations = 1;
          this.currentIteration = null;
          this.progress = null;
        }
        return _createClass2(AnimationEffectTiming3, [{
          key: "easing",
          get: function get9() {
            return this._easing;
          },
          set: function set6(value) {
            this.easingFunction = parseEasingFunction2(value);
            this._easing = value;
          }
        }]);
      })();
      function convertToArrayForm2(effectInput) {
        var normalizedEffectInput = [];
        for (var property in effectInput) {
          if (property in ["easing", "offset", "composite"]) {
            continue;
          }
          var values2 = effectInput[property];
          if (!Array.isArray(values2)) {
            values2 = [values2];
          }
          var numKeyframes = values2.length;
          for (var i = 0; i < numKeyframes; i++) {
            if (!normalizedEffectInput[i]) {
              var keyframe = {};
              if ("offset" in effectInput) {
                keyframe.offset = Number(effectInput.offset);
              }
              if ("easing" in effectInput) {
                keyframe.easing = effectInput.easing;
              }
              if ("composite" in effectInput) {
                keyframe.composite = effectInput.composite;
              }
              normalizedEffectInput[i] = keyframe;
            }
            if (values2[i] !== void 0 && values2[i] !== null) {
              normalizedEffectInput[i][property] = values2[i];
            }
          }
        }
        normalizedEffectInput.sort(function(a2, b) {
          return (a2.computedOffset || 0) - (b.computedOffset || 0);
        });
        return normalizedEffectInput;
      }
      function normalizeKeyframes2(effectInput, timing) {
        if (effectInput === null) {
          return [];
        }
        if (!Array.isArray(effectInput)) {
          effectInput = convertToArrayForm2(effectInput);
        }
        var keyframes = effectInput.map(function(originalKeyframe) {
          var keyframe = {};
          if (timing !== null && timing !== void 0 && timing.composite) {
            keyframe.composite = "auto";
          }
          for (var member in originalKeyframe) {
            var memberValue = originalKeyframe[member];
            if (member === "offset") {
              if (memberValue !== null) {
                memberValue = Number(memberValue);
                if (!isFinite(memberValue)) throw new Error("Keyframe offsets must be numbers.");
                if (memberValue < 0 || memberValue > 1) throw new Error("Keyframe offsets must be between 0 and 1.");
                keyframe.computedOffset = memberValue;
              }
            } else if (member === "composite") {
              if (["replace", "add", "accumulate", "auto"].indexOf(memberValue) === -1) {
                throw new Error("".concat(memberValue, " compositing is not supported"));
              }
            } else ;
            keyframe[member] = memberValue;
          }
          if (keyframe.offset === void 0) {
            keyframe.offset = null;
          }
          if (keyframe.easing === void 0) {
            keyframe.easing = (timing === null || timing === void 0 ? void 0 : timing.easing) || "linear";
          }
          if (keyframe.composite === void 0) {
            keyframe.composite = "auto";
          }
          return keyframe;
        });
        var everyFrameHasOffset = true;
        var previousOffset = -Infinity;
        for (var i = 0; i < keyframes.length; i++) {
          var offset = keyframes[i].offset;
          if (!util.isNil(offset)) {
            if (offset < previousOffset) {
              throw new TypeError("Keyframes are not loosely sorted by offset. Sort or specify offsets.");
            }
            previousOffset = offset;
          } else {
            everyFrameHasOffset = false;
          }
        }
        keyframes = keyframes.filter(function(keyframe) {
          return Number(keyframe.offset) >= 0 && Number(keyframe.offset) <= 1;
        });
        function spaceKeyframes() {
          var _keyframes$offset;
          var _keyframes = keyframes, length = _keyframes.length;
          keyframes[length - 1].computedOffset = Number((_keyframes$offset = keyframes[length - 1].offset) !== null && _keyframes$offset !== void 0 ? _keyframes$offset : 1);
          if (length > 1) {
            var _keyframes$0$offset;
            keyframes[0].computedOffset = Number((_keyframes$0$offset = keyframes[0].offset) !== null && _keyframes$0$offset !== void 0 ? _keyframes$0$offset : 0);
          }
          var previousIndex = 0;
          var previousOffset2 = Number(keyframes[0].computedOffset);
          for (var _i = 1; _i < length; _i++) {
            var _offset = keyframes[_i].computedOffset;
            if (!util.isNil(_offset) && !util.isNil(previousOffset2)) {
              for (var j = 1; j < _i - previousIndex; j++) keyframes[previousIndex + j].computedOffset = previousOffset2 + (Number(_offset) - previousOffset2) * j / (_i - previousIndex);
              previousIndex = _i;
              previousOffset2 = Number(_offset);
            }
          }
        }
        if (!everyFrameHasOffset) spaceKeyframes();
        return keyframes;
      }
      var fills2 = "backwards|forwards|both|none".split("|");
      var directions2 = "reverse|alternate|alternate-reverse".split("|");
      function makeTiming2(timingInput, forGroup) {
        var timing = new AnimationEffectTiming2();
        if (forGroup) {
          timing.fill = "both";
          timing.duration = "auto";
        }
        if (typeof timingInput === "number" && !isNaN(timingInput)) {
          timing.duration = timingInput;
        } else if (timingInput !== void 0) {
          Object.keys(timingInput).forEach(function(property) {
            if (timingInput[property] !== void 0 && timingInput[property] !== null && timingInput[property] !== "auto") {
              if (typeof timing[property] === "number" || property === "duration") {
                if (typeof timingInput[property] !== "number" || isNaN(timingInput[property])) {
                  return;
                }
              }
              if (property === "fill" && fills2.indexOf(timingInput[property]) === -1) {
                return;
              }
              if (property === "direction" && directions2.indexOf(timingInput[property]) === -1) {
                return;
              }
              timing[property] = timingInput[property];
            }
          });
        }
        return timing;
      }
      function normalizeTimingInput2(timingInput, forGroup) {
        timingInput = numericTimingToObject2(timingInput !== null && timingInput !== void 0 ? timingInput : {
          duration: "auto"
        });
        return makeTiming2(timingInput, forGroup);
      }
      function numericTimingToObject2(timingInput) {
        if (typeof timingInput === "number") {
          if (isNaN(timingInput)) {
            timingInput = {
              duration: "auto"
            };
          } else {
            timingInput = {
              duration: timingInput
            };
          }
        }
        return timingInput;
      }
      var KeyframeEffect2 = /* @__PURE__ */ (function() {
        function KeyframeEffect3(target, effectInput, timingInput) {
          var _this2 = this;
          _classCallCheck2(this, KeyframeEffect3);
          this.composite = "replace";
          this.iterationComposite = "replace";
          this.target = target;
          this.timing = normalizeTimingInput2(timingInput, false);
          this.timing.effect = this;
          this.timing.activeDuration = calculateActiveDuration2(this.timing);
          this.timing.endTime = Math.max(0, this.timing.delay + this.timing.activeDuration + this.timing.endDelay);
          this.normalizedKeyframes = normalizeKeyframes2(effectInput, this.timing);
          this.interpolations = convertEffectInput2(this.normalizedKeyframes, this.timing, this.target);
          var Proxy3 = gLite.runtime.globalThis.Proxy;
          this.computedTiming = Proxy3 ? new Proxy3(this.timing, {
            get: function get9(target2, prop) {
              if (prop === "duration") {
                return target2.duration === "auto" ? 0 : target2.duration;
              }
              if (prop === "fill") {
                return target2.fill === "auto" ? "none" : target2.fill;
              }
              if (prop === "localTime") {
                return _this2.animation && _this2.animation.currentTime || null;
              }
              if (prop === "currentIteration") {
                if (!_this2.animation || _this2.animation.playState !== "running") {
                  return null;
                }
                return target2.currentIteration || 0;
              }
              if (prop === "progress") {
                if (!_this2.animation || _this2.animation.playState !== "running") {
                  return null;
                }
                return target2.progress || 0;
              }
              return target2[prop];
            },
            set: function set6() {
              return true;
            }
          }) : this.timing;
        }
        return _createClass2(KeyframeEffect3, [{
          key: "applyInterpolations",
          value: function applyInterpolations() {
            this.interpolations(this.target, Number(this.timeFraction));
          }
        }, {
          key: "update",
          value: function update(localTime) {
            if (localTime === null) {
              return false;
            }
            this.timeFraction = calculateIterationProgress2(this.timing.activeDuration, localTime, this.timing);
            return this.timeFraction !== null;
          }
        }, {
          key: "getKeyframes",
          value: function getKeyframes() {
            return this.normalizedKeyframes;
          }
        }, {
          key: "setKeyframes",
          value: function setKeyframes(keyframes) {
            this.normalizedKeyframes = normalizeKeyframes2(keyframes);
          }
          /**
           * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getComputedTiming
           */
        }, {
          key: "getComputedTiming",
          value: function getComputedTiming() {
            return this.computedTiming;
          }
          /**
           * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getTiming
           */
        }, {
          key: "getTiming",
          value: function getTiming() {
            return this.timing;
          }
          /**
           * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/updateTiming
           */
        }, {
          key: "updateTiming",
          value: function updateTiming(timing) {
            var _this2 = this;
            Object.keys(timing || {}).forEach(function(name) {
              _this2.timing[name] = timing[name];
            });
          }
        }]);
      })();
      function compareAnimations2(leftAnimation, rightAnimation) {
        return Number(leftAnimation.id) - Number(rightAnimation.id);
      }
      var AnimationTimeline2 = /* @__PURE__ */ (function() {
        function AnimationTimeline3(document2) {
          var _this2 = this;
          _classCallCheck2(this, AnimationTimeline3);
          this.animations = [];
          this.ticking = false;
          this.timelineTicking = false;
          this.hasRestartedThisFrame = false;
          this.animationsWithPromises = [];
          this.inTick = false;
          this.pendingEffects = [];
          this.currentTime = null;
          this.rafId = 0;
          this.rafCallbacks = [];
          this.webAnimationsNextTick = function(t) {
            _this2.currentTime = t;
            _this2.discardAnimations();
            if (_this2.animations.length === 0) {
              _this2.timelineTicking = false;
            } else {
              _this2.requestAnimationFrame(_this2.webAnimationsNextTick);
            }
          };
          this.processRafCallbacks = function(t) {
            var processing = _this2.rafCallbacks;
            _this2.rafCallbacks = [];
            if (t < Number(_this2.currentTime)) t = Number(_this2.currentTime);
            _this2.animations.sort(compareAnimations2);
            _this2.animations = _this2.tick(t, true, _this2.animations)[0];
            processing.forEach(function(entry) {
              entry[1](t);
            });
            _this2.applyPendingEffects();
          };
          this.document = document2;
        }
        return _createClass2(AnimationTimeline3, [{
          key: "getAnimations",
          value: function getAnimations() {
            this.discardAnimations();
            return this.animations.slice();
          }
        }, {
          key: "isTicking",
          value: function isTicking() {
            return this.inTick;
          }
        }, {
          key: "play",
          value: function play(target, keyframes, options) {
            var effect2 = new KeyframeEffect2(target, keyframes, options);
            var animation = new Animation3(effect2, this);
            this.animations.push(animation);
            this.restartWebAnimationsNextTick();
            animation.updatePromises();
            animation.play();
            animation.updatePromises();
            return animation;
          }
          // RAF is supposed to be the last script to occur before frame rendering but not
          // all browsers behave like this. This function is for synchonously updating an
          // animation's effects whenever its state is mutated by script to work around
          // incorrect script execution ordering by the browser.
        }, {
          key: "applyDirtiedAnimation",
          value: function applyDirtiedAnimation(animation) {
            var _this2 = this;
            if (this.inTick) {
              return;
            }
            animation.markTarget();
            var animations = animation.targetAnimations();
            animations.sort(compareAnimations2);
            var inactiveAnimations = this.tick(Number(this.currentTime), false, animations.slice())[1];
            inactiveAnimations.forEach(function(animation2) {
              var index2 = _this2.animations.indexOf(animation2);
              if (index2 !== -1) {
                _this2.animations.splice(index2, 1);
              }
            });
            this.applyPendingEffects();
          }
        }, {
          key: "restart",
          value: function restart() {
            if (!this.ticking) {
              this.ticking = true;
              this.requestAnimationFrame(function() {
              });
              this.hasRestartedThisFrame = true;
            }
            return this.hasRestartedThisFrame;
          }
        }, {
          key: "destroy",
          value: function destroy() {
            this.document.defaultView.cancelAnimationFrame(this.frameId);
          }
        }, {
          key: "applyPendingEffects",
          value: function applyPendingEffects() {
            this.pendingEffects.forEach(function(effect2) {
              effect2 === null || effect2 === void 0 || effect2.applyInterpolations();
            });
            this.pendingEffects = [];
          }
        }, {
          key: "updateAnimationsPromises",
          value: function updateAnimationsPromises() {
            this.animationsWithPromises = this.animationsWithPromises.filter(function(animation) {
              return animation.updatePromises();
            });
          }
        }, {
          key: "discardAnimations",
          value: function discardAnimations() {
            this.updateAnimationsPromises();
            this.animations = this.animations.filter(function(animation) {
              return animation.playState !== "finished" && animation.playState !== "idle";
            });
          }
        }, {
          key: "restartWebAnimationsNextTick",
          value: function restartWebAnimationsNextTick() {
            if (!this.timelineTicking) {
              this.timelineTicking = true;
              this.requestAnimationFrame(this.webAnimationsNextTick);
            }
          }
        }, {
          key: "rAF",
          value: function rAF(f) {
            var id3 = this.rafId++;
            if (this.rafCallbacks.length === 0) {
              this.frameId = this.document.defaultView.requestAnimationFrame(this.processRafCallbacks);
            }
            this.rafCallbacks.push([id3, f]);
            return id3;
          }
        }, {
          key: "requestAnimationFrame",
          value: function requestAnimationFrame2(f) {
            var _this3 = this;
            return this.rAF(function(x3) {
              _this3.updateAnimationsPromises();
              f(x3);
              _this3.updateAnimationsPromises();
            });
          }
        }, {
          key: "tick",
          value: function tick2(t, isAnimationFrame, updatingAnimations) {
            var _this4 = this, _this$pendingEffects, _this$pendingEffects2;
            this.inTick = true;
            this.hasRestartedThisFrame = false;
            this.currentTime = t;
            this.ticking = false;
            var newPendingClears = [];
            var newPendingEffects = [];
            var activeAnimations = [];
            var inactiveAnimations = [];
            updatingAnimations.forEach(function(animation) {
              animation.tick(t, isAnimationFrame);
              if (!animation._inEffect) {
                newPendingClears.push(animation.effect);
                animation.unmarkTarget();
              } else {
                newPendingEffects.push(animation.effect);
                animation.markTarget();
              }
              if (animation._needsTick) _this4.ticking = true;
              var alive = animation._inEffect || animation._needsTick;
              animation._inTimeline = alive;
              if (alive) {
                activeAnimations.push(animation);
              } else {
                inactiveAnimations.push(animation);
              }
            });
            (_this$pendingEffects = this.pendingEffects).push.apply(_this$pendingEffects, newPendingClears);
            (_this$pendingEffects2 = this.pendingEffects).push.apply(_this$pendingEffects2, newPendingEffects);
            if (this.ticking) this.requestAnimationFrame(function() {
            });
            this.inTick = false;
            return [activeAnimations, inactiveAnimations];
          }
        }]);
      })();
      gLite.runtime.EasingFunction = parseEasingFunction2;
      gLite.runtime.AnimationTimeline = AnimationTimeline2;
      exports.Animation = Animation3;
      exports.AnimationEvent = AnimationEvent2;
      exports.AnimationTimeline = AnimationTimeline2;
      exports.EasingFunctions = EasingFunctions2;
      exports.KeyframeEffect = KeyframeEffect2;
      exports.compareAnimations = compareAnimations2;
      exports.makeTiming = makeTiming2;
      exports.normalizeKeyframes = normalizeKeyframes2;
      exports.normalizeTimingInput = normalizeTimingInput2;
      exports.numericTimingToObject = numericTimingToObject2;
    }
  });

  // node_modules/@antv/g/dist/index.js
  var require_dist6 = __commonJS({
    "node_modules/@antv/g/dist/index.js"(exports) {
      "use strict";
      var gCameraApi = require_dist3();
      var gDomMutationObserverApi = require_dist4();
      var gLite = require_dist2();
      var gWebAnimationsApi = require_dist5();
      Object.keys(gCameraApi).forEach(function(k) {
        if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
          enumerable: true,
          get: function() {
            return gCameraApi[k];
          }
        });
      });
      Object.keys(gDomMutationObserverApi).forEach(function(k) {
        if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
          enumerable: true,
          get: function() {
            return gDomMutationObserverApi[k];
          }
        });
      });
      Object.keys(gLite).forEach(function(k) {
        if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
          enumerable: true,
          get: function() {
            return gLite[k];
          }
        });
      });
      Object.keys(gWebAnimationsApi).forEach(function(k) {
        if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
          enumerable: true,
          get: function() {
            return gWebAnimationsApi[k];
          }
        });
      });
    }
  });

  // node_modules/@antv/g6/lib/utils/shape.js
  var require_shape = __commonJS({
    "node_modules/@antv/g6/lib/utils/shape.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getDescendantShapes = getDescendantShapes2;
      exports.getAncestorShapes = getAncestorShapes2;
      function getDescendantShapes2(shape) {
        const succeeds = [];
        const traverse2 = (shape2) => {
          if (shape2 === null || shape2 === void 0 ? void 0 : shape2.children.length) {
            shape2.children.forEach((child) => {
              succeeds.push(child);
              traverse2(child);
            });
          }
        };
        traverse2(shape);
        return succeeds;
      }
      function getAncestorShapes2(shape) {
        const ancestors = [];
        let currentNode = shape.parentNode;
        while (currentNode) {
          ancestors.push(currentNode);
          currentNode = currentNode.parentNode;
        }
        return ancestors;
      }
    }
  });

  // node_modules/@antv/g6/lib/elements/shapes/image.js
  var require_image = __commonJS({
    "node_modules/@antv/g6/lib/elements/shapes/image.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.dispatchPositionChange = exports.connectImage = exports.Image = void 0;
      var g_1 = require_dist6();
      var shape_1 = require_shape();
      var Image6 = class extends g_1.Image {
        constructor(options) {
          super(options);
          this.onMounted = () => {
            this.handleRadius();
          };
          this.onAttrModified = () => {
            this.handleRadius();
          };
          current2 = this;
          this.isMutationObserved = true;
          this.addEventListener(g_1.ElementEvent.MOUNTED, this.onMounted);
          this.addEventListener(g_1.ElementEvent.ATTR_MODIFIED, this.onAttrModified);
        }
        handleRadius() {
          const { radius, clipPath, width: width2 = 0, height = 0 } = this.attributes;
          if (radius && width2 && height) {
            const [x3, y3] = this.getBounds().min;
            const clipPathStyle = { x: x3, y: y3, radius, width: width2, height };
            if (clipPath) {
              Object.assign(this.parsedStyle.clipPath.style, clipPathStyle);
            } else {
              const rect2 = new g_1.Rect({ style: clipPathStyle });
              this.style.clipPath = rect2;
            }
          } else {
            if (clipPath)
              this.style.clipPath = null;
          }
        }
      };
      exports.Image = Image6;
      var ImagesWeakMap2 = /* @__PURE__ */ new WeakMap();
      var current2 = null;
      var connectImage3 = (target) => {
        if (current2 && (0, shape_1.getAncestorShapes)(current2).includes(target)) {
          const images = ImagesWeakMap2.get(target);
          if (images) {
            if (!images.includes(current2))
              images.push(current2);
          } else
            ImagesWeakMap2.set(target, [current2]);
        }
      };
      exports.connectImage = connectImage3;
      var dispatchPositionChange2 = (target) => {
        const image = ImagesWeakMap2.get(target);
        if (image) {
          image.forEach((i) => i.handleRadius());
        }
      };
      exports.dispatchPositionChange = dispatchPositionChange2;
    }
  });

  // node_modules/@babel/runtime/helpers/esm/typeof.js
  function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof(o);
  }

  // node_modules/@babel/runtime/helpers/esm/toPrimitive.js
  function toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != _typeof(i)) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }

  // node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
  function toPropertyKey(t) {
    var i = toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
  }

  // node_modules/@babel/runtime/helpers/esm/defineProperty.js
  function _defineProperty(e, r, t) {
    return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e[r] = t, e;
  }

  // node_modules/@babel/runtime/helpers/esm/objectSpread2.js
  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread2(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }

  // node_modules/@babel/runtime/helpers/esm/classCallCheck.js
  function _classCallCheck(a2, n) {
    if (!(a2 instanceof n)) throw new TypeError("Cannot call a class as a function");
  }

  // node_modules/@babel/runtime/helpers/esm/createClass.js
  function _defineProperties(e, r) {
    for (var t = 0; t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
      writable: false
    }), e;
  }

  // node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
  function _arrayLikeToArray(r, a2) {
    (null == a2 || a2 > r.length) && (a2 = r.length);
    for (var e = 0, n = Array(a2); e < a2; e++) n[e] = r[e];
    return n;
  }

  // node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
  function _arrayWithoutHoles(r) {
    if (Array.isArray(r)) return _arrayLikeToArray(r);
  }

  // node_modules/@babel/runtime/helpers/esm/iterableToArray.js
  function _iterableToArray(r) {
    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
  }

  // node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
  function _unsupportedIterableToArray(r, a2) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray(r, a2);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a2) : void 0;
    }
  }

  // node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  // node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
  function _toConsumableArray(r) {
    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
  }

  // node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
      return t2.__proto__ || Object.getPrototypeOf(t2);
    }, _getPrototypeOf(t);
  }

  // node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch (t2) {
    }
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
      return !!t;
    })();
  }

  // node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
  function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }

  // node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
  function _possibleConstructorReturn(t, e) {
    if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t);
  }

  // node_modules/@babel/runtime/helpers/esm/callSuper.js
  function _callSuper(t, o, e) {
    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
  }

  // node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e3) {
      return t2.__proto__ = e3, t2;
    }, _setPrototypeOf(t, e);
  }

  // node_modules/@babel/runtime/helpers/esm/inherits.js
  function _inherits(t, e) {
    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t,
        writable: true,
        configurable: true
      }
    }), Object.defineProperty(t, "prototype", {
      writable: false
    }), e && _setPrototypeOf(t, e);
  }

  // node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
  function _arrayWithHoles(r) {
    if (Array.isArray(r)) return r;
  }

  // node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
  function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e, n, i, u, a2 = [], f = true, o = false;
      try {
        if (i = (t = t.call(r)).next, 0 === l) {
          if (Object(t) !== t) return;
          f = false;
        } else for (; !(f = (e = i.call(t)).done) && (a2.push(e.value), a2.length !== l); f = true) ;
      } catch (r2) {
        o = true, n = r2;
      } finally {
        try {
          if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
        } finally {
          if (o) throw n;
        }
      }
      return a2;
    }
  }

  // node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  // node_modules/@babel/runtime/helpers/esm/slicedToArray.js
  function _slicedToArray(r, e) {
    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
  }

  // node_modules/eventemitter3/index.mjs
  var import_index = __toESM(require_eventemitter3(), 1);
  var eventemitter3_default = import_index.default;

  // node_modules/@antv/g-lite/dist/index.esm.js
  var import_gl_matrix2 = __toESM(require_cjs());
  var import_util2 = __toESM(require_lib());

  // node_modules/@babel/runtime/helpers/esm/superPropBase.js
  function _superPropBase(t, o) {
    for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)); ) ;
    return t;
  }

  // node_modules/@babel/runtime/helpers/esm/get.js
  function _get() {
    return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {
      var p = _superPropBase(e, t);
      if (p) {
        var n = Object.getOwnPropertyDescriptor(p, t);
        return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
      }
    }, _get.apply(null, arguments);
  }

  // node_modules/@babel/runtime/helpers/esm/superPropGet.js
  function _superPropGet(t, o, e, r) {
    var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e);
    return 2 & r && "function" == typeof p ? function(t2) {
      return p.apply(e, t2);
    } : p;
  }

  // node_modules/@antv/g-math/dist/index.esm.js
  var import_util = __toESM(require_lib());
  var import_gl_matrix = __toESM(require_cjs());
  function distance(x1, y1, x22, y22) {
    var dx = x1 - x22;
    var dy = y1 - y22;
    return Math.sqrt(dx * dx + dy * dy);
  }
  function getBBoxByArray(xArr, yArr) {
    var minX = Math.min.apply(Math, _toConsumableArray(xArr));
    var minY = Math.min.apply(Math, _toConsumableArray(yArr));
    var maxX = Math.max.apply(Math, _toConsumableArray(xArr));
    var maxY = Math.max.apply(Math, _toConsumableArray(yArr));
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  function xExtrema(rx, ry, xRotation) {
    return Math.atan(-ry / rx * Math.tan(xRotation));
  }
  function yExtrema(rx, ry, xRotation) {
    return Math.atan(ry / (rx * Math.tan(xRotation)));
  }
  function xAt(cx, cy, rx, ry, xRotation, angle2) {
    return rx * Math.cos(xRotation) * Math.cos(angle2) - ry * Math.sin(xRotation) * Math.sin(angle2) + cx;
  }
  function yAt(cx, cy, rx, ry, xRotation, angle2) {
    return rx * Math.sin(xRotation) * Math.cos(angle2) + ry * Math.cos(xRotation) * Math.sin(angle2) + cy;
  }
  function box$5(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
    var xDim = xExtrema(rx, ry, xRotation);
    var minX = Infinity;
    var maxX = -Infinity;
    var xs = [startAngle, endAngle];
    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
      var xAngle = xDim + i;
      if (startAngle < endAngle) {
        if (startAngle < xAngle && xAngle < endAngle) {
          xs.push(xAngle);
        }
      } else if (endAngle < xAngle && xAngle < startAngle) {
        xs.push(xAngle);
      }
    }
    for (var _i = 0; _i < xs.length; _i++) {
      var x3 = xAt(cx, cy, rx, ry, xRotation, xs[_i]);
      if (x3 < minX) {
        minX = x3;
      }
      if (x3 > maxX) {
        maxX = x3;
      }
    }
    var yDim = yExtrema(rx, ry, xRotation);
    var minY = Infinity;
    var maxY = -Infinity;
    var ys = [startAngle, endAngle];
    for (var _i2 = -Math.PI * 2; _i2 <= Math.PI * 2; _i2 += Math.PI) {
      var yAngle = yDim + _i2;
      if (startAngle < endAngle) {
        if (startAngle < yAngle && yAngle < endAngle) {
          ys.push(yAngle);
        }
      } else if (endAngle < yAngle && yAngle < startAngle) {
        ys.push(yAngle);
      }
    }
    for (var _i3 = 0; _i3 < ys.length; _i3++) {
      var y3 = yAt(cx, cy, rx, ry, xRotation, ys[_i3]);
      if (y3 < minY) {
        minY = y3;
      }
      if (y3 > maxY) {
        maxY = y3;
      }
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  var EPSILON = 1e-4;
  function nearestPoint$2(xArr, yArr, x3, y3, tCallback, length) {
    var t = -1;
    var d2 = Infinity;
    var v0 = [x3, y3];
    var segNum = 20;
    if (length && length > 200) {
      segNum = length / 10;
    }
    var increaseRate = 1 / segNum;
    var interval2 = increaseRate / 10;
    for (var i = 0; i <= segNum; i++) {
      var _t = i * increaseRate;
      var v1 = [tCallback.apply(void 0, _toConsumableArray(xArr.concat([_t]))), tCallback.apply(void 0, _toConsumableArray(yArr.concat([_t])))];
      var d1 = distance(v0[0], v0[1], v1[0], v1[1]);
      if (d1 < d2) {
        t = _t;
        d2 = d1;
      }
    }
    if (t === 0) {
      return {
        x: xArr[0],
        y: yArr[0]
      };
    }
    if (t === 1) {
      var count = xArr.length;
      return {
        x: xArr[count - 1],
        y: yArr[count - 1]
      };
    }
    d2 = Infinity;
    for (var _i = 0; _i < 32; _i++) {
      if (interval2 < EPSILON) {
        break;
      }
      var prev = t - interval2;
      var next = t + interval2;
      var _v = [tCallback.apply(void 0, _toConsumableArray(xArr.concat([prev]))), tCallback.apply(void 0, _toConsumableArray(yArr.concat([prev])))];
      var _d = distance(v0[0], v0[1], _v[0], _v[1]);
      if (prev >= 0 && _d < d2) {
        t = prev;
        d2 = _d;
      } else {
        var v2 = [tCallback.apply(void 0, _toConsumableArray(xArr.concat([next]))), tCallback.apply(void 0, _toConsumableArray(yArr.concat([next])))];
        var d22 = distance(v0[0], v0[1], v2[0], v2[1]);
        if (next <= 1 && d22 < d2) {
          t = next;
          d2 = d22;
        } else {
          interval2 *= 0.5;
        }
      }
    }
    return {
      x: tCallback.apply(void 0, _toConsumableArray(xArr.concat([t]))),
      y: tCallback.apply(void 0, _toConsumableArray(yArr.concat([t])))
    };
  }
  function length$4(x1, y1, x22, y22) {
    return distance(x1, y1, x22, y22);
  }
  function pointAt$3(x1, y1, x22, y22, t) {
    return {
      x: (1 - t) * x1 + t * x22,
      y: (1 - t) * y1 + t * y22
    };
  }
  function pointToLine(x1, y1, x22, y22, x3, y3) {
    var d2 = [x22 - x1, y22 - y1];
    if (import_gl_matrix.vec2.exactEquals(d2, [0, 0])) {
      return Math.sqrt((x3 - x1) * (x3 - x1) + (y3 - y1) * (y3 - y1));
    }
    var u = [-d2[1], d2[0]];
    import_gl_matrix.vec2.normalize(u, u);
    var a2 = [x3 - x1, y3 - y1];
    return Math.abs(import_gl_matrix.vec2.dot(a2, u));
  }
  function cubicAt(p0, p1, p2, p3, t) {
    var onet = 1 - t;
    return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;
  }
  function extrema$1(p0, p1, p2, p3) {
    var a2 = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
    var b = 6 * p0 - 12 * p1 + 6 * p2;
    var c2 = 3 * p1 - 3 * p0;
    var extremas = [];
    var t1;
    var t2;
    var discSqrt;
    if ((0, import_util.isNumberEqual)(a2, 0)) {
      if (!(0, import_util.isNumberEqual)(b, 0)) {
        t1 = -c2 / b;
        if (t1 >= 0 && t1 <= 1) {
          extremas.push(t1);
        }
      }
    } else {
      var disc = b * b - 4 * a2 * c2;
      if ((0, import_util.isNumberEqual)(disc, 0)) {
        extremas.push(-b / (2 * a2));
      } else if (disc > 0) {
        discSqrt = Math.sqrt(disc);
        t1 = (-b + discSqrt) / (2 * a2);
        t2 = (-b - discSqrt) / (2 * a2);
        if (t1 >= 0 && t1 <= 1) {
          extremas.push(t1);
        }
        if (t2 >= 0 && t2 <= 1) {
          extremas.push(t2);
        }
      }
    }
    return extremas;
  }
  function box$3(x1, y1, x22, y22, x3, y3, x4, y4) {
    var xArr = [x1, x4];
    var yArr = [y1, y4];
    var xExtrema2 = extrema$1(x1, x22, x3, x4);
    var yExtrema2 = extrema$1(y1, y22, y3, y4);
    for (var i = 0; i < xExtrema2.length; i++) {
      xArr.push(cubicAt(x1, x22, x3, x4, xExtrema2[i]));
    }
    for (var _i = 0; _i < yExtrema2.length; _i++) {
      yArr.push(cubicAt(y1, y22, y3, y4, yExtrema2[_i]));
    }
    return getBBoxByArray(xArr, yArr);
  }
  function nearestPoint$1(x1, y1, x22, y22, x3, y3, x4, y4, x0, y0, length) {
    return nearestPoint$2([x1, x22, x3, x4], [y1, y22, y3, y4], x0, y0, cubicAt, length);
  }
  function pointDistance$3(x1, y1, x22, y22, x3, y3, x4, y4, x0, y0, length) {
    var point4 = nearestPoint$1(x1, y1, x22, y22, x3, y3, x4, y4, x0, y0, length);
    return distance(point4.x, point4.y, x0, y0);
  }
  function lengthOfSegment(points) {
    if (points.length < 2) {
      return 0;
    }
    var totalLength = 0;
    for (var i = 0; i < points.length - 1; i++) {
      var from = points[i];
      var to = points[i + 1];
      totalLength += distance(from[0], from[1], to[0], to[1]);
    }
    return totalLength;
  }
  function length$2(points) {
    return lengthOfSegment(points);
  }
  function quadraticAt(p0, p1, p2, t) {
    var onet = 1 - t;
    return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
  }
  function extrema(p0, p1, p2) {
    var a2 = p0 + p2 - 2 * p1;
    if ((0, import_util.isNumberEqual)(a2, 0)) {
      return [0.5];
    }
    var rst = (p0 - p1) / a2;
    if (rst <= 1 && rst >= 0) {
      return [rst];
    }
    return [];
  }
  function box(x1, y1, x22, y22, x3, y3) {
    var xExtrema2 = extrema(x1, x22, x3)[0];
    var yExtrema2 = extrema(y1, y22, y3)[0];
    var xArr = [x1, x3];
    var yArr = [y1, y3];
    if (xExtrema2 !== void 0) {
      xArr.push(quadraticAt(x1, x22, x3, xExtrema2));
    }
    if (yExtrema2 !== void 0) {
      yArr.push(quadraticAt(y1, y22, y3, yExtrema2));
    }
    return getBBoxByArray(xArr, yArr);
  }
  function nearestPoint(x1, y1, x22, y22, x3, y3, x0, y0) {
    return nearestPoint$2([x1, x22, x3], [y1, y22, y3], x0, y0, quadraticAt);
  }
  function pointDistance(x1, y1, x22, y22, x3, y3, x0, y0) {
    var point4 = nearestPoint(x1, y1, x22, y22, x3, y3, x0, y0);
    return distance(point4.x, point4.y, x0, y0);
  }

  // node_modules/@babel/runtime/helpers/esm/OverloadYield.js
  function _OverloadYield(e, d2) {
    this.v = e, this.k = d2;
  }

  // node_modules/@babel/runtime/helpers/esm/regeneratorDefine.js
  function _regeneratorDefine(e, r, n, t) {
    var i = Object.defineProperty;
    try {
      i({}, "", {});
    } catch (e3) {
      i = 0;
    }
    _regeneratorDefine = function regeneratorDefine(e3, r2, n2, t2) {
      function o(r3, n3) {
        _regeneratorDefine(e3, r3, function(e4) {
          return this._invoke(r3, n3, e4);
        });
      }
      r2 ? i ? i(e3, r2, {
        value: n2,
        enumerable: !t2,
        configurable: !t2,
        writable: !t2
      }) : e3[r2] = n2 : (o("next", 0), o("throw", 1), o("return", 2));
    }, _regeneratorDefine(e, r, n, t);
  }

  // node_modules/@babel/runtime/helpers/esm/regenerator.js
  function _regenerator() {
    var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag";
    function i(r2, n2, o2, i2) {
      var c3 = n2 && n2.prototype instanceof Generator ? n2 : Generator, u2 = Object.create(c3.prototype);
      return _regeneratorDefine(u2, "_invoke", (function(r3, n3, o3) {
        var i3, c4, u3, f2 = 0, p = o3 || [], y3 = false, G = {
          p: 0,
          n: 0,
          v: e,
          a: d2,
          f: d2.bind(e, 4),
          d: function d3(t2, r4) {
            return i3 = t2, c4 = 0, u3 = e, G.n = r4, a2;
          }
        };
        function d2(r4, n4) {
          for (c4 = r4, u3 = n4, t = 0; !y3 && f2 && !o4 && t < p.length; t++) {
            var o4, i4 = p[t], d3 = G.p, l = i4[2];
            r4 > 3 ? (o4 = l === n4) && (u3 = i4[(c4 = i4[4]) ? 5 : (c4 = 3, 3)], i4[4] = i4[5] = e) : i4[0] <= d3 && ((o4 = r4 < 2 && d3 < i4[1]) ? (c4 = 0, G.v = n4, G.n = i4[1]) : d3 < l && (o4 = r4 < 3 || i4[0] > n4 || n4 > l) && (i4[4] = r4, i4[5] = n4, G.n = l, c4 = 0));
          }
          if (o4 || r4 > 1) return a2;
          throw y3 = true, n4;
        }
        return function(o4, p2, l) {
          if (f2 > 1) throw TypeError("Generator is already running");
          for (y3 && 1 === p2 && d2(p2, l), c4 = p2, u3 = l; (t = c4 < 2 ? e : u3) || !y3; ) {
            i3 || (c4 ? c4 < 3 ? (c4 > 1 && (G.n = -1), d2(c4, u3)) : G.n = u3 : G.v = u3);
            try {
              if (f2 = 2, i3) {
                if (c4 || (o4 = "next"), t = i3[o4]) {
                  if (!(t = t.call(i3, u3))) throw TypeError("iterator result is not an object");
                  if (!t.done) return t;
                  u3 = t.value, c4 < 2 && (c4 = 0);
                } else 1 === c4 && (t = i3["return"]) && t.call(i3), c4 < 2 && (u3 = TypeError("The iterator does not provide a '" + o4 + "' method"), c4 = 1);
                i3 = e;
              } else if ((t = (y3 = G.n < 0) ? u3 : r3.call(n3, G)) !== a2) break;
            } catch (t2) {
              i3 = e, c4 = 1, u3 = t2;
            } finally {
              f2 = 1;
            }
          }
          return {
            value: t,
            done: y3
          };
        };
      })(r2, o2, i2), true), u2;
    }
    var a2 = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    t = Object.getPrototypeOf;
    var c2 = [][n] ? t(t([][n]())) : (_regeneratorDefine(t = {}, n, function() {
      return this;
    }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c2);
    function f(e3) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(e3, GeneratorFunctionPrototype) : (e3.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine(e3, o, "GeneratorFunction")), e3.prototype = Object.create(u), e3;
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine(u), _regeneratorDefine(u, o, "Generator"), _regeneratorDefine(u, n, function() {
      return this;
    }), _regeneratorDefine(u, "toString", function() {
      return "[object Generator]";
    }), (_regenerator = function _regenerator2() {
      return {
        w: i,
        m: f
      };
    })();
  }

  // node_modules/@babel/runtime/helpers/esm/regeneratorAsyncIterator.js
  function AsyncIterator2(t, e) {
    function n(r2, o, i, f) {
      try {
        var c2 = t[r2](o), u = c2.value;
        return u instanceof _OverloadYield ? e.resolve(u.v).then(function(t2) {
          n("next", t2, i, f);
        }, function(t2) {
          n("throw", t2, i, f);
        }) : e.resolve(u).then(function(t2) {
          c2.value = t2, i(c2);
        }, function(t2) {
          return n("throw", t2, i, f);
        });
      } catch (t2) {
        f(t2);
      }
    }
    var r;
    this.next || (_regeneratorDefine(AsyncIterator2.prototype), _regeneratorDefine(AsyncIterator2.prototype, "function" == typeof Symbol && Symbol.asyncIterator || "@asyncIterator", function() {
      return this;
    })), _regeneratorDefine(this, "_invoke", function(t2, o, i) {
      function f() {
        return new e(function(e3, r2) {
          n(t2, i, e3, r2);
        });
      }
      return r = r ? r.then(f, f) : f();
    }, true);
  }

  // node_modules/@babel/runtime/helpers/esm/regeneratorAsyncGen.js
  function _regeneratorAsyncGen(r, e, t, o, n) {
    return new AsyncIterator2(_regenerator().w(r, e, t, o), n || Promise);
  }

  // node_modules/@babel/runtime/helpers/esm/regeneratorAsync.js
  function _regeneratorAsync(n, e, r, t, o) {
    var a2 = _regeneratorAsyncGen(n, e, r, t, o);
    return a2.next().then(function(n2) {
      return n2.done ? n2.value : a2.next();
    });
  }

  // node_modules/@babel/runtime/helpers/esm/regeneratorKeys.js
  function _regeneratorKeys(e) {
    var n = Object(e), r = [];
    for (var t in n) r.unshift(t);
    return function e3() {
      for (; r.length; ) if ((t = r.pop()) in n) return e3.value = t, e3.done = false, e3;
      return e3.done = true, e3;
    };
  }

  // node_modules/@babel/runtime/helpers/esm/regeneratorValues.js
  function _regeneratorValues(e) {
    if (null != e) {
      var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0;
      if (t) return t.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) return {
        next: function next() {
          return e && r >= e.length && (e = void 0), {
            value: e && e[r++],
            done: !e
          };
        }
      };
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }

  // node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js
  function _regeneratorRuntime() {
    "use strict";
    var r = _regenerator(), e = r.m(_regeneratorRuntime), t = (Object.getPrototypeOf ? Object.getPrototypeOf(e) : e.__proto__).constructor;
    function n(r2) {
      var e3 = "function" == typeof r2 && r2.constructor;
      return !!e3 && (e3 === t || "GeneratorFunction" === (e3.displayName || e3.name));
    }
    var o = {
      "throw": 1,
      "return": 2,
      "break": 3,
      "continue": 3
    };
    function a2(r2) {
      var e3, t2;
      return function(n2) {
        e3 || (e3 = {
          stop: function stop() {
            return t2(n2.a, 2);
          },
          "catch": function _catch() {
            return n2.v;
          },
          abrupt: function abrupt(r3, e4) {
            return t2(n2.a, o[r3], e4);
          },
          delegateYield: function delegateYield(r3, o2, a3) {
            return e3.resultName = o2, t2(n2.d, _regeneratorValues(r3), a3);
          },
          finish: function finish(r3) {
            return t2(n2.f, r3);
          }
        }, t2 = function t3(r3, _t, o2) {
          n2.p = e3.prev, n2.n = e3.next;
          try {
            return r3(_t, o2);
          } finally {
            e3.next = n2.n;
          }
        }), e3.resultName && (e3[e3.resultName] = n2.v, e3.resultName = void 0), e3.sent = n2.v, e3.next = n2.n;
        try {
          return r2.call(this, e3);
        } finally {
          n2.p = e3.prev, n2.n = e3.next;
        }
      };
    }
    return (_regeneratorRuntime = function _regeneratorRuntime2() {
      return {
        wrap: function wrap3(e3, t2, n2, o2) {
          return r.w(a2(e3), t2, n2, o2 && o2.reverse());
        },
        isGeneratorFunction: n,
        mark: r.m,
        awrap: function awrap(r2, e3) {
          return new _OverloadYield(r2, e3);
        },
        AsyncIterator: AsyncIterator2,
        async: function async(r2, e3, t2, o2, u) {
          return (n(e3) ? _regeneratorAsyncGen : _regeneratorAsync)(a2(r2), e3, t2, o2, u);
        },
        keys: _regeneratorKeys,
        values: _regeneratorValues
      };
    })();
  }

  // node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
  function asyncGeneratorStep(n, t, e, r, o, a2, c2) {
    try {
      var i = n[a2](c2), u = i.value;
    } catch (n2) {
      return void e(n2);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
  }
  function _asyncToGenerator(n) {
    return function() {
      var t = this, e = arguments;
      return new Promise(function(r, o) {
        var a2 = n.apply(t, e);
        function _next(n2) {
          asyncGeneratorStep(a2, r, o, _next, _throw, "next", n2);
        }
        function _throw(n2) {
          asyncGeneratorStep(a2, r, o, _next, _throw, "throw", n2);
        }
        _next(void 0);
      });
    };
  }

  // node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js
  function _createForOfIteratorHelper(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (!t) {
      if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
        t && (r = t);
        var _n = 0, F = function F2() {
        };
        return {
          s: F,
          n: function n() {
            return _n >= r.length ? {
              done: true
            } : {
              done: false,
              value: r[_n++]
            };
          },
          e: function e3(r2) {
            throw r2;
          },
          f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o, a2 = true, u = false;
    return {
      s: function s() {
        t = t.call(r);
      },
      n: function n() {
        var r2 = t.next();
        return a2 = r2.done, r2;
      },
      e: function e3(r2) {
        u = true, o = r2;
      },
      f: function f() {
        try {
          a2 || null == t["return"] || t["return"]();
        } finally {
          if (u) throw o;
        }
      }
    };
  }

  // node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
  function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r[n];
    }
    return t;
  }

  // node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
  function _objectWithoutProperties(e, t) {
    if (null == e) return {};
    var o, r, i = _objectWithoutPropertiesLoose(e, t);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
    }
    return i;
  }

  // node_modules/@antv/g-lite/dist/index.esm.js
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  var rbush = { exports: {} };
  (function(module, exports) {
    (function(global2, factory) {
      module.exports = factory();
    })(commonjsGlobal, function() {
      function quickselect(arr, k, left, right, compare) {
        quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare3);
      }
      function quickselectStep(arr, k, left, right, compare) {
        while (right > left) {
          if (right - left > 600) {
            var n = right - left + 1;
            var m2 = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m2 - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m2 * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m2) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
          }
          var t = arr[k];
          var i = left;
          var j = right;
          swap(arr, left, k);
          if (compare(arr[right], t) > 0) {
            swap(arr, left, right);
          }
          while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) {
              i++;
            }
            while (compare(arr[j], t) > 0) {
              j--;
            }
          }
          if (compare(arr[left], t) === 0) {
            swap(arr, left, j);
          } else {
            j++;
            swap(arr, j, right);
          }
          if (j <= k) {
            left = j + 1;
          }
          if (k <= j) {
            right = j - 1;
          }
        }
      }
      function swap(arr, i, j) {
        var tmp2 = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp2;
      }
      function defaultCompare3(a2, b) {
        return a2 < b ? -1 : a2 > b ? 1 : 0;
      }
      var RBush2 = function RBush3(maxEntries) {
        if (maxEntries === void 0) maxEntries = 9;
        this._maxEntries = Math.max(4, maxEntries);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
        this.clear();
      };
      RBush2.prototype.all = function all() {
        return this._all(this.data, []);
      };
      RBush2.prototype.search = function search(bbox) {
        var node = this.data;
        var result = [];
        if (!intersects(bbox, node)) {
          return result;
        }
        var toBBox = this.toBBox;
        var nodesToSearch = [];
        while (node) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var childBBox = node.leaf ? toBBox(child) : child;
            if (intersects(bbox, childBBox)) {
              if (node.leaf) {
                result.push(child);
              } else if (contains(bbox, childBBox)) {
                this._all(child, result);
              } else {
                nodesToSearch.push(child);
              }
            }
          }
          node = nodesToSearch.pop();
        }
        return result;
      };
      RBush2.prototype.collides = function collides(bbox) {
        var node = this.data;
        if (!intersects(bbox, node)) {
          return false;
        }
        var nodesToSearch = [];
        while (node) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var childBBox = node.leaf ? this.toBBox(child) : child;
            if (intersects(bbox, childBBox)) {
              if (node.leaf || contains(bbox, childBBox)) {
                return true;
              }
              nodesToSearch.push(child);
            }
          }
          node = nodesToSearch.pop();
        }
        return false;
      };
      RBush2.prototype.load = function load(data2) {
        if (!(data2 && data2.length)) {
          return this;
        }
        if (data2.length < this._minEntries) {
          for (var i = 0; i < data2.length; i++) {
            this.insert(data2[i]);
          }
          return this;
        }
        var node = this._build(data2.slice(), 0, data2.length - 1, 0);
        if (!this.data.children.length) {
          this.data = node;
        } else if (this.data.height === node.height) {
          this._splitRoot(this.data, node);
        } else {
          if (this.data.height < node.height) {
            var tmpNode = this.data;
            this.data = node;
            node = tmpNode;
          }
          this._insert(node, this.data.height - node.height - 1, true);
        }
        return this;
      };
      RBush2.prototype.insert = function insert(item) {
        if (item) {
          this._insert(item, this.data.height - 1);
        }
        return this;
      };
      RBush2.prototype.clear = function clear() {
        this.data = createNode([]);
        return this;
      };
      RBush2.prototype.remove = function remove(item, equalsFn) {
        if (!item) {
          return this;
        }
        var node = this.data;
        var bbox = this.toBBox(item);
        var path = [];
        var indexes = [];
        var i, parent, goingUp;
        while (node || path.length) {
          if (!node) {
            node = path.pop();
            parent = path[path.length - 1];
            i = indexes.pop();
            goingUp = true;
          }
          if (node.leaf) {
            var index2 = findItem(item, node.children, equalsFn);
            if (index2 !== -1) {
              node.children.splice(index2, 1);
              path.push(node);
              this._condense(path);
              return this;
            }
          }
          if (!goingUp && !node.leaf && contains(node, bbox)) {
            path.push(node);
            indexes.push(i);
            i = 0;
            parent = node;
            node = node.children[0];
          } else if (parent) {
            i++;
            node = parent.children[i];
            goingUp = false;
          } else {
            node = null;
          }
        }
        return this;
      };
      RBush2.prototype.toBBox = function toBBox(item) {
        return item;
      };
      RBush2.prototype.compareMinX = function compareMinX(a2, b) {
        return a2.minX - b.minX;
      };
      RBush2.prototype.compareMinY = function compareMinY(a2, b) {
        return a2.minY - b.minY;
      };
      RBush2.prototype.toJSON = function toJSON() {
        return this.data;
      };
      RBush2.prototype.fromJSON = function fromJSON(data2) {
        this.data = data2;
        return this;
      };
      RBush2.prototype._all = function _all(node, result) {
        var nodesToSearch = [];
        while (node) {
          if (node.leaf) {
            result.push.apply(result, node.children);
          } else {
            nodesToSearch.push.apply(nodesToSearch, node.children);
          }
          node = nodesToSearch.pop();
        }
        return result;
      };
      RBush2.prototype._build = function _build(items, left, right, height) {
        var N2 = right - left + 1;
        var M = this._maxEntries;
        var node;
        if (N2 <= M) {
          node = createNode(items.slice(left, right + 1));
          calcBBox(node, this.toBBox);
          return node;
        }
        if (!height) {
          height = Math.ceil(Math.log(N2) / Math.log(M));
          M = Math.ceil(N2 / Math.pow(M, height - 1));
        }
        node = createNode([]);
        node.leaf = false;
        node.height = height;
        var N22 = Math.ceil(N2 / M);
        var N1 = N22 * Math.ceil(Math.sqrt(M));
        multiSelect(items, left, right, N1, this.compareMinX);
        for (var i = left; i <= right; i += N1) {
          var right2 = Math.min(i + N1 - 1, right);
          multiSelect(items, i, right2, N22, this.compareMinY);
          for (var j = i; j <= right2; j += N22) {
            var right3 = Math.min(j + N22 - 1, right2);
            node.children.push(this._build(items, j, right3, height - 1));
          }
        }
        calcBBox(node, this.toBBox);
        return node;
      };
      RBush2.prototype._chooseSubtree = function _chooseSubtree(bbox, node, level, path) {
        while (true) {
          path.push(node);
          if (node.leaf || path.length - 1 === level) {
            break;
          }
          var minArea = Infinity;
          var minEnlargement = Infinity;
          var targetNode = void 0;
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var area = bboxArea(child);
            var enlargement = enlargedArea(bbox, child) - area;
            if (enlargement < minEnlargement) {
              minEnlargement = enlargement;
              minArea = area < minArea ? area : minArea;
              targetNode = child;
            } else if (enlargement === minEnlargement) {
              if (area < minArea) {
                minArea = area;
                targetNode = child;
              }
            }
          }
          node = targetNode || node.children[0];
        }
        return node;
      };
      RBush2.prototype._insert = function _insert(item, level, isNode2) {
        var bbox = isNode2 ? item : this.toBBox(item);
        var insertPath = [];
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);
        node.children.push(item);
        extend2(node, bbox);
        while (level >= 0) {
          if (insertPath[level].children.length > this._maxEntries) {
            this._split(insertPath, level);
            level--;
          } else {
            break;
          }
        }
        this._adjustParentBBoxes(bbox, insertPath, level);
      };
      RBush2.prototype._split = function _split(insertPath, level) {
        var node = insertPath[level];
        var M = node.children.length;
        var m2 = this._minEntries;
        this._chooseSplitAxis(node, m2, M);
        var splitIndex = this._chooseSplitIndex(node, m2, M);
        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;
        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);
        if (level) {
          insertPath[level - 1].children.push(newNode);
        } else {
          this._splitRoot(node, newNode);
        }
      };
      RBush2.prototype._splitRoot = function _splitRoot(node, newNode) {
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
      };
      RBush2.prototype._chooseSplitIndex = function _chooseSplitIndex(node, m2, M) {
        var index2;
        var minOverlap = Infinity;
        var minArea = Infinity;
        for (var i = m2; i <= M - m2; i++) {
          var bbox1 = distBBox(node, 0, i, this.toBBox);
          var bbox2 = distBBox(node, i, M, this.toBBox);
          var overlap = intersectionArea(bbox1, bbox2);
          var area = bboxArea(bbox1) + bboxArea(bbox2);
          if (overlap < minOverlap) {
            minOverlap = overlap;
            index2 = i;
            minArea = area < minArea ? area : minArea;
          } else if (overlap === minOverlap) {
            if (area < minArea) {
              minArea = area;
              index2 = i;
            }
          }
        }
        return index2 || M - m2;
      };
      RBush2.prototype._chooseSplitAxis = function _chooseSplitAxis(node, m2, M) {
        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
        var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
        var xMargin = this._allDistMargin(node, m2, M, compareMinX);
        var yMargin = this._allDistMargin(node, m2, M, compareMinY);
        if (xMargin < yMargin) {
          node.children.sort(compareMinX);
        }
      };
      RBush2.prototype._allDistMargin = function _allDistMargin(node, m2, M, compare) {
        node.children.sort(compare);
        var toBBox = this.toBBox;
        var leftBBox = distBBox(node, 0, m2, toBBox);
        var rightBBox = distBBox(node, M - m2, M, toBBox);
        var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
        for (var i = m2; i < M - m2; i++) {
          var child = node.children[i];
          extend2(leftBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(leftBBox);
        }
        for (var i$1 = M - m2 - 1; i$1 >= m2; i$1--) {
          var child$1 = node.children[i$1];
          extend2(rightBBox, node.leaf ? toBBox(child$1) : child$1);
          margin += bboxMargin(rightBBox);
        }
        return margin;
      };
      RBush2.prototype._adjustParentBBoxes = function _adjustParentBBoxes(bbox, path, level) {
        for (var i = level; i >= 0; i--) {
          extend2(path[i], bbox);
        }
      };
      RBush2.prototype._condense = function _condense(path) {
        for (var i = path.length - 1, siblings = void 0; i >= 0; i--) {
          if (path[i].children.length === 0) {
            if (i > 0) {
              siblings = path[i - 1].children;
              siblings.splice(siblings.indexOf(path[i]), 1);
            } else {
              this.clear();
            }
          } else {
            calcBBox(path[i], this.toBBox);
          }
        }
      };
      function findItem(item, items, equalsFn) {
        if (!equalsFn) {
          return items.indexOf(item);
        }
        for (var i = 0; i < items.length; i++) {
          if (equalsFn(item, items[i])) {
            return i;
          }
        }
        return -1;
      }
      function calcBBox(node, toBBox) {
        distBBox(node, 0, node.children.length, toBBox, node);
      }
      function distBBox(node, k, p, toBBox, destNode) {
        if (!destNode) {
          destNode = createNode(null);
        }
        destNode.minX = Infinity;
        destNode.minY = Infinity;
        destNode.maxX = -Infinity;
        destNode.maxY = -Infinity;
        for (var i = k; i < p; i++) {
          var child = node.children[i];
          extend2(destNode, node.leaf ? toBBox(child) : child);
        }
        return destNode;
      }
      function extend2(a2, b) {
        a2.minX = Math.min(a2.minX, b.minX);
        a2.minY = Math.min(a2.minY, b.minY);
        a2.maxX = Math.max(a2.maxX, b.maxX);
        a2.maxY = Math.max(a2.maxY, b.maxY);
        return a2;
      }
      function compareNodeMinX(a2, b) {
        return a2.minX - b.minX;
      }
      function compareNodeMinY(a2, b) {
        return a2.minY - b.minY;
      }
      function bboxArea(a2) {
        return (a2.maxX - a2.minX) * (a2.maxY - a2.minY);
      }
      function bboxMargin(a2) {
        return a2.maxX - a2.minX + (a2.maxY - a2.minY);
      }
      function enlargedArea(a2, b) {
        return (Math.max(b.maxX, a2.maxX) - Math.min(b.minX, a2.minX)) * (Math.max(b.maxY, a2.maxY) - Math.min(b.minY, a2.minY));
      }
      function intersectionArea(a2, b) {
        var minX = Math.max(a2.minX, b.minX);
        var minY = Math.max(a2.minY, b.minY);
        var maxX = Math.min(a2.maxX, b.maxX);
        var maxY = Math.min(a2.maxY, b.maxY);
        return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
      }
      function contains(a2, b) {
        return a2.minX <= b.minX && a2.minY <= b.minY && b.maxX <= a2.maxX && b.maxY <= a2.maxY;
      }
      function intersects(a2, b) {
        return b.minX <= a2.maxX && b.minY <= a2.maxY && b.maxX >= a2.minX && b.maxY >= a2.minY;
      }
      function createNode(children) {
        return {
          children,
          height: 1,
          leaf: true,
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity
        };
      }
      function multiSelect(arr, left, right, n, compare) {
        var stack = [left, right];
        while (stack.length) {
          right = stack.pop();
          left = stack.pop();
          if (right - left <= n) {
            continue;
          }
          var mid = left + Math.ceil((right - left) / n / 2) * n;
          quickselect(arr, mid, left, right, compare);
          stack.push(left, mid, mid, right);
        }
      }
      return RBush2;
    });
  })(rbush);
  var RBush = rbush.exports;
  var Shape = /* @__PURE__ */ (function(Shape2) {
    Shape2["GROUP"] = "g";
    Shape2["FRAGMENT"] = "fragment";
    Shape2["CIRCLE"] = "circle";
    Shape2["ELLIPSE"] = "ellipse";
    Shape2["IMAGE"] = "image";
    Shape2["RECT"] = "rect";
    Shape2["LINE"] = "line";
    Shape2["POLYLINE"] = "polyline";
    Shape2["POLYGON"] = "polygon";
    Shape2["TEXT"] = "text";
    Shape2["PATH"] = "path";
    Shape2["HTML"] = "html";
    Shape2["MESH"] = "mesh";
    return Shape2;
  })({});
  var ClipSpaceNearZ = /* @__PURE__ */ (function(ClipSpaceNearZ2) {
    ClipSpaceNearZ2[ClipSpaceNearZ2["ZERO"] = 0] = "ZERO";
    ClipSpaceNearZ2[ClipSpaceNearZ2["NEGATIVE_ONE"] = 1] = "NEGATIVE_ONE";
    return ClipSpaceNearZ2;
  })({});
  var AbstractRendererPlugin = /* @__PURE__ */ (function() {
    function AbstractRendererPlugin2() {
      _classCallCheck(this, AbstractRendererPlugin2);
      this.plugins = [];
    }
    return _createClass(AbstractRendererPlugin2, [{
      key: "addRenderingPlugin",
      value: function addRenderingPlugin(plugin) {
        this.plugins.push(plugin);
        this.context.renderingPlugins.push(plugin);
      }
    }, {
      key: "removeAllRenderingPlugins",
      value: function removeAllRenderingPlugins() {
        var _this2 = this;
        this.plugins.forEach(function(plugin) {
          var index2 = _this2.context.renderingPlugins.indexOf(plugin);
          if (index2 >= 0) {
            _this2.context.renderingPlugins.splice(index2, 1);
          }
        });
      }
    }]);
  })();
  var AbstractRenderer = /* @__PURE__ */ (function() {
    function AbstractRenderer2(config) {
      _classCallCheck(this, AbstractRenderer2);
      this.clipSpaceNearZ = ClipSpaceNearZ.NEGATIVE_ONE;
      this.plugins = [];
      this.config = _objectSpread2({
        /**
         * only dirty object will cause re-render
         */
        enableDirtyCheck: true,
        enableCulling: false,
        /**
         * enable auto rendering by default
         */
        enableAutoRendering: true,
        /**
         * enable dirty rectangle rendering by default
         */
        enableDirtyRectangleRendering: true,
        enableDirtyRectangleRenderingDebug: false,
        enableSizeAttenuation: true,
        enableRenderingOptimization: false
      }, config);
    }
    return _createClass(AbstractRenderer2, [{
      key: "registerPlugin",
      value: function registerPlugin(plugin) {
        var index2 = this.plugins.findIndex(function(p) {
          return p === plugin;
        });
        if (index2 === -1) {
          this.plugins.push(plugin);
        }
      }
    }, {
      key: "unregisterPlugin",
      value: function unregisterPlugin(plugin) {
        var index2 = this.plugins.findIndex(function(p) {
          return p === plugin;
        });
        if (index2 > -1) {
          this.plugins.splice(index2, 1);
        }
      }
    }, {
      key: "getPlugins",
      value: function getPlugins() {
        return this.plugins;
      }
    }, {
      key: "getPlugin",
      value: function getPlugin(name) {
        return this.plugins.find(function(plugin) {
          return plugin.name === name;
        });
      }
    }, {
      key: "getConfig",
      value: function getConfig() {
        return this.config;
      }
    }, {
      key: "setConfig",
      value: function setConfig(config) {
        Object.assign(this.config, config);
      }
    }]);
  })();
  var addVec3 = import_gl_matrix2.vec3.add;
  var copyVec3 = import_gl_matrix2.vec3.copy;
  var maxVec3 = import_gl_matrix2.vec3.max;
  var minVec3 = import_gl_matrix2.vec3.min;
  var scaleVec3 = import_gl_matrix2.vec3.scale;
  var subVec3 = import_gl_matrix2.vec3.sub;
  var AABB = /* @__PURE__ */ (function() {
    function AABB2() {
      _classCallCheck(this, AABB2);
      this.center = [0, 0, 0];
      this.halfExtents = [0, 0, 0];
      this.min = [0, 0, 0];
      this.max = [0, 0, 0];
    }
    return _createClass(AABB2, [{
      key: "update",
      value: function update(center, halfExtents) {
        copyVec3(this.center, center);
        copyVec3(this.halfExtents, halfExtents);
        subVec3(this.min, this.center, this.halfExtents);
        addVec3(this.max, this.center, this.halfExtents);
      }
    }, {
      key: "setMinMax",
      value: function setMinMax(min4, max4) {
        addVec3(this.center, max4, min4);
        scaleVec3(this.center, this.center, 0.5);
        subVec3(this.halfExtents, max4, min4);
        scaleVec3(this.halfExtents, this.halfExtents, 0.5);
        copyVec3(this.min, min4);
        copyVec3(this.max, max4);
      }
    }, {
      key: "getMin",
      value: function getMin() {
        return this.min;
      }
    }, {
      key: "getMax",
      value: function getMax() {
        return this.max;
      }
    }, {
      key: "add",
      value: function add5(aabb) {
        if (AABB2.isEmpty(aabb)) {
          return;
        }
        if (AABB2.isEmpty(this)) {
          this.setMinMax(aabb.getMin(), aabb.getMax());
          return;
        }
        var tc = this.center;
        var tcx = tc[0];
        var tcy = tc[1];
        var tcz = tc[2];
        var th = this.halfExtents;
        var thx = th[0];
        var thy = th[1];
        var thz = th[2];
        var tminx = tcx - thx;
        var tmaxx = tcx + thx;
        var tminy = tcy - thy;
        var tmaxy = tcy + thy;
        var tminz = tcz - thz;
        var tmaxz = tcz + thz;
        var oc = aabb.center;
        var ocx = oc[0];
        var ocy = oc[1];
        var ocz = oc[2];
        var oh = aabb.halfExtents;
        var ohx = oh[0];
        var ohy = oh[1];
        var ohz = oh[2];
        var ominx = ocx - ohx;
        var omaxx = ocx + ohx;
        var ominy = ocy - ohy;
        var omaxy = ocy + ohy;
        var ominz = ocz - ohz;
        var omaxz = ocz + ohz;
        if (ominx < tminx) {
          tminx = ominx;
        }
        if (omaxx > tmaxx) {
          tmaxx = omaxx;
        }
        if (ominy < tminy) {
          tminy = ominy;
        }
        if (omaxy > tmaxy) {
          tmaxy = omaxy;
        }
        if (ominz < tminz) {
          tminz = ominz;
        }
        if (omaxz > tmaxz) {
          tmaxz = omaxz;
        }
        tc[0] = (tminx + tmaxx) * 0.5;
        tc[1] = (tminy + tmaxy) * 0.5;
        tc[2] = (tminz + tmaxz) * 0.5;
        th[0] = (tmaxx - tminx) * 0.5;
        th[1] = (tmaxy - tminy) * 0.5;
        th[2] = (tmaxz - tminz) * 0.5;
        this.min[0] = tminx;
        this.min[1] = tminy;
        this.min[2] = tminz;
        this.max[0] = tmaxx;
        this.max[1] = tmaxy;
        this.max[2] = tmaxz;
      }
    }, {
      key: "setFromTransformedAABB",
      value: function setFromTransformedAABB(aabb, m2) {
        var bc = this.center;
        var br = this.halfExtents;
        var ac = aabb.center;
        var ar = aabb.halfExtents;
        var mx0 = m2[0];
        var mx1 = m2[4];
        var mx2 = m2[8];
        var my0 = m2[1];
        var my1 = m2[5];
        var my2 = m2[9];
        var mz0 = m2[2];
        var mz1 = m2[6];
        var mz2 = m2[10];
        var mx0a = Math.abs(mx0);
        var mx1a = Math.abs(mx1);
        var mx2a = Math.abs(mx2);
        var my0a = Math.abs(my0);
        var my1a = Math.abs(my1);
        var my2a = Math.abs(my2);
        var mz0a = Math.abs(mz0);
        var mz1a = Math.abs(mz1);
        var mz2a = Math.abs(mz2);
        bc[0] = m2[12] + mx0 * ac[0] + mx1 * ac[1] + mx2 * ac[2];
        bc[1] = m2[13] + my0 * ac[0] + my1 * ac[1] + my2 * ac[2];
        bc[2] = m2[14] + mz0 * ac[0] + mz1 * ac[1] + mz2 * ac[2];
        br[0] = mx0a * ar[0] + mx1a * ar[1] + mx2a * ar[2];
        br[1] = my0a * ar[0] + my1a * ar[1] + my2a * ar[2];
        br[2] = mz0a * ar[0] + mz1a * ar[1] + mz2a * ar[2];
        subVec3(this.min, bc, br);
        addVec3(this.max, bc, br);
      }
    }, {
      key: "intersects",
      value: function intersects(aabb) {
        var aMax = this.getMax();
        var aMin = this.getMin();
        var bMax = aabb.getMax();
        var bMin = aabb.getMin();
        return aMin[0] <= bMax[0] && aMax[0] >= bMin[0] && aMin[1] <= bMax[1] && aMax[1] >= bMin[1] && aMin[2] <= bMax[2] && aMax[2] >= bMin[2];
      }
    }, {
      key: "intersection",
      value: function intersection(aabb) {
        if (!this.intersects(aabb)) {
          return null;
        }
        var intersection2 = new AABB2();
        var min4 = maxVec3([0, 0, 0], this.getMin(), aabb.getMin());
        var max4 = minVec3([0, 0, 0], this.getMax(), aabb.getMax());
        intersection2.setMinMax(min4, max4);
        return intersection2;
      }
      /**
       * get n-vertex
       * @param plane plane of CullingVolume
       */
    }, {
      key: "getNegativeFarPoint",
      value: function getNegativeFarPoint(plane) {
        if (plane.pnVertexFlag === 273) {
          return copyVec3([0, 0, 0], this.min);
        }
        if (plane.pnVertexFlag === 272) {
          return [this.min[0], this.min[1], this.max[2]];
        }
        if (plane.pnVertexFlag === 257) {
          return [this.min[0], this.max[1], this.min[2]];
        }
        if (plane.pnVertexFlag === 256) {
          return [this.min[0], this.max[1], this.max[2]];
        }
        if (plane.pnVertexFlag === 17) {
          return [this.max[0], this.min[1], this.min[2]];
        }
        if (plane.pnVertexFlag === 16) {
          return [this.max[0], this.min[1], this.max[2]];
        }
        if (plane.pnVertexFlag === 1) {
          return [this.max[0], this.max[1], this.min[2]];
        }
        return [this.max[0], this.max[1], this.max[2]];
      }
      /**
       * get p-vertex
       * @param plane plane of CullingVolume
       */
    }, {
      key: "getPositiveFarPoint",
      value: function getPositiveFarPoint(plane) {
        if (plane.pnVertexFlag === 273) {
          return copyVec3([0, 0, 0], this.max);
        }
        if (plane.pnVertexFlag === 272) {
          return [this.max[0], this.max[1], this.min[2]];
        }
        if (plane.pnVertexFlag === 257) {
          return [this.max[0], this.min[1], this.max[2]];
        }
        if (plane.pnVertexFlag === 256) {
          return [this.max[0], this.min[1], this.min[2]];
        }
        if (plane.pnVertexFlag === 17) {
          return [this.min[0], this.max[1], this.max[2]];
        }
        if (plane.pnVertexFlag === 16) {
          return [this.min[0], this.max[1], this.min[2]];
        }
        if (plane.pnVertexFlag === 1) {
          return [this.min[0], this.min[1], this.max[2]];
        }
        return [this.min[0], this.min[1], this.min[2]];
      }
    }], [{
      key: "isEmpty",
      value: function isEmpty7(aabb) {
        return !aabb || aabb.halfExtents[0] === 0 && aabb.halfExtents[1] === 0 && aabb.halfExtents[2] === 0;
      }
    }]);
  })();
  var Plane = /* @__PURE__ */ (function() {
    function Plane2(distance6, normal) {
      _classCallCheck(this, Plane2);
      this.distance = distance6 || 0;
      this.normal = normal || import_gl_matrix2.vec3.fromValues(0, 1, 0);
      this.updatePNVertexFlag();
    }
    return _createClass(Plane2, [{
      key: "updatePNVertexFlag",
      value: function updatePNVertexFlag() {
        this.pnVertexFlag = (Number(this.normal[0] >= 0) << 8) + (Number(this.normal[1] >= 0) << 4) + Number(this.normal[2] >= 0);
      }
    }, {
      key: "distanceToPoint",
      value: function distanceToPoint(point4) {
        return import_gl_matrix2.vec3.dot(point4, this.normal) - this.distance;
      }
    }, {
      key: "normalize",
      value: function normalize5() {
        var invLen = 1 / import_gl_matrix2.vec3.len(this.normal);
        import_gl_matrix2.vec3.scale(this.normal, this.normal, invLen);
        this.distance *= invLen;
      }
    }, {
      key: "intersectsLine",
      value: function intersectsLine2(start, end, point4) {
        var d0 = this.distanceToPoint(start);
        var d1 = this.distanceToPoint(end);
        var t = d0 / (d0 - d1);
        var intersects = t >= 0 && t <= 1;
        if (intersects && point4) {
          import_gl_matrix2.vec3.lerp(point4, start, end, t);
        }
        return intersects;
      }
    }]);
  })();
  var Mask = /* @__PURE__ */ (function(Mask2) {
    Mask2[Mask2["OUTSIDE"] = 4294967295] = "OUTSIDE";
    Mask2[Mask2["INSIDE"] = 0] = "INSIDE";
    Mask2[Mask2["INDETERMINATE"] = 2147483647] = "INDETERMINATE";
    return Mask2;
  })({});
  var Frustum = /* @__PURE__ */ (function() {
    function Frustum2(planes) {
      _classCallCheck(this, Frustum2);
      this.planes = [];
      if (planes) {
        this.planes = planes;
      } else {
        for (var i = 0; i < 6; i++) {
          this.planes.push(new Plane());
        }
      }
    }
    return _createClass(Frustum2, [{
      key: "extractFromVPMatrix",
      value: function extractFromVPMatrix(projectionMatrix) {
        var _projectionMatrix = _slicedToArray(projectionMatrix, 16), m0 = _projectionMatrix[0], m1 = _projectionMatrix[1], m2 = _projectionMatrix[2], m3 = _projectionMatrix[3], m4 = _projectionMatrix[4], m5 = _projectionMatrix[5], m6 = _projectionMatrix[6], m7 = _projectionMatrix[7], m8 = _projectionMatrix[8], m9 = _projectionMatrix[9], m10 = _projectionMatrix[10], m11 = _projectionMatrix[11], m12 = _projectionMatrix[12], m13 = _projectionMatrix[13], m14 = _projectionMatrix[14], m15 = _projectionMatrix[15];
        import_gl_matrix2.vec3.set(this.planes[0].normal, m3 - m0, m7 - m4, m11 - m8);
        this.planes[0].distance = m15 - m12;
        import_gl_matrix2.vec3.set(this.planes[1].normal, m3 + m0, m7 + m4, m11 + m8);
        this.planes[1].distance = m15 + m12;
        import_gl_matrix2.vec3.set(this.planes[2].normal, m3 + m1, m7 + m5, m11 + m9);
        this.planes[2].distance = m15 + m13;
        import_gl_matrix2.vec3.set(this.planes[3].normal, m3 - m1, m7 - m5, m11 - m9);
        this.planes[3].distance = m15 - m13;
        import_gl_matrix2.vec3.set(this.planes[4].normal, m3 - m2, m7 - m6, m11 - m10);
        this.planes[4].distance = m15 - m14;
        import_gl_matrix2.vec3.set(this.planes[5].normal, m3 + m2, m7 + m6, m11 + m10);
        this.planes[5].distance = m15 + m14;
        this.planes.forEach(function(plane) {
          plane.normalize();
          plane.updatePNVertexFlag();
        });
      }
    }]);
  })();
  var Point = /* @__PURE__ */ (function() {
    function Point2() {
      var x3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      _classCallCheck(this, Point2);
      this.x = 0;
      this.y = 0;
      this.x = x3;
      this.y = y3;
    }
    return _createClass(Point2, [{
      key: "clone",
      value: function clone8() {
        return new Point2(this.x, this.y);
      }
    }, {
      key: "copyFrom",
      value: function copyFrom(p) {
        this.x = p.x;
        this.y = p.y;
      }
    }]);
  })();
  var Rectangle = /* @__PURE__ */ (function() {
    function Rectangle3(x3, y3, width2, height) {
      _classCallCheck(this, Rectangle3);
      this.x = x3;
      this.y = y3;
      this.width = width2;
      this.height = height;
      this.left = x3;
      this.right = x3 + width2;
      this.top = y3;
      this.bottom = y3 + height;
    }
    return _createClass(Rectangle3, [{
      key: "toJSON",
      value: function toJSON() {
      }
    }], [{
      key: "fromRect",
      value: (
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMRect/fromRect_static
         */
        function fromRect(rect2) {
          return new Rectangle3(rect2.x, rect2.y, rect2.width, rect2.height);
        }
      )
      /**
       * will return a new rect instance
       */
    }, {
      key: "applyTransform",
      value: function applyTransform2(rect2, matrix3) {
        var topLeft = import_gl_matrix2.vec4.fromValues(rect2.x, rect2.y, 0, 1);
        var topRight = import_gl_matrix2.vec4.fromValues(rect2.x + rect2.width, rect2.y, 0, 1);
        var bottomLeft = import_gl_matrix2.vec4.fromValues(rect2.x, rect2.y + rect2.height, 0, 1);
        var bottomRight = import_gl_matrix2.vec4.fromValues(rect2.x + rect2.width, rect2.y + rect2.height, 0, 1);
        var transformedTopLeft = import_gl_matrix2.vec4.create();
        var transformedTopRight = import_gl_matrix2.vec4.create();
        var transformedBottomLeft = import_gl_matrix2.vec4.create();
        var transformedBottomRight = import_gl_matrix2.vec4.create();
        import_gl_matrix2.vec4.transformMat4(transformedTopLeft, topLeft, matrix3);
        import_gl_matrix2.vec4.transformMat4(transformedTopRight, topRight, matrix3);
        import_gl_matrix2.vec4.transformMat4(transformedBottomLeft, bottomLeft, matrix3);
        import_gl_matrix2.vec4.transformMat4(transformedBottomRight, bottomRight, matrix3);
        var minX = Math.min(transformedTopLeft[0], transformedTopRight[0], transformedBottomLeft[0], transformedBottomRight[0]);
        var minY = Math.min(transformedTopLeft[1], transformedTopRight[1], transformedBottomLeft[1], transformedBottomRight[1]);
        var maxX = Math.max(transformedTopLeft[0], transformedTopRight[0], transformedBottomLeft[0], transformedBottomRight[0]);
        var maxY = Math.max(transformedTopLeft[1], transformedTopRight[1], transformedBottomLeft[1], transformedBottomRight[1]);
        return Rectangle3.fromRect({
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        });
      }
    }]);
  })();
  var ERROR_MSG_METHOD_NOT_IMPLEMENTED = "Method not implemented.";
  var ERROR_MSG_USE_DOCUMENT_ELEMENT = "Use document.documentElement instead.";
  var ERROR_MSG_APPEND_DESTROYED_ELEMENT = "Cannot append a destroyed element.";
  function getAngle(angle2) {
    if (angle2 === void 0) {
      return 0;
    }
    if (angle2 > 360 || angle2 < -360) {
      return angle2 % 360;
    }
    return angle2;
  }
  var $vec3$3 = import_gl_matrix2.vec3.create();
  function createVec3(x3) {
    var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    var clone8 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
    if (Array.isArray(x3) && x3.length === 3) {
      return clone8 ? import_gl_matrix2.vec3.clone(x3) : import_gl_matrix2.vec3.copy($vec3$3, x3);
    }
    if ((0, import_util2.isNumber)(x3)) {
      return clone8 ? import_gl_matrix2.vec3.fromValues(x3, y3, z) : import_gl_matrix2.vec3.set($vec3$3, x3, y3, z);
    }
    return clone8 ? import_gl_matrix2.vec3.fromValues(x3[0], x3[1] || y3, x3[2] || z) : import_gl_matrix2.vec3.set($vec3$3, x3[0], x3[1] || y3, x3[2] || z);
  }
  var DEG_RAD = Math.PI / 180;
  function deg2rad(deg) {
    return deg * DEG_RAD;
  }
  var RAD_DEG = 180 / Math.PI;
  function rad2deg(rad2) {
    return rad2 * RAD_DEG;
  }
  function turn2deg(turn) {
    return 360 * turn;
  }
  var HALF_PI = Math.PI / 2;
  function getEulerFromQuat(out, quat3) {
    var x3 = quat3[0];
    var y3 = quat3[1];
    var z = quat3[2];
    var w = quat3[3];
    var x22 = x3 * x3;
    var y22 = y3 * y3;
    var z2 = z * z;
    var w2 = w * w;
    var unit = x22 + y22 + z2 + w2;
    var test = x3 * w - y3 * z;
    if (test > 0.499995 * unit) {
      out[0] = HALF_PI;
      out[1] = 2 * Math.atan2(y3, x3);
      out[2] = 0;
    } else if (test < -0.499995 * unit) {
      out[0] = -HALF_PI;
      out[1] = 2 * Math.atan2(y3, x3);
      out[2] = 0;
    } else {
      out[0] = Math.asin(2 * (x3 * z - w * y3));
      out[1] = Math.atan2(2 * (x3 * w + y3 * z), 1 - 2 * (z2 + w2));
      out[2] = Math.atan2(2 * (x3 * y3 + z * w), 1 - 2 * (y22 + z2));
    }
    return out;
  }
  function getEulerFromMat4(out, m2) {
    var x3;
    var z;
    var _mat4$getScaling = import_gl_matrix2.mat4.getScaling(import_gl_matrix2.vec3.create(), m2), _mat4$getScaling2 = _slicedToArray(_mat4$getScaling, 3), sx = _mat4$getScaling2[0], sy = _mat4$getScaling2[1], sz = _mat4$getScaling2[2];
    var y3 = Math.asin(-m2[2] / sx);
    if (y3 < HALF_PI) {
      if (y3 > -HALF_PI) {
        x3 = Math.atan2(m2[6] / sy, m2[10] / sz);
        z = Math.atan2(m2[1] / sx, m2[0] / sx);
      } else {
        z = 0;
        x3 = -Math.atan2(m2[4] / sy, m2[5] / sy);
      }
    } else {
      z = 0;
      x3 = Math.atan2(m2[4] / sy, m2[5] / sy);
    }
    out[0] = x3;
    out[1] = y3;
    out[2] = z;
    return out;
  }
  function getEuler(out, quat3) {
    if (quat3.length === 16) {
      return getEulerFromMat4(out, quat3);
    }
    return getEulerFromQuat(out, quat3);
  }
  function fromRotationTranslationScale(rotation, x3, y3, scaleX2, scaleY2) {
    var cos = Math.cos(rotation);
    var sin = Math.sin(rotation);
    return import_gl_matrix2.mat3.fromValues(scaleX2 * cos, scaleY2 * sin, 0, -scaleX2 * sin, scaleY2 * cos, 0, x3, y3, 1);
  }
  function makePerspective(out, left, right, top, bottom, near, far) {
    var zero = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
    var twoNear = 2 * near;
    var rightMinusLeft = right - left;
    var topMinusBottom = top - bottom;
    var x3 = twoNear / rightMinusLeft;
    var y3 = twoNear / topMinusBottom;
    var a2 = (right + left) / rightMinusLeft;
    var b = (top + bottom) / topMinusBottom;
    var c2;
    var d2;
    var farMinusNear = far - near;
    var farMulNear = far * near;
    if (zero) {
      c2 = -far / farMinusNear;
      d2 = -farMulNear / farMinusNear;
    } else {
      c2 = -(far + near) / farMinusNear;
      d2 = -2 * farMulNear / farMinusNear;
    }
    out[0] = x3;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = y3;
    out[6] = 0;
    out[7] = 0;
    out[8] = a2;
    out[9] = b;
    out[10] = c2;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = d2;
    out[15] = 0;
    return out;
  }
  function decompose(mat) {
    var row0x = mat[0];
    var row0y = mat[1];
    var row1x = mat[3];
    var row1y = mat[4];
    var scalingX = Math.sqrt(row0x * row0x + row0y * row0y);
    var scalingY = Math.sqrt(row1x * row1x + row1y * row1y);
    var determinant2 = row0x * row1y - row0y * row1x;
    if (determinant2 < 0) {
      if (row0x < row1y) {
        scalingX = -scalingX;
      } else {
        scalingY = -scalingY;
      }
    }
    if (scalingX) {
      var invScalingX = 1 / scalingX;
      row0x *= invScalingX;
      row0y *= invScalingX;
    }
    if (scalingY) {
      var invScalingY = 1 / scalingY;
      row1x *= invScalingY;
      row1y *= invScalingY;
    }
    var rotation = Math.atan2(row0y, row0x);
    var angle2 = rad2deg(rotation);
    return [mat[6], mat[7], scalingX, scalingY, angle2];
  }
  var tmp = import_gl_matrix2.mat4.create();
  var perspectiveMatrix = import_gl_matrix2.mat4.create();
  var tmpVec4 = import_gl_matrix2.vec4.create();
  var row = [import_gl_matrix2.vec3.create(), import_gl_matrix2.vec3.create(), import_gl_matrix2.vec3.create()];
  var pdum3 = import_gl_matrix2.vec3.create();
  function decomposeMat4(matrix3, translation, scale4, skew2, perspective, quaternion) {
    if (!normalize(tmp, matrix3)) return false;
    import_gl_matrix2.mat4.copy(perspectiveMatrix, tmp);
    perspectiveMatrix[3] = 0;
    perspectiveMatrix[7] = 0;
    perspectiveMatrix[11] = 0;
    perspectiveMatrix[15] = 1;
    if (Math.abs(import_gl_matrix2.mat4.determinant(perspectiveMatrix)) < 1e-8) return false;
    var a03 = tmp[3];
    var a13 = tmp[7];
    var a23 = tmp[11];
    var a30 = tmp[12];
    var a31 = tmp[13];
    var a32 = tmp[14];
    var a33 = tmp[15];
    if (a03 !== 0 || a13 !== 0 || a23 !== 0) {
      tmpVec4[0] = a03;
      tmpVec4[1] = a13;
      tmpVec4[2] = a23;
      tmpVec4[3] = a33;
      var ret = import_gl_matrix2.mat4.invert(perspectiveMatrix, perspectiveMatrix);
      if (!ret) return false;
      import_gl_matrix2.mat4.transpose(perspectiveMatrix, perspectiveMatrix);
      import_gl_matrix2.vec4.transformMat4(perspective, tmpVec4, perspectiveMatrix);
    } else {
      perspective[0] = perspective[1] = perspective[2] = 0;
      perspective[3] = 1;
    }
    translation[0] = a30;
    translation[1] = a31;
    translation[2] = a32;
    mat3from4(row, tmp);
    scale4[0] = import_gl_matrix2.vec3.length(row[0]);
    import_gl_matrix2.vec3.normalize(row[0], row[0]);
    skew2[0] = import_gl_matrix2.vec3.dot(row[0], row[1]);
    combine(row[1], row[1], row[0], 1, -skew2[0]);
    scale4[1] = import_gl_matrix2.vec3.length(row[1]);
    import_gl_matrix2.vec3.normalize(row[1], row[1]);
    skew2[0] /= scale4[1];
    skew2[1] = import_gl_matrix2.vec3.dot(row[0], row[2]);
    combine(row[2], row[2], row[0], 1, -skew2[1]);
    skew2[2] = import_gl_matrix2.vec3.dot(row[1], row[2]);
    combine(row[2], row[2], row[1], 1, -skew2[2]);
    scale4[2] = import_gl_matrix2.vec3.length(row[2]);
    import_gl_matrix2.vec3.normalize(row[2], row[2]);
    skew2[1] /= scale4[2];
    skew2[2] /= scale4[2];
    import_gl_matrix2.vec3.cross(pdum3, row[1], row[2]);
    if (import_gl_matrix2.vec3.dot(row[0], pdum3) < 0) {
      for (var i = 0; i < 3; i++) {
        scale4[i] *= -1;
        row[i][0] *= -1;
        row[i][1] *= -1;
        row[i][2] *= -1;
      }
    }
    quaternion[0] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] - row[1][1] - row[2][2], 0));
    quaternion[1] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] + row[1][1] - row[2][2], 0));
    quaternion[2] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] - row[1][1] + row[2][2], 0));
    quaternion[3] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] + row[1][1] + row[2][2], 0));
    if (row[2][1] > row[1][2]) quaternion[0] = -quaternion[0];
    if (row[0][2] > row[2][0]) quaternion[1] = -quaternion[1];
    if (row[1][0] > row[0][1]) quaternion[2] = -quaternion[2];
    return true;
  }
  function normalize(out, mat) {
    var m44 = mat[15];
    if (m44 === 0) return false;
    var scale4 = 1 / m44;
    for (var i = 0; i < 16; i++) out[i] = mat[i] * scale4;
    return true;
  }
  function mat3from4(out, mat4x4) {
    out[0][0] = mat4x4[0];
    out[0][1] = mat4x4[1];
    out[0][2] = mat4x4[2];
    out[1][0] = mat4x4[4];
    out[1][1] = mat4x4[5];
    out[1][2] = mat4x4[6];
    out[2][0] = mat4x4[8];
    out[2][1] = mat4x4[9];
    out[2][2] = mat4x4[10];
  }
  function combine(out, a2, b, scale1, scale22) {
    out[0] = a2[0] * scale1 + b[0] * scale22;
    out[1] = a2[1] * scale1 + b[1] * scale22;
    out[2] = a2[2] * scale1 + b[2] * scale22;
  }
  var CameraType = /* @__PURE__ */ (function(CameraType2) {
    CameraType2[CameraType2["ORBITING"] = 0] = "ORBITING";
    CameraType2[CameraType2["EXPLORING"] = 1] = "EXPLORING";
    CameraType2[CameraType2["TRACKING"] = 2] = "TRACKING";
    return CameraType2;
  })({});
  var CameraTrackingMode = /* @__PURE__ */ (function(CameraTrackingMode2) {
    CameraTrackingMode2[CameraTrackingMode2["DEFAULT"] = 0] = "DEFAULT";
    CameraTrackingMode2[CameraTrackingMode2["ROTATIONAL"] = 1] = "ROTATIONAL";
    CameraTrackingMode2[CameraTrackingMode2["TRANSLATIONAL"] = 2] = "TRANSLATIONAL";
    CameraTrackingMode2[CameraTrackingMode2["CINEMATIC"] = 3] = "CINEMATIC";
    return CameraTrackingMode2;
  })({});
  var CameraProjectionMode = /* @__PURE__ */ (function(CameraProjectionMode2) {
    CameraProjectionMode2[CameraProjectionMode2["ORTHOGRAPHIC"] = 0] = "ORTHOGRAPHIC";
    CameraProjectionMode2[CameraProjectionMode2["PERSPECTIVE"] = 1] = "PERSPECTIVE";
    return CameraProjectionMode2;
  })({});
  var CameraEvent = {
    UPDATED: "updated"
  };
  var MIN_DISTANCE = 2e-4;
  var Camera = /* @__PURE__ */ (function() {
    function Camera2() {
      _classCallCheck(this, Camera2);
      this.clipSpaceNearZ = ClipSpaceNearZ.NEGATIVE_ONE;
      this.eventEmitter = new eventemitter3_default();
      this.matrix = import_gl_matrix2.mat4.create();
      this.right = import_gl_matrix2.vec3.fromValues(1, 0, 0);
      this.up = import_gl_matrix2.vec3.fromValues(0, 1, 0);
      this.forward = import_gl_matrix2.vec3.fromValues(0, 0, 1);
      this.position = import_gl_matrix2.vec3.fromValues(0, 0, 1);
      this.focalPoint = import_gl_matrix2.vec3.fromValues(0, 0, 0);
      this.distanceVector = import_gl_matrix2.vec3.fromValues(0, 0, -1);
      this.distance = 1;
      this.azimuth = 0;
      this.elevation = 0;
      this.roll = 0;
      this.relAzimuth = 0;
      this.relElevation = 0;
      this.relRoll = 0;
      this.dollyingStep = 0;
      this.maxDistance = Infinity;
      this.minDistance = -Infinity;
      this.zoom = 1;
      this.rotateWorld = false;
      this.fov = 30;
      this.near = 0.1;
      this.far = 1e3;
      this.aspect = 1;
      this.projectionMatrix = import_gl_matrix2.mat4.create();
      this.projectionMatrixInverse = import_gl_matrix2.mat4.create();
      this.jitteredProjectionMatrix = void 0;
      this.enableUpdate = true;
      this.type = CameraType.EXPLORING;
      this.trackingMode = CameraTrackingMode.DEFAULT;
      this.projectionMode = CameraProjectionMode.PERSPECTIVE;
      this.frustum = new Frustum();
      this.orthoMatrix = import_gl_matrix2.mat4.create();
    }
    return _createClass(Camera2, [{
      key: "isOrtho",
      value: (
        // constructor(type = CameraType.EXPLORING, trackingMode = CameraTrackingMode.DEFAULT) {
        //   this.setType(type, trackingMode);
        // }
        function isOrtho() {
          return this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC;
        }
      )
    }, {
      key: "getProjectionMode",
      value: function getProjectionMode() {
        return this.projectionMode;
      }
    }, {
      key: "getPerspective",
      value: function getPerspective() {
        return this.jitteredProjectionMatrix || this.projectionMatrix;
      }
    }, {
      key: "getPerspectiveInverse",
      value: function getPerspectiveInverse() {
        return this.projectionMatrixInverse;
      }
    }, {
      key: "getFrustum",
      value: function getFrustum() {
        return this.frustum;
      }
    }, {
      key: "getPosition",
      value: function getPosition() {
        return this.position;
      }
    }, {
      key: "getFocalPoint",
      value: function getFocalPoint() {
        return this.focalPoint;
      }
    }, {
      key: "getDollyingStep",
      value: function getDollyingStep() {
        return this.dollyingStep;
      }
    }, {
      key: "getNear",
      value: function getNear() {
        return this.near;
      }
    }, {
      key: "getFar",
      value: function getFar() {
        return this.far;
      }
    }, {
      key: "getZoom",
      value: function getZoom() {
        return this.zoom;
      }
    }, {
      key: "getOrthoMatrix",
      value: function getOrthoMatrix() {
        return this.orthoMatrix;
      }
    }, {
      key: "getView",
      value: function getView() {
        return this.view;
      }
    }, {
      key: "setEnableUpdate",
      value: function setEnableUpdate(enabled) {
        this.enableUpdate = enabled;
      }
    }, {
      key: "setType",
      value: function setType(type, trackingMode) {
        this.type = type;
        if (this.type === CameraType.EXPLORING) {
          this.setWorldRotation(true);
        } else {
          this.setWorldRotation(false);
        }
        this._getAngles();
        if (this.type === CameraType.TRACKING && trackingMode !== void 0) {
          this.setTrackingMode(trackingMode);
        }
        return this;
      }
    }, {
      key: "setProjectionMode",
      value: function setProjectionMode(projectionMode) {
        this.projectionMode = projectionMode;
        return this;
      }
    }, {
      key: "setTrackingMode",
      value: function setTrackingMode(trackingMode) {
        if (this.type !== CameraType.TRACKING) {
          throw new Error("Impossible to set a tracking mode if the camera is not of tracking type");
        }
        this.trackingMode = trackingMode;
        return this;
      }
      /**
       * If flag is true, it reverses the azimuth and elevation angles.
       * Subsequent calls to rotate, setAzimuth, setElevation,
       * changeAzimuth or changeElevation will cause the inverted effect.
       * setRoll or changeRoll is not affected by this method.
       *
       * This inversion is useful when one wants to simulate that the world
       * is moving, instead of the camera.
       *
       * By default the camera angles are not reversed.
       * @param {Boolean} flag the boolean flag to reverse the angles.
       */
    }, {
      key: "setWorldRotation",
      value: function setWorldRotation(flag) {
        this.rotateWorld = flag;
        this._getAngles();
        return this;
      }
      /**
       * 计算 MV 矩阵，为相机矩阵的逆矩阵
       */
    }, {
      key: "getViewTransform",
      value: function getViewTransform() {
        return import_gl_matrix2.mat4.invert(import_gl_matrix2.mat4.create(), this.matrix);
      }
    }, {
      key: "getWorldTransform",
      value: function getWorldTransform() {
        return this.matrix;
      }
    }, {
      key: "jitterProjectionMatrix",
      value: function jitterProjectionMatrix(x3, y3) {
        var translation = import_gl_matrix2.mat4.fromTranslation(import_gl_matrix2.mat4.create(), [x3, y3, 0]);
        this.jitteredProjectionMatrix = import_gl_matrix2.mat4.multiply(import_gl_matrix2.mat4.create(), translation, this.projectionMatrix);
      }
    }, {
      key: "clearJitterProjectionMatrix",
      value: function clearJitterProjectionMatrix() {
        this.jitteredProjectionMatrix = void 0;
      }
      /**
       * 设置相机矩阵
       */
    }, {
      key: "setMatrix",
      value: function setMatrix(matrix3) {
        this.matrix = matrix3;
        this._update();
        return this;
      }
      /**
       * Set projection matrix manually.
       */
    }, {
      key: "setProjectionMatrix",
      value: function setProjectionMatrix(matrix3) {
        this.projectionMatrix = matrix3;
      }
    }, {
      key: "setFov",
      value: function setFov(fov) {
        this.setPerspective(this.near, this.far, fov, this.aspect);
        return this;
      }
    }, {
      key: "setAspect",
      value: function setAspect(aspect) {
        this.setPerspective(this.near, this.far, this.fov, aspect);
        return this;
      }
    }, {
      key: "setNear",
      value: function setNear(near) {
        if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
          this.setPerspective(near, this.far, this.fov, this.aspect);
        } else {
          this.setOrthographic(this.left, this.rright, this.top, this.bottom, near, this.far);
        }
        return this;
      }
    }, {
      key: "setFar",
      value: function setFar(far) {
        if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
          this.setPerspective(this.near, far, this.fov, this.aspect);
        } else {
          this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, far);
        }
        return this;
      }
      /**
       * Sets an offset in a larger frustum, used in PixelPicking
       */
    }, {
      key: "setViewOffset",
      value: function setViewOffset(fullWidth, fullHeight, x3, y3, width2, height) {
        this.aspect = fullWidth / fullHeight;
        if (this.view === void 0) {
          this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          };
        }
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x3;
        this.view.offsetY = y3;
        this.view.width = width2;
        this.view.height = height;
        if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
          this.setPerspective(this.near, this.far, this.fov, this.aspect);
        } else {
          this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
        }
        return this;
      }
    }, {
      key: "clearViewOffset",
      value: function clearViewOffset() {
        if (this.view !== void 0) {
          this.view.enabled = false;
        }
        if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
          this.setPerspective(this.near, this.far, this.fov, this.aspect);
        } else {
          this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
        }
        return this;
      }
    }, {
      key: "setZoom",
      value: function setZoom(zoom) {
        this.zoom = zoom;
        if (this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
          this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
        } else if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
          this.setPerspective(this.near, this.far, this.fov, this.aspect);
        }
        return this;
      }
      /**
       * Zoom by specified point in viewport coordinates.
       */
    }, {
      key: "setZoomByViewportPoint",
      value: function setZoomByViewportPoint(zoom, viewportPoint) {
        var _this$canvas$viewport = this.canvas.viewport2Canvas({
          x: viewportPoint[0],
          y: viewportPoint[1]
        }), ox = _this$canvas$viewport.x, oy = _this$canvas$viewport.y;
        var roll = this.roll;
        this.rotate(0, 0, -roll);
        this.setPosition(ox, oy);
        this.setFocalPoint(ox, oy);
        this.setZoom(zoom);
        this.rotate(0, 0, roll);
        var _this$canvas$viewport2 = this.canvas.viewport2Canvas({
          x: viewportPoint[0],
          y: viewportPoint[1]
        }), cx = _this$canvas$viewport2.x, cy = _this$canvas$viewport2.y;
        var dvec = import_gl_matrix2.vec3.fromValues(cx - ox, cy - oy, 0);
        var dx = import_gl_matrix2.vec3.dot(dvec, this.right) / import_gl_matrix2.vec3.length(this.right);
        var dy = import_gl_matrix2.vec3.dot(dvec, this.up) / import_gl_matrix2.vec3.length(this.up);
        var _this$getPosition = this.getPosition(), _this$getPosition2 = _slicedToArray(_this$getPosition, 2), px = _this$getPosition2[0], py = _this$getPosition2[1];
        var _this$getFocalPoint = this.getFocalPoint(), _this$getFocalPoint2 = _slicedToArray(_this$getFocalPoint, 2), fx = _this$getFocalPoint2[0], fy = _this$getFocalPoint2[1];
        this.setPosition(px - dx, py - dy);
        this.setFocalPoint(fx - dx, fy - dy);
        return this;
      }
    }, {
      key: "setPerspective",
      value: function setPerspective(near, far, fov, aspect) {
        var _this$view;
        this.projectionMode = CameraProjectionMode.PERSPECTIVE;
        this.fov = fov;
        this.near = near;
        this.far = far;
        this.aspect = aspect;
        var top = this.near * Math.tan(deg2rad(0.5 * this.fov)) / this.zoom;
        var height = 2 * top;
        var width2 = this.aspect * height;
        var left = -0.5 * width2;
        if ((_this$view = this.view) !== null && _this$view !== void 0 && _this$view.enabled) {
          var fullWidth = this.view.fullWidth;
          var fullHeight = this.view.fullHeight;
          left += this.view.offsetX * width2 / fullWidth;
          top -= this.view.offsetY * height / fullHeight;
          width2 *= this.view.width / fullWidth;
          height *= this.view.height / fullHeight;
        }
        makePerspective(this.projectionMatrix, left, left + width2, top - height, top, near, this.far, this.clipSpaceNearZ === ClipSpaceNearZ.ZERO);
        import_gl_matrix2.mat4.invert(this.projectionMatrixInverse, this.projectionMatrix);
        this.triggerUpdate();
        return this;
      }
    }, {
      key: "setOrthographic",
      value: function setOrthographic(l, r, t, b, near, far) {
        var _this$view2;
        this.projectionMode = CameraProjectionMode.ORTHOGRAPHIC;
        this.rright = r;
        this.left = l;
        this.top = t;
        this.bottom = b;
        this.near = near;
        this.far = far;
        var dx = (this.rright - this.left) / (2 * this.zoom);
        var dy = (this.top - this.bottom) / (2 * this.zoom);
        var cx = (this.rright + this.left) / 2;
        var cy = (this.top + this.bottom) / 2;
        var left = cx - dx;
        var right = cx + dx;
        var top = cy + dy;
        var bottom = cy - dy;
        if ((_this$view2 = this.view) !== null && _this$view2 !== void 0 && _this$view2.enabled) {
          var scaleW = (this.rright - this.left) / this.view.fullWidth / this.zoom;
          var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          left += scaleW * this.view.offsetX;
          right = left + scaleW * this.view.width;
          top -= scaleH * this.view.offsetY;
          bottom = top - scaleH * this.view.height;
        }
        if (this.clipSpaceNearZ === ClipSpaceNearZ.NEGATIVE_ONE) {
          import_gl_matrix2.mat4.ortho(this.projectionMatrix, left, right, top, bottom, near, far);
        } else {
          import_gl_matrix2.mat4.orthoZO(this.projectionMatrix, left, right, top, bottom, near, far);
        }
        import_gl_matrix2.mat4.invert(this.projectionMatrixInverse, this.projectionMatrix);
        this._getOrthoMatrix();
        this.triggerUpdate();
        return this;
      }
      /**
       * Move the camera in world coordinates.
       * It will keep looking at the current focal point.
       *
       * support scalars or vectors.
       * @example
       * setPosition(1, 2, 3);
       * setPosition([1, 2, 3]);
       */
    }, {
      key: "setPosition",
      value: function setPosition(x3) {
        var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.position[1];
        var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.position[2];
        var position2 = createVec3(x3, y3, z);
        this._setPosition(position2);
        this.setFocalPoint(this.focalPoint);
        this.triggerUpdate();
        return this;
      }
      /**
       * Sets the focal point of this camera in world coordinates.
       *
       * support scalars or vectors.
       * @example
       * setFocalPoint(1, 2, 3);
       * setFocalPoint([1, 2, 3]);
       */
    }, {
      key: "setFocalPoint",
      value: function setFocalPoint(x3) {
        var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.focalPoint[1];
        var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.focalPoint[2];
        var up = import_gl_matrix2.vec3.fromValues(0, 1, 0);
        this.focalPoint = createVec3(x3, y3, z);
        if (this.trackingMode === CameraTrackingMode.CINEMATIC) {
          var d2 = import_gl_matrix2.vec3.subtract(import_gl_matrix2.vec3.create(), this.focalPoint, this.position);
          x3 = d2[0];
          y3 = d2[1];
          z = d2[2];
          var r = import_gl_matrix2.vec3.length(d2);
          var el = rad2deg(Math.asin(y3 / r));
          var az = 90 + rad2deg(Math.atan2(z, x3));
          var m2 = import_gl_matrix2.mat4.create();
          import_gl_matrix2.mat4.rotateY(m2, m2, deg2rad(az));
          import_gl_matrix2.mat4.rotateX(m2, m2, deg2rad(el));
          up = import_gl_matrix2.vec3.transformMat4(import_gl_matrix2.vec3.create(), [0, 1, 0], m2);
        }
        import_gl_matrix2.mat4.invert(this.matrix, import_gl_matrix2.mat4.lookAt(import_gl_matrix2.mat4.create(), this.position, this.focalPoint, up));
        this._getAxes();
        this._getDistance();
        this._getAngles();
        this.triggerUpdate();
        return this;
      }
    }, {
      key: "getDistance",
      value: function getDistance2() {
        return this.distance;
      }
    }, {
      key: "getDistanceVector",
      value: function getDistanceVector() {
        return this.distanceVector;
      }
      /**
       * Moves the camera towards/from the focal point.
       */
    }, {
      key: "setDistance",
      value: function setDistance(d2) {
        if (this.distance === d2 || d2 < 0) {
          return this;
        }
        this.distance = d2;
        if (this.distance < MIN_DISTANCE) {
          this.distance = MIN_DISTANCE;
        }
        this.dollyingStep = this.distance / 100;
        var pos = import_gl_matrix2.vec3.create();
        d2 = this.distance;
        var n = this.forward;
        var f = this.focalPoint;
        pos[0] = d2 * n[0] + f[0];
        pos[1] = d2 * n[1] + f[1];
        pos[2] = d2 * n[2] + f[2];
        this._setPosition(pos);
        this.triggerUpdate();
        return this;
      }
    }, {
      key: "setMaxDistance",
      value: function setMaxDistance(d2) {
        this.maxDistance = d2;
        return this;
      }
    }, {
      key: "setMinDistance",
      value: function setMinDistance(d2) {
        this.minDistance = d2;
        return this;
      }
      /**
       * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
       * the azimuth in degrees
       */
    }, {
      key: "setAzimuth",
      value: function setAzimuth(az) {
        this.azimuth = getAngle(az);
        this.computeMatrix();
        this._getAxes();
        if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
          this._getPosition();
        } else if (this.type === CameraType.TRACKING) {
          this._getFocalPoint();
        }
        this.triggerUpdate();
        return this;
      }
    }, {
      key: "getAzimuth",
      value: function getAzimuth() {
        return this.azimuth;
      }
      /**
       * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
       */
    }, {
      key: "setElevation",
      value: function setElevation(el) {
        this.elevation = getAngle(el);
        this.computeMatrix();
        this._getAxes();
        if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
          this._getPosition();
        } else if (this.type === CameraType.TRACKING) {
          this._getFocalPoint();
        }
        this.triggerUpdate();
        return this;
      }
    }, {
      key: "getElevation",
      value: function getElevation() {
        return this.elevation;
      }
      /**
       * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
       */
    }, {
      key: "setRoll",
      value: function setRoll(angle2) {
        this.roll = getAngle(angle2);
        this.computeMatrix();
        this._getAxes();
        if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
          this._getPosition();
        } else if (this.type === CameraType.TRACKING) {
          this._getFocalPoint();
        }
        this.triggerUpdate();
        return this;
      }
    }, {
      key: "getRoll",
      value: function getRoll() {
        return this.roll;
      }
      /**
       * 根据相机矩阵重新计算各种相机参数
       */
    }, {
      key: "_update",
      value: function _update() {
        this._getAxes();
        this._getPosition();
        this._getDistance();
        this._getAngles();
        this._getOrthoMatrix();
        this.triggerUpdate();
      }
      /**
       * 计算相机矩阵
       */
    }, {
      key: "computeMatrix",
      value: function computeMatrix() {
        var rotZ = import_gl_matrix2.quat.setAxisAngle(import_gl_matrix2.quat.create(), [0, 0, 1], deg2rad(this.roll));
        import_gl_matrix2.mat4.identity(this.matrix);
        var rotX = import_gl_matrix2.quat.setAxisAngle(import_gl_matrix2.quat.create(), [1, 0, 0], deg2rad((this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.elevation));
        var rotY = import_gl_matrix2.quat.setAxisAngle(import_gl_matrix2.quat.create(), [0, 1, 0], deg2rad((this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.azimuth));
        var rotQ = import_gl_matrix2.quat.multiply(import_gl_matrix2.quat.create(), rotY, rotX);
        rotQ = import_gl_matrix2.quat.multiply(import_gl_matrix2.quat.create(), rotQ, rotZ);
        var rotMatrix = import_gl_matrix2.mat4.fromQuat(import_gl_matrix2.mat4.create(), rotQ);
        if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
          import_gl_matrix2.mat4.translate(this.matrix, this.matrix, this.focalPoint);
          import_gl_matrix2.mat4.multiply(this.matrix, this.matrix, rotMatrix);
          import_gl_matrix2.mat4.translate(this.matrix, this.matrix, [0, 0, this.distance]);
        } else if (this.type === CameraType.TRACKING) {
          import_gl_matrix2.mat4.translate(this.matrix, this.matrix, this.position);
          import_gl_matrix2.mat4.multiply(this.matrix, this.matrix, rotMatrix);
        }
      }
      /**
       * Sets the camera position in the camera matrix
       */
    }, {
      key: "_setPosition",
      value: function _setPosition(x3, y3, z) {
        this.position = createVec3(x3, y3, z);
        var m2 = this.matrix;
        m2[12] = this.position[0];
        m2[13] = this.position[1];
        m2[14] = this.position[2];
        m2[15] = 1;
        this._getOrthoMatrix();
      }
      /**
       * Recalculates axes based on the current matrix
       */
    }, {
      key: "_getAxes",
      value: function _getAxes() {
        import_gl_matrix2.vec3.copy(this.right, createVec3(import_gl_matrix2.vec4.transformMat4(import_gl_matrix2.vec4.create(), [1, 0, 0, 0], this.matrix)));
        import_gl_matrix2.vec3.copy(this.up, createVec3(import_gl_matrix2.vec4.transformMat4(import_gl_matrix2.vec4.create(), [0, 1, 0, 0], this.matrix)));
        import_gl_matrix2.vec3.copy(this.forward, createVec3(import_gl_matrix2.vec4.transformMat4(import_gl_matrix2.vec4.create(), [0, 0, 1, 0], this.matrix)));
        import_gl_matrix2.vec3.normalize(this.right, this.right);
        import_gl_matrix2.vec3.normalize(this.up, this.up);
        import_gl_matrix2.vec3.normalize(this.forward, this.forward);
      }
      /**
       * Recalculates euler angles based on the current state
       */
    }, {
      key: "_getAngles",
      value: function _getAngles() {
        var x3 = this.distanceVector[0];
        var y3 = this.distanceVector[1];
        var z = this.distanceVector[2];
        var r = import_gl_matrix2.vec3.length(this.distanceVector);
        if (r === 0) {
          this.elevation = 0;
          this.azimuth = 0;
          return;
        }
        if (this.type === CameraType.TRACKING) {
          this.elevation = rad2deg(Math.asin(y3 / r));
          this.azimuth = rad2deg(Math.atan2(-x3, -z));
        } else if (this.rotateWorld) {
          this.elevation = rad2deg(Math.asin(y3 / r));
          this.azimuth = rad2deg(Math.atan2(-x3, -z));
        } else {
          this.elevation = -rad2deg(Math.asin(y3 / r));
          this.azimuth = -rad2deg(Math.atan2(-x3, -z));
        }
      }
      /**
       * 重新计算相机位置，只有 ORBITING 模式相机位置才会发生变化
       */
    }, {
      key: "_getPosition",
      value: function _getPosition() {
        import_gl_matrix2.vec3.copy(this.position, createVec3(import_gl_matrix2.vec4.transformMat4(import_gl_matrix2.vec4.create(), [0, 0, 0, 1], this.matrix)));
        this._getDistance();
      }
      /**
       * 重新计算视点，只有 TRACKING 模式视点才会发生变化
       */
    }, {
      key: "_getFocalPoint",
      value: function _getFocalPoint() {
        import_gl_matrix2.vec3.transformMat3(this.distanceVector, [0, 0, -this.distance], import_gl_matrix2.mat3.fromMat4(import_gl_matrix2.mat3.create(), this.matrix));
        import_gl_matrix2.vec3.add(this.focalPoint, this.position, this.distanceVector);
        this._getDistance();
      }
      /**
       * 重新计算视距
       */
    }, {
      key: "_getDistance",
      value: function _getDistance() {
        this.distanceVector = import_gl_matrix2.vec3.subtract(import_gl_matrix2.vec3.create(), this.focalPoint, this.position);
        this.distance = import_gl_matrix2.vec3.length(this.distanceVector);
        this.dollyingStep = this.distance / 100;
      }
    }, {
      key: "_getOrthoMatrix",
      value: function _getOrthoMatrix() {
        if (this.projectionMode !== CameraProjectionMode.ORTHOGRAPHIC) {
          return;
        }
        var position2 = this.position;
        var rotZ = import_gl_matrix2.quat.setAxisAngle(import_gl_matrix2.quat.create(), [0, 0, 1], -this.roll * Math.PI / 180);
        import_gl_matrix2.mat4.fromRotationTranslationScaleOrigin(this.orthoMatrix, rotZ, import_gl_matrix2.vec3.fromValues((this.rright - this.left) / 2 - position2[0], (this.top - this.bottom) / 2 - position2[1], 0), import_gl_matrix2.vec3.fromValues(this.zoom, this.zoom, 1), position2);
      }
    }, {
      key: "triggerUpdate",
      value: function triggerUpdate() {
        if (this.enableUpdate) {
          var viewMatrix = this.getViewTransform();
          var vpMatrix = import_gl_matrix2.mat4.multiply(import_gl_matrix2.mat4.create(), this.getPerspective(), viewMatrix);
          this.getFrustum().extractFromVPMatrix(vpMatrix);
          this.eventEmitter.emit(CameraEvent.UPDATED);
        }
      }
    }, {
      key: "rotate",
      value: function rotate3(azimuth, elevation, roll) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "pan",
      value: function pan(tx, ty) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "dolly",
      value: function dolly(value) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "createLandmark",
      value: function createLandmark(name, params) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "gotoLandmark",
      value: function gotoLandmark(name, options) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "cancelLandmarkAnimation",
      value: function cancelLandmarkAnimation() {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }]);
  })();
  var Strategy = /* @__PURE__ */ (function(Strategy2) {
    Strategy2[Strategy2["Standard"] = 0] = "Standard";
    return Strategy2;
  })({});
  var SortReason = /* @__PURE__ */ (function(SortReason2) {
    SortReason2[SortReason2["ADDED"] = 0] = "ADDED";
    SortReason2[SortReason2["REMOVED"] = 1] = "REMOVED";
    SortReason2[SortReason2["Z_INDEX_CHANGED"] = 2] = "Z_INDEX_CHANGED";
    return SortReason2;
  })({});
  var $vec3$2 = import_gl_matrix2.vec3.create();
  var $mat4$1 = import_gl_matrix2.mat4.create();
  var $quat$2 = import_gl_matrix2.quat.create();
  function updateLocalTransform(transform) {
    if (!transform.localDirtyFlag) {
      return;
    }
    var hasSkew = transform.localSkew[0] !== 0 || transform.localSkew[1] !== 0;
    if (hasSkew) {
      import_gl_matrix2.mat4.fromRotationTranslationScaleOrigin(transform.localTransform, transform.localRotation, transform.localPosition, import_gl_matrix2.vec3.fromValues(1, 1, 1), transform.origin);
      if (transform.localSkew[0] !== 0 || transform.localSkew[1] !== 0) {
        import_gl_matrix2.mat4.identity($mat4$1);
        $mat4$1[4] = Math.tan(transform.localSkew[0]);
        $mat4$1[1] = Math.tan(transform.localSkew[1]);
        import_gl_matrix2.mat4.multiply(transform.localTransform, transform.localTransform, $mat4$1);
      }
      var scaling = import_gl_matrix2.mat4.fromRotationTranslationScaleOrigin($mat4$1, import_gl_matrix2.quat.set($quat$2, 0, 0, 0, 1), import_gl_matrix2.vec3.set($vec3$2, 1, 1, 1), transform.localScale, transform.origin);
      import_gl_matrix2.mat4.multiply(transform.localTransform, transform.localTransform, scaling);
    } else {
      var localTransform = transform.localTransform, localPosition = transform.localPosition, localRotation = transform.localRotation, localScale = transform.localScale, origin = transform.origin;
      var hasPosition2 = localPosition[0] !== 0 || localPosition[1] !== 0 || localPosition[2] !== 0;
      var hasRotation = localRotation[3] !== 1 || localRotation[0] !== 0 || localRotation[1] !== 0 || localRotation[2] !== 0;
      var hasScale = localScale[0] !== 1 || localScale[1] !== 1 || localScale[2] !== 1;
      var hasOrigin = origin[0] !== 0 || origin[1] !== 0 || origin[2] !== 0;
      if (!hasRotation && !hasScale && !hasOrigin) {
        if (hasPosition2) {
          import_gl_matrix2.mat4.fromTranslation(localTransform, localPosition);
        } else {
          import_gl_matrix2.mat4.identity(localTransform);
        }
      } else {
        import_gl_matrix2.mat4.fromRotationTranslationScaleOrigin(localTransform, localRotation, localPosition, localScale, origin);
      }
    }
    transform.localDirtyFlag = false;
  }
  function updateWorldTransform(transform, parentTransform) {
    if (!transform.dirtyFlag) {
      return;
    }
    if (!parentTransform) {
      import_gl_matrix2.mat4.copy(transform.worldTransform, transform.localTransform);
    } else {
      import_gl_matrix2.mat4.multiply(transform.worldTransform, parentTransform.worldTransform, transform.localTransform);
    }
    transform.dirtyFlag = false;
  }
  var EMPTY_PARSED_PATH = {
    absolutePath: [],
    hasArc: false,
    segments: [],
    polygons: [],
    polylines: [],
    curve: null,
    totalLength: 0,
    rect: new Rectangle(0, 0, 0, 0)
  };
  var PropertySyntax = /* @__PURE__ */ (function(PropertySyntax2) {
    PropertySyntax2["COORDINATE"] = "<coordinate>";
    PropertySyntax2["COLOR"] = "<color>";
    PropertySyntax2["PAINT"] = "<paint>";
    PropertySyntax2["NUMBER"] = "<number>";
    PropertySyntax2["ANGLE"] = "<angle>";
    PropertySyntax2["OPACITY_VALUE"] = "<opacity-value>";
    PropertySyntax2["SHADOW_BLUR"] = "<shadow-blur>";
    PropertySyntax2["LENGTH"] = "<length>";
    PropertySyntax2["PERCENTAGE"] = "<percentage>";
    PropertySyntax2["LENGTH_PERCENTAGE"] = "<length> | <percentage>";
    PropertySyntax2["LENGTH_PERCENTAGE_12"] = "[<length> | <percentage>]{1,2}";
    PropertySyntax2["LENGTH_PERCENTAGE_14"] = "[<length> | <percentage>]{1,4}";
    PropertySyntax2["LIST_OF_POINTS"] = "<list-of-points>";
    PropertySyntax2["PATH"] = "<path>";
    PropertySyntax2["FILTER"] = "<filter>";
    PropertySyntax2["Z_INDEX"] = "<z-index>";
    PropertySyntax2["OFFSET_DISTANCE"] = "<offset-distance>";
    PropertySyntax2["DEFINED_PATH"] = "<defined-path>";
    PropertySyntax2["MARKER"] = "<marker>";
    PropertySyntax2["TRANSFORM"] = "<transform>";
    PropertySyntax2["TRANSFORM_ORIGIN"] = "<transform-origin>";
    PropertySyntax2["TEXT"] = "<text>";
    PropertySyntax2["TEXT_TRANSFORM"] = "<text-transform>";
    return PropertySyntax2;
  })({});
  function define2(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }
  function Color() {
  }
  var darker = 0.7;
  var brighter = 1 / darker;
  var reI = "\\s*([+-]?\\d+)\\s*";
  var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
  var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
  var reHex = /^#([0-9a-f]{3,8})$/;
  var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
  var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
  var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
  var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
  var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
  var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  define2(Color, color, {
    copy(channels) {
      return Object.assign(new this.constructor(), this, channels);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: color_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: color_formatHex,
    formatHex8: color_formatHex8,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });
  function color_formatHex() {
    return this.rgb().formatHex();
  }
  function color_formatHex8() {
    return this.rgb().formatHex8();
  }
  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }
  function color_formatRgb() {
    return this.rgb().formatRgb();
  }
  function color(format2) {
    var m2, l;
    format2 = (format2 + "").trim().toLowerCase();
    return (m2 = reHex.exec(format2)) ? (l = m2[1].length, m2 = parseInt(m2[1], 16), l === 6 ? rgbn(m2) : l === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format2)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format2)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format2)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format2)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
  }
  function rgbn(n) {
    return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
  }
  function rgba(r, g, b, a2) {
    if (a2 <= 0) r = g = b = NaN;
    return new Rgb(r, g, b, a2);
  }
  function rgbConvert(o) {
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Rgb();
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }
  function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
  }
  function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }
  define2(Rgb, rgb, extend(Color, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex,
    formatHex8: rgb_formatHex8,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));
  function rgb_formatHex() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
  }
  function rgb_formatHex8() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function rgb_formatRgb() {
    const a2 = clampa(this.opacity);
    return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
  }
  function clampa(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
  }
  function clampi(value) {
    return Math.max(0, Math.min(255, Math.round(value) || 0));
  }
  function hex(value) {
    value = clampi(value);
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla(h, s, l, a2) {
    if (a2 <= 0) h = s = l = NaN;
    else if (l <= 0 || l >= 1) h = s = NaN;
    else if (s <= 0) h = NaN;
    return new Hsl(h, s, l, a2);
  }
  function hslConvert(o) {
    if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Hsl();
    if (o instanceof Hsl) return o;
    o = o.rgb();
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, min4 = Math.min(r, g, b), max4 = Math.max(r, g, b), h = NaN, s = max4 - min4, l = (max4 + min4) / 2;
    if (s) {
      if (r === max4) h = (g - b) / s + (g < b) * 6;
      else if (g === max4) h = (b - r) / s + 2;
      else h = (r - g) / s + 4;
      s /= l < 0.5 ? max4 + min4 : 2 - max4 - min4;
      h *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl(h, s, l, o.opacity);
  }
  function hsl(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
  }
  function Hsl(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }
  define2(Hsl, hsl, extend(Color, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb() {
      var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
      return new Rgb(
        hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
        hsl2rgb(h, m1, m2),
        hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
        this.opacity
      );
    },
    clamp() {
      return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl() {
      const a2 = clampa(this.opacity);
      return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
    }
  }));
  function clamph(value) {
    value = (value || 0) % 360;
    return value < 0 ? value + 360 : value;
  }
  function clampt(value) {
    return Math.max(0, Math.min(1, value || 0));
  }
  function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
  }
  function memoize(func, resolver) {
    if (typeof func !== "function" || resolver != null && typeof resolver !== "function") {
      throw new TypeError("Expected a function");
    }
    var _memoized = function memoized() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var key = resolver ? resolver.apply(this, args) : args[0];
      var cache = _memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      _memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    _memoized.cache = new (memoize.Cache || Map)();
    memoize.cacheList.push(_memoized.cache);
    return _memoized;
  }
  memoize.Cache = Map;
  memoize.cacheList = [];
  memoize.clearCache = function() {
    memoize.cacheList.forEach(function(cache) {
      return cache.clear();
    });
  };
  var UnitType = /* @__PURE__ */ (function(UnitType2) {
    UnitType2[UnitType2["kUnknown"] = 0] = "kUnknown";
    UnitType2[UnitType2["kNumber"] = 1] = "kNumber";
    UnitType2[UnitType2["kPercentage"] = 2] = "kPercentage";
    UnitType2[UnitType2["kEms"] = 3] = "kEms";
    UnitType2[UnitType2["kPixels"] = 4] = "kPixels";
    UnitType2[UnitType2["kRems"] = 5] = "kRems";
    UnitType2[UnitType2["kDegrees"] = 6] = "kDegrees";
    UnitType2[UnitType2["kRadians"] = 7] = "kRadians";
    UnitType2[UnitType2["kGradians"] = 8] = "kGradians";
    UnitType2[UnitType2["kTurns"] = 9] = "kTurns";
    UnitType2[UnitType2["kMilliseconds"] = 10] = "kMilliseconds";
    UnitType2[UnitType2["kSeconds"] = 11] = "kSeconds";
    UnitType2[UnitType2["kInteger"] = 12] = "kInteger";
    return UnitType2;
  })({});
  var UnitCategory = /* @__PURE__ */ (function(UnitCategory2) {
    UnitCategory2[UnitCategory2["kUNumber"] = 0] = "kUNumber";
    UnitCategory2[UnitCategory2["kUPercent"] = 1] = "kUPercent";
    UnitCategory2[UnitCategory2["kULength"] = 2] = "kULength";
    UnitCategory2[UnitCategory2["kUAngle"] = 3] = "kUAngle";
    UnitCategory2[UnitCategory2["kUTime"] = 4] = "kUTime";
    UnitCategory2[UnitCategory2["kUOther"] = 5] = "kUOther";
    return UnitCategory2;
  })({});
  var Nested = /* @__PURE__ */ (function(Nested2) {
    Nested2[Nested2["kYes"] = 0] = "kYes";
    Nested2[Nested2["kNo"] = 1] = "kNo";
    return Nested2;
  })({});
  var ParenLess = /* @__PURE__ */ (function(ParenLess2) {
    ParenLess2[ParenLess2["kYes"] = 0] = "kYes";
    ParenLess2[ParenLess2["kNo"] = 1] = "kNo";
    return ParenLess2;
  })({});
  var data = [
    {
      name: "em",
      unit_type: UnitType.kEms
    },
    // {
    //   name: 'ex',
    //   unit_type: UnitType.kExs,
    // },
    {
      name: "px",
      unit_type: UnitType.kPixels
    },
    // {
    //   name: "cm",
    //   unit_type: UnitType.kCentimeters,
    // },
    // {
    //   name: "mm",
    //   unit_type: UnitType.kMillimeters,
    // },
    // {
    //   name: "q",
    //   unit_type: UnitType.kQuarterMillimeters,
    // },
    // {
    //   name: "in",
    //   unit_type: UnitType.kInches,
    // },
    // {
    //   name: "pt",
    //   unit_type: UnitType.kPoints,
    // },
    // {
    //   name: "pc",
    //   unit_type: UnitType.kPicas,
    // },
    {
      name: "deg",
      unit_type: UnitType.kDegrees
    },
    {
      name: "rad",
      unit_type: UnitType.kRadians
    },
    {
      name: "grad",
      unit_type: UnitType.kGradians
    },
    {
      name: "ms",
      unit_type: UnitType.kMilliseconds
    },
    {
      name: "s",
      unit_type: UnitType.kSeconds
    },
    // {
    //   name: "hz",
    //   unit_type: UnitType.kHertz,
    // },
    // {
    //   name: "khz",
    //   unit_type: UnitType.kKilohertz,
    // },
    // {
    //   name: "dpi",
    //   unit_type: "kDotsPerInch",
    // },
    // {
    //   name: "dpcm",
    //   unit_type: "kDotsPerCentimeter",
    // },
    // {
    //   name: "dppx",
    //   unit_type: "kDotsPerPixel",
    // },
    // {
    //   name: "x",
    //   unit_type: "kDotsPerPixel",
    // },
    // {
    //   name: "vw",
    //   unit_type: "kViewportWidth",
    // },
    // {
    //   name: "vh",
    //   unit_type: "kViewportHeight",
    // },
    // {
    //   name: "vi",
    //   unit_type: "kViewportInlineSize",
    // },
    // {
    //   name: "vb",
    //   unit_type: "kViewportBlockSize",
    // },
    // {
    //   name: "vmin",
    //   unit_type: UnitType.kViewportMin,
    // },
    // {
    //   name: "vmax",
    //   unit_type: UnitType.kViewportMax,
    // },
    // {
    //   name: "svw",
    //   unit_type: "kSmallViewportWidth",
    // },
    // {
    //   name: "svh",
    //   unit_type: "kSmallViewportHeight",
    // },
    // {
    //   name: "svi",
    //   unit_type: "kSmallViewportInlineSize",
    // },
    // {
    //   name: "svb",
    //   unit_type: "kSmallViewportBlockSize",
    // },
    // {
    //   name: "svmin",
    //   unit_type: "kSmallViewportMin",
    // },
    // {
    //   name: "svmax",
    //   unit_type: "kSmallViewportMax",
    // },
    // {
    //   name: "lvw",
    //   unit_type: "kLargeViewportWidth",
    // },
    // {
    //   name: "lvh",
    //   unit_type: "kLargeViewportHeight",
    // },
    // {
    //   name: "lvi",
    //   unit_type: "kLargeViewportInlineSize",
    // },
    // {
    //   name: "lvb",
    //   unit_type: "kLargeViewportBlockSize",
    // },
    // {
    //   name: "lvmin",
    //   unit_type: UnitType.kLargeViewportMin,
    // },
    // {
    //   name: "lvmax",
    //   unit_type: UnitType.kLargeViewportMax,
    // },
    // {
    //   name: "dvw",
    //   unit_type: UnitType.kDynamicViewportWidth,
    // },
    // {
    //   name: "dvh",
    //   unit_type: UnitType.kDynamicViewportHeight,
    // },
    // {
    //   name: "dvi",
    //   unit_type: UnitType.kDynamicViewportInlineSize,
    // },
    // {
    //   name: "dvb",
    //   unit_type: UnitType.kDynamicViewportBlockSize,
    // },
    // {
    //   name: "dvmin",
    //   unit_type: UnitType.kDynamicViewportMin,
    // },
    // {
    //   name: "dvmax",
    //   unit_type: UnitType.kDynamicViewportMax,
    // },
    // {
    //   name: "cqw",
    //   unit_type: UnitType.kContainerWidth,
    // },
    // {
    //   name: "cqh",
    //   unit_type: UnitType.kContainerHeight,
    // },
    // {
    //   name: "cqi",
    //   unit_type: UnitType.kContainerInlineSize,
    // },
    // {
    //   name: "cqb",
    //   unit_type: UnitType.kContainerBlockSize,
    // },
    // {
    //   name: "cqmin",
    //   unit_type: UnitType.kContainerMin,
    // },
    // {
    //   name: "cqmax",
    //   unit_type: UnitType.kContainerMax,
    // },
    {
      name: "rem",
      unit_type: UnitType.kRems
    },
    // {
    //   name: 'fr',
    //   unit_type: UnitType.kFraction,
    // },
    {
      name: "turn",
      unit_type: UnitType.kTurns
    }
    // {
    //   name: 'ch',
    //   unit_type: UnitType.kChs,
    // },
    // {
    //   name: '__qem',
    //   unit_type: UnitType.kQuirkyEms,
    // },
  ];
  var CSSStyleValueType = /* @__PURE__ */ (function(CSSStyleValueType2) {
    CSSStyleValueType2[CSSStyleValueType2["kUnknownType"] = 0] = "kUnknownType";
    CSSStyleValueType2[CSSStyleValueType2["kUnparsedType"] = 1] = "kUnparsedType";
    CSSStyleValueType2[CSSStyleValueType2["kKeywordType"] = 2] = "kKeywordType";
    CSSStyleValueType2[CSSStyleValueType2["kUnitType"] = 3] = "kUnitType";
    CSSStyleValueType2[CSSStyleValueType2["kSumType"] = 4] = "kSumType";
    CSSStyleValueType2[CSSStyleValueType2["kProductType"] = 5] = "kProductType";
    CSSStyleValueType2[CSSStyleValueType2["kNegateType"] = 6] = "kNegateType";
    CSSStyleValueType2[CSSStyleValueType2["kInvertType"] = 7] = "kInvertType";
    CSSStyleValueType2[CSSStyleValueType2["kMinType"] = 8] = "kMinType";
    CSSStyleValueType2[CSSStyleValueType2["kMaxType"] = 9] = "kMaxType";
    CSSStyleValueType2[CSSStyleValueType2["kClampType"] = 10] = "kClampType";
    CSSStyleValueType2[CSSStyleValueType2["kTransformType"] = 11] = "kTransformType";
    CSSStyleValueType2[CSSStyleValueType2["kPositionType"] = 12] = "kPositionType";
    CSSStyleValueType2[CSSStyleValueType2["kURLImageType"] = 13] = "kURLImageType";
    CSSStyleValueType2[CSSStyleValueType2["kColorType"] = 14] = "kColorType";
    CSSStyleValueType2[CSSStyleValueType2["kUnsupportedColorType"] = 15] = "kUnsupportedColorType";
    return CSSStyleValueType2;
  })({});
  var stringToUnitType = function stringToUnitType2(name) {
    return data.find(function(item) {
      return item.name === name;
    }).unit_type;
  };
  var unitFromName = function unitFromName2(name) {
    if (!name) {
      return UnitType.kUnknown;
    }
    if (name === "number") {
      return UnitType.kNumber;
    }
    if (name === "percent" || name === "%") {
      return UnitType.kPercentage;
    }
    return stringToUnitType(name);
  };
  var unitTypeToUnitCategory = function unitTypeToUnitCategory2(type) {
    switch (type) {
      case UnitType.kNumber:
      case UnitType.kInteger:
        return UnitCategory.kUNumber;
      case UnitType.kPercentage:
        return UnitCategory.kUPercent;
      case UnitType.kPixels:
        return UnitCategory.kULength;
      case UnitType.kMilliseconds:
      case UnitType.kSeconds:
        return UnitCategory.kUTime;
      case UnitType.kDegrees:
      case UnitType.kRadians:
      case UnitType.kGradians:
      case UnitType.kTurns:
        return UnitCategory.kUAngle;
      // case UnitType.kHertz:
      // case UnitType.kKilohertz:
      //   return UnitCategory.kUFrequency;
      // case UnitType.kDotsPerPixel:
      // case UnitType.kDotsPerInch:
      // case UnitType.kDotsPerCentimeter:
      //   return UnitCategory.kUResolution;
      default:
        return UnitCategory.kUOther;
    }
  };
  var canonicalUnitTypeForCategory = function canonicalUnitTypeForCategory2(category) {
    switch (category) {
      case UnitCategory.kUNumber:
        return UnitType.kNumber;
      case UnitCategory.kULength:
        return UnitType.kPixels;
      case UnitCategory.kUPercent:
        return UnitType.kPercentage;
      // return UnitType.kUnknown; // Cannot convert between numbers and percent.
      case UnitCategory.kUTime:
        return UnitType.kSeconds;
      case UnitCategory.kUAngle:
        return UnitType.kDegrees;
      // case UnitCategory.kUFrequency:
      //   return UnitType.kHertz;
      // case UnitCategory.kUResolution:
      //   return UnitType.kDotsPerPixel;
      default:
        return UnitType.kUnknown;
    }
  };
  var conversionToCanonicalUnitsScaleFactor = function conversionToCanonicalUnitsScaleFactor2(unit_type) {
    var factor = 1;
    switch (unit_type) {
      // These are "canonical" units in their respective categories.
      case UnitType.kPixels:
      // case UnitType.kUserUnits:
      case UnitType.kDegrees:
      case UnitType.kSeconds:
        break;
      case UnitType.kMilliseconds:
        factor = 1e-3;
        break;
      // case UnitType.kCentimeters:
      //   // factor = kCssPixelsPerCentimeter;
      //   break;
      // case UnitType.kDotsPerCentimeter:
      //   // factor = 1 / kCssPixelsPerCentimeter;
      //   break;
      // case UnitType.kMillimeters:
      //   // factor = kCssPixelsPerMillimeter;
      //   break;
      // case UnitType.kQuarterMillimeters:
      //   // factor = kCssPixelsPerQuarterMillimeter;
      //   break;
      // case UnitType.kInches:
      //   // factor = kCssPixelsPerInch;
      //   break;
      // case UnitType.kDotsPerInch:
      //   // factor = 1 / kCssPixelsPerInch;
      //   break;
      // case UnitType.kPoints:
      //   // factor = kCssPixelsPerPoint;
      //   break;
      // case UnitType.kPicas:
      //   // factor = kCssPixelsPerPica;
      //   break;
      case UnitType.kRadians:
        factor = 180 / Math.PI;
        break;
      case UnitType.kGradians:
        factor = 0.9;
        break;
      case UnitType.kTurns:
        factor = 360;
        break;
    }
    return factor;
  };
  var unitTypeToString = function unitTypeToString2(type) {
    switch (type) {
      case UnitType.kNumber:
      case UnitType.kInteger:
        return "";
      case UnitType.kPercentage:
        return "%";
      case UnitType.kEms:
        return "em";
      // case UnitType.kExs:
      //   return 'ex';
      case UnitType.kRems:
        return "rem";
      // case UnitType.kChs:
      //   return 'ch';
      case UnitType.kPixels:
        return "px";
      // case UnitType.kCentimeters:
      //   return 'cm';
      // case UnitType.kDotsPerPixel:
      //   return 'dppx';
      // case UnitType.kDotsPerInch:
      //   return 'dpi';
      // case UnitType.kDotsPerCentimeter:
      //   return 'dpcm';
      // case UnitType.kMillimeters:
      //   return 'mm';
      // case UnitType.kQuarterMillimeters:
      //   return 'q';
      // case UnitType.kInches:
      //   return 'in';
      // case UnitType.kPoints:
      //   return 'pt';
      // case UnitType.kPicas:
      //   return 'pc';
      case UnitType.kDegrees:
        return "deg";
      case UnitType.kRadians:
        return "rad";
      case UnitType.kGradians:
        return "grad";
      case UnitType.kMilliseconds:
        return "ms";
      case UnitType.kSeconds:
        return "s";
      // case UnitType.kHertz:
      //   return 'hz';
      // case UnitType.kKilohertz:
      //   return 'khz';
      case UnitType.kTurns:
        return "turn";
    }
    return "";
  };
  var CSSStyleValue = /* @__PURE__ */ (function() {
    function CSSStyleValue2() {
      _classCallCheck(this, CSSStyleValue2);
    }
    return _createClass(CSSStyleValue2, [{
      key: "toString",
      value: (
        // protected abstract toCSSValue(): CSSValue;
        function toString3() {
          return this.buildCSSText(Nested.kNo, ParenLess.kNo, "");
        }
      )
    }, {
      key: "isNumericValue",
      value: function isNumericValue() {
        return this.getType() >= CSSStyleValueType.kUnitType && this.getType() <= CSSStyleValueType.kClampType;
      }
    }], [{
      key: "isAngle",
      value: (
        // static parse(propertyName: string, value: string): CSSStyleValue {
        //   return parseCSSStyleValue(propertyName, value)[0];
        // }
        // static parseAll(propertyName: string, value: string): CSSStyleValue[] {
        //   return parseCSSStyleValue(propertyName, value);
        // }
        function isAngle(unit) {
          return unit === UnitType.kDegrees || unit === UnitType.kRadians || unit === UnitType.kGradians || unit === UnitType.kTurns;
        }
      )
      // static isViewportPercentageLength(type: UnitType) {
      //   return type >= UnitType.kViewportWidth && type <= UnitType.kDynamicViewportMax;
      // }
      // static isContainerPercentageLength(type: UnitType) {
      //   return type >= UnitType.kContainerWidth && type <= UnitType.kContainerMax;
      // }
    }, {
      key: "isLength",
      value: function isLength(type) {
        return type >= UnitType.kEms && type < UnitType.kDegrees;
      }
    }, {
      key: "isRelativeUnit",
      value: function isRelativeUnit(type) {
        return type === UnitType.kPercentage || type === UnitType.kEms || // type === UnitType.kExs ||
        type === UnitType.kRems;
      }
    }, {
      key: "isTime",
      value: function isTime(unit) {
        return unit === UnitType.kSeconds || unit === UnitType.kMilliseconds;
      }
      // static isFrequency(unit: UnitType) {
      //   return unit == UnitType.kHertz || unit == UnitType.kKilohertz;
      // }
      // static isResolution(type: UnitType) {
      //   return type >= UnitType.kDotsPerPixel && type <= UnitType.kDotsPerCentimeter;
      // }
      // static isFlex(unit: UnitType) {
      //   return unit === UnitType.kFraction;
      // }
    }]);
  })();
  var CSSColorValue = /* @__PURE__ */ (function(_CSSStyleValue) {
    function CSSColorValue2(colorSpace) {
      var _this2;
      _classCallCheck(this, CSSColorValue2);
      _this2 = _callSuper(this, CSSColorValue2);
      _this2.colorSpace = colorSpace;
      return _this2;
    }
    _inherits(CSSColorValue2, _CSSStyleValue);
    return _createClass(CSSColorValue2, [{
      key: "getType",
      value: function getType2() {
        return CSSStyleValueType.kColorType;
      }
      /**
       * @see https://drafts.css-houdini.org/css-typed-om-1/#dom-csscolorvalue-to
       */
    }, {
      key: "to",
      value: function to(colorSpace) {
        return this;
      }
    }]);
  })(CSSStyleValue);
  var GradientType = /* @__PURE__ */ (function(GradientType2) {
    GradientType2[GradientType2["Constant"] = 0] = "Constant";
    GradientType2[GradientType2["LinearGradient"] = 1] = "LinearGradient";
    GradientType2[GradientType2["RadialGradient"] = 2] = "RadialGradient";
    return GradientType2;
  })({});
  var CSSGradientValue = /* @__PURE__ */ (function(_CSSStyleValue) {
    function CSSGradientValue2(type, value) {
      var _this2;
      _classCallCheck(this, CSSGradientValue2);
      _this2 = _callSuper(this, CSSGradientValue2);
      _this2.type = type;
      _this2.value = value;
      return _this2;
    }
    _inherits(CSSGradientValue2, _CSSStyleValue);
    return _createClass(CSSGradientValue2, [{
      key: "clone",
      value: function clone8() {
        return new CSSGradientValue2(this.type, this.value);
      }
    }, {
      key: "buildCSSText",
      value: function buildCSSText(n, p, result) {
        return result;
      }
    }, {
      key: "getType",
      value: function getType2() {
        return CSSStyleValueType.kColorType;
      }
    }]);
  })(CSSStyleValue);
  var CSSKeywordValue = /* @__PURE__ */ (function(_CSSStyleValue) {
    function CSSKeywordValue2(value) {
      var _this2;
      _classCallCheck(this, CSSKeywordValue2);
      _this2 = _callSuper(this, CSSKeywordValue2);
      _this2.value = value;
      return _this2;
    }
    _inherits(CSSKeywordValue2, _CSSStyleValue);
    return _createClass(CSSKeywordValue2, [{
      key: "clone",
      value: function clone8() {
        return new CSSKeywordValue2(this.value);
      }
    }, {
      key: "getType",
      value: function getType2() {
        return CSSStyleValueType.kKeywordType;
      }
    }, {
      key: "buildCSSText",
      value: function buildCSSText(n, p, result) {
        return result + this.value;
      }
    }]);
  })(CSSStyleValue);
  var formatInfinityOrNaN = function formatInfinityOrNaN2(number) {
    var suffix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    var result = "";
    if (!Number.isFinite(number)) {
      if (number > 0) result = "infinity";
      else result = "-infinity";
    } else {
      result = "NaN";
    }
    return result += suffix;
  };
  var toCanonicalUnit = function toCanonicalUnit2(unit) {
    return canonicalUnitTypeForCategory(unitTypeToUnitCategory(unit));
  };
  var CSSUnitValue = /* @__PURE__ */ (function(_CSSStyleValue) {
    function CSSUnitValue2(value) {
      var _this2;
      var unitOrName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : UnitType.kNumber;
      _classCallCheck(this, CSSUnitValue2);
      _this2 = _callSuper(this, CSSUnitValue2);
      var unit;
      if (typeof unitOrName === "string") {
        unit = unitFromName(unitOrName);
      } else {
        unit = unitOrName;
      }
      _this2.unit = unit;
      _this2.value = value;
      return _this2;
    }
    _inherits(CSSUnitValue2, _CSSStyleValue);
    return _createClass(CSSUnitValue2, [{
      key: "clone",
      value: function clone8() {
        return new CSSUnitValue2(this.value, this.unit);
      }
    }, {
      key: "equals",
      value: function equals(other) {
        var other_unit_value = other;
        return this.value === other_unit_value.value && this.unit === other_unit_value.unit;
      }
    }, {
      key: "getType",
      value: function getType2() {
        return CSSStyleValueType.kUnitType;
      }
    }, {
      key: "convertTo",
      value: function convertTo(target_unit) {
        if (this.unit === target_unit) {
          return new CSSUnitValue2(this.value, this.unit);
        }
        var canonical_unit = toCanonicalUnit(this.unit);
        if (canonical_unit !== toCanonicalUnit(target_unit) || canonical_unit === UnitType.kUnknown) {
          return null;
        }
        var scale_factor = conversionToCanonicalUnitsScaleFactor(this.unit) / conversionToCanonicalUnitsScaleFactor(target_unit);
        return new CSSUnitValue2(this.value * scale_factor, target_unit);
      }
    }, {
      key: "buildCSSText",
      value: function buildCSSText(n, p, result) {
        var text;
        switch (this.unit) {
          case UnitType.kUnknown:
            break;
          case UnitType.kInteger:
            text = Number(this.value).toFixed(0);
            break;
          case UnitType.kNumber:
          case UnitType.kPercentage:
          case UnitType.kEms:
          // case UnitType.kQuirkyEms:
          // case UnitType.kExs:
          case UnitType.kRems:
          // case UnitType.kChs:
          case UnitType.kPixels:
          // case UnitType.kCentimeters:
          // case UnitType.kDotsPerPixel:
          // case UnitType.kDotsPerInch:
          // case UnitType.kDotsPerCentimeter:
          // case UnitType.kMillimeters:
          // case UnitType.kQuarterMillimeters:
          // case UnitType.kInches:
          // case UnitType.kPoints:
          // case UnitType.kPicas:
          // case UnitType.kUserUnits:
          case UnitType.kDegrees:
          case UnitType.kRadians:
          case UnitType.kGradians:
          case UnitType.kMilliseconds:
          case UnitType.kSeconds:
          // case UnitType.kHertz:
          // case UnitType.kKilohertz:
          case UnitType.kTurns: {
            var kMinInteger = -999999;
            var kMaxInteger = 999999;
            var value = this.value;
            var unit = unitTypeToString(this.unit);
            if (value < kMinInteger || value > kMaxInteger) {
              var _unit = unitTypeToString(this.unit);
              if (!Number.isFinite(value) || Number.isNaN(value)) {
                text = formatInfinityOrNaN(value, _unit);
              } else {
                text = value + (_unit || "");
              }
            } else {
              text = "".concat(value).concat(unit);
            }
          }
        }
        result += text;
        return result;
      }
    }]);
  })(CSSStyleValue);
  var Opx = new CSSUnitValue(0, "px");
  new CSSUnitValue(1, "px");
  var Odeg = new CSSUnitValue(0, "deg");
  var CSSRGB = /* @__PURE__ */ (function(_CSSColorValue) {
    function CSSRGB2(r, g, b) {
      var _this2;
      var alpha = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
      var isNone = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      _classCallCheck(this, CSSRGB2);
      _this2 = _callSuper(this, CSSRGB2, ["rgb"]);
      _this2.r = r;
      _this2.g = g;
      _this2.b = b;
      _this2.alpha = alpha;
      _this2.isNone = isNone;
      return _this2;
    }
    _inherits(CSSRGB2, _CSSColorValue);
    return _createClass(CSSRGB2, [{
      key: "clone",
      value: function clone8() {
        return new CSSRGB2(this.r, this.g, this.b, this.alpha);
      }
    }, {
      key: "buildCSSText",
      value: function buildCSSText(n, p, result) {
        return "".concat(result, "rgba(").concat(this.r, ",").concat(this.g, ",").concat(this.b, ",").concat(this.alpha, ")");
      }
    }]);
  })(CSSColorValue);
  var unsetKeywordValue = new CSSKeywordValue("unset");
  var initialKeywordValue = new CSSKeywordValue("initial");
  var inheritKeywordValue = new CSSKeywordValue("inherit");
  var keywordCache = {
    "": unsetKeywordValue,
    unset: unsetKeywordValue,
    initial: initialKeywordValue,
    inherit: inheritKeywordValue
  };
  var getOrCreateKeyword = function getOrCreateKeyword2(name) {
    if (!keywordCache[name]) {
      keywordCache[name] = new CSSKeywordValue(name);
    }
    return keywordCache[name];
  };
  var noneColor = new CSSRGB(0, 0, 0, 0, true);
  var transparentColor = new CSSRGB(0, 0, 0, 0);
  var getOrCreateRGBA = memoize(function(r, g, b, a2) {
    return new CSSRGB(r, g, b, a2);
  }, function(r, g, b, a2) {
    return "rgba(".concat(r, ",").concat(g, ",").concat(b, ",").concat(a2, ")");
  });
  var getOrCreateUnitValue = function getOrCreateUnitValue2(value) {
    var unitOrName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : UnitType.kNumber;
    return new CSSUnitValue(value, unitOrName);
  };
  new CSSUnitValue(50, "%");
  function colorStopToString(colorStop) {
    var type = colorStop.type, value = colorStop.value;
    if (type === "hex") {
      return "#".concat(value);
    }
    if (type === "literal") {
      return value;
    }
    if (type === "rgb") {
      return "rgb(".concat(value.join(","), ")");
    }
    return "rgba(".concat(value.join(","), ")");
  }
  var parseGradient$1 = /* @__PURE__ */ (function() {
    var tokens3 = {
      linearGradient: /^(linear\-gradient)/i,
      repeatingLinearGradient: /^(repeating\-linear\-gradient)/i,
      radialGradient: /^(radial\-gradient)/i,
      repeatingRadialGradient: /^(repeating\-radial\-gradient)/i,
      /**
       * @see https://projects.verou.me/conic-gradient/
       */
      conicGradient: /^(conic\-gradient)/i,
      sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
      extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
      positionKeywords: /^(left|center|right|top|bottom)/i,
      pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
      percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
      emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
      angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
      startCall: /^\(/,
      endCall: /^\)/,
      comma: /^,/,
      hexColor: /^\#([0-9a-fA-F]+)/,
      literalColor: /^([a-zA-Z]+)/,
      rgbColor: /^rgb/i,
      rgbaColor: /^rgba/i,
      number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
    };
    var input = "";
    function error2(msg) {
      throw new Error("".concat(input, ": ").concat(msg));
    }
    function getAST() {
      var ast = matchListDefinitions();
      if (input.length > 0) {
        error2("Invalid input not EOF");
      }
      return ast;
    }
    function matchListDefinitions() {
      return matchListing(matchDefinition);
    }
    function matchDefinition() {
      return matchGradient("linear-gradient", tokens3.linearGradient, matchLinearOrientation) || matchGradient("repeating-linear-gradient", tokens3.repeatingLinearGradient, matchLinearOrientation) || matchGradient("radial-gradient", tokens3.radialGradient, matchListRadialOrientations) || matchGradient("repeating-radial-gradient", tokens3.repeatingRadialGradient, matchListRadialOrientations) || matchGradient("conic-gradient", tokens3.conicGradient, matchListRadialOrientations);
    }
    function matchGradient(gradientType, pattern, orientationMatcher) {
      return matchCall(pattern, function(captures) {
        var orientation5 = orientationMatcher();
        if (orientation5) {
          if (!scan(tokens3.comma)) {
            error2("Missing comma before color stops");
          }
        }
        return {
          type: gradientType,
          orientation: orientation5,
          colorStops: matchListing(matchColorStop)
        };
      });
    }
    function matchCall(pattern, callback) {
      var captures = scan(pattern);
      if (captures) {
        if (!scan(tokens3.startCall)) {
          error2("Missing (");
        }
        var result = callback(captures);
        if (!scan(tokens3.endCall)) {
          error2("Missing )");
        }
        return result;
      }
    }
    function matchLinearOrientation() {
      return matchSideOrCorner() || matchAngle();
    }
    function matchSideOrCorner() {
      return match2("directional", tokens3.sideOrCorner, 1);
    }
    function matchAngle() {
      return match2("angular", tokens3.angleValue, 1);
    }
    function matchListRadialOrientations() {
      var radialOrientations;
      var radialOrientation = matchRadialOrientation();
      var lookaheadCache;
      if (radialOrientation) {
        radialOrientations = [];
        radialOrientations.push(radialOrientation);
        lookaheadCache = input;
        if (scan(tokens3.comma)) {
          radialOrientation = matchRadialOrientation();
          if (radialOrientation) {
            radialOrientations.push(radialOrientation);
          } else {
            input = lookaheadCache;
          }
        }
      }
      return radialOrientations;
    }
    function matchRadialOrientation() {
      var radialType = matchCircle() || matchEllipse();
      if (radialType) {
        radialType.at = matchAtPosition();
      } else {
        var extent = matchExtentKeyword();
        if (extent) {
          radialType = extent;
          var positionAt = matchAtPosition();
          if (positionAt) {
            radialType.at = positionAt;
          }
        } else {
          var defaultPosition = matchPositioning();
          if (defaultPosition) {
            radialType = {
              type: "default-radial",
              // @ts-ignore
              at: defaultPosition
            };
          }
        }
      }
      return radialType;
    }
    function matchCircle() {
      var circle3 = match2("shape", /^(circle)/i, 0);
      if (circle3) {
        circle3.style = matchLength() || matchExtentKeyword();
      }
      return circle3;
    }
    function matchEllipse() {
      var ellipse = match2("shape", /^(ellipse)/i, 0);
      if (ellipse) {
        ellipse.style = matchDistance() || matchExtentKeyword();
      }
      return ellipse;
    }
    function matchExtentKeyword() {
      return match2("extent-keyword", tokens3.extentKeywords, 1);
    }
    function matchAtPosition() {
      if (match2("position", /^at/, 0)) {
        var positioning = matchPositioning();
        if (!positioning) {
          error2("Missing positioning value");
        }
        return positioning;
      }
    }
    function matchPositioning() {
      var location = matchCoordinates();
      if (location.x || location.y) {
        return {
          type: "position",
          value: location
        };
      }
    }
    function matchCoordinates() {
      return {
        x: matchDistance(),
        y: matchDistance()
      };
    }
    function matchListing(matcher) {
      var captures = matcher();
      var result = [];
      if (captures) {
        result.push(captures);
        while (scan(tokens3.comma)) {
          captures = matcher();
          if (captures) {
            result.push(captures);
          } else {
            error2("One extra comma");
          }
        }
      }
      return result;
    }
    function matchColorStop() {
      var color2 = matchColor();
      if (!color2) {
        error2("Expected color definition");
      }
      color2.length = matchDistance();
      return color2;
    }
    function matchColor() {
      return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor();
    }
    function matchLiteralColor() {
      return match2("literal", tokens3.literalColor, 0);
    }
    function matchHexColor() {
      return match2("hex", tokens3.hexColor, 1);
    }
    function matchRGBColor() {
      return matchCall(tokens3.rgbColor, function() {
        return {
          type: "rgb",
          value: matchListing(matchNumber)
        };
      });
    }
    function matchRGBAColor() {
      return matchCall(tokens3.rgbaColor, function() {
        return {
          type: "rgba",
          value: matchListing(matchNumber)
        };
      });
    }
    function matchNumber() {
      return scan(tokens3.number)[1];
    }
    function matchDistance() {
      return match2("%", tokens3.percentageValue, 1) || matchPositionKeyword() || matchLength();
    }
    function matchPositionKeyword() {
      return match2("position-keyword", tokens3.positionKeywords, 1);
    }
    function matchLength() {
      return match2("px", tokens3.pixelValue, 1) || match2("em", tokens3.emValue, 1);
    }
    function match2(type, pattern, captureIndex) {
      var captures = scan(pattern);
      if (captures) {
        return {
          type,
          value: captures[captureIndex]
        };
      }
    }
    function scan(regexp) {
      var blankCaptures = /^[\n\r\t\s]+/.exec(input);
      if (blankCaptures) {
        consume(blankCaptures[0].length);
      }
      var captures = regexp.exec(input);
      if (captures) {
        consume(captures[0].length);
      }
      return captures;
    }
    function consume(size2) {
      input = input.substring(size2);
    }
    return function(code) {
      input = code;
      return getAST();
    };
  })();
  function computeLinearGradient(min4, width2, height, angle2) {
    var rad2 = deg2rad(angle2.value);
    var rx = 0;
    var ry = 0;
    var rcx = rx + width2 / 2;
    var rcy = ry + height / 2;
    var length = Math.abs(width2 * Math.cos(rad2)) + Math.abs(height * Math.sin(rad2));
    var x1 = min4[0] + rcx - Math.cos(rad2) * length / 2;
    var y1 = min4[1] + rcy - Math.sin(rad2) * length / 2;
    var x22 = min4[0] + rcx + Math.cos(rad2) * length / 2;
    var y22 = min4[1] + rcy + Math.sin(rad2) * length / 2;
    return {
      x1,
      y1,
      x2: x22,
      y2: y22
    };
  }
  function computeRadialGradient(min4, width2, height, cx, cy, size2) {
    var x3 = cx.value;
    var y3 = cy.value;
    if (cx.unit === UnitType.kPercentage) {
      x3 = cx.value / 100 * width2;
    }
    if (cy.unit === UnitType.kPercentage) {
      y3 = cy.value / 100 * height;
    }
    var r = Math.max((0, import_util2.distanceSquareRoot)([0, 0], [x3, y3]), (0, import_util2.distanceSquareRoot)([0, height], [x3, y3]), (0, import_util2.distanceSquareRoot)([width2, height], [x3, y3]), (0, import_util2.distanceSquareRoot)([width2, 0], [x3, y3]));
    if (size2) {
      if (size2 instanceof CSSUnitValue) {
        r = size2.value;
      } else if (size2 instanceof CSSKeywordValue) {
        if (size2.value === "closest-side") {
          r = Math.min(x3, width2 - x3, y3, height - y3);
        } else if (size2.value === "farthest-side") {
          r = Math.max(x3, width2 - x3, y3, height - y3);
        } else if (size2.value === "closest-corner") {
          r = Math.min((0, import_util2.distanceSquareRoot)([0, 0], [x3, y3]), (0, import_util2.distanceSquareRoot)([0, height], [x3, y3]), (0, import_util2.distanceSquareRoot)([width2, height], [x3, y3]), (0, import_util2.distanceSquareRoot)([width2, 0], [x3, y3]));
        }
      }
    }
    return {
      x: x3 + min4[0],
      y: y3 + min4[1],
      r
    };
  }
  var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
  var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
  var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
  var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
  function spaceColorStops(colorStops) {
    var _colorStops$length;
    var length = colorStops.length;
    colorStops[length - 1].length = (_colorStops$length = colorStops[length - 1].length) !== null && _colorStops$length !== void 0 ? _colorStops$length : {
      type: "%",
      value: "100"
    };
    if (length > 1) {
      var _colorStops$0$length;
      colorStops[0].length = (_colorStops$0$length = colorStops[0].length) !== null && _colorStops$0$length !== void 0 ? _colorStops$0$length : {
        type: "%",
        value: "0"
      };
    }
    var previousIndex = 0;
    var previousOffset = Number(colorStops[0].length.value);
    for (var i = 1; i < length; i++) {
      var _colorStops$i$length;
      var offset = (_colorStops$i$length = colorStops[i].length) === null || _colorStops$i$length === void 0 ? void 0 : _colorStops$i$length.value;
      if (!(0, import_util2.isNil)(offset) && !(0, import_util2.isNil)(previousOffset)) {
        for (var j = 1; j < i - previousIndex; j++) colorStops[previousIndex + j].length = {
          type: "%",
          value: "".concat(previousOffset + (Number(offset) - previousOffset) * j / (i - previousIndex))
        };
        previousIndex = i;
        previousOffset = Number(offset);
      }
    }
  }
  var SideOrCornerToDegMap = {
    left: 270 - 90,
    top: 0 - 90,
    bottom: 180 - 90,
    right: 90 - 90,
    "left top": 315 - 90,
    "top left": 315 - 90,
    "left bottom": 225 - 90,
    "bottom left": 225 - 90,
    "right top": 45 - 90,
    "top right": 45 - 90,
    "right bottom": 135 - 90,
    "bottom right": 135 - 90
  };
  var angleToDeg = memoize(function(orientation5) {
    var angle2;
    if (orientation5.type === "angular") {
      angle2 = Number(orientation5.value);
    } else {
      angle2 = SideOrCornerToDegMap[orientation5.value] || 0;
    }
    return getOrCreateUnitValue(angle2, "deg");
  });
  var positonToCSSUnitValue = memoize(function(position2) {
    var cx = 50;
    var cy = 50;
    var unitX = "%";
    var unitY = "%";
    if ((position2 === null || position2 === void 0 ? void 0 : position2.type) === "position") {
      var _position$value = position2.value, x3 = _position$value.x, y3 = _position$value.y;
      if ((x3 === null || x3 === void 0 ? void 0 : x3.type) === "position-keyword") {
        if (x3.value === "left") {
          cx = 0;
        } else if (x3.value === "center") {
          cx = 50;
        } else if (x3.value === "right") {
          cx = 100;
        } else if (x3.value === "top") {
          cy = 0;
        } else if (x3.value === "bottom") {
          cy = 100;
        }
      }
      if ((y3 === null || y3 === void 0 ? void 0 : y3.type) === "position-keyword") {
        if (y3.value === "left") {
          cx = 0;
        } else if (y3.value === "center") {
          cy = 50;
        } else if (y3.value === "right") {
          cx = 100;
        } else if (y3.value === "top") {
          cy = 0;
        } else if (y3.value === "bottom") {
          cy = 100;
        }
      }
      if ((x3 === null || x3 === void 0 ? void 0 : x3.type) === "px" || (x3 === null || x3 === void 0 ? void 0 : x3.type) === "%" || (x3 === null || x3 === void 0 ? void 0 : x3.type) === "em") {
        unitX = x3 === null || x3 === void 0 ? void 0 : x3.type;
        cx = Number(x3.value);
      }
      if ((y3 === null || y3 === void 0 ? void 0 : y3.type) === "px" || (y3 === null || y3 === void 0 ? void 0 : y3.type) === "%" || (y3 === null || y3 === void 0 ? void 0 : y3.type) === "em") {
        unitY = y3 === null || y3 === void 0 ? void 0 : y3.type;
        cy = Number(y3.value);
      }
    }
    return {
      cx: getOrCreateUnitValue(cx, unitX),
      cy: getOrCreateUnitValue(cy, unitY)
    };
  });
  var parseGradient = memoize(function(colorStr) {
    if (colorStr.indexOf("linear") > -1 || colorStr.indexOf("radial") > -1) {
      var ast = parseGradient$1(colorStr);
      return ast.map(function(_ref) {
        var type2 = _ref.type, orientation5 = _ref.orientation, colorStops = _ref.colorStops;
        spaceColorStops(colorStops);
        var steps2 = colorStops.map(function(colorStop) {
          return {
            offset: getOrCreateUnitValue(Number(colorStop.length.value), "%"),
            color: colorStopToString(colorStop)
          };
        });
        if (type2 === "linear-gradient") {
          return new CSSGradientValue(GradientType.LinearGradient, {
            angle: orientation5 ? angleToDeg(orientation5) : Odeg,
            steps: steps2
          });
        }
        if (type2 === "radial-gradient") {
          if (!orientation5) {
            orientation5 = [{
              type: "shape",
              value: "circle"
            }];
          }
          if (orientation5[0].type === "shape" && orientation5[0].value === "circle") {
            var _positonToCSSUnitValu = positonToCSSUnitValue(orientation5[0].at), cx = _positonToCSSUnitValu.cx, cy = _positonToCSSUnitValu.cy;
            var size2;
            if (orientation5[0].style) {
              var _orientation$0$style = orientation5[0].style, _type = _orientation$0$style.type, value = _orientation$0$style.value;
              if (_type === "extent-keyword") {
                size2 = getOrCreateKeyword(value);
              } else {
                size2 = getOrCreateUnitValue(value, _type);
              }
            }
            return new CSSGradientValue(GradientType.RadialGradient, {
              cx,
              cy,
              size: size2,
              steps: steps2
            });
          }
        }
        return void 0;
      });
    }
    var type = colorStr[0];
    if (colorStr[1] === "(" || colorStr[2] === "(") {
      if (type === "l") {
        var arr = regexLG.exec(colorStr);
        if (arr) {
          var _arr$2$match;
          var steps = ((_arr$2$match = arr[2].match(regexColorStop)) === null || _arr$2$match === void 0 ? void 0 : _arr$2$match.map(function(stop) {
            return stop.split(":");
          })) || [];
          return [new CSSGradientValue(GradientType.LinearGradient, {
            angle: getOrCreateUnitValue(parseFloat(arr[1]), "deg"),
            steps: steps.map(function(_ref2) {
              var _ref3 = _slicedToArray(_ref2, 2), offset = _ref3[0], color2 = _ref3[1];
              return {
                offset: getOrCreateUnitValue(Number(offset) * 100, "%"),
                color: color2
              };
            })
          })];
        }
      } else if (type === "r") {
        var parsedRadialGradient = parseRadialGradient(colorStr);
        if (parsedRadialGradient) {
          if ((0, import_util2.isString)(parsedRadialGradient)) {
            colorStr = parsedRadialGradient;
          } else {
            return [new CSSGradientValue(GradientType.RadialGradient, parsedRadialGradient)];
          }
        }
      } else if (type === "p") {
        return parsePattern(colorStr);
      }
    }
  });
  function parseRadialGradient(gradientStr) {
    var arr = regexRG.exec(gradientStr);
    if (arr) {
      var _arr$4$match;
      var steps = ((_arr$4$match = arr[4].match(regexColorStop)) === null || _arr$4$match === void 0 ? void 0 : _arr$4$match.map(function(stop) {
        return stop.split(":");
      })) || [];
      return {
        cx: getOrCreateUnitValue(50, "%"),
        cy: getOrCreateUnitValue(50, "%"),
        steps: steps.map(function(_ref4) {
          var _ref5 = _slicedToArray(_ref4, 2), offset = _ref5[0], color2 = _ref5[1];
          return {
            offset: getOrCreateUnitValue(Number(offset) * 100, "%"),
            color: color2
          };
        })
      };
    }
    return null;
  }
  function parsePattern(patternStr) {
    var arr = regexPR.exec(patternStr);
    if (arr) {
      var repetition = arr[1];
      var src = arr[2];
      switch (repetition) {
        case "a":
          repetition = "repeat";
          break;
        case "x":
          repetition = "repeat-x";
          break;
        case "y":
          repetition = "repeat-y";
          break;
        case "n":
          repetition = "no-repeat";
          break;
        default:
          repetition = "no-repeat";
      }
      return {
        image: src,
        // @ts-ignore
        repetition
      };
    }
    return null;
  }
  function isPattern(object) {
    return object && !!object.image;
  }
  function isCSSRGB(object) {
    return object && !(0, import_util2.isNil)(object.r) && !(0, import_util2.isNil)(object.g) && !(0, import_util2.isNil)(object.b);
  }
  var parseColor = memoize(function(colorStr) {
    if (isPattern(colorStr)) {
      return _objectSpread2({
        repetition: "repeat"
      }, colorStr);
    }
    if ((0, import_util2.isNil)(colorStr)) {
      colorStr = "";
    }
    if (colorStr === "transparent") {
      return transparentColor;
    }
    if (colorStr === "currentColor") {
      colorStr = "black";
    } else if (colorStr === "none") {
      return noneColor;
    }
    var g = parseGradient(colorStr);
    if (g) {
      return g;
    }
    var color$1 = color(colorStr);
    var rgba2 = [0, 0, 0, 0];
    if (color$1 !== null) {
      rgba2[0] = color$1.r || 0;
      rgba2[1] = color$1.g || 0;
      rgba2[2] = color$1.b || 0;
      rgba2[3] = color$1.opacity;
    }
    return getOrCreateRGBA.apply(void 0, rgba2);
  });
  function mergeColors(left, right) {
    if (!isCSSRGB(left) || !isCSSRGB(right)) {
      return;
    }
    return [[Number(left.r), Number(left.g), Number(left.b), Number(left.alpha)], [Number(right.r), Number(right.g), Number(right.b), Number(right.alpha)], function(color2) {
      var rgba2 = color2.slice();
      if (rgba2[3]) {
        for (var i = 0; i < 3; i++) rgba2[i] = Math.round((0, import_util2.clamp)(rgba2[i], 0, 255));
      }
      rgba2[3] = (0, import_util2.clamp)(rgba2[3], 0, 1);
      return "rgba(".concat(rgba2.join(","), ")");
    }];
  }
  function parseDimension(unitRegExp, string) {
    if ((0, import_util2.isNil)(string)) {
      return getOrCreateUnitValue(0, "px");
    }
    string = "".concat(string).trim().toLowerCase();
    if (isFinite(Number(string))) {
      if ("px".search(unitRegExp) >= 0) {
        return getOrCreateUnitValue(Number(string), "px");
      }
      if ("deg".search(unitRegExp) >= 0) {
        return getOrCreateUnitValue(Number(string), "deg");
      }
    }
    var matchedUnits = [];
    string = string.replace(unitRegExp, function(match2) {
      matchedUnits.push(match2);
      return "U".concat(match2);
    });
    var taggedUnitRegExp = "U(".concat(unitRegExp.source, ")");
    return matchedUnits.map(function(unit) {
      return getOrCreateUnitValue(Number(string.replace(new RegExp("U".concat(unit), "g"), "").replace(new RegExp(taggedUnitRegExp, "g"), "*0")), unit);
    })[0];
  }
  var parseLengthUnmemoize = function parseLengthUnmemoize2(css) {
    return parseDimension(new RegExp("px", "g"), css);
  };
  var parseLength = memoize(parseLengthUnmemoize);
  var parserPercentageUnmemoize = function parserPercentageUnmemoize2(css) {
    return parseDimension(new RegExp("%", "g"), css);
  };
  memoize(parserPercentageUnmemoize);
  var parseLengthOrPercentageUnmemoize = function parseLengthOrPercentageUnmemoize2(css) {
    if ((0, import_util2.isNumber)(css) || isFinite(Number(css))) {
      return getOrCreateUnitValue(Number(css) || 0, "px");
    }
    return parseDimension(new RegExp("px|%|em|rem", "g"), css);
  };
  var parseLengthOrPercentage = memoize(parseLengthOrPercentageUnmemoize);
  var parseAngleUnmemoize = function parseAngleUnmemoize2(css) {
    return parseDimension(new RegExp("deg|rad|grad|turn", "g"), css);
  };
  var parseAngle = memoize(parseAngleUnmemoize);
  function mergeDimensions(left, right, target, nonNegative) {
    var index2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
    var unit = "";
    var leftValue = left.value || 0;
    var rightValue = right.value || 0;
    var canonicalUnit = toCanonicalUnit(left.unit);
    var leftCanonicalUnitValue = left.convertTo(canonicalUnit);
    var rightCanonicalUnitValue = right.convertTo(canonicalUnit);
    if (leftCanonicalUnitValue && rightCanonicalUnitValue) {
      leftValue = leftCanonicalUnitValue.value;
      rightValue = rightCanonicalUnitValue.value;
      unit = unitTypeToString(left.unit);
    } else if (CSSUnitValue.isLength(left.unit) || CSSUnitValue.isLength(right.unit)) {
      leftValue = convertPercentUnit(left, index2, target);
      rightValue = convertPercentUnit(right, index2, target);
      unit = "px";
    }
    return [leftValue, rightValue, function(value) {
      if (nonNegative) {
        value = Math.max(value, 0);
      }
      return value + unit;
    }];
  }
  function convertAngleUnit(value) {
    var deg = 0;
    if (value.unit === UnitType.kDegrees) {
      deg = value.value;
    } else if (value.unit === UnitType.kRadians) {
      deg = rad2deg(Number(value.value));
    } else if (value.unit === UnitType.kTurns) {
      deg = turn2deg(Number(value.value));
    } else if (value.value) {
      deg = value.value;
    }
    return deg;
  }
  function parseDimensionArrayFormat(string, size2) {
    var parsed;
    if (Array.isArray(string)) {
      parsed = string.map(function(segment) {
        return Number(segment);
      });
    } else if ((0, import_util2.isString)(string)) {
      parsed = string.split(" ").map(function(segment) {
        return Number(segment);
      });
    } else if ((0, import_util2.isNumber)(string)) {
      parsed = [string];
    }
    if (size2 === 2) {
      if (parsed.length === 1) {
        return [parsed[0], parsed[0]];
      }
      return [parsed[0], parsed[1]];
    }
    if (size2 === 4) {
      if (parsed.length === 1) {
        return [parsed[0], parsed[0], parsed[0], parsed[0]];
      }
      if (parsed.length === 2) {
        return [parsed[0], parsed[1], parsed[0], parsed[1]];
      }
      if (parsed.length === 3) {
        return [parsed[0], parsed[1], parsed[2], parsed[1]];
      }
      return [parsed[0], parsed[1], parsed[2], parsed[3]];
    }
    if (size2 === "even" && parsed.length % 2 === 1) {
      return [].concat(_toConsumableArray(parsed), _toConsumableArray(parsed));
    }
    return parsed;
  }
  function convertPercentUnit(valueWithUnit, vec3Index, target) {
    var useMin = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (valueWithUnit.unit === UnitType.kPixels) {
      return Number(valueWithUnit.value);
    }
    if (valueWithUnit.unit === UnitType.kPercentage && target) {
      var bounds = target.nodeName === Shape.GROUP ? target.getLocalBounds() : target.getGeometryBounds();
      return (useMin ? bounds.min[vec3Index] : 0) + valueWithUnit.value / 100 * bounds.halfExtents[vec3Index] * 2;
    }
    return 0;
  }
  var parseParam = function parseParam2(css) {
    return parseDimension(/deg|rad|grad|turn|px|%/g, css);
  };
  var supportedFilters = ["blur", "brightness", "drop-shadow", "contrast", "grayscale", "sepia", "saturate", "hue-rotate", "invert"];
  function parseFilter() {
    var filterStr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    filterStr = filterStr.toLowerCase().trim();
    if (filterStr === "none") {
      return [];
    }
    var filterRegExp = /\s*([\w-]+)\(([^)]*)\)/g;
    var result = [];
    var match2;
    var prevLastIndex = 0;
    while (match2 = filterRegExp.exec(filterStr)) {
      if (match2.index !== prevLastIndex) {
        return [];
      }
      prevLastIndex = match2.index + match2[0].length;
      if (supportedFilters.indexOf(match2[1]) > -1) {
        result.push({
          name: match2[1],
          params: match2[2].split(" ").map(function(p) {
            return parseParam(p) || parseColor(p);
          })
        });
      }
      if (filterRegExp.lastIndex === filterStr.length) {
        return result;
      }
    }
    return [];
  }
  function numberToString(x3) {
    return x3.toString();
  }
  var parseNumberUnmemoize = function parseNumberUnmemoize2(string) {
    if (typeof string === "number") {
      return getOrCreateUnitValue(string);
    }
    if (/^\s*[-+]?(\d*\.)?\d+\s*$/.test(string)) {
      return getOrCreateUnitValue(Number(string));
    }
    return getOrCreateUnitValue(0);
  };
  var parseNumber = memoize(parseNumberUnmemoize);
  memoize(function(string) {
    if ((0, import_util2.isString)(string)) {
      return string.split(" ").map(parseNumber);
    }
    return string.map(parseNumber);
  });
  function mergeNumbers(left, right) {
    return [left, right, numberToString];
  }
  function clampedMergeNumbers(min4, max4) {
    return function(left, right) {
      return [left, right, function(x3) {
        return numberToString((0, import_util2.clamp)(x3, min4, max4));
      }];
    };
  }
  function mergeNumberLists(left, right) {
    if (left.length !== right.length) {
      return;
    }
    return [left, right, function(numberList) {
      return numberList;
    }];
  }
  function getOrCalculatePathTotalLength(path) {
    if (path.parsedStyle.d.totalLength === 0) {
      path.parsedStyle.d.totalLength = (0, import_util2.getTotalLength)(path.parsedStyle.d.absolutePath);
    }
    return path.parsedStyle.d.totalLength;
  }
  function getOrCalculatePolylineTotalLength(polyline) {
    if (polyline.parsedStyle.points.totalLength === 0) {
      polyline.parsedStyle.points.totalLength = length$2(polyline.parsedStyle.points.points);
    }
    return polyline.parsedStyle.points.totalLength;
  }
  function removeRedundantMCommand(path) {
    for (var i = 0; i < path.length; i++) {
      var prevSegment = path[i - 1];
      var segment = path[i];
      var cmd = segment[0];
      if (cmd === "M") {
        if (prevSegment) {
          var prevCmd = prevSegment[0];
          var srcPoint = [segment[1], segment[2]];
          var destPoint = void 0;
          if (prevCmd === "L" || prevCmd === "M") {
            destPoint = [prevSegment[1], prevSegment[2]];
          } else if (prevCmd === "C" || prevCmd === "A" || prevCmd === "Q") {
            destPoint = [prevSegment[prevSegment.length - 2], prevSegment[prevSegment.length - 1]];
          }
          if (destPoint && isSamePoint(srcPoint, destPoint)) {
            path.splice(i, 1);
            i--;
          }
        }
      }
    }
  }
  function hasArcOrBezier(path) {
    var hasArc = false;
    var count = path.length;
    for (var i = 0; i < count; i++) {
      var params = path[i];
      var cmd = params[0];
      if (cmd === "C" || cmd === "A" || cmd === "Q") {
        hasArc = true;
        break;
      }
    }
    return hasArc;
  }
  function extractPolygons(pathArray) {
    var polygons = [];
    var polylines = [];
    var points = [];
    for (var i = 0; i < pathArray.length; i++) {
      var params = pathArray[i];
      var cmd = params[0];
      if (cmd === "M") {
        if (points.length) {
          polylines.push(points);
          points = [];
        }
        points.push([params[1], params[2]]);
      } else if (cmd === "Z") {
        if (points.length) {
          polygons.push(points);
          points = [];
        }
      } else {
        points.push([params[1], params[2]]);
      }
    }
    if (points.length > 0) {
      polylines.push(points);
    }
    return {
      polygons,
      polylines
    };
  }
  function isSamePoint(point1, point22) {
    return point1[0] === point22[0] && point1[1] === point22[1];
  }
  function getPathBBox(segments, lineWidth) {
    var xArr = [];
    var yArr = [];
    var segmentsWithAngle = [];
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
      var box2 = void 0;
      switch (segment.command) {
        case "Q":
          box2 = box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
          break;
        case "C":
          box2 = box$3(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
          break;
        case "A":
          var arcParams = segment.arcParams;
          box2 = box$5(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
          break;
        default:
          xArr.push(currentPoint[0]);
          yArr.push(currentPoint[1]);
          break;
      }
      if (box2) {
        segment.box = box2;
        xArr.push(box2.x, box2.x + box2.width);
        yArr.push(box2.y, box2.y + box2.height);
      }
      if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) {
        segmentsWithAngle.push(segment);
      }
    }
    xArr = xArr.filter(function(item) {
      return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
    });
    yArr = yArr.filter(function(item) {
      return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
    });
    var minX = (0, import_util2.min)(xArr);
    var minY = (0, import_util2.min)(yArr);
    var maxX = (0, import_util2.max)(xArr);
    var maxY = (0, import_util2.max)(yArr);
    if (segmentsWithAngle.length === 0) {
      return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    }
    for (var _i = 0; _i < segmentsWithAngle.length; _i++) {
      var _segment = segmentsWithAngle[_i];
      var _currentPoint = _segment.currentPoint;
      var extra = void 0;
      if (_currentPoint[0] === minX) {
        extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
        minX -= extra.xExtra;
      } else if (_currentPoint[0] === maxX) {
        extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
        maxX += extra.xExtra;
      }
      if (_currentPoint[1] === minY) {
        extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
        minY -= extra.yExtra;
      } else if (_currentPoint[1] === maxY) {
        extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
        maxY += extra.yExtra;
      }
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  function getExtraFromSegmentWithAngle(segment, lineWidth) {
    var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
    var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
    var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
    var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
    var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
    if (!currentAngle || Math.sin(currentAngle) === 0 || (0, import_util2.isNumberEqual)(currentAngle, 0)) {
      return {
        xExtra: 0,
        yExtra: 0
      };
    }
    var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
    var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
    xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
    yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
    var extra = {
      // 水平方向投影
      xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
      // 垂直方向投影
      yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
    };
    return extra;
  }
  function toSymmetry(point4, center) {
    return [center[0] + (center[0] - point4[0]), center[1] + (center[1] - point4[1])];
  }
  var angleBetween = function angleBetween2(v0, v1) {
    var p = v0.x * v1.x + v0.y * v1.y;
    var n = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)));
    var sign = v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1;
    var angle2 = sign * Math.acos(p / n);
    return angle2;
  };
  var pointOnEllipticalArc = function pointOnEllipticalArc2(p0, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p1, t) {
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    xAxisRotation = (0, import_util2.mod)(xAxisRotation, 360);
    var xAxisRotationRadians = deg2rad(xAxisRotation);
    if (p0.x === p1.x && p0.y === p1.y) {
      return {
        x: p0.x,
        y: p0.y,
        ellipticalArcAngle: 0
      };
    }
    if (rx === 0 || ry === 0) {
      return {
        x: 0,
        y: 0,
        ellipticalArcAngle: 0
      };
    }
    var dx = (p0.x - p1.x) / 2;
    var dy = (p0.y - p1.y) / 2;
    var transformedPoint = {
      x: Math.cos(xAxisRotationRadians) * dx + Math.sin(xAxisRotationRadians) * dy,
      y: -Math.sin(xAxisRotationRadians) * dx + Math.cos(xAxisRotationRadians) * dy
    };
    var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
    if (radiiCheck > 1) {
      rx *= Math.sqrt(radiiCheck);
      ry *= Math.sqrt(radiiCheck);
    }
    var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
    var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
    var cRadicand = cSquareNumerator / cSquareRootDenom;
    cRadicand = cRadicand < 0 ? 0 : cRadicand;
    var cCoef = (largeArcFlag !== sweepFlag ? 1 : -1) * Math.sqrt(cRadicand);
    var transformedCenter = {
      x: cCoef * (rx * transformedPoint.y / ry),
      y: cCoef * (-(ry * transformedPoint.x) / rx)
    };
    var center = {
      x: Math.cos(xAxisRotationRadians) * transformedCenter.x - Math.sin(xAxisRotationRadians) * transformedCenter.y + (p0.x + p1.x) / 2,
      y: Math.sin(xAxisRotationRadians) * transformedCenter.x + Math.cos(xAxisRotationRadians) * transformedCenter.y + (p0.y + p1.y) / 2
    };
    var startVector = {
      x: (transformedPoint.x - transformedCenter.x) / rx,
      y: (transformedPoint.y - transformedCenter.y) / ry
    };
    var startAngle = angleBetween({
      x: 1,
      y: 0
    }, startVector);
    var endVector = {
      x: (-transformedPoint.x - transformedCenter.x) / rx,
      y: (-transformedPoint.y - transformedCenter.y) / ry
    };
    var sweepAngle = angleBetween(startVector, endVector);
    if (!sweepFlag && sweepAngle > 0) {
      sweepAngle -= 2 * Math.PI;
    } else if (sweepFlag && sweepAngle < 0) {
      sweepAngle += 2 * Math.PI;
    }
    sweepAngle %= 2 * Math.PI;
    var angle2 = startAngle + sweepAngle * t;
    var ellipseComponentX = rx * Math.cos(angle2);
    var ellipseComponentY = ry * Math.sin(angle2);
    var point4 = {
      x: Math.cos(xAxisRotationRadians) * ellipseComponentX - Math.sin(xAxisRotationRadians) * ellipseComponentY + center.x,
      y: Math.sin(xAxisRotationRadians) * ellipseComponentX + Math.cos(xAxisRotationRadians) * ellipseComponentY + center.y,
      ellipticalArcStartAngle: startAngle,
      ellipticalArcEndAngle: startAngle + sweepAngle,
      ellipticalArcAngle: angle2,
      ellipticalArcCenter: center,
      resultantRx: rx,
      resultantRy: ry
    };
    return point4;
  };
  function path2Segments(path) {
    var segments = [];
    var currentPoint = null;
    var nextParams = null;
    var startMovePoint = null;
    var lastStartMovePointIndex = 0;
    var count = path.length;
    for (var i = 0; i < count; i++) {
      var params = path[i];
      nextParams = path[i + 1];
      var command = params[0];
      var segment = {
        command,
        prePoint: currentPoint,
        params,
        startTangent: null,
        endTangent: null,
        currentPoint: null,
        nextPoint: null,
        arcParams: null,
        box: null,
        cubicParams: null
      };
      switch (command) {
        case "M":
          startMovePoint = [params[1], params[2]];
          lastStartMovePointIndex = i;
          break;
        case "A":
          var arcParams = getArcParams(currentPoint, params);
          segment.arcParams = arcParams;
          break;
      }
      if (command === "Z") {
        currentPoint = startMovePoint;
        nextParams = path[lastStartMovePointIndex + 1];
      } else {
        var len = params.length;
        currentPoint = [params[len - 2], params[len - 1]];
      }
      if (nextParams && nextParams[0] === "Z") {
        nextParams = path[lastStartMovePointIndex];
        if (segments[lastStartMovePointIndex]) {
          segments[lastStartMovePointIndex].prePoint = currentPoint;
        }
      }
      segment.currentPoint = currentPoint;
      if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
        segments[lastStartMovePointIndex].prePoint = segment.prePoint;
      }
      var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
      segment.nextPoint = nextPoint;
      var prePoint = segment.prePoint;
      if (["L", "H", "V"].includes(command)) {
        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
      } else if (command === "Q") {
        var cp = [params[1], params[2]];
        segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
        segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
      } else if (command === "T") {
        var preSegment = segments[i - 1];
        var _cp = toSymmetry(preSegment.currentPoint, prePoint);
        if (preSegment.command === "Q") {
          segment.command = "Q";
          segment.startTangent = [prePoint[0] - _cp[0], prePoint[1] - _cp[1]];
          segment.endTangent = [currentPoint[0] - _cp[0], currentPoint[1] - _cp[1]];
        } else {
          segment.command = "TL";
          segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
          segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
        }
      } else if (command === "C") {
        var cp1 = [params[1], params[2]];
        var cp2 = [params[3], params[4]];
        segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
        if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
          segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
        }
        if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
          segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
        }
      } else if (command === "S") {
        var _preSegment = segments[i - 1];
        var _cp2 = toSymmetry(_preSegment.currentPoint, prePoint);
        var _cp3 = [params[1], params[2]];
        if (_preSegment.command === "C") {
          segment.command = "C";
          segment.startTangent = [prePoint[0] - _cp2[0], prePoint[1] - _cp2[1]];
          segment.endTangent = [currentPoint[0] - _cp3[0], currentPoint[1] - _cp3[1]];
        } else {
          segment.command = "SQ";
          segment.startTangent = [prePoint[0] - _cp3[0], prePoint[1] - _cp3[1]];
          segment.endTangent = [currentPoint[0] - _cp3[0], currentPoint[1] - _cp3[1]];
        }
      } else if (command === "A") {
        var _getTangentAtRatio = getTangentAtRatio(segment, 0), dx1 = _getTangentAtRatio.x, dy1 = _getTangentAtRatio.y;
        var _getTangentAtRatio2 = getTangentAtRatio(segment, 1, false), dx2 = _getTangentAtRatio2.x, dy2 = _getTangentAtRatio2.y;
        segment.startTangent = [dx1, dy1];
        segment.endTangent = [dx2, dy2];
      }
      segments.push(segment);
    }
    return segments;
  }
  function getTangentAtRatio(segment, ratio) {
    var sign = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    var _segment$arcParams = segment.arcParams, _segment$arcParams$rx = _segment$arcParams.rx, rx = _segment$arcParams$rx === void 0 ? 0 : _segment$arcParams$rx, _segment$arcParams$ry = _segment$arcParams.ry, ry = _segment$arcParams$ry === void 0 ? 0 : _segment$arcParams$ry, xRotation = _segment$arcParams.xRotation, arcFlag = _segment$arcParams.arcFlag, sweepFlag = _segment$arcParams.sweepFlag;
    var p1 = pointOnEllipticalArc({
      x: segment.prePoint[0],
      y: segment.prePoint[1]
    }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, {
      x: segment.currentPoint[0],
      y: segment.currentPoint[1]
    }, ratio);
    var p2 = pointOnEllipticalArc({
      x: segment.prePoint[0],
      y: segment.prePoint[1]
    }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, {
      x: segment.currentPoint[0],
      y: segment.currentPoint[1]
    }, sign ? ratio + 5e-3 : ratio - 5e-3);
    var xDist = p2.x - p1.x;
    var yDist = p2.y - p1.y;
    var dist = Math.sqrt(xDist * xDist + yDist * yDist);
    return {
      x: -xDist / dist,
      y: -yDist / dist
    };
  }
  function vMag(v) {
    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
  }
  function vRatio(u, v) {
    return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
  }
  function vAngle(u, v) {
    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
  }
  function getArcParams(startPoint, params) {
    var rx = params[1];
    var ry = params[2];
    var xRotation = (0, import_util2.mod)(deg2rad(params[3]), Math.PI * 2);
    var arcFlag = params[4];
    var sweepFlag = params[5];
    var x1 = startPoint[0];
    var y1 = startPoint[1];
    var x22 = params[6];
    var y22 = params[7];
    var xp = Math.cos(xRotation) * (x1 - x22) / 2 + Math.sin(xRotation) * (y1 - y22) / 2;
    var yp = -1 * Math.sin(xRotation) * (x1 - x22) / 2 + Math.cos(xRotation) * (y1 - y22) / 2;
    var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }
    var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
    var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
    if (arcFlag === sweepFlag) {
      f *= -1;
    }
    if (isNaN(f)) {
      f = 0;
    }
    var cxp = ry ? f * rx * yp / ry : 0;
    var cyp = rx ? f * -ry * xp / rx : 0;
    var cx = (x1 + x22) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
    var cy = (y1 + y22) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
    var u = [(xp - cxp) / rx, (yp - cyp) / ry];
    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
    var theta = vAngle([1, 0], u);
    var dTheta = vAngle(u, v);
    if (vRatio(u, v) <= -1) {
      dTheta = Math.PI;
    }
    if (vRatio(u, v) >= 1) {
      dTheta = 0;
    }
    if (sweepFlag === 0 && dTheta > 0) {
      dTheta -= 2 * Math.PI;
    }
    if (sweepFlag === 1 && dTheta < 0) {
      dTheta += 2 * Math.PI;
    }
    return {
      cx,
      cy,
      // 弧形的起点和终点相同时，长轴和短轴的长度按 0 处理
      rx: isSamePoint(startPoint, [x22, y22]) ? 0 : rx,
      ry: isSamePoint(startPoint, [x22, y22]) ? 0 : ry,
      startAngle: theta,
      endAngle: theta + dTheta,
      xRotation,
      arcFlag,
      sweepFlag
    };
  }
  var internalParsePath = function internalParsePath2(path) {
    if (path === "" || Array.isArray(path) && path.length === 0) {
      return {
        absolutePath: [],
        hasArc: false,
        segments: [],
        polygons: [],
        polylines: [],
        curve: null,
        totalLength: 0,
        rect: {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        }
      };
    }
    var absolutePath;
    try {
      absolutePath = (0, import_util2.normalizePath)(path);
    } catch (_unused) {
      absolutePath = (0, import_util2.normalizePath)("");
      console.error("[g]: Invalid SVG Path definition: ".concat(path));
    }
    removeRedundantMCommand(absolutePath);
    var hasArc = hasArcOrBezier(absolutePath);
    var _extractPolygons = extractPolygons(absolutePath), polygons = _extractPolygons.polygons, polylines = _extractPolygons.polylines;
    var segments = path2Segments(absolutePath);
    var _getPathBBox = getPathBBox(segments, 0), x3 = _getPathBBox.x, y3 = _getPathBBox.y, width2 = _getPathBBox.width, height = _getPathBBox.height;
    return {
      absolutePath,
      hasArc,
      segments,
      polygons,
      polylines,
      // curve,
      // Delay the calculation of length.
      totalLength: 0,
      rect: {
        x: Number.isFinite(x3) ? x3 : 0,
        y: Number.isFinite(y3) ? y3 : 0,
        width: Number.isFinite(width2) ? width2 : 0,
        height: Number.isFinite(height) ? height : 0
      }
    };
  };
  var memoizedParsePath = memoize(internalParsePath);
  function parsePath(path) {
    return (0, import_util2.isString)(path) ? memoizedParsePath(path) : internalParsePath(path);
  }
  function mergePaths(left, right, object) {
    var curve1 = left.curve;
    var curve2 = right.curve;
    if (!curve1 || curve1.length === 0) {
      curve1 = (0, import_util2.path2Curve)(left.absolutePath, false);
      left.curve = curve1;
    }
    if (!curve2 || curve2.length === 0) {
      curve2 = (0, import_util2.path2Curve)(right.absolutePath, false);
      right.curve = curve2;
    }
    var curves = [curve1, curve2];
    if (curve1.length !== curve2.length) {
      curves = (0, import_util2.equalizeSegments)(curve1, curve2);
    }
    var curve0 = (0, import_util2.getDrawDirection)(curves[0]) !== (0, import_util2.getDrawDirection)(curves[1]) ? (0, import_util2.reverseCurve)(curves[0]) : (0, import_util2.clonePath)(curves[0]);
    return [curve0, (0, import_util2.getRotatedCurve)(curves[1], curve0), function(pathArray) {
      return pathArray;
    }];
  }
  function parsePoints(pointsOrStr, object) {
    var points;
    if ((0, import_util2.isString)(pointsOrStr)) {
      points = pointsOrStr.split(" ").map(function(pointStr) {
        var _pointStr$split = pointStr.split(","), _pointStr$split2 = _slicedToArray(_pointStr$split, 2), x3 = _pointStr$split2[0], y3 = _pointStr$split2[1];
        return [Number(x3), Number(y3)];
      });
    } else {
      points = pointsOrStr;
    }
    return {
      points,
      totalLength: 0,
      segments: []
    };
  }
  function mergePoints(left, right) {
    return [left.points, right.points, function(points) {
      return points;
    }];
  }
  var _ = null;
  var TRANSFORM_REGEXP = /\s*(\w+)\(([^)]*)\)/g;
  function cast(pattern) {
    return function(contents) {
      var i = 0;
      return pattern.map(function(x3) {
        return x3 === _ ? contents[i++] : x3;
      });
    };
  }
  function id(x3) {
    return x3;
  }
  var transformFunctions = {
    // @ts-ignore
    matrix: ["NNNNNN", [_, _, 0, 0, _, _, 0, 0, 0, 0, 1, 0, _, _, 0, 1], id],
    matrix3d: ["NNNNNNNNNNNNNNNN", id],
    rotate: ["A"],
    rotateX: ["A"],
    rotateY: ["A"],
    rotateZ: ["A"],
    rotate3d: ["NNNA"],
    perspective: ["L"],
    scale: ["Nn", cast([_, _, new CSSUnitValue(1)]), id],
    scaleX: ["N", cast([_, new CSSUnitValue(1), new CSSUnitValue(1)]), cast([_, new CSSUnitValue(1)])],
    scaleY: ["N", cast([new CSSUnitValue(1), _, new CSSUnitValue(1)]), cast([new CSSUnitValue(1), _])],
    scaleZ: ["N", cast([new CSSUnitValue(1), new CSSUnitValue(1), _])],
    scale3d: ["NNN", id],
    skew: ["Aa", null, id],
    skewX: ["A", null, cast([_, Odeg])],
    skewY: ["A", null, cast([Odeg, _])],
    translate: ["Tt", cast([_, _, Opx]), id],
    translateX: ["T", cast([_, Opx, Opx]), cast([_, Opx])],
    translateY: ["T", cast([Opx, _, Opx]), cast([Opx, _])],
    translateZ: ["L", cast([Opx, Opx, _])],
    translate3d: ["TTL", id]
  };
  function parseArrayTransform(transform) {
    var result = [];
    var length = transform.length;
    for (var i = 0; i < length; i++) {
      var item = transform[i];
      var name = item[0];
      var args = item.slice(1);
      if (name === "translate" || name === "skew") {
        if (args.length === 1) args.push(0);
      } else if (name === "scale") {
        if (args.length === 1) args.push(args[0]);
      }
      var functionData = transformFunctions[name];
      if (!functionData) return [];
      var parsedArgs = args.map(function(value) {
        return getOrCreateUnitValue(value);
      });
      result.push({
        t: name,
        d: parsedArgs
      });
    }
    return result;
  }
  function parseTransform(transform) {
    if (Array.isArray(transform)) {
      return parseArrayTransform(transform);
    }
    transform = (transform || "none").trim();
    if (transform === "none") {
      return [];
    }
    var result = [];
    var match2;
    var prevLastIndex = 0;
    TRANSFORM_REGEXP.lastIndex = 0;
    while (match2 = TRANSFORM_REGEXP.exec(transform)) {
      if (match2.index !== prevLastIndex) {
        return [];
      }
      prevLastIndex = match2.index + match2[0].length;
      var functionName = match2[1];
      var functionData = transformFunctions[functionName];
      if (!functionData) {
        return [];
      }
      var args = match2[2].split(",");
      var argTypes = functionData[0];
      if (argTypes.length < args.length) {
        return [];
      }
      var parsedArgs = [];
      for (var i = 0; i < argTypes.length; i++) {
        var arg = args[i];
        var type = argTypes[i];
        var parsedArg = void 0;
        if (!arg) {
          parsedArg = {
            a: Odeg,
            n: parsedArgs[0],
            t: Opx
          }[type];
        } else {
          parsedArg = {
            A: function A3(s) {
              return s.trim() === "0" ? Odeg : parseAngle(s);
            },
            N: parseNumber,
            T: parseLengthOrPercentage,
            L: parseLength
          }[type.toUpperCase()](arg);
        }
        if (parsedArg === void 0) {
          return [];
        }
        parsedArgs.push(parsedArg);
      }
      result.push({
        t: functionName,
        d: parsedArgs
      });
      if (TRANSFORM_REGEXP.lastIndex === transform.length) {
        return result;
      }
    }
    return [];
  }
  function parseTransformUnmemoize(transform) {
    if (Array.isArray(transform)) {
      return parseArrayTransform(transform);
    }
    transform = (transform || "none").trim();
    if (transform === "none") {
      return [];
    }
    var result = [];
    var match2;
    var prevLastIndex = 0;
    TRANSFORM_REGEXP.lastIndex = 0;
    while (match2 = TRANSFORM_REGEXP.exec(transform)) {
      if (match2.index !== prevLastIndex) {
        return [];
      }
      prevLastIndex = match2.index + match2[0].length;
      var functionName = match2[1];
      var functionData = transformFunctions[functionName];
      if (!functionData) {
        return [];
      }
      var args = match2[2].split(",");
      var argTypes = functionData[0];
      if (argTypes.length < args.length) {
        return [];
      }
      var parsedArgs = [];
      for (var i = 0; i < argTypes.length; i++) {
        var arg = args[i];
        var type = argTypes[i];
        var parsedArg = void 0;
        if (!arg) {
          parsedArg = {
            a: Odeg,
            n: parsedArgs[0],
            t: Opx
          }[type];
        } else {
          parsedArg = {
            A: function A3(s) {
              return s.trim() === "0" ? Odeg : parseAngleUnmemoize(s);
            },
            N: parseNumberUnmemoize,
            T: parseLengthOrPercentageUnmemoize,
            L: parseLengthUnmemoize
          }[type.toUpperCase()](arg);
        }
        if (parsedArg === void 0) {
          return [];
        }
        parsedArgs.push(parsedArg);
      }
      result.push({
        t: functionName,
        d: parsedArgs
      });
      if (TRANSFORM_REGEXP.lastIndex === transform.length) {
        return result;
      }
    }
    return [];
  }
  function convertItemToMatrix(item) {
    var x3;
    var y3;
    var z;
    var angle2;
    switch (item.t) {
      case "rotateX":
        angle2 = deg2rad(convertAngleUnit(item.d[0]));
        return [1, 0, 0, 0, 0, Math.cos(angle2), Math.sin(angle2), 0, 0, -Math.sin(angle2), Math.cos(angle2), 0, 0, 0, 0, 1];
      case "rotateY":
        angle2 = deg2rad(convertAngleUnit(item.d[0]));
        return [Math.cos(angle2), 0, -Math.sin(angle2), 0, 0, 1, 0, 0, Math.sin(angle2), 0, Math.cos(angle2), 0, 0, 0, 0, 1];
      case "rotate":
      case "rotateZ":
        angle2 = deg2rad(convertAngleUnit(item.d[0]));
        return [Math.cos(angle2), Math.sin(angle2), 0, 0, -Math.sin(angle2), Math.cos(angle2), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case "rotate3d":
        x3 = item.d[0].value;
        y3 = item.d[1].value;
        z = item.d[2].value;
        angle2 = deg2rad(convertAngleUnit(item.d[3]));
        var sqrLength = x3 * x3 + y3 * y3 + z * z;
        if (sqrLength === 0) {
          x3 = 1;
          y3 = 0;
          z = 0;
        } else if (sqrLength !== 1) {
          var length = Math.sqrt(sqrLength);
          x3 /= length;
          y3 /= length;
          z /= length;
        }
        var s = Math.sin(angle2 / 2);
        var sc = s * Math.cos(angle2 / 2);
        var sq = s * s;
        return [1 - 2 * (y3 * y3 + z * z) * sq, 2 * (x3 * y3 * sq + z * sc), 2 * (x3 * z * sq - y3 * sc), 0, 2 * (x3 * y3 * sq - z * sc), 1 - 2 * (x3 * x3 + z * z) * sq, 2 * (y3 * z * sq + x3 * sc), 0, 2 * (x3 * z * sq + y3 * sc), 2 * (y3 * z * sq - x3 * sc), 1 - 2 * (x3 * x3 + y3 * y3) * sq, 0, 0, 0, 0, 1];
      case "scale":
        return [item.d[0].value, 0, 0, 0, 0, item.d[1].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case "scaleX":
        return [item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case "scaleY":
        return [1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case "scaleZ":
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1];
      case "scale3d":
        return [item.d[0].value, 0, 0, 0, 0, item.d[1].value, 0, 0, 0, 0, item.d[2].value, 0, 0, 0, 0, 1];
      case "skew":
        var xAngle = deg2rad(convertAngleUnit(item.d[0]));
        var yAngle = deg2rad(convertAngleUnit(item.d[1]));
        return [1, Math.tan(yAngle), 0, 0, Math.tan(xAngle), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case "skewX":
        angle2 = deg2rad(convertAngleUnit(item.d[0]));
        return [1, 0, 0, 0, Math.tan(angle2), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case "skewY":
        angle2 = deg2rad(convertAngleUnit(item.d[0]));
        return [1, Math.tan(angle2), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case "translate":
        x3 = convertPercentUnit(item.d[0], 0, null) || 0;
        y3 = convertPercentUnit(item.d[1], 0, null) || 0;
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x3, y3, 0, 1];
      case "translateX":
        x3 = convertPercentUnit(item.d[0], 0, null) || 0;
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x3, 0, 0, 1];
      case "translateY":
        y3 = convertPercentUnit(item.d[0], 0, null) || 0;
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, y3, 0, 1];
      case "translateZ":
        z = convertPercentUnit(item.d[0], 0, null) || 0;
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, z, 1];
      case "translate3d":
        x3 = convertPercentUnit(item.d[0], 0, null) || 0;
        y3 = convertPercentUnit(item.d[1], 0, null) || 0;
        z = convertPercentUnit(item.d[2], 0, null) || 0;
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x3, y3, z, 1];
      case "perspective":
        var t = convertPercentUnit(item.d[0], 0, null) || 0;
        var p = t ? -1 / t : 0;
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, p, 0, 0, 0, 1];
      case "matrix":
        return [item.d[0].value, item.d[1].value, 0, 0, item.d[2].value, item.d[3].value, 0, 0, 0, 0, 1, 0, item.d[4].value, item.d[5].value, 0, 1];
      case "matrix3d":
        return item.d.map(function(d2) {
          return d2.value;
        });
    }
  }
  function multiplyMatrices(a2, b) {
    return [a2[0] * b[0] + a2[4] * b[1] + a2[8] * b[2] + a2[12] * b[3], a2[1] * b[0] + a2[5] * b[1] + a2[9] * b[2] + a2[13] * b[3], a2[2] * b[0] + a2[6] * b[1] + a2[10] * b[2] + a2[14] * b[3], a2[3] * b[0] + a2[7] * b[1] + a2[11] * b[2] + a2[15] * b[3], a2[0] * b[4] + a2[4] * b[5] + a2[8] * b[6] + a2[12] * b[7], a2[1] * b[4] + a2[5] * b[5] + a2[9] * b[6] + a2[13] * b[7], a2[2] * b[4] + a2[6] * b[5] + a2[10] * b[6] + a2[14] * b[7], a2[3] * b[4] + a2[7] * b[5] + a2[11] * b[6] + a2[15] * b[7], a2[0] * b[8] + a2[4] * b[9] + a2[8] * b[10] + a2[12] * b[11], a2[1] * b[8] + a2[5] * b[9] + a2[9] * b[10] + a2[13] * b[11], a2[2] * b[8] + a2[6] * b[9] + a2[10] * b[10] + a2[14] * b[11], a2[3] * b[8] + a2[7] * b[9] + a2[11] * b[10] + a2[15] * b[11], a2[0] * b[12] + a2[4] * b[13] + a2[8] * b[14] + a2[12] * b[15], a2[1] * b[12] + a2[5] * b[13] + a2[9] * b[14] + a2[13] * b[15], a2[2] * b[12] + a2[6] * b[13] + a2[10] * b[14] + a2[14] * b[15], a2[3] * b[12] + a2[7] * b[13] + a2[11] * b[14] + a2[15] * b[15]];
  }
  function convertToMatrix(transformList) {
    if (transformList.length === 0) {
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    }
    return transformList.map(convertItemToMatrix).reduce(multiplyMatrices);
  }
  function makeMatrixDecomposition(transformList) {
    var translate3 = [0, 0, 0];
    var scale4 = [1, 1, 1];
    var skew2 = [0, 0, 0];
    var perspective = [0, 0, 0, 1];
    var quaternion = [0, 0, 0, 1];
    decomposeMat4(
      // @ts-ignore
      convertToMatrix(transformList),
      translate3,
      scale4,
      skew2,
      perspective,
      quaternion
    );
    return [[translate3, scale4, skew2, quaternion, perspective]];
  }
  var composeMatrix = /* @__PURE__ */ (function() {
    function multiply2(a2, b) {
      var result = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];
      for (var i = 0; i < 4; i++) {
        for (var j = 0; j < 4; j++) {
          for (var k = 0; k < 4; k++) {
            result[i][j] += b[i][k] * a2[k][j];
          }
        }
      }
      return result;
    }
    function is2D(m2) {
      return m2[0][2] === 0 && m2[0][3] === 0 && m2[1][2] === 0 && m2[1][3] === 0 && m2[2][0] === 0 && m2[2][1] === 0 && m2[2][2] === 1 && m2[2][3] === 0 && m2[3][2] === 0 && m2[3][3] === 1;
    }
    function composeMatrix2(translate3, scale4, skew2, quat3, perspective) {
      var matrix3 = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
      for (var i = 0; i < 4; i++) {
        matrix3[i][3] = perspective[i];
      }
      for (var _i = 0; _i < 3; _i++) {
        for (var j = 0; j < 3; j++) {
          matrix3[3][_i] += translate3[j] * matrix3[j][_i];
        }
      }
      var x3 = quat3[0];
      var y3 = quat3[1];
      var z = quat3[2];
      var w = quat3[3];
      var rotMatrix = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
      rotMatrix[0][0] = 1 - 2 * (y3 * y3 + z * z);
      rotMatrix[0][1] = 2 * (x3 * y3 - z * w);
      rotMatrix[0][2] = 2 * (x3 * z + y3 * w);
      rotMatrix[1][0] = 2 * (x3 * y3 + z * w);
      rotMatrix[1][1] = 1 - 2 * (x3 * x3 + z * z);
      rotMatrix[1][2] = 2 * (y3 * z - x3 * w);
      rotMatrix[2][0] = 2 * (x3 * z - y3 * w);
      rotMatrix[2][1] = 2 * (y3 * z + x3 * w);
      rotMatrix[2][2] = 1 - 2 * (x3 * x3 + y3 * y3);
      matrix3 = multiply2(matrix3, rotMatrix);
      var temp = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
      if (skew2[2]) {
        temp[2][1] = skew2[2];
        matrix3 = multiply2(matrix3, temp);
      }
      if (skew2[1]) {
        temp[2][1] = 0;
        temp[2][0] = skew2[0];
        matrix3 = multiply2(matrix3, temp);
      }
      if (skew2[0]) {
        temp[2][0] = 0;
        temp[1][0] = skew2[0];
        matrix3 = multiply2(matrix3, temp);
      }
      for (var _i2 = 0; _i2 < 3; _i2++) {
        for (var _j = 0; _j < 3; _j++) {
          matrix3[_i2][_j] *= scale4[_i2];
        }
      }
      if (is2D(matrix3)) {
        return [matrix3[0][0], matrix3[0][1], matrix3[1][0], matrix3[1][1], matrix3[3][0], matrix3[3][1]];
      }
      return matrix3[0].concat(matrix3[1], matrix3[2], matrix3[3]);
    }
    return composeMatrix2;
  })();
  function numberToLongString(x3) {
    return x3.toFixed(6).replace(".000000", "");
  }
  function mergeMatrices(left, right) {
    var leftArgs;
    var rightArgs;
    if (left.decompositionPair !== right) {
      left.decompositionPair = right;
      leftArgs = makeMatrixDecomposition(left);
    }
    if (right.decompositionPair !== left) {
      right.decompositionPair = left;
      rightArgs = makeMatrixDecomposition(right);
    }
    if (leftArgs[0] === null || rightArgs[0] === null) return [
      // @ts-ignore
      [false],
      // @ts-ignore
      [true],
      // @ts-ignore
      function(x3) {
        return x3 ? right[0].d : left[0].d;
      }
    ];
    leftArgs[0].push(0);
    rightArgs[0].push(1);
    return [
      leftArgs,
      rightArgs,
      // @ts-ignore
      function(list) {
        var q = quat(leftArgs[0][3], rightArgs[0][3], list[5]);
        var mat = composeMatrix(list[0], list[1], list[2], q, list[4]);
        var stringifiedArgs = mat.map(numberToLongString).join(",");
        return stringifiedArgs;
      }
    ];
  }
  function dot(v1, v2) {
    var result = 0;
    for (var i = 0; i < v1.length; i++) {
      result += v1[i] * v2[i];
    }
    return result;
  }
  function quat(fromQ, toQ, f) {
    var product = dot(fromQ, toQ);
    product = (0, import_util2.clamp)(product, -1, 1);
    var quat3 = [];
    if (product === 1) {
      quat3 = fromQ;
    } else {
      var theta = Math.acos(product);
      var w = Math.sin(f * theta) * 1 / Math.sqrt(1 - product * product);
      for (var i = 0; i < 4; i++) {
        quat3.push(fromQ[i] * (Math.cos(f * theta) - product * w) + toQ[i] * w);
      }
    }
    return quat3;
  }
  function typeTo2D(type) {
    return type.replace(/[XY]/, "");
  }
  function typeTo3D(type) {
    return type.replace(/(X|Y|Z|3d)?$/, "3d");
  }
  var isMatrixOrPerspective = function isMatrixOrPerspective2(lt, rt) {
    return lt === "perspective" && rt === "perspective" || (lt === "matrix" || lt === "matrix3d") && (rt === "matrix" || rt === "matrix3d");
  };
  function mergeTransforms(left, right, target) {
    var flipResults = false;
    if (!left.length || !right.length) {
      if (!left.length) {
        flipResults = true;
        left = right;
        right = [];
      }
      var _loop = function _loop2() {
        var _left$i = left[i], type2 = _left$i.t, args = _left$i.d;
        var defaultValue = type2.substring(0, 5) === "scale" ? 1 : 0;
        right.push({
          t: type2,
          d: args.map(function(arg) {
            if (typeof arg === "number") {
              return getOrCreateUnitValue(defaultValue);
            }
            return getOrCreateUnitValue(defaultValue, arg.unit);
          })
        });
      };
      for (var i = 0; i < left.length; i++) {
        _loop();
      }
    }
    var leftResult = [];
    var rightResult = [];
    var types = [];
    if (left.length !== right.length) {
      var merged = mergeMatrices(left, right);
      leftResult = [merged[0]];
      rightResult = [merged[1]];
      types = [["matrix", [merged[2]]]];
    } else {
      for (var _i3 = 0; _i3 < left.length; _i3++) {
        var leftType = left[_i3].t;
        var rightType = right[_i3].t;
        var leftArgs = left[_i3].d;
        var rightArgs = right[_i3].d;
        var leftFunctionData = transformFunctions[leftType];
        var rightFunctionData = transformFunctions[rightType];
        var type = void 0;
        if (isMatrixOrPerspective(leftType, rightType)) {
          var _merged = mergeMatrices([left[_i3]], [right[_i3]]);
          leftResult.push(_merged[0]);
          rightResult.push(_merged[1]);
          types.push(["matrix", [_merged[2]]]);
          continue;
        } else if (leftType === rightType) {
          type = leftType;
        } else if (leftFunctionData[2] && rightFunctionData[2] && typeTo2D(leftType) === typeTo2D(rightType)) {
          type = typeTo2D(leftType);
          leftArgs = leftFunctionData[2](leftArgs);
          rightArgs = rightFunctionData[2](rightArgs);
        } else if (leftFunctionData[1] && rightFunctionData[1] && typeTo3D(leftType) === typeTo3D(rightType)) {
          type = typeTo3D(leftType);
          leftArgs = leftFunctionData[1](leftArgs);
          rightArgs = rightFunctionData[1](rightArgs);
        } else {
          var _merged2 = mergeMatrices(left, right);
          leftResult = [_merged2[0]];
          rightResult = [_merged2[1]];
          types = [["matrix", [_merged2[2]]]];
          break;
        }
        var leftArgsCopy = [];
        var rightArgsCopy = [];
        var stringConversions = [];
        for (var j = 0; j < leftArgs.length; j++) {
          var _merged3 = mergeDimensions(leftArgs[j], rightArgs[j], target, false, j);
          leftArgsCopy[j] = _merged3[0];
          rightArgsCopy[j] = _merged3[1];
          stringConversions.push(_merged3[2]);
        }
        leftResult.push(leftArgsCopy);
        rightResult.push(rightArgsCopy);
        types.push([type, stringConversions]);
      }
    }
    if (flipResults) {
      var tmp2 = leftResult;
      leftResult = rightResult;
      rightResult = tmp2;
    }
    return [leftResult, rightResult, function(list) {
      return list.map(function(args, i2) {
        var stringifiedArgs = args.map(function(arg, j2) {
          return types[i2][1][j2](arg);
        }).join(",");
        if (types[i2][0] === "matrix" && stringifiedArgs.split(",").length === 16) {
          types[i2][0] = "matrix3d";
        }
        if (types[i2][0] === "matrix3d" && stringifiedArgs.split(",").length === 6) {
          types[i2][0] = "matrix";
        }
        return "".concat(types[i2][0], "(").concat(stringifiedArgs, ")");
      }).join(" ");
    }];
  }
  var parseTransformOrigin = memoize(function(value) {
    if ((0, import_util2.isString)(value)) {
      if (value === "text-anchor") {
        return [getOrCreateUnitValue(0, "px"), getOrCreateUnitValue(0, "px")];
      }
      var values2 = value.split(" ");
      if (values2.length === 1) {
        if (values2[0] === "top" || values2[0] === "bottom") {
          values2[1] = values2[0];
          values2[0] = "center";
        } else {
          values2[1] = "center";
        }
      }
      if (values2.length !== 2) {
        return null;
      }
      return [parseLengthOrPercentage(convertKeyword2Percent(values2[0])), parseLengthOrPercentage(convertKeyword2Percent(values2[1]))];
    }
    return [getOrCreateUnitValue(value[0] || 0, "px"), getOrCreateUnitValue(value[1] || 0, "px")];
  });
  function convertKeyword2Percent(keyword) {
    if (keyword === "center") {
      return "50%";
    }
    if (keyword === "left" || keyword === "top") {
      return "0%";
    }
    if (keyword === "right" || keyword === "bottom") {
      return "100%";
    }
    return keyword;
  }
  var BUILT_IN_PROPERTIES = [
    {
      /**
       * used in CSS Layout API
       * eg. `display: 'flex'`
       */
      n: "display",
      k: ["none"]
    },
    {
      /**
       * range [0.0, 1.0]
       * @see https://developer.mozilla.org/en-US/docs/Web/CSS/opacity
       */
      n: "opacity",
      "int": true,
      inh: true,
      d: "1",
      syntax: PropertySyntax.OPACITY_VALUE
    },
    {
      /**
       * inheritable, range [0.0, 1.0]
       * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-opacity
       * @see https://svgwg.org/svg2-draft/painting.html#FillOpacity
       */
      n: "fillOpacity",
      "int": true,
      inh: true,
      d: "1",
      syntax: PropertySyntax.OPACITY_VALUE
    },
    {
      /**
       * inheritable, range [0.0, 1.0]
       * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-opacity
       * @see https://svgwg.org/svg2-draft/painting.html#StrokeOpacity
       */
      n: "strokeOpacity",
      "int": true,
      inh: true,
      d: "1",
      syntax: PropertySyntax.OPACITY_VALUE
    },
    {
      /**
       * background-color is not inheritable
       * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes
       */
      n: "fill",
      "int": true,
      k: ["none"],
      d: "none",
      syntax: PropertySyntax.PAINT
    },
    {
      n: "fillRule",
      k: ["nonzero", "evenodd"],
      d: "nonzero"
    },
    /**
     * default to none
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke#usage_notes
     */
    {
      n: "stroke",
      "int": true,
      k: ["none"],
      d: "none",
      syntax: PropertySyntax.PAINT,
      /**
       * Stroke 'none' won't affect geometry but others will.
       */
      l: true
    },
    {
      n: "shadowType",
      k: ["inner", "outer", "both"],
      d: "outer",
      l: true
    },
    {
      n: "shadowColor",
      "int": true,
      syntax: PropertySyntax.COLOR
    },
    {
      n: "shadowOffsetX",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "shadowOffsetY",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "shadowBlur",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.SHADOW_BLUR
    },
    {
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-width
       */
      n: "lineWidth",
      "int": true,
      inh: true,
      d: "1",
      l: true,
      a: ["strokeWidth"],
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "increasedLineWidthForHitTesting",
      inh: true,
      d: "0",
      l: true,
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "lineJoin",
      inh: true,
      l: true,
      a: ["strokeLinejoin"],
      k: ["miter", "bevel", "round"],
      d: "miter"
    },
    {
      n: "lineCap",
      inh: true,
      l: true,
      a: ["strokeLinecap"],
      k: ["butt", "round", "square"],
      d: "butt"
    },
    {
      n: "lineDash",
      "int": true,
      inh: true,
      k: ["none"],
      a: ["strokeDasharray"],
      syntax: PropertySyntax.LENGTH_PERCENTAGE_12
    },
    {
      n: "lineDashOffset",
      "int": true,
      inh: true,
      d: "0",
      a: ["strokeDashoffset"],
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "offsetPath",
      syntax: PropertySyntax.DEFINED_PATH
    },
    {
      n: "offsetDistance",
      "int": true,
      syntax: PropertySyntax.OFFSET_DISTANCE
    },
    {
      n: "dx",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "dy",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "zIndex",
      ind: true,
      "int": true,
      d: "0",
      k: ["auto"],
      syntax: PropertySyntax.Z_INDEX
    },
    {
      n: "visibility",
      k: ["visible", "hidden"],
      ind: true,
      inh: true,
      /**
       * support interpolation
       * @see https://developer.mozilla.org/en-US/docs/Web/CSS/visibility#interpolation
       */
      "int": true,
      d: "visible"
    },
    {
      n: "pointerEvents",
      inh: true,
      k: [
        "none",
        "auto",
        "stroke",
        "fill",
        "painted",
        "visible",
        "visiblestroke",
        "visiblefill",
        "visiblepainted",
        // 'bounding-box',
        "all"
      ],
      d: "auto"
    },
    {
      n: "filter",
      ind: true,
      l: true,
      k: ["none"],
      d: "none",
      syntax: PropertySyntax.FILTER
    },
    {
      n: "clipPath",
      syntax: PropertySyntax.DEFINED_PATH
    },
    {
      n: "textPath",
      syntax: PropertySyntax.DEFINED_PATH
    },
    {
      n: "textPathSide",
      k: ["left", "right"],
      d: "left"
    },
    {
      n: "textPathStartOffset",
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "transform",
      p: 100,
      "int": true,
      k: ["none"],
      d: "none",
      syntax: PropertySyntax.TRANSFORM
    },
    {
      n: "transformOrigin",
      p: 100,
      d: "0 0",
      // // int: true,
      // d: (nodeName: string) => {
      //   if (nodeName === Shape.CIRCLE || nodeName === Shape.ELLIPSE) {
      //     return 'center';
      //   }
      //   if (nodeName === Shape.TEXT) {
      //     return 'text-anchor';
      //   }
      //   return 'left top';
      // },
      l: true,
      syntax: PropertySyntax.TRANSFORM_ORIGIN
    },
    {
      n: "cx",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "cy",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "cz",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "r",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "rx",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "ry",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    // Rect Image Group
    {
      // x in local space
      n: "x",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.COORDINATE
    },
    {
      // y in local space
      n: "y",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.COORDINATE
    },
    {
      // z in local space
      n: "z",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "width",
      "int": true,
      l: true,
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/width
       */
      k: ["auto", "fit-content", "min-content", "max-content"],
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "height",
      "int": true,
      l: true,
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/height
       */
      k: ["auto", "fit-content", "min-content", "max-content"],
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "radius",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE_14
    },
    // Line
    {
      n: "x1",
      "int": true,
      l: true,
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "y1",
      "int": true,
      l: true,
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "z1",
      "int": true,
      l: true,
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "x2",
      "int": true,
      l: true,
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "y2",
      "int": true,
      l: true,
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "z2",
      "int": true,
      l: true,
      syntax: PropertySyntax.COORDINATE
    },
    // Path
    {
      n: "d",
      "int": true,
      l: true,
      d: "",
      syntax: PropertySyntax.PATH,
      p: 50
    },
    // Polyline & Polygon
    {
      n: "points",
      /**
       * support interpolation
       */
      "int": true,
      l: true,
      syntax: PropertySyntax.LIST_OF_POINTS,
      p: 50
    },
    // Text
    {
      n: "text",
      l: true,
      d: "",
      syntax: PropertySyntax.TEXT,
      p: 50
    },
    {
      n: "textTransform",
      l: true,
      inh: true,
      k: ["capitalize", "uppercase", "lowercase", "none"],
      d: "none",
      syntax: PropertySyntax.TEXT_TRANSFORM,
      p: 51
      // it must get parsed after text
    },
    {
      n: "font",
      l: true
    },
    {
      n: "fontSize",
      "int": true,
      inh: true,
      /**
       * @see https://www.w3schools.com/css/css_font_size.asp
       */
      d: "16px",
      l: true,
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "fontFamily",
      l: true,
      inh: true,
      d: "sans-serif"
    },
    {
      n: "fontStyle",
      l: true,
      inh: true,
      k: ["normal", "italic", "oblique"],
      d: "normal"
    },
    {
      n: "fontWeight",
      l: true,
      inh: true,
      k: ["normal", "bold", "bolder", "lighter"],
      d: "normal"
    },
    {
      n: "fontVariant",
      l: true,
      inh: true,
      k: ["normal", "small-caps"],
      d: "normal"
    },
    {
      n: "lineHeight",
      l: true,
      syntax: PropertySyntax.LENGTH,
      "int": true,
      d: "0"
    },
    {
      n: "letterSpacing",
      l: true,
      syntax: PropertySyntax.LENGTH,
      "int": true,
      d: "0"
    },
    {
      n: "miterLimit",
      l: true,
      syntax: PropertySyntax.NUMBER,
      d: function d(nodeName) {
        if (nodeName === Shape.PATH || nodeName === Shape.POLYGON || nodeName === Shape.POLYLINE) {
          return "4";
        }
        return "10";
      }
    },
    {
      n: "wordWrap",
      l: true
    },
    {
      n: "wordWrapWidth",
      l: true
    },
    {
      n: "maxLines",
      l: true
    },
    {
      n: "textOverflow",
      l: true,
      d: "clip"
    },
    {
      n: "leading",
      l: true
    },
    {
      n: "textBaseline",
      l: true,
      inh: true,
      k: ["top", "hanging", "middle", "alphabetic", "ideographic", "bottom"],
      d: "alphabetic"
    },
    {
      n: "textAlign",
      l: true,
      inh: true,
      k: ["start", "center", "middle", "end", "left", "right"],
      d: "start"
    },
    // {
    //   n: 'whiteSpace',
    //   l: true,
    // },
    {
      n: "markerStart",
      syntax: PropertySyntax.MARKER
    },
    {
      n: "markerEnd",
      syntax: PropertySyntax.MARKER
    },
    {
      n: "markerMid",
      syntax: PropertySyntax.MARKER
    },
    {
      n: "markerStartOffset",
      syntax: PropertySyntax.LENGTH,
      l: true,
      "int": true,
      d: "0"
    },
    {
      n: "markerEndOffset",
      syntax: PropertySyntax.LENGTH,
      l: true,
      "int": true,
      d: "0"
    }
  ];
  var GEOMETRY_ATTRIBUTE_NAMES = new Set(BUILT_IN_PROPERTIES.filter(function(n) {
    return !!n.l;
  }).map(function(n) {
    return n.n;
  }));
  var propertyMetadataCache = {};
  var DefaultStyleValueRegistry = /* @__PURE__ */ (function() {
    function DefaultStyleValueRegistry2(runtime2) {
      var _this2 = this;
      _classCallCheck(this, DefaultStyleValueRegistry2);
      this.runtime = runtime2;
      BUILT_IN_PROPERTIES.forEach(function(property) {
        _this2.registerMetadata(property);
      });
    }
    return _createClass(DefaultStyleValueRegistry2, [{
      key: "registerMetadata",
      value: function registerMetadata(metadata) {
        [metadata.n].concat(_toConsumableArray(metadata.a || [])).forEach(function(name) {
          propertyMetadataCache[name] = metadata;
        });
      }
    }, {
      key: "getPropertySyntax",
      value: function getPropertySyntax(syntax) {
        return this.runtime.CSSPropertySyntaxFactory[syntax];
      }
      /**
       * * parse value, eg.
       * fill: 'red' => CSSRGB
       * translateX: '10px' => CSSUnitValue { unit: 'px', value: 10 }
       * fontSize: '2em' => { unit: 'px', value: 32 }
       *
       * * calculate used value
       * * post process
       */
    }, {
      key: "processProperties",
      value: function processProperties(object, attributes) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
          skipUpdateAttribute: false,
          skipParse: false,
          forceUpdateGeometry: false,
          usedAttributes: [],
          memoize: true
        };
        Object.assign(object.attributes, attributes);
        var oldClipPath = object.parsedStyle.clipPath;
        var oldOffsetPath = object.parsedStyle.offsetPath;
        assignParsedStyle(object, attributes);
        var needUpdateGeometry = !!options.forceUpdateGeometry;
        if (!needUpdateGeometry) {
          for (var i in attributes) {
            if (GEOMETRY_ATTRIBUTE_NAMES.has(i)) {
              needUpdateGeometry = true;
              break;
            }
          }
        }
        var list = getParsedStyleListOf(object);
        if (list.has("fill") && attributes.fill) {
          object.parsedStyle.fill = parseColor(attributes.fill);
        }
        if (list.has("stroke") && attributes.stroke) {
          object.parsedStyle.stroke = parseColor(attributes.stroke);
        }
        if (list.has("shadowColor") && attributes.shadowColor) {
          object.parsedStyle.shadowColor = parseColor(attributes.shadowColor);
        }
        if (list.has("filter") && attributes.filter) {
          object.parsedStyle.filter = parseFilter(attributes.filter);
        }
        if (list.has("radius") && !(0, import_util2.isNil)(attributes.radius)) {
          object.parsedStyle.radius = parseDimensionArrayFormat(
            // @ts-ignore
            attributes.radius,
            4
          );
        }
        if (list.has("lineDash") && !(0, import_util2.isNil)(attributes.lineDash)) {
          object.parsedStyle.lineDash = parseDimensionArrayFormat(attributes.lineDash, "even");
        }
        if (list.has("points") && attributes.points) {
          object.parsedStyle.points = parsePoints(attributes.points);
        }
        if (list.has("d") && attributes.d === "") {
          object.parsedStyle.d = _objectSpread2({}, EMPTY_PARSED_PATH);
        }
        if (list.has("d") && attributes.d) {
          object.parsedStyle.d = parsePath(
            // @ts-ignore
            attributes.d
          );
        }
        if (list.has("textTransform") && attributes.textTransform) {
          this.runtime.CSSPropertySyntaxFactory[PropertySyntax.TEXT_TRANSFORM].calculator(null, null, {
            value: attributes.textTransform
          }, object, null);
        }
        if (list.has("clipPath") && !(0, import_util2.isUndefined)(attributes.clipPath)) {
          this.runtime.CSSPropertySyntaxFactory[PropertySyntax.DEFINED_PATH].calculator("clipPath", oldClipPath, attributes.clipPath, object, this.runtime);
        }
        if (list.has("offsetPath") && attributes.offsetPath) {
          this.runtime.CSSPropertySyntaxFactory[PropertySyntax.DEFINED_PATH].calculator("offsetPath", oldOffsetPath, attributes.offsetPath, object, this.runtime);
        }
        if (list.has("transform") && attributes.transform) {
          object.parsedStyle.transform = parseTransform(attributes.transform);
        }
        if (list.has("transformOrigin") && attributes.transformOrigin) {
          object.parsedStyle.transformOrigin = parseTransformOrigin(attributes.transformOrigin);
        }
        if (list.has("markerStart") && attributes.markerStart) {
          object.parsedStyle.markerStart = this.runtime.CSSPropertySyntaxFactory[PropertySyntax.MARKER].calculator(
            null,
            // @ts-ignore
            attributes.markerStart,
            // @ts-ignore
            attributes.markerStart,
            null,
            null
          );
        }
        if (list.has("markerEnd") && attributes.markerEnd) {
          object.parsedStyle.markerEnd = this.runtime.CSSPropertySyntaxFactory[PropertySyntax.MARKER].calculator(
            null,
            // @ts-ignore
            attributes.markerEnd,
            // @ts-ignore
            attributes.markerEnd,
            null,
            null
          );
        }
        if (list.has("markerMid") && attributes.markerMid) {
          object.parsedStyle.markerMid = this.runtime.CSSPropertySyntaxFactory[PropertySyntax.MARKER].calculator(
            "",
            // @ts-ignore
            attributes.markerMid,
            // @ts-ignore
            attributes.markerMid,
            null,
            null
          );
        }
        if (list.has("zIndex") && !(0, import_util2.isNil)(attributes.zIndex)) {
          this.runtime.CSSPropertySyntaxFactory[PropertySyntax.Z_INDEX].postProcessor(object);
        }
        if (list.has("offsetDistance") && !(0, import_util2.isNil)(attributes.offsetDistance)) {
          this.runtime.CSSPropertySyntaxFactory[PropertySyntax.OFFSET_DISTANCE].postProcessor(object);
        }
        if (list.has("transform") && attributes.transform) {
          this.runtime.CSSPropertySyntaxFactory[PropertySyntax.TRANSFORM].postProcessor(object);
        }
        if (list.has("transformOrigin") && attributes.transformOrigin) {
          this.runtime.CSSPropertySyntaxFactory[PropertySyntax.TRANSFORM_ORIGIN].postProcessor(object);
        }
        if (needUpdateGeometry) {
          object.geometry.dirty = true;
          object.dirty(true, true);
          if (!options.forceUpdateGeometry) {
            this.runtime.sceneGraphService.dirtyToRoot(object);
          }
        }
      }
      /**
       * update geometry when relative props changed,
       * eg. r of Circle, width/height of Rect
       */
    }, {
      key: "updateGeometry",
      value: function updateGeometry(object) {
        var nodeName = object.nodeName;
        var geometryUpdater = this.runtime.geometryUpdaterFactory[nodeName];
        if (geometryUpdater) {
          var geometry = object.geometry;
          if (!geometry.contentBounds) {
            geometry.contentBounds = new AABB();
          }
          if (!geometry.renderBounds) {
            geometry.renderBounds = new AABB();
          }
          var parsedStyle = object.parsedStyle;
          var _geometryUpdater$upda = geometryUpdater.update(parsedStyle, object), _geometryUpdater$upda2 = _geometryUpdater$upda.cx, cx = _geometryUpdater$upda2 === void 0 ? 0 : _geometryUpdater$upda2, _geometryUpdater$upda3 = _geometryUpdater$upda.cy, cy = _geometryUpdater$upda3 === void 0 ? 0 : _geometryUpdater$upda3, _geometryUpdater$upda4 = _geometryUpdater$upda.cz, cz = _geometryUpdater$upda4 === void 0 ? 0 : _geometryUpdater$upda4, _geometryUpdater$upda5 = _geometryUpdater$upda.hwidth, hwidth = _geometryUpdater$upda5 === void 0 ? 0 : _geometryUpdater$upda5, _geometryUpdater$upda6 = _geometryUpdater$upda.hheight, hheight = _geometryUpdater$upda6 === void 0 ? 0 : _geometryUpdater$upda6, _geometryUpdater$upda7 = _geometryUpdater$upda.hdepth, hdepth = _geometryUpdater$upda7 === void 0 ? 0 : _geometryUpdater$upda7;
          var halfExtents = [Math.abs(hwidth), Math.abs(hheight), hdepth];
          var stroke = parsedStyle.stroke, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$increase = parsedStyle.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _parsedStyle$increase === void 0 ? 0 : _parsedStyle$increase, _parsedStyle$shadowTy = parsedStyle.shadowType, shadowType = _parsedStyle$shadowTy === void 0 ? "outer" : _parsedStyle$shadowTy, shadowColor = parsedStyle.shadowColor, _parsedStyle$filter = parsedStyle.filter, filter = _parsedStyle$filter === void 0 ? [] : _parsedStyle$filter, transformOrigin = parsedStyle.transformOrigin;
          var center = [cx, cy, cz];
          geometry.contentBounds.update(center, halfExtents);
          var expansion = nodeName === Shape.POLYLINE || nodeName === Shape.POLYGON || nodeName === Shape.PATH ? Math.SQRT2 : 0.5;
          var hasStroke = stroke && !stroke.isNone;
          if (hasStroke) {
            var halfLineWidth = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) * expansion;
            halfExtents[0] += halfLineWidth;
            halfExtents[1] += halfLineWidth;
          }
          geometry.renderBounds.update(center, halfExtents);
          if (shadowColor && shadowType && shadowType !== "inner") {
            var _geometry$renderBound = geometry.renderBounds, min4 = _geometry$renderBound.min, max4 = _geometry$renderBound.max;
            var shadowBlur = parsedStyle.shadowBlur, shadowOffsetX = parsedStyle.shadowOffsetX, shadowOffsetY = parsedStyle.shadowOffsetY;
            var shadowBlurInPixels = shadowBlur || 0;
            var shadowOffsetXInPixels = shadowOffsetX || 0;
            var shadowOffsetYInPixels = shadowOffsetY || 0;
            var shadowLeft = min4[0] - shadowBlurInPixels + shadowOffsetXInPixels;
            var shadowRight = max4[0] + shadowBlurInPixels + shadowOffsetXInPixels;
            var shadowTop = min4[1] - shadowBlurInPixels + shadowOffsetYInPixels;
            var shadowBottom = max4[1] + shadowBlurInPixels + shadowOffsetYInPixels;
            min4[0] = Math.min(min4[0], shadowLeft);
            max4[0] = Math.max(max4[0], shadowRight);
            min4[1] = Math.min(min4[1], shadowTop);
            max4[1] = Math.max(max4[1], shadowBottom);
            geometry.renderBounds.setMinMax(min4, max4);
          }
          filter.forEach(function(_ref) {
            var name = _ref.name, params = _ref.params;
            if (name === "blur") {
              var blurRadius = params[0].value;
              geometry.renderBounds.update(geometry.renderBounds.center, import_gl_matrix2.vec3.add(geometry.renderBounds.halfExtents, geometry.renderBounds.halfExtents, [blurRadius, blurRadius, 0]));
            } else if (name === "drop-shadow") {
              var _shadowOffsetX = params[0].value;
              var _shadowOffsetY = params[1].value;
              var _shadowBlur = params[2].value;
              var _geometry$renderBound2 = geometry.renderBounds, _min = _geometry$renderBound2.min, _max = _geometry$renderBound2.max;
              var _shadowLeft = _min[0] - _shadowBlur + _shadowOffsetX;
              var _shadowRight = _max[0] + _shadowBlur + _shadowOffsetX;
              var _shadowTop = _min[1] - _shadowBlur + _shadowOffsetY;
              var _shadowBottom = _max[1] + _shadowBlur + _shadowOffsetY;
              _min[0] = Math.min(_min[0], _shadowLeft);
              _max[0] = Math.max(_max[0], _shadowRight);
              _min[1] = Math.min(_min[1], _shadowTop);
              _max[1] = Math.max(_max[1], _shadowBottom);
              geometry.renderBounds.setMinMax(_min, _max);
            }
          });
          object.geometry.dirty = false;
          var flipY = hwidth < 0;
          var flipX = hheight < 0;
          var usedOriginXValue = (flipY ? -1 : 1) * (transformOrigin ? convertPercentUnit(transformOrigin[0], 0, object, true) : 0);
          var usedOriginYValue = (flipX ? -1 : 1) * (transformOrigin ? convertPercentUnit(transformOrigin[1], 1, object, true) : 0);
          if (usedOriginXValue || usedOriginYValue) {
            object.setOrigin(usedOriginXValue, usedOriginYValue);
          }
        }
      }
    }, {
      key: "updateSizeAttenuation",
      value: function updateSizeAttenuation(node, zoom) {
        if (node.style.isSizeAttenuation) {
          if (!node.style.rawLineWidth) {
            node.style.rawLineWidth = node.style.lineWidth;
          }
          node.style.lineWidth = (node.style.rawLineWidth || 1) / zoom;
          if (node.nodeName === Shape.CIRCLE) {
            if (!node.style.rawR) {
              node.style.rawR = node.style.r;
            }
            node.style.r = (node.style.rawR || 1) / zoom;
          }
        } else {
          if (node.style.rawLineWidth) {
            node.style.lineWidth = node.style.rawLineWidth;
            delete node.style.rawLineWidth;
          }
          if (node.nodeName === Shape.CIRCLE) {
            if (node.style.rawR) {
              node.style.r = node.style.rawR;
              delete node.style.rawR;
            }
          }
        }
      }
    }]);
  })();
  function assignParsedStyle(object, attributes) {
    var list = getParsedStyleListOf(object);
    for (var key in attributes) {
      if (list.has(key)) {
        object.parsedStyle[key] = attributes[key];
      }
    }
  }
  function getParsedStyleListOf(object) {
    return object.constructor.PARSED_STYLE_LIST;
  }
  var CSSPropertyAngle = /* @__PURE__ */ (function() {
    function CSSPropertyAngle2() {
      _classCallCheck(this, CSSPropertyAngle2);
      this.mixer = mergeNumbers;
    }
    return _createClass(CSSPropertyAngle2, [{
      key: "calculator",
      value: function calculator(name, oldParsed, parsed, object) {
        return convertAngleUnit(parsed);
      }
    }]);
  })();
  var CSSPropertyClipPath = /* @__PURE__ */ (function() {
    function CSSPropertyClipPath2() {
      _classCallCheck(this, CSSPropertyClipPath2);
    }
    return _createClass(CSSPropertyClipPath2, [{
      key: "calculator",
      value: function calculator(name, oldPath, newPath, object, runtime2) {
        if (newPath instanceof CSSKeywordValue) {
          newPath = null;
        }
        runtime2.sceneGraphService.updateDisplayObjectDependency(name, oldPath, newPath, object);
        if (name === "clipPath") {
          object.forEach(function(leaf) {
            if (leaf.childNodes.length === 0) {
              runtime2.sceneGraphService.dirtyToRoot(leaf);
            }
          });
        }
        return newPath;
      }
    }]);
  })();
  var CSSPropertyColor = /* @__PURE__ */ (function() {
    function CSSPropertyColor2() {
      _classCallCheck(this, CSSPropertyColor2);
      this.parser = parseColor;
      this.mixer = mergeColors;
    }
    return _createClass(CSSPropertyColor2, [{
      key: "calculator",
      value: function calculator(name, oldParsed, parsed, object) {
        if (parsed instanceof CSSKeywordValue) {
          return parsed.value === "none" ? noneColor : transparentColor;
        }
        return parsed;
      }
    }]);
  })();
  var CSSPropertyFilter = /* @__PURE__ */ (function() {
    function CSSPropertyFilter2() {
      _classCallCheck(this, CSSPropertyFilter2);
    }
    return _createClass(CSSPropertyFilter2, [{
      key: "calculator",
      value: function calculator(name, oldParsed, parsed) {
        if (parsed instanceof CSSKeywordValue) {
          return [];
        }
        return parsed;
      }
    }]);
  })();
  function getFontSize(object) {
    var _ref = object.parsedStyle, fontSize = _ref.fontSize;
    return (0, import_util2.isNil)(fontSize) ? null : fontSize;
  }
  var CSSPropertyLengthOrPercentage = /* @__PURE__ */ (function() {
    function CSSPropertyLengthOrPercentage2() {
      _classCallCheck(this, CSSPropertyLengthOrPercentage2);
      this.mixer = mergeNumbers;
    }
    return _createClass(CSSPropertyLengthOrPercentage2, [{
      key: "calculator",
      value: (
        /**
         * according to parent's bounds
         *
         * @example
         * CSS.percent(50) -> CSS.px(0.5 * parent.width)
         */
        function calculator(name, oldParsed, computed, object, runtime2) {
          if ((0, import_util2.isNumber)(computed)) {
            return computed;
          }
          if (CSSUnitValue.isRelativeUnit(computed.unit)) {
            if (computed.unit === UnitType.kPercentage) {
              return 0;
            }
            if (computed.unit === UnitType.kEms) {
              if (object.parentNode) {
                var fontSize = getFontSize(object.parentNode);
                if (fontSize) {
                  fontSize *= computed.value;
                  return fontSize;
                }
              }
              return 0;
            }
            if (computed.unit === UnitType.kRems) {
              var _object$ownerDocument;
              if (object !== null && object !== void 0 && (_object$ownerDocument = object.ownerDocument) !== null && _object$ownerDocument !== void 0 && _object$ownerDocument.documentElement) {
                var _fontSize = getFontSize(object.ownerDocument.documentElement);
                if (_fontSize) {
                  _fontSize *= computed.value;
                  return _fontSize;
                }
              }
              return 0;
            }
          } else {
            return computed.value;
          }
        }
      )
    }]);
  })();
  var CSSPropertyLengthOrPercentage12 = /* @__PURE__ */ (function() {
    function CSSPropertyLengthOrPercentage122() {
      _classCallCheck(this, CSSPropertyLengthOrPercentage122);
      this.mixer = mergeNumberLists;
    }
    return _createClass(CSSPropertyLengthOrPercentage122, [{
      key: "calculator",
      value: function calculator(name, oldParsed, computed) {
        return computed.map(function(c2) {
          return c2.value;
        });
      }
    }]);
  })();
  var CSSPropertyLengthOrPercentage14 = /* @__PURE__ */ (function() {
    function CSSPropertyLengthOrPercentage142() {
      _classCallCheck(this, CSSPropertyLengthOrPercentage142);
      this.mixer = mergeNumberLists;
    }
    return _createClass(CSSPropertyLengthOrPercentage142, [{
      key: "calculator",
      value: function calculator(name, oldParsed, computed) {
        return computed.map(function(c2) {
          return c2.value;
        });
      }
    }]);
  })();
  var CSSPropertyMarker = /* @__PURE__ */ (function() {
    function CSSPropertyMarker2() {
      _classCallCheck(this, CSSPropertyMarker2);
    }
    return _createClass(CSSPropertyMarker2, [{
      key: "calculator",
      value: function calculator(name, oldMarker, newMarker, object) {
        var _newMarker;
        if (newMarker instanceof CSSKeywordValue) {
          newMarker = null;
        }
        var cloned = (_newMarker = newMarker) === null || _newMarker === void 0 ? void 0 : _newMarker.cloneNode(true);
        if (cloned) {
          cloned.style.isMarker = true;
        }
        return cloned;
      }
    }]);
  })();
  var CSSPropertyNumber = /* @__PURE__ */ (function() {
    function CSSPropertyNumber2() {
      _classCallCheck(this, CSSPropertyNumber2);
      this.mixer = mergeNumbers;
    }
    return _createClass(CSSPropertyNumber2, [{
      key: "calculator",
      value: function calculator(name, oldParsed, computed) {
        return computed.value;
      }
    }]);
  })();
  var CSSPropertyOffsetDistance = /* @__PURE__ */ (function() {
    function CSSPropertyOffsetDistance2() {
      _classCallCheck(this, CSSPropertyOffsetDistance2);
      this.mixer = clampedMergeNumbers(0, 1);
    }
    return _createClass(CSSPropertyOffsetDistance2, [{
      key: "calculator",
      value: function calculator(name, oldParsed, computed) {
        return computed.value;
      }
    }, {
      key: "postProcessor",
      value: function postProcessor(object) {
        var _object$parsedStyle = object.parsedStyle, offsetPath = _object$parsedStyle.offsetPath, offsetDistance = _object$parsedStyle.offsetDistance;
        if (!offsetPath) {
          return;
        }
        var nodeName = offsetPath.nodeName;
        if (nodeName === Shape.LINE || nodeName === Shape.PATH || nodeName === Shape.POLYLINE) {
          var point4 = offsetPath.getPoint(offsetDistance);
          if (point4) {
            object.setLocalPosition(point4.x, point4.y);
          }
        }
      }
    }]);
  })();
  var CSSPropertyOpacity = /* @__PURE__ */ (function() {
    function CSSPropertyOpacity2() {
      _classCallCheck(this, CSSPropertyOpacity2);
      this.mixer = clampedMergeNumbers(0, 1);
    }
    return _createClass(CSSPropertyOpacity2, [{
      key: "calculator",
      value: function calculator(name, oldParsed, computed) {
        return computed.value;
      }
    }]);
  })();
  var CSSPropertyPath = /* @__PURE__ */ (function() {
    function CSSPropertyPath2() {
      _classCallCheck(this, CSSPropertyPath2);
      this.parser = parsePath;
      this.mixer = mergePaths;
    }
    return _createClass(CSSPropertyPath2, [{
      key: "calculator",
      value: function calculator(name, oldParsed, parsed) {
        if (parsed instanceof CSSKeywordValue && parsed.value === "unset") {
          return {
            absolutePath: [],
            hasArc: false,
            segments: [],
            polygons: [],
            polylines: [],
            curve: null,
            totalLength: 0,
            rect: new Rectangle(0, 0, 0, 0)
          };
        }
        return parsed;
      }
    }]);
  })();
  var CSSPropertyPoints = /* @__PURE__ */ _createClass(function CSSPropertyPoints2() {
    _classCallCheck(this, CSSPropertyPoints2);
    this.mixer = mergePoints;
  });
  var CSSPropertyShadowBlur = /* @__PURE__ */ (function(_CSSPropertyLengthOrP) {
    function CSSPropertyShadowBlur2() {
      var _this2;
      _classCallCheck(this, CSSPropertyShadowBlur2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this2 = _callSuper(this, CSSPropertyShadowBlur2, [].concat(args));
      _this2.mixer = clampedMergeNumbers(0, Infinity);
      return _this2;
    }
    _inherits(CSSPropertyShadowBlur2, _CSSPropertyLengthOrP);
    return _createClass(CSSPropertyShadowBlur2);
  })(CSSPropertyLengthOrPercentage);
  var CSSPropertyText = /* @__PURE__ */ (function() {
    function CSSPropertyText2() {
      _classCallCheck(this, CSSPropertyText2);
    }
    return _createClass(CSSPropertyText2, [{
      key: "calculator",
      value: function calculator(name, oldParsed, parsed, object) {
        if (parsed instanceof CSSKeywordValue) {
          if (parsed.value === "unset") {
            return "";
          }
          return parsed.value;
        }
        return "".concat(parsed);
      }
    }, {
      key: "postProcessor",
      value: function postProcessor(object) {
        object.nodeValue = "".concat(object.parsedStyle.text) || "";
      }
    }]);
  })();
  var CSSPropertyTextTransform = /* @__PURE__ */ (function() {
    function CSSPropertyTextTransform2() {
      _classCallCheck(this, CSSPropertyTextTransform2);
    }
    return _createClass(CSSPropertyTextTransform2, [{
      key: "calculator",
      value: function calculator(name, oldParsed, parsed, object) {
        var rawText = object.getAttribute("text");
        if (rawText) {
          var transformedText = rawText;
          if (parsed.value === "capitalize") {
            transformedText = rawText.charAt(0).toUpperCase() + rawText.slice(1);
          } else if (parsed.value === "lowercase") {
            transformedText = rawText.toLowerCase();
          } else if (parsed.value === "uppercase") {
            transformedText = rawText.toUpperCase();
          }
          object.parsedStyle.text = transformedText;
        }
        return parsed.value;
      }
    }]);
  })();
  var CANVAS_Map = /* @__PURE__ */ new WeakMap();
  function cleanExistedCanvas(container, canvas2, cleanUp) {
    if (container) {
      var $dom = typeof container === "string" ? document.getElementById(container) : container;
      if (CANVAS_Map.has($dom)) CANVAS_Map.get($dom).destroy(cleanUp);
      CANVAS_Map.set($dom, canvas2);
    }
  }
  var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
  function isElement(target) {
    return !!target.getAttribute;
  }
  function sortedIndex(array, value) {
    var low = 0;
    var high = array.length;
    while (low < high) {
      var mid = low + high >>> 1;
      if (sortByZIndex(array[mid], value) < 0) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return low;
  }
  function sortByZIndex(o1, o2) {
    var zIndex1 = Number(o1.parsedStyle.zIndex || 0);
    var zIndex2 = Number(o2.parsedStyle.zIndex || 0);
    if (zIndex1 === zIndex2) {
      var parent = o1.parentNode;
      if (parent) {
        var children = parent.childNodes || [];
        return children.indexOf(o1) - children.indexOf(o2);
      }
    }
    return zIndex1 - zIndex2;
  }
  function findClosestClipPathTarget(object) {
    var el = object;
    do {
      var _el$parsedStyle;
      var clipPath = (_el$parsedStyle = el.parsedStyle) === null || _el$parsedStyle === void 0 ? void 0 : _el$parsedStyle.clipPath;
      if (clipPath) return el;
      el = el.parentElement;
    } while (el !== null);
    return null;
  }
  var PX_SUFFIX = "px";
  function setDOMSize($el, width2, height) {
    if (isBrowser && $el.style) {
      $el.style.width = width2 + PX_SUFFIX;
      $el.style.height = height + PX_SUFFIX;
    }
  }
  function getStyle($el, property) {
    if (isBrowser) {
      return document.defaultView.getComputedStyle($el, null).getPropertyValue(property);
    }
  }
  function getWidth($el) {
    var width2 = getStyle($el, "width");
    if (width2 === "auto") {
      return $el.offsetWidth;
    }
    return parseFloat(width2);
  }
  function getHeight($el) {
    var height = getStyle($el, "height");
    if (height === "auto") {
      return $el.offsetHeight;
    }
    return parseFloat(height);
  }
  var MOUSE_POINTER_ID = 1;
  var TOUCH_TO_POINTER = {
    touchstart: "pointerdown",
    touchend: "pointerup",
    touchendoutside: "pointerupoutside",
    touchmove: "pointermove",
    touchcancel: "pointercancel"
  };
  var clock = typeof performance === "object" && performance.now ? performance : Date;
  function isInFragment(node) {
    if (node.nodeName === Shape.FRAGMENT) return true;
    return node.getRootNode().nodeName === Shape.FRAGMENT;
  }
  function isFillOrStrokeAffected() {
    var pointerEvents = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "auto";
    var fill = arguments.length > 1 ? arguments[1] : void 0;
    var stroke = arguments.length > 2 ? arguments[2] : void 0;
    var hasFill = false;
    var hasStroke = false;
    var isFillOtherThanNone = !!fill && !fill.isNone;
    var isStrokeOtherThanNone = !!stroke && !stroke.isNone;
    if (pointerEvents === "visiblepainted" || pointerEvents === "painted" || pointerEvents === "auto") {
      hasFill = isFillOtherThanNone;
      hasStroke = isStrokeOtherThanNone;
    } else if (pointerEvents === "visiblefill" || pointerEvents === "fill") {
      hasFill = true;
    } else if (pointerEvents === "visiblestroke" || pointerEvents === "stroke") {
      hasStroke = true;
    } else if (pointerEvents === "visible" || pointerEvents === "all") {
      hasFill = true;
      hasStroke = true;
    }
    return [hasFill, hasStroke];
  }
  var uId = 1;
  var uniqueId = function uniqueId2() {
    return uId++;
  };
  var root = (
    // eslint-disable-next-line no-nested-ternary
    typeof self === "object" && self.self === self ? self : (
      // @ts-ignore
      typeof global === "object" && global.global === global ? (
        // @ts-ignore
        global
      ) : {}
    )
  );
  var nowOffset = Date.now();
  var pnow = function pnow2() {
    if (root.performance && typeof root.performance.now === "function") {
      return root.performance.now();
    }
    return Date.now() - nowOffset;
  };
  var reservedCBs = {};
  var lastTime = Date.now();
  var polyfillRaf = function polyfillRaf2(callback) {
    if (typeof callback !== "function") {
      throw new TypeError("".concat(callback, " is not a function"));
    }
    var currentTime = Date.now();
    var gap = currentTime - lastTime;
    var delay = gap > 16 ? 0 : 16 - gap;
    var id3 = uniqueId();
    reservedCBs[id3] = callback;
    if (Object.keys(reservedCBs).length > 1) return id3;
    setTimeout(function() {
      lastTime = currentTime;
      var copied = reservedCBs;
      reservedCBs = {};
      Object.keys(copied).forEach(function(key) {
        return copied[key](pnow());
      });
    }, delay);
    return id3;
  };
  var polyfillCaf = function polyfillCaf2(id3) {
    delete reservedCBs[id3];
  };
  var vendorPrefixes = ["", "webkit", "moz", "ms", "o"];
  var getRequestAnimationFrame = function getRequestAnimationFrame2(vp2) {
    if (typeof vp2 !== "string") return polyfillRaf;
    if (vp2 === "") return root.requestAnimationFrame;
    return root["".concat(vp2, "RequestAnimationFrame")];
  };
  var getCancelAnimationFrame = function getCancelAnimationFrame2(vp2) {
    if (typeof vp2 !== "string") return polyfillCaf;
    if (vp2 === "") return root.cancelAnimationFrame;
    return root["".concat(vp2, "CancelAnimationFrame")] || root["".concat(vp2, "CancelRequestAnimationFrame")];
  };
  var find = function find2(arr, predicate) {
    var i = 0;
    while (arr[i] !== void 0) {
      if (predicate(arr[i])) return arr[i];
      i += 1;
    }
  };
  var vp = find(vendorPrefixes, function(vp2) {
    return !!getRequestAnimationFrame(vp2);
  });
  var raf = getRequestAnimationFrame(vp);
  var caf = getCancelAnimationFrame(vp);
  root.requestAnimationFrame = raf;
  root.cancelAnimationFrame = caf;
  var AsyncParallelHook = /* @__PURE__ */ (function() {
    function AsyncParallelHook2() {
      _classCallCheck(this, AsyncParallelHook2);
      this.callbacks = [];
    }
    return _createClass(AsyncParallelHook2, [{
      key: "getCallbacksNum",
      value: function getCallbacksNum() {
        return this.callbacks.length;
      }
    }, {
      key: "tapPromise",
      value: function tapPromise(options, fn) {
        this.callbacks.push(fn);
      }
    }, {
      key: "promise",
      value: function promise() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return Promise.all(this.callbacks.map(function(callback) {
          return callback.apply(void 0, args);
        }));
      }
    }]);
  })();
  var AsyncSeriesWaterfallHook = /* @__PURE__ */ (function() {
    function AsyncSeriesWaterfallHook2() {
      _classCallCheck(this, AsyncSeriesWaterfallHook2);
      this.callbacks = [];
    }
    return _createClass(AsyncSeriesWaterfallHook2, [{
      key: "tapPromise",
      value: function tapPromise(options, fn) {
        this.callbacks.push(fn);
      }
    }, {
      key: "promise",
      value: (function() {
        var _promise = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee() {
          var _this$callbacks, result, i, callback, _args = arguments;
          return _regeneratorRuntime().wrap(function(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                if (!this.callbacks.length) {
                  _context.next = 6;
                  break;
                }
                _context.next = 1;
                return (_this$callbacks = this.callbacks)[0].apply(_this$callbacks, _args);
              case 1:
                result = _context.sent;
                i = 0;
              case 2:
                if (!(i < this.callbacks.length - 1)) {
                  _context.next = 5;
                  break;
                }
                callback = this.callbacks[i];
                _context.next = 3;
                return callback(result);
              case 3:
                result = _context.sent;
              case 4:
                i++;
                _context.next = 2;
                break;
              case 5:
                return _context.abrupt("return", result);
              case 6:
                return _context.abrupt("return", null);
              case 7:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
        function promise() {
          return _promise.apply(this, arguments);
        }
        return promise;
      })()
    }]);
  })();
  var SyncHook = /* @__PURE__ */ (function() {
    function SyncHook2() {
      _classCallCheck(this, SyncHook2);
      this.callbacks = [];
    }
    return _createClass(SyncHook2, [{
      key: "tap",
      value: function tap(options, fn) {
        this.callbacks.push(fn);
      }
    }, {
      key: "call",
      value: function call() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var argsArr = arguments;
        this.callbacks.forEach(function(callback) {
          callback.apply(void 0, argsArr);
        });
      }
    }]);
  })();
  var SyncWaterfallHook = /* @__PURE__ */ (function() {
    function SyncWaterfallHook2() {
      _classCallCheck(this, SyncWaterfallHook2);
      this.callbacks = [];
    }
    return _createClass(SyncWaterfallHook2, [{
      key: "tap",
      value: function tap(options, fn) {
        this.callbacks.push(fn);
      }
    }, {
      key: "call",
      value: function call() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (this.callbacks.length) {
          var argsArr = arguments;
          var result = this.callbacks[0].apply(void 0, argsArr);
          for (var i = 0; i < this.callbacks.length - 1; i++) {
            var callback = this.callbacks[i];
            result = callback(result);
          }
          return result;
        }
        return null;
      }
    }]);
  })();
  var genericFontFamilies = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"];
  var stringRegExp = /([\"\'])[^\'\"]+\1/;
  function getFontAttr(attributes) {
    var _attributes$fontSize = attributes.fontSize, fontSize = _attributes$fontSize === void 0 ? 16 : _attributes$fontSize, _attributes$fontFamil = attributes.fontFamily, fontFamily = _attributes$fontFamil === void 0 ? "sans-serif" : _attributes$fontFamil, _attributes$fontStyle = attributes.fontStyle, fontStyle = _attributes$fontStyle === void 0 ? "normal" : _attributes$fontStyle, _attributes$fontVaria = attributes.fontVariant, fontVariant = _attributes$fontVaria === void 0 ? "normal" : _attributes$fontVaria, _attributes$fontWeigh = attributes.fontWeight, fontWeight = _attributes$fontWeigh === void 0 ? "normal" : _attributes$fontWeigh;
    return {
      fontSize,
      fontFamily,
      fontStyle,
      fontVariant,
      fontWeight
    };
  }
  var toFontString = memoize(function toFontStringRaw(attributes) {
    var _getFontAttr = getFontAttr(attributes), fontSize = _getFontAttr.fontSize, fontFamily = _getFontAttr.fontFamily, fontStyle = _getFontAttr.fontStyle, fontVariant = _getFontAttr.fontVariant, fontWeight = _getFontAttr.fontWeight;
    var fontSizeString = (0, import_util2.isNumber)(fontSize) && "".concat(fontSize, "px") || "16px";
    var fontFamilies = fontFamily.split(",");
    for (var i = fontFamilies.length - 1; i >= 0; i--) {
      var _fontFamily = fontFamilies[i].trim();
      if (!stringRegExp.test(_fontFamily) && genericFontFamilies.indexOf(_fontFamily) < 0) {
        _fontFamily = '"'.concat(_fontFamily, '"');
      }
      fontFamilies[i] = _fontFamily;
    }
    return "".concat(fontStyle, " ").concat(fontVariant, " ").concat(fontWeight, " ").concat(fontSizeString, " ").concat(fontFamilies.join(","));
  }, function(attributes) {
    var _getFontAttr2 = getFontAttr(attributes), fontSize = _getFontAttr2.fontSize, fontFamily = _getFontAttr2.fontFamily, fontStyle = _getFontAttr2.fontStyle, fontVariant = _getFontAttr2.fontVariant, fontWeight = _getFontAttr2.fontWeight;
    return "".concat(fontStyle, "_").concat(fontVariant, "_").concat(fontWeight, "_").concat(fontSize, "_").concat(fontFamily);
  });
  var MIN_SCALE = 1e-6;
  var clampScale = function clampScale2(item) {
    return Math.max(item, MIN_SCALE);
  };
  function createSkewMatrix(skewMatrix, skewX2, skewY2) {
    import_gl_matrix2.mat4.identity(skewMatrix);
    skewMatrix[4] = Math.tan(skewX2);
    skewMatrix[1] = Math.tan(skewY2);
    return skewMatrix;
  }
  var $mat4_1 = import_gl_matrix2.mat4.create();
  var $mat4_2 = import_gl_matrix2.mat4.create();
  var parser = {
    scale: function scale(d2) {
      import_gl_matrix2.mat4.fromScaling($mat4_1, [d2[0].value, d2[1].value, 1].map(function(item) {
        return clampScale(item);
      }));
    },
    scaleX: function scaleX(d2) {
      import_gl_matrix2.mat4.fromScaling($mat4_1, [d2[0].value, 1, 1].map(function(item) {
        return clampScale(item);
      }));
    },
    scaleY: function scaleY(d2) {
      import_gl_matrix2.mat4.fromScaling($mat4_1, [1, d2[0].value, 1].map(function(item) {
        return clampScale(item);
      }));
    },
    scaleZ: function scaleZ(d2) {
      import_gl_matrix2.mat4.fromScaling($mat4_1, [1, 1, d2[0].value].map(function(item) {
        return clampScale(item);
      }));
    },
    scale3d: function scale3d(d2) {
      import_gl_matrix2.mat4.fromScaling($mat4_1, [d2[0].value, d2[1].value, d2[2].value].map(function(item) {
        return clampScale(item);
      }));
    },
    translate: function translate(d2) {
      import_gl_matrix2.mat4.fromTranslation($mat4_1, [d2[0].value, d2[1].value, 0]);
    },
    translateX: function translateX(d2) {
      import_gl_matrix2.mat4.fromTranslation($mat4_1, [d2[0].value, 0, 0]);
    },
    translateY: function translateY(d2) {
      import_gl_matrix2.mat4.fromTranslation($mat4_1, [0, d2[0].value, 0]);
    },
    translateZ: function translateZ(d2) {
      import_gl_matrix2.mat4.fromTranslation($mat4_1, [0, 0, d2[0].value]);
    },
    translate3d: function translate3d(d2) {
      import_gl_matrix2.mat4.fromTranslation($mat4_1, [d2[0].value, d2[1].value, d2[2].value]);
    },
    rotate: function rotate(d2) {
      import_gl_matrix2.mat4.fromZRotation($mat4_1, deg2rad(convertAngleUnit(d2[0])));
    },
    rotateX: function rotateX(d2) {
      import_gl_matrix2.mat4.fromXRotation($mat4_1, deg2rad(convertAngleUnit(d2[0])));
    },
    rotateY: function rotateY(d2) {
      import_gl_matrix2.mat4.fromYRotation($mat4_1, deg2rad(convertAngleUnit(d2[0])));
    },
    rotateZ: function rotateZ(d2) {
      import_gl_matrix2.mat4.fromZRotation($mat4_1, deg2rad(convertAngleUnit(d2[0])));
    },
    rotate3d: function rotate3d(d2) {
      import_gl_matrix2.mat4.fromRotation($mat4_1, deg2rad(convertAngleUnit(d2[3])), [d2[0].value, d2[1].value, d2[2].value]);
    },
    skew: function skew(d2) {
      createSkewMatrix($mat4_1, deg2rad(d2[0].value), deg2rad(d2[1].value));
    },
    skewX: function skewX(d2) {
      createSkewMatrix($mat4_1, deg2rad(d2[0].value), 0);
    },
    skewY: function skewY(d2) {
      createSkewMatrix($mat4_1, 0, deg2rad(d2[0].value));
    },
    matrix: function matrix(d2) {
      import_gl_matrix2.mat4.set($mat4_1, d2[0].value, d2[1].value, 0, 0, d2[2].value, d2[3].value, 0, 0, 0, 0, 1, 0, d2[4].value, d2[5].value, 0, 1);
    },
    matrix3d: function matrix3d(d2) {
      import_gl_matrix2.mat4.set.apply(import_gl_matrix2.mat4, [$mat4_1].concat(_toConsumableArray(d2.map(function(s) {
        return s.value;
      }))));
    }
  };
  var $vec3One$1 = import_gl_matrix2.vec3.fromValues(1, 1, 1);
  var $vec3Zero$1 = import_gl_matrix2.vec3.create();
  var optimizer = {
    translate: function translate2(object, d2) {
      runtime.sceneGraphService.setLocalScale(object, $vec3One$1, false);
      runtime.sceneGraphService.setLocalEulerAngles(object, $vec3Zero$1, void 0, void 0, false);
      runtime.sceneGraphService.setLocalPosition(object, [d2[0].value, d2[1].value, 0], false);
      runtime.sceneGraphService.dirtyLocalTransform(object, object.transformable);
    }
  };
  function parsedTransformToMat4(transform, object) {
    if (transform.length) {
      if (transform.length === 1 && optimizer[transform[0].t]) {
        optimizer[transform[0].t](object, transform[0].d);
        return;
      }
      var m2 = import_gl_matrix2.mat4.identity($mat4_2);
      for (var i = 0; i < transform.length; i++) {
        var _transform$i = transform[i], t = _transform$i.t, d2 = _transform$i.d;
        var p = parser[t];
        if (p) {
          p(d2);
          import_gl_matrix2.mat4.mul(m2, m2, $mat4_1);
        }
      }
      object.setLocalTransform(m2);
    } else {
      object.resetLocalTransform();
    }
    return object.getLocalTransform();
  }
  var CSSPropertyTransform = /* @__PURE__ */ (function() {
    function CSSPropertyTransform2() {
      _classCallCheck(this, CSSPropertyTransform2);
      this.parser = parseTransformUnmemoize;
      this.mixer = mergeTransforms;
    }
    return _createClass(CSSPropertyTransform2, [{
      key: "calculator",
      value: function calculator(name, oldParsed, parsed, object) {
        if (parsed instanceof CSSKeywordValue) {
          return [];
        }
        return parsed;
      }
    }, {
      key: "postProcessor",
      value: function postProcessor(object) {
        parsedTransformToMat4(object.parsedStyle.transform, object);
      }
    }]);
  })();
  var CSSPropertyTransformOrigin = /* @__PURE__ */ (function() {
    function CSSPropertyTransformOrigin2() {
      _classCallCheck(this, CSSPropertyTransformOrigin2);
    }
    return _createClass(CSSPropertyTransformOrigin2, [{
      key: "postProcessor",
      value: function postProcessor(object) {
        var transformOrigin = object.parsedStyle.transformOrigin;
        if (transformOrigin[0].unit === UnitType.kPixels && transformOrigin[1].unit === UnitType.kPixels) {
          object.setOrigin(transformOrigin[0].value, transformOrigin[1].value);
        } else {
          object.getGeometryBounds();
        }
      }
    }]);
  })();
  var CSSPropertyZIndex = /* @__PURE__ */ (function() {
    function CSSPropertyZIndex2() {
      _classCallCheck(this, CSSPropertyZIndex2);
    }
    return _createClass(CSSPropertyZIndex2, [{
      key: "calculator",
      value: function calculator(name, oldParsed, computed, object) {
        return computed.value;
      }
    }, {
      key: "postProcessor",
      value: function postProcessor(object) {
        if (object.parentNode) {
          var parentEntity = object.parentNode;
          var parentRenderable = parentEntity.renderable;
          var parentSortable = parentEntity.sortable;
          if (parentRenderable) {
            parentEntity.dirty();
          }
          if (parentSortable) {
            parentSortable.dirty = true;
            parentSortable.dirtyReason = SortReason.Z_INDEX_CHANGED;
          }
        }
      }
    }]);
  })();
  var CircleUpdater = /* @__PURE__ */ (function() {
    function CircleUpdater2() {
      _classCallCheck(this, CircleUpdater2);
    }
    return _createClass(CircleUpdater2, [{
      key: "update",
      value: function update(parsedStyle, object) {
        var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, _parsedStyle$r = parsedStyle.r, r = _parsedStyle$r === void 0 ? 0 : _parsedStyle$r;
        return {
          cx,
          cy,
          hwidth: r,
          hheight: r
        };
      }
    }]);
  })();
  var EllipseUpdater = /* @__PURE__ */ (function() {
    function EllipseUpdater2() {
      _classCallCheck(this, EllipseUpdater2);
    }
    return _createClass(EllipseUpdater2, [{
      key: "update",
      value: function update(parsedStyle, object) {
        var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, _parsedStyle$rx = parsedStyle.rx, rx = _parsedStyle$rx === void 0 ? 0 : _parsedStyle$rx, _parsedStyle$ry = parsedStyle.ry, ry = _parsedStyle$ry === void 0 ? 0 : _parsedStyle$ry;
        return {
          cx,
          cy,
          hwidth: rx,
          hheight: ry
        };
      }
    }]);
  })();
  var LineUpdater = /* @__PURE__ */ (function() {
    function LineUpdater2() {
      _classCallCheck(this, LineUpdater2);
    }
    return _createClass(LineUpdater2, [{
      key: "update",
      value: function update(parsedStyle) {
        var x1 = parsedStyle.x1, y1 = parsedStyle.y1, x22 = parsedStyle.x2, y22 = parsedStyle.y2;
        var minX = Math.min(x1, x22);
        var maxX = Math.max(x1, x22);
        var minY = Math.min(y1, y22);
        var maxY = Math.max(y1, y22);
        var width2 = maxX - minX;
        var height = maxY - minY;
        var hwidth = width2 / 2;
        var hheight = height / 2;
        return {
          cx: minX + hwidth,
          cy: minY + hheight,
          hwidth,
          hheight
        };
      }
    }]);
  })();
  var PathUpdater = /* @__PURE__ */ (function() {
    function PathUpdater2() {
      _classCallCheck(this, PathUpdater2);
    }
    return _createClass(PathUpdater2, [{
      key: "update",
      value: function update(parsedStyle) {
        var d2 = parsedStyle.d;
        var _d$rect = d2.rect, x3 = _d$rect.x, y3 = _d$rect.y, width2 = _d$rect.width, height = _d$rect.height;
        var hwidth = width2 / 2;
        var hheight = height / 2;
        return {
          cx: x3 + hwidth,
          cy: y3 + hheight,
          hwidth,
          hheight
        };
      }
    }]);
  })();
  var PolylineUpdater = /* @__PURE__ */ (function() {
    function PolylineUpdater2() {
      _classCallCheck(this, PolylineUpdater2);
    }
    return _createClass(PolylineUpdater2, [{
      key: "update",
      value: function update(parsedStyle) {
        if (parsedStyle.points && (0, import_util2.isArray)(parsedStyle.points.points)) {
          var points = parsedStyle.points.points;
          var minX = Math.min.apply(Math, _toConsumableArray(points.map(function(point4) {
            return point4[0];
          })));
          var maxX = Math.max.apply(Math, _toConsumableArray(points.map(function(point4) {
            return point4[0];
          })));
          var minY = Math.min.apply(Math, _toConsumableArray(points.map(function(point4) {
            return point4[1];
          })));
          var maxY = Math.max.apply(Math, _toConsumableArray(points.map(function(point4) {
            return point4[1];
          })));
          var width2 = maxX - minX;
          var height = maxY - minY;
          var hwidth = width2 / 2;
          var hheight = height / 2;
          return {
            cx: minX + hwidth,
            cy: minY + hheight,
            hwidth,
            hheight
          };
        }
        return {
          cx: 0,
          cy: 0,
          hwidth: 0,
          hheight: 0
        };
      }
    }]);
  })();
  var RectUpdater = /* @__PURE__ */ (function() {
    function RectUpdater2() {
      _classCallCheck(this, RectUpdater2);
    }
    return _createClass(RectUpdater2, [{
      key: "update",
      value: function update(parsedStyle, object) {
        var _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, src = parsedStyle.src, _parsedStyle$width = parsedStyle.width, width2 = _parsedStyle$width === void 0 ? 0 : _parsedStyle$width, _parsedStyle$height = parsedStyle.height, height = _parsedStyle$height === void 0 ? 0 : _parsedStyle$height;
        var contentWidth = width2;
        var contentHeight = height;
        if (src && !(0, import_util2.isString)(src)) {
          if (!contentWidth) {
            contentWidth = src.width;
            parsedStyle.width = contentWidth;
          }
          if (!contentHeight) {
            contentHeight = src.height;
            parsedStyle.height = contentHeight;
          }
        }
        return {
          cx: x3 + contentWidth / 2,
          cy: y3 + contentHeight / 2,
          hwidth: contentWidth / 2,
          hheight: contentHeight / 2
        };
      }
    }]);
  })();
  var TextUpdater = /* @__PURE__ */ (function() {
    function TextUpdater2(globalRuntime) {
      _classCallCheck(this, TextUpdater2);
      this.globalRuntime = globalRuntime;
    }
    return _createClass(TextUpdater2, [{
      key: "isReadyToMeasure",
      value: function isReadyToMeasure(parsedStyle, object) {
        var text = parsedStyle.text;
        return text;
      }
    }, {
      key: "update",
      value: function update(parsedStyle, object) {
        var _object$ownerDocument;
        var text = parsedStyle.text, _parsedStyle$textAlig = parsedStyle.textAlign, textAlign = _parsedStyle$textAlig === void 0 ? "start" : _parsedStyle$textAlig, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$textBase = parsedStyle.textBaseline, textBaseline = _parsedStyle$textBase === void 0 ? "alphabetic" : _parsedStyle$textBase, _parsedStyle$dx = parsedStyle.dx, dx = _parsedStyle$dx === void 0 ? 0 : _parsedStyle$dx, _parsedStyle$dy = parsedStyle.dy, dy = _parsedStyle$dy === void 0 ? 0 : _parsedStyle$dy, _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y;
        if (!this.isReadyToMeasure(parsedStyle, object)) {
          parsedStyle.metrics = {
            font: "",
            width: 0,
            height: 0,
            lines: [],
            lineWidths: [],
            lineHeight: 0,
            maxLineWidth: 0,
            fontProperties: {
              ascent: 0,
              descent: 0,
              fontSize: 0
            },
            lineMetrics: []
          };
          return {
            hwidth: 0,
            hheight: 0,
            cx: 0,
            cy: 0
          };
        }
        var _ref = (object === null || object === void 0 || (_object$ownerDocument = object.ownerDocument) === null || _object$ownerDocument === void 0 || (_object$ownerDocument = _object$ownerDocument.defaultView) === null || _object$ownerDocument === void 0 ? void 0 : _object$ownerDocument.getConfig()) || {}, offscreenCanvas = _ref.offscreenCanvas;
        var metrics = this.globalRuntime.textService.measureText(text, parsedStyle, offscreenCanvas);
        parsedStyle.metrics = metrics;
        var width2 = metrics.width, height = metrics.height;
        var hwidth = width2 / 2;
        var hheight = height / 2;
        var lineXOffset = x3 + hwidth;
        if (textAlign === "center" || textAlign === "middle") {
          lineXOffset += lineWidth / 2 - hwidth;
        } else if (textAlign === "right" || textAlign === "end") {
          lineXOffset += lineWidth - hwidth * 2;
        }
        var lineYOffset = y3 - hheight;
        if (textBaseline === "middle") {
          lineYOffset += hheight;
        } else if (textBaseline === "top" || textBaseline === "hanging") {
          lineYOffset += hheight * 2;
        } else if (textBaseline === "alphabetic") ;
        else if (textBaseline === "bottom" || textBaseline === "ideographic") {
          lineYOffset += 0;
        }
        if (dx) {
          lineXOffset += dx;
        }
        if (dy) {
          lineYOffset += dy;
        }
        return {
          cx: lineXOffset,
          cy: lineYOffset,
          hwidth,
          hheight
        };
      }
    }]);
  })();
  var GroupUpdater = /* @__PURE__ */ (function() {
    function GroupUpdater2() {
      _classCallCheck(this, GroupUpdater2);
    }
    return _createClass(GroupUpdater2, [{
      key: "update",
      value: function update(parsedStyle, object) {
        return {
          cx: 0,
          cy: 0,
          hwidth: 0,
          hheight: 0
        };
      }
    }]);
  })();
  var HTMLUpdater = /* @__PURE__ */ (function() {
    function HTMLUpdater2() {
      _classCallCheck(this, HTMLUpdater2);
    }
    return _createClass(HTMLUpdater2, [{
      key: "update",
      value: function update(parsedStyle, object) {
        var _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, _parsedStyle$width = parsedStyle.width, width2 = _parsedStyle$width === void 0 ? 0 : _parsedStyle$width, _parsedStyle$height = parsedStyle.height, height = _parsedStyle$height === void 0 ? 0 : _parsedStyle$height;
        return {
          cx: x3 + width2 / 2,
          cy: y3 + height / 2,
          hwidth: width2 / 2,
          hheight: height / 2
        };
      }
    }]);
  })();
  var FederatedEvent = /* @__PURE__ */ (function() {
    function FederatedEvent2(manager) {
      _classCallCheck(this, FederatedEvent2);
      this.eventPhase = FederatedEvent2.prototype.NONE;
      this.bubbles = true;
      this.cancelBubble = true;
      this.cancelable = false;
      this.defaultPrevented = false;
      this.propagationStopped = false;
      this.propagationImmediatelyStopped = false;
      this.layer = new Point();
      this.page = new Point();
      this.canvas = new Point();
      this.viewport = new Point();
      this.composed = false;
      this.NONE = 0;
      this.CAPTURING_PHASE = 1;
      this.AT_TARGET = 2;
      this.BUBBLING_PHASE = 3;
      this.manager = manager;
    }
    return _createClass(FederatedEvent2, [{
      key: "name",
      get: (
        /**
         * The type of event, supports the following:
         * * pointerdown
         * * touchstart
         * * mousedown
         * * rightdown
         * * ...
         */
        /**
         * @deprecated
         */
        function get9() {
          return this.type;
        }
      )
    }, {
      key: "layerX",
      get: function get9() {
        return this.layer.x;
      }
    }, {
      key: "layerY",
      get: function get9() {
        return this.layer.y;
      }
    }, {
      key: "pageX",
      get: function get9() {
        return this.page.x;
      }
    }, {
      key: "pageY",
      get: function get9() {
        return this.page.y;
      }
    }, {
      key: "x",
      get: function get9() {
        return this.canvas.x;
      }
    }, {
      key: "y",
      get: function get9() {
        return this.canvas.y;
      }
    }, {
      key: "canvasX",
      get: function get9() {
        return this.canvas.x;
      }
    }, {
      key: "canvasY",
      get: function get9() {
        return this.canvas.y;
      }
    }, {
      key: "viewportX",
      get: function get9() {
        return this.viewport.x;
      }
    }, {
      key: "viewportY",
      get: function get9() {
        return this.viewport.y;
      }
    }, {
      key: "composedPath",
      value: (
        /**
         * The propagation path for this event
         * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/composedPath
         *
         * So composedPath()[0] represents the original target.
         * @see https://polymer-library.polymer-project.org/3.0/docs/devguide/events#retargeting
         */
        function composedPath() {
          if (this.manager && (!this.path || this.path[0] !== this.target)) {
            this.path = this.target ? this.manager.propagationPath(this.target) : [];
          }
          return this.path;
        }
      )
      /**
       * @deprecated
       */
    }, {
      key: "propagationPath",
      get: function get9() {
        return this.composedPath();
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault
       */
    }, {
      key: "preventDefault",
      value: function preventDefault() {
        if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
          this.nativeEvent.preventDefault();
        }
        this.defaultPrevented = true;
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopImmediatePropagation
       */
    }, {
      key: "stopImmediatePropagation",
      value: function stopImmediatePropagation() {
        this.propagationImmediatelyStopped = true;
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation
       */
    }, {
      key: "stopPropagation",
      value: function stopPropagation() {
        this.propagationStopped = true;
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/view
       */
    }, {
      key: "initEvent",
      value: (
        /**
         * added for compatibility with DOM Event,
         * deprecated props and methods
         */
        function initEvent() {
        }
      )
    }, {
      key: "initUIEvent",
      value: function initUIEvent() {
      }
    }, {
      key: "clone",
      value: function clone8() {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }]);
  })();
  var FederatedMouseEvent = /* @__PURE__ */ (function(_ref) {
    function FederatedMouseEvent2() {
      var _this2;
      _classCallCheck(this, FederatedMouseEvent2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this2 = _callSuper(this, FederatedMouseEvent2, [].concat(args));
      _this2.client = new Point();
      _this2.movement = new Point();
      _this2.offset = new Point();
      _this2.global = new Point();
      _this2.screen = new Point();
      return _this2;
    }
    _inherits(FederatedMouseEvent2, _ref);
    return _createClass(FederatedMouseEvent2, [{
      key: "clientX",
      get: function get9() {
        return this.client.x;
      }
    }, {
      key: "clientY",
      get: function get9() {
        return this.client.y;
      }
    }, {
      key: "movementX",
      get: function get9() {
        return this.movement.x;
      }
    }, {
      key: "movementY",
      get: function get9() {
        return this.movement.y;
      }
    }, {
      key: "offsetX",
      get: function get9() {
        return this.offset.x;
      }
    }, {
      key: "offsetY",
      get: function get9() {
        return this.offset.y;
      }
    }, {
      key: "globalX",
      get: function get9() {
        return this.global.x;
      }
    }, {
      key: "globalY",
      get: function get9() {
        return this.global.y;
      }
    }, {
      key: "screenX",
      get: function get9() {
        return this.screen.x;
      }
    }, {
      key: "screenY",
      get: function get9() {
        return this.screen.y;
      }
    }, {
      key: "getModifierState",
      value: function getModifierState(key) {
        return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
      }
    }, {
      key: "initMouseEvent",
      value: function initMouseEvent() {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }]);
  })(FederatedEvent);
  var FederatedPointerEvent = /* @__PURE__ */ (function(_FederatedMouseEvent) {
    function FederatedPointerEvent2() {
      var _this2;
      _classCallCheck(this, FederatedPointerEvent2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this2 = _callSuper(this, FederatedPointerEvent2, [].concat(args));
      _this2.width = 0;
      _this2.height = 0;
      _this2.isPrimary = false;
      return _this2;
    }
    _inherits(FederatedPointerEvent2, _FederatedMouseEvent);
    return _createClass(FederatedPointerEvent2, [{
      key: "getCoalescedEvents",
      value: (
        /**
         * The type of pointer that triggered the event.
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType
         */
        /**
         * Pressure applied by the pointing device during the event.
         *s
         * A Touch's force property will be represented by this value.
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure
         */
        /**
         * Barrel pressure on a stylus pointer.
         *
         * @see https://w3c.github.io/pointerevents/#pointerevent-interface
         */
        /**
         * The angle, in degrees, between the pointer device and the screen.
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX
         */
        /**
         * The angle, in degrees, between the pointer device and the screen.
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY
         */
        /**
         * Twist of a stylus pointer.
         *
         * @see https://w3c.github.io/pointerevents/#pointerevent-interface
         */
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/getCoalescedEvents
         */
        function getCoalescedEvents() {
          if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
            return [this];
          }
          return [];
        }
      )
      /**
       * @see https://chromestatus.com/feature/5765569655603200
       */
    }, {
      key: "getPredictedEvents",
      value: function getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!");
      }
      /**
       * @see https://github.com/antvis/G/issues/1115
       * We currently reuses event objects in the event system,
       * avoiding the creation of a large number of event objects.
       * Reused objects are only used to carry different data,
       * such as coordinate information, native event objects,
       * and therefore the lifecycle is limited to the event handler,
       * which can lead to unintended consequences if an attempt is made to cache the entire event object.
       *
       * Therefore, while keeping the above performance considerations in mind, it is possible to provide a clone method that creates a new object when the user really wants to cache it, e.g.
       */
    }, {
      key: "clone",
      value: function clone8() {
        return this.manager.clonePointerEvent(this);
      }
    }]);
  })(FederatedMouseEvent);
  var FederatedWheelEvent = /* @__PURE__ */ (function(_FederatedMouseEvent) {
    function FederatedWheelEvent2() {
      _classCallCheck(this, FederatedWheelEvent2);
      return _callSuper(this, FederatedWheelEvent2, arguments);
    }
    _inherits(FederatedWheelEvent2, _FederatedMouseEvent);
    return _createClass(FederatedWheelEvent2, [{
      key: "clone",
      value: (
        /**
         * The units of `deltaX`, `deltaY`, and `deltaZ`. This is one of `DOM_DELTA_LINE`,
         * `DOM_DELTA_PAGE`, `DOM_DELTA_PIXEL`.
         */
        /** Horizontal scroll amount */
        /** Vertical scroll amount */
        /** z-axis scroll amount. */
        function clone8() {
          return this.manager.cloneWheelEvent(this);
        }
      )
    }]);
  })(FederatedMouseEvent);
  var CustomEvent = /* @__PURE__ */ (function(_FederatedEvent) {
    function CustomEvent2(eventName, object) {
      var _this2;
      _classCallCheck(this, CustomEvent2);
      _this2 = _callSuper(this, CustomEvent2, [null]);
      _this2.type = eventName;
      _this2.detail = object;
      Object.assign(_this2, object);
      return _this2;
    }
    _inherits(CustomEvent2, _FederatedEvent);
    return _createClass(CustomEvent2);
  })(FederatedEvent);
  var EventTarget = /* @__PURE__ */ (function() {
    function EventTarget2() {
      _classCallCheck(this, EventTarget2);
      this.emitter = new eventemitter3_default();
    }
    return _createClass(EventTarget2, [{
      key: "on",
      value: (
        /**
         * @deprecated
         * @alias addEventListener
         */
        function on(type, listener, options) {
          this.addEventListener(type, listener, options);
          return this;
        }
      )
      /**
       * support `capture` & `once` in options
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener
       */
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener, options) {
        var capture = false;
        var once = false;
        if ((0, import_util2.isBoolean)(options)) capture = options;
        else if (options) {
          var _options$capture = options.capture;
          capture = _options$capture === void 0 ? false : _options$capture;
          var _options$once = options.once;
          once = _options$once === void 0 ? false : _options$once;
        }
        if (capture) type += "capture";
        listener = (0, import_util2.isFunction)(listener) ? listener : listener.handleEvent;
        var context = (0, import_util2.isFunction)(listener) ? void 0 : listener;
        if (once) this.emitter.once(type, listener, context);
        else this.emitter.on(type, listener, context);
        return this;
      }
      /**
       * @deprecated
       * @alias removeEventListener
       */
    }, {
      key: "off",
      value: function off(type, listener, options) {
        if (type) {
          this.removeEventListener(type, listener, options);
        } else {
          this.removeAllEventListeners();
        }
        return this;
      }
    }, {
      key: "removeAllEventListeners",
      value: function removeAllEventListeners() {
        var _this$emitter;
        (_this$emitter = this.emitter) === null || _this$emitter === void 0 || _this$emitter.removeAllListeners();
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {
        var _listener;
        if (!this.emitter) return this;
        var capture = (0, import_util2.isBoolean)(options) ? options : options === null || options === void 0 ? void 0 : options.capture;
        if (capture) type += "capture";
        listener = (0, import_util2.isFunction)(listener) ? listener : (_listener = listener) === null || _listener === void 0 ? void 0 : _listener.handleEvent;
        var context = (0, import_util2.isFunction)(listener) ? void 0 : listener;
        this.emitter.off(type, listener, context);
        return this;
      }
      /**
       * @deprecated
       * @alias dispatchEvent
       */
    }, {
      key: "emit",
      value: function emit2(eventName, object) {
        this.dispatchEvent(new CustomEvent(eventName, object));
      }
    }, {
      key: "dispatchEventToSelf",
      value: function dispatchEventToSelf(e) {
        e.target || (e.target = this);
        e.currentTarget = this;
        this.emitter.emit(e.type, e);
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(e) {
        var skipPropagate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var dispatchToSelf = arguments.length > 2 ? arguments[2] : void 0;
        if (dispatchToSelf) {
          this.dispatchEventToSelf(e);
          return true;
        }
        var canvas2;
        if (this.document) {
          canvas2 = this;
        } else if (this.defaultView) {
          canvas2 = this.defaultView;
        } else {
          var _ownerDocument;
          canvas2 = (_ownerDocument = this.ownerDocument) === null || _ownerDocument === void 0 ? void 0 : _ownerDocument.defaultView;
        }
        if (canvas2) {
          e.manager = canvas2.getEventService();
          if (!e.manager) return false;
          e.defaultPrevented = false;
          if (e.path) {
            e.path.length = 0;
          } else {
            e.page = [];
          }
          if (!skipPropagate) {
            e.target = this;
          }
          e.manager.dispatchEvent(e, e.type, skipPropagate);
        } else {
          this.dispatchEventToSelf(e);
        }
        return !e.defaultPrevented;
      }
    }]);
  })();
  var Node = /* @__PURE__ */ (function(_EventTarget) {
    function Node3() {
      var _this2;
      _classCallCheck(this, Node3);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this2 = _callSuper(this, Node3, [].concat(args));
      _this2.shadow = false;
      _this2.ownerDocument = null;
      _this2.isConnected = false;
      _this2.baseURI = "";
      _this2.childNodes = [];
      _this2.nodeType = 0;
      _this2.nodeName = "";
      _this2.nodeValue = null;
      _this2.parentNode = null;
      _this2.destroyed = false;
      return _this2;
    }
    _inherits(Node3, _EventTarget);
    return _createClass(Node3, [{
      key: "textContent",
      get: (
        /**
         * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent
         */
        function get9() {
          var out = "";
          if (this.nodeName === Shape.TEXT) {
            out += this.style.text;
          }
          var _iterator = _createForOfIteratorHelper(this.childNodes), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var _child = _step.value;
              if (_child.nodeName === Shape.TEXT) {
                out += _child.nodeValue;
              } else {
                out += _child.textContent;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return out;
        }
      ),
      set: function set6(content) {
        var _this2 = this;
        this.childNodes.slice().forEach(function(child) {
          _this2.removeChild(child);
        });
        if (this.nodeName === Shape.TEXT) {
          this.style.text = "".concat(content);
        }
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/getRootNode
       */
    }, {
      key: "getRootNode",
      value: function getRootNode() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (this.parentNode) {
          return this.parentNode.getRootNode(opts);
        }
        if (opts.composed && this.host) {
          return this.host.getRootNode(opts);
        }
        return this;
      }
    }, {
      key: "hasChildNodes",
      value: function hasChildNodes() {
        return this.childNodes.length > 0;
      }
    }, {
      key: "isDefaultNamespace",
      value: function isDefaultNamespace(namespace) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "lookupNamespaceURI",
      value: function lookupNamespaceURI(prefix) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "lookupPrefix",
      value: function lookupPrefix(namespace) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "normalize",
      value: function normalize5() {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/isEqualNode
       */
    }, {
      key: "isEqualNode",
      value: function isEqualNode(otherNode) {
        return this === otherNode;
      }
    }, {
      key: "isSameNode",
      value: function isSameNode2(otherNode) {
        return this.isEqualNode(otherNode);
      }
    }, {
      key: "parent",
      get: (
        /**
         * @deprecated
         * @alias parentNode
         */
        function get9() {
          return this.parentNode;
        }
      )
    }, {
      key: "parentElement",
      get: function get9() {
        return null;
      }
    }, {
      key: "nextSibling",
      get: function get9() {
        return null;
      }
    }, {
      key: "previousSibling",
      get: function get9() {
        return null;
      }
    }, {
      key: "firstChild",
      get: function get9() {
        return this.childNodes.length > 0 ? this.childNodes[0] : null;
      }
    }, {
      key: "lastChild",
      get: function get9() {
        return this.childNodes.length > 0 ? this.childNodes[this.childNodes.length - 1] : null;
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
       * @see https://github.com/b-fuze/deno-dom/blob/master/src/dom/node.ts#L338
       */
    }, {
      key: "compareDocumentPosition",
      value: function compareDocumentPosition(other) {
        if (other === this) {
          return 0;
        }
        var node1Root = other;
        var node2Root = this;
        var node1Hierarchy = [node1Root];
        var node2Hierarchy = [node2Root];
        while ((_node1Root$parentNode = node1Root.parentNode) !== null && _node1Root$parentNode !== void 0 ? _node1Root$parentNode : node2Root.parentNode) {
          var _node1Root$parentNode;
          node1Root = node1Root.parentNode ? (node1Hierarchy.push(node1Root.parentNode), node1Root.parentNode) : node1Root;
          node2Root = node2Root.parentNode ? (node2Hierarchy.push(node2Root.parentNode), node2Root.parentNode) : node2Root;
        }
        if (node1Root !== node2Root) {
          return Node3.DOCUMENT_POSITION_DISCONNECTED | Node3.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node3.DOCUMENT_POSITION_PRECEDING;
        }
        var longerHierarchy = node1Hierarchy.length > node2Hierarchy.length ? node1Hierarchy : node2Hierarchy;
        var shorterHierarchy = longerHierarchy === node1Hierarchy ? node2Hierarchy : node1Hierarchy;
        if (longerHierarchy[longerHierarchy.length - shorterHierarchy.length] === shorterHierarchy[0]) {
          return longerHierarchy === node1Hierarchy ? (
            // other is a child of this
            Node3.DOCUMENT_POSITION_CONTAINED_BY | Node3.DOCUMENT_POSITION_FOLLOWING
          ) : (
            // this is a child of other
            Node3.DOCUMENT_POSITION_CONTAINS | Node3.DOCUMENT_POSITION_PRECEDING
          );
        }
        var longerStart = longerHierarchy.length - shorterHierarchy.length;
        for (var i = shorterHierarchy.length - 1; i >= 0; i--) {
          var shorterHierarchyNode = shorterHierarchy[i];
          var longerHierarchyNode = longerHierarchy[longerStart + i];
          if (longerHierarchyNode !== shorterHierarchyNode) {
            var siblings = shorterHierarchyNode.parentNode.childNodes;
            if (siblings.indexOf(shorterHierarchyNode) < siblings.indexOf(longerHierarchyNode)) {
              if (shorterHierarchy === node1Hierarchy) {
                return Node3.DOCUMENT_POSITION_PRECEDING;
              }
              return Node3.DOCUMENT_POSITION_FOLLOWING;
            }
            if (longerHierarchy === node1Hierarchy) {
              return Node3.DOCUMENT_POSITION_PRECEDING;
            }
            return Node3.DOCUMENT_POSITION_FOLLOWING;
          }
        }
        return Node3.DOCUMENT_POSITION_FOLLOWING;
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/cloneNode
       */
    }, {
      key: "contain",
      value: (
        /**
         * @deprecated
         * @alias contains
         */
        function contain2(other) {
          return this.contains(other);
        }
      )
    }, {
      key: "contains",
      value: function contains(other) {
        var tmp2 = other;
        while (tmp2 && this !== tmp2) {
          tmp2 = tmp2.parentNode;
        }
        return !!tmp2;
      }
    }, {
      key: "getAncestor",
      value: function getAncestor(n) {
        var temp = this;
        while (n > 0 && temp) {
          temp = temp.parentNode;
          n--;
        }
        return temp;
      }
    }, {
      key: "forEach",
      value: function forEach(callback) {
        var stack = [this];
        while (stack.length > 0) {
          var node = stack.pop();
          var result = callback(node);
          if (result === false) {
            break;
          }
          for (var i = node.childNodes.length - 1; i >= 0; i--) {
            stack.push(node.childNodes[i]);
          }
        }
      }
    }], [{
      key: "isNode",
      value: function isNode2(target) {
        return !!target.childNodes;
      }
    }]);
  })(EventTarget);
  Node.DOCUMENT_POSITION_DISCONNECTED = 1;
  Node.DOCUMENT_POSITION_PRECEDING = 2;
  Node.DOCUMENT_POSITION_FOLLOWING = 4;
  Node.DOCUMENT_POSITION_CONTAINS = 8;
  Node.DOCUMENT_POSITION_CONTAINED_BY = 16;
  Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
  var PROPAGATION_LIMIT = 2048;
  var EventService = /* @__PURE__ */ (function() {
    function EventService2(globalRuntime, context) {
      var _this2 = this;
      _classCallCheck(this, EventService2);
      this.nativeHTMLMap = /* @__PURE__ */ new WeakMap();
      this.cursor = "default";
      this.mappingTable = {};
      this.mappingState = {
        trackingData: {}
      };
      this.eventPool = /* @__PURE__ */ new Map();
      this.tmpMatrix = import_gl_matrix2.mat4.create();
      this.tmpVec3 = import_gl_matrix2.vec3.create();
      this.onPointerDown = function(from) {
        var e = _this2.createPointerEvent(from);
        _this2.dispatchEvent(e, "pointerdown");
        if (e.pointerType === "touch") {
          _this2.dispatchEvent(e, "touchstart");
        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
          var isRightButton = e.button === 2;
          _this2.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");
        }
        var trackingData = _this2.trackingData(from.pointerId);
        trackingData.pressTargetsByButton[from.button] = e.composedPath();
        _this2.freeEvent(e);
      };
      this.onPointerUp = function(from) {
        var now2 = clock.now();
        var e = _this2.createPointerEvent(from, void 0, void 0, _this2.context.config.alwaysTriggerPointerEventOnCanvas ? _this2.rootTarget : void 0);
        _this2.dispatchEvent(e, "pointerup");
        if (e.pointerType === "touch") {
          _this2.dispatchEvent(e, "touchend");
        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
          var isRightButton = e.button === 2;
          _this2.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");
        }
        var trackingData = _this2.trackingData(from.pointerId);
        var pressTarget = _this2.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        var clickTarget = pressTarget;
        if (pressTarget && !e.composedPath().includes(pressTarget)) {
          var currentTarget = pressTarget;
          while (currentTarget && !e.composedPath().includes(currentTarget)) {
            e.currentTarget = currentTarget;
            _this2.notifyTarget(e, "pointerupoutside");
            if (e.pointerType === "touch") {
              _this2.notifyTarget(e, "touchendoutside");
            } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
              var _isRightButton = e.button === 2;
              _this2.notifyTarget(e, _isRightButton ? "rightupoutside" : "mouseupoutside");
            }
            if (Node.isNode(currentTarget)) {
              currentTarget = currentTarget.parentNode;
            }
          }
          delete trackingData.pressTargetsByButton[from.button];
          clickTarget = currentTarget;
        }
        if (clickTarget) {
          var _e$detail;
          var clickEvent = _this2.clonePointerEvent(e, "click");
          clickEvent.target = clickTarget;
          clickEvent.path = [];
          if (!trackingData.clicksByButton[from.button]) {
            trackingData.clicksByButton[from.button] = {
              clickCount: 0,
              target: clickEvent.target,
              timeStamp: now2
            };
          }
          var canvas2 = _this2.context.renderingContext.root.ownerDocument.defaultView;
          var clickHistory = trackingData.clicksByButton[from.button];
          if (clickHistory.target === clickEvent.target && now2 - clickHistory.timeStamp < canvas2.getConfig().dblClickSpeed) {
            ++clickHistory.clickCount;
          } else {
            clickHistory.clickCount = 1;
          }
          clickHistory.target = clickEvent.target;
          clickHistory.timeStamp = now2;
          clickEvent.detail = clickHistory.clickCount;
          if (!((_e$detail = e.detail) !== null && _e$detail !== void 0 && _e$detail.preventClick)) {
            if (!_this2.context.config.useNativeClickEvent && (clickEvent.pointerType === "mouse" || clickEvent.pointerType === "touch")) {
              _this2.dispatchEvent(clickEvent, "click");
            }
            _this2.dispatchEvent(clickEvent, "pointertap");
          }
          _this2.freeEvent(clickEvent);
        }
        _this2.freeEvent(e);
      };
      this.onPointerMove = function(from) {
        var e = _this2.createPointerEvent(from, void 0, void 0, _this2.context.config.alwaysTriggerPointerEventOnCanvas ? _this2.rootTarget : void 0);
        var isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
        var trackingData = _this2.trackingData(from.pointerId);
        var outTarget = _this2.findMountedTarget(trackingData.overTargets);
        if (trackingData.overTargets && outTarget !== e.target) {
          var outType = from.type === "mousemove" ? "mouseout" : "pointerout";
          var outEvent = _this2.createPointerEvent(from, outType, outTarget || void 0);
          _this2.dispatchEvent(outEvent, "pointerout");
          if (isMouse) _this2.dispatchEvent(outEvent, "mouseout");
          if (!e.composedPath().includes(outTarget)) {
            var leaveEvent = _this2.createPointerEvent(from, "pointerleave", outTarget || void 0);
            leaveEvent.eventPhase = leaveEvent.AT_TARGET;
            while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {
              leaveEvent.currentTarget = leaveEvent.target;
              _this2.notifyTarget(leaveEvent);
              if (isMouse) {
                _this2.notifyTarget(leaveEvent, "mouseleave");
              }
              if (Node.isNode(leaveEvent.target)) {
                leaveEvent.target = leaveEvent.target.parentNode;
              }
            }
            _this2.freeEvent(leaveEvent);
          }
          _this2.freeEvent(outEvent);
        }
        if (outTarget !== e.target) {
          var overType = from.type === "mousemove" ? "mouseover" : "pointerover";
          var overEvent = _this2.clonePointerEvent(e, overType);
          _this2.dispatchEvent(overEvent, "pointerover");
          if (isMouse) _this2.dispatchEvent(overEvent, "mouseover");
          var overTargetAncestor = outTarget && Node.isNode(outTarget) && outTarget.parentNode;
          while (overTargetAncestor && overTargetAncestor !== (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
            if (overTargetAncestor === e.target) break;
            overTargetAncestor = overTargetAncestor.parentNode;
          }
          var didPointerEnter = !overTargetAncestor || overTargetAncestor === (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode);
          if (didPointerEnter) {
            var enterEvent = _this2.clonePointerEvent(e, "pointerenter");
            enterEvent.eventPhase = enterEvent.AT_TARGET;
            while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
              enterEvent.currentTarget = enterEvent.target;
              _this2.notifyTarget(enterEvent);
              if (isMouse) _this2.notifyTarget(enterEvent, "mouseenter");
              if (Node.isNode(enterEvent.target)) {
                enterEvent.target = enterEvent.target.parentNode;
              }
            }
            _this2.freeEvent(enterEvent);
          }
          _this2.freeEvent(overEvent);
        }
        _this2.dispatchEvent(e, "pointermove");
        if (e.pointerType === "touch") _this2.dispatchEvent(e, "touchmove");
        if (isMouse) {
          _this2.dispatchEvent(e, "mousemove");
          _this2.cursor = _this2.getCursor(e.target);
        }
        trackingData.overTargets = e.composedPath();
        _this2.freeEvent(e);
      };
      this.onPointerOut = function(from) {
        var trackingData = _this2.trackingData(from.pointerId);
        if (trackingData.overTargets) {
          var isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
          var outTarget = _this2.findMountedTarget(trackingData.overTargets);
          var outEvent = _this2.createPointerEvent(from, "pointerout", outTarget || void 0);
          _this2.dispatchEvent(outEvent);
          if (isMouse) _this2.dispatchEvent(outEvent, "mouseout");
          var leaveEvent = _this2.createPointerEvent(from, "pointerleave", outTarget || void 0);
          leaveEvent.eventPhase = leaveEvent.AT_TARGET;
          while (leaveEvent.target && leaveEvent.target !== (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
            leaveEvent.currentTarget = leaveEvent.target;
            _this2.notifyTarget(leaveEvent);
            if (isMouse) {
              _this2.notifyTarget(leaveEvent, "mouseleave");
            }
            if (Node.isNode(leaveEvent.target)) {
              leaveEvent.target = leaveEvent.target.parentNode;
            }
          }
          trackingData.overTargets = null;
          _this2.freeEvent(outEvent);
          _this2.freeEvent(leaveEvent);
        }
        _this2.cursor = null;
      };
      this.onPointerOver = function(from) {
        var trackingData = _this2.trackingData(from.pointerId);
        var e = _this2.createPointerEvent(from);
        var isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
        _this2.dispatchEvent(e, "pointerover");
        if (isMouse) _this2.dispatchEvent(e, "mouseover");
        if (e.pointerType === "mouse") _this2.cursor = _this2.getCursor(e.target);
        var enterEvent = _this2.clonePointerEvent(e, "pointerenter");
        enterEvent.eventPhase = enterEvent.AT_TARGET;
        while (enterEvent.target && enterEvent.target !== (Node.isNode(_this2.rootTarget) && _this2.rootTarget.parentNode)) {
          enterEvent.currentTarget = enterEvent.target;
          _this2.notifyTarget(enterEvent);
          if (isMouse) {
            _this2.notifyTarget(enterEvent, "mouseenter");
          }
          if (Node.isNode(enterEvent.target)) {
            enterEvent.target = enterEvent.target.parentNode;
          }
        }
        trackingData.overTargets = e.composedPath();
        _this2.freeEvent(e);
        _this2.freeEvent(enterEvent);
      };
      this.onPointerUpOutside = function(from) {
        var trackingData = _this2.trackingData(from.pointerId);
        var pressTarget = _this2.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        var e = _this2.createPointerEvent(from);
        if (pressTarget) {
          var currentTarget = pressTarget;
          while (currentTarget) {
            e.currentTarget = currentTarget;
            _this2.notifyTarget(e, "pointerupoutside");
            if (e.pointerType === "touch") ;
            else if (e.pointerType === "mouse" || e.pointerType === "pen") {
              _this2.notifyTarget(e, e.button === 2 ? "rightupoutside" : "mouseupoutside");
            }
            if (Node.isNode(currentTarget)) {
              currentTarget = currentTarget.parentNode;
            }
          }
          delete trackingData.pressTargetsByButton[from.button];
        }
        _this2.freeEvent(e);
      };
      this.onWheel = function(from) {
        var wheelEvent = _this2.createWheelEvent(from);
        _this2.dispatchEvent(wheelEvent);
        _this2.freeEvent(wheelEvent);
      };
      this.onClick = function(from) {
        if (_this2.context.config.useNativeClickEvent) {
          var e = _this2.createPointerEvent(from);
          _this2.dispatchEvent(e);
          _this2.freeEvent(e);
        }
      };
      this.onPointerCancel = function(from) {
        var e = _this2.createPointerEvent(from, void 0, void 0, _this2.context.config.alwaysTriggerPointerEventOnCanvas ? _this2.rootTarget : void 0);
        _this2.dispatchEvent(e);
        _this2.freeEvent(e);
      };
      this.globalRuntime = globalRuntime;
      this.context = context;
    }
    return _createClass(EventService2, [{
      key: "init",
      value: function init() {
        this.rootTarget = this.context.renderingContext.root.parentNode;
        this.addEventMapping("pointerdown", this.onPointerDown);
        this.addEventMapping("pointerup", this.onPointerUp);
        this.addEventMapping("pointermove", this.onPointerMove);
        this.addEventMapping("pointerout", this.onPointerOut);
        this.addEventMapping("pointerleave", this.onPointerOut);
        this.addEventMapping("pointercancel", this.onPointerCancel);
        this.addEventMapping("pointerover", this.onPointerOver);
        this.addEventMapping("pointerupoutside", this.onPointerUpOutside);
        this.addEventMapping("wheel", this.onWheel);
        this.addEventMapping("click", this.onClick);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.mappingTable = {};
        this.mappingState = {};
        this.eventPool.clear();
      }
    }, {
      key: "getScale",
      value: function getScale() {
        var bbox = this.context.contextService.getBoundingClientRect();
        var scaleX2 = 1;
        var scaleY2 = 1;
        var $el = this.context.contextService.getDomElement();
        if ($el && bbox) {
          var offsetWidth = $el.offsetWidth, offsetHeight = $el.offsetHeight;
          if (offsetWidth && offsetHeight) {
            scaleX2 = bbox.width / offsetWidth;
            scaleY2 = bbox.height / offsetHeight;
          }
        }
        return {
          scaleX: scaleX2,
          scaleY: scaleY2,
          bbox
        };
      }
      /**
       * Should account for CSS Transform applied on container.
       * @see https://github.com/antvis/G/issues/1161
       * @see https://github.com/antvis/G/issues/1677
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/offsetX
       */
    }, {
      key: "client2Viewport",
      value: function client2Viewport(client) {
        var _this$getScale = this.getScale(), scaleX2 = _this$getScale.scaleX, scaleY2 = _this$getScale.scaleY, bbox = _this$getScale.bbox;
        return new Point((client.x - ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0)) / scaleX2, (client.y - ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0)) / scaleY2);
      }
    }, {
      key: "viewport2Client",
      value: function viewport2Client(canvas2) {
        var _this$getScale2 = this.getScale(), scaleX2 = _this$getScale2.scaleX, scaleY2 = _this$getScale2.scaleY, bbox = _this$getScale2.bbox;
        return new Point((canvas2.x + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0)) * scaleX2, (canvas2.y + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0)) * scaleY2);
      }
    }, {
      key: "viewport2Canvas",
      value: function viewport2Canvas(_ref) {
        var x3 = _ref.x, y3 = _ref.y;
        var canvas2 = this.rootTarget.defaultView;
        var camera = canvas2.getCamera();
        var _this$context$config = this.context.config, width2 = _this$context$config.width, height = _this$context$config.height;
        var projectionMatrixInverse = camera.getPerspectiveInverse();
        var worldMatrix = camera.getWorldTransform();
        var vpMatrix = import_gl_matrix2.mat4.multiply(this.tmpMatrix, worldMatrix, projectionMatrixInverse);
        var viewport = import_gl_matrix2.vec3.set(this.tmpVec3, x3 / width2 * 2 - 1, (1 - y3 / height) * 2 - 1, 0);
        import_gl_matrix2.vec3.transformMat4(viewport, viewport, vpMatrix);
        return new Point(viewport[0], viewport[1]);
      }
    }, {
      key: "canvas2Viewport",
      value: function canvas2Viewport(canvasP) {
        var canvas2 = this.rootTarget.defaultView;
        var camera = canvas2.getCamera();
        var projectionMatrix = camera.getPerspective();
        var viewMatrix = camera.getViewTransform();
        var vpMatrix = import_gl_matrix2.mat4.multiply(this.tmpMatrix, projectionMatrix, viewMatrix);
        var clip = import_gl_matrix2.vec3.set(this.tmpVec3, canvasP.x, canvasP.y, 0);
        import_gl_matrix2.vec3.transformMat4(this.tmpVec3, this.tmpVec3, vpMatrix);
        var _this$context$config2 = this.context.config, width2 = _this$context$config2.width, height = _this$context$config2.height;
        return new Point((clip[0] + 1) / 2 * width2, (1 - (clip[1] + 1) / 2) * height);
      }
    }, {
      key: "setPickHandler",
      value: function setPickHandler(pickHandler) {
        this.pickHandler = pickHandler;
      }
    }, {
      key: "addEventMapping",
      value: function addEventMapping(type, fn) {
        if (!this.mappingTable[type]) {
          this.mappingTable[type] = [];
        }
        this.mappingTable[type].push({
          fn,
          priority: 0
        });
        this.mappingTable[type].sort(function(a2, b) {
          return a2.priority - b.priority;
        });
      }
    }, {
      key: "mapEvent",
      value: function mapEvent(e) {
        if (!this.rootTarget) {
          return;
        }
        var mappers = this.mappingTable[e.type];
        if (mappers) {
          for (var i = 0, j = mappers.length; i < j; i++) {
            mappers[i].fn(e);
          }
        } else {
          console.warn("[EventService]: Event mapping not defined for ".concat(e.type));
        }
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(e, type, skipPropagate) {
        if (!skipPropagate) {
          e.propagationStopped = false;
          e.propagationImmediatelyStopped = false;
          this.propagate(e, type);
        } else {
          e.eventPhase = e.AT_TARGET;
          var canvas2 = this.rootTarget.defaultView || null;
          e.currentTarget = canvas2;
          this.notifyListeners(e, type);
        }
      }
    }, {
      key: "propagate",
      value: function propagate(e, type) {
        if (!e.target) {
          return;
        }
        var composedPath = e.composedPath();
        e.eventPhase = e.CAPTURING_PHASE;
        for (var i = composedPath.length - 1; i >= 1; i--) {
          e.currentTarget = composedPath[i];
          this.notifyTarget(e, type);
          if (e.propagationStopped || e.propagationImmediatelyStopped) return;
        }
        e.eventPhase = e.AT_TARGET;
        e.currentTarget = e.target;
        this.notifyTarget(e, type);
        if (e.propagationStopped || e.propagationImmediatelyStopped) return;
        var index2 = composedPath.indexOf(e.currentTarget);
        e.eventPhase = e.BUBBLING_PHASE;
        for (var _i = index2 + 1; _i < composedPath.length; _i++) {
          e.currentTarget = composedPath[_i];
          this.notifyTarget(e, type);
          if (e.propagationStopped || e.propagationImmediatelyStopped) return;
        }
      }
    }, {
      key: "propagationPath",
      value: function propagationPath(target) {
        var propagationPath2 = [target];
        var canvas2 = this.rootTarget.defaultView || null;
        if (canvas2 && canvas2 === target) {
          propagationPath2.unshift(canvas2.document);
          return propagationPath2;
        }
        for (var i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {
          if (Node.isNode(target) && target.parentNode) {
            propagationPath2.push(target.parentNode);
            target = target.parentNode;
          }
        }
        if (canvas2) {
          propagationPath2.push(canvas2);
        }
        return propagationPath2;
      }
    }, {
      key: "hitTest",
      value: function hitTest(position2) {
        var viewportX = position2.viewportX, viewportY = position2.viewportY;
        var _this$context$config3 = this.context.config, width2 = _this$context$config3.width, height = _this$context$config3.height, disableHitTesting = _this$context$config3.disableHitTesting;
        if (viewportX < 0 || viewportY < 0 || viewportX > width2 || viewportY > height) {
          return null;
        }
        return !disableHitTesting && this.pickHandler(position2) || this.rootTarget || // return Document
        null;
      }
      /**
       * whether the native event trigger came from Canvas,
       * should account for HTML shape
       */
    }, {
      key: "isNativeEventFromCanvas",
      value: function isNativeEventFromCanvas($el, nativeEvent) {
        var _target;
        var target = nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.target;
        if ((_target = target) !== null && _target !== void 0 && _target.shadowRoot) {
          target = nativeEvent.composedPath()[0];
        }
        if (target) {
          if (target === $el) {
            return true;
          }
          if ($el && $el.contains) {
            return $el.contains(target);
          }
        }
        if (nativeEvent !== null && nativeEvent !== void 0 && nativeEvent.composedPath) {
          return nativeEvent.composedPath().indexOf($el) > -1;
        }
        return false;
      }
      /**
       * Find HTML from composed path in native UI event.
       */
    }, {
      key: "getExistedHTML",
      value: function getExistedHTML(event) {
        if (event.nativeEvent.composedPath) {
          for (var _i2 = 0, _arr = event.nativeEvent.composedPath(); _i2 < _arr.length; _i2++) {
            var eventTarget = _arr[_i2];
            var existed = this.nativeHTMLMap.get(eventTarget);
            if (existed) {
              return existed;
            }
          }
        }
        return null;
      }
    }, {
      key: "pickTarget",
      value: function pickTarget(event) {
        return this.hitTest({
          clientX: event.clientX,
          clientY: event.clientY,
          viewportX: event.viewportX,
          viewportY: event.viewportY,
          x: event.canvasX,
          y: event.canvasY
        });
      }
    }, {
      key: "createPointerEvent",
      value: function createPointerEvent(from, type, target, fallbackTarget) {
        var event = this.allocateEvent(FederatedPointerEvent);
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        var existedHTML = this.getExistedHTML(event);
        var $el = this.context.contextService.getDomElement();
        event.target = target !== null && target !== void 0 ? target : existedHTML || this.isNativeEventFromCanvas($el, event.nativeEvent) && this.pickTarget(event) || fallbackTarget;
        if (typeof type === "string") {
          event.type = type;
        }
        return event;
      }
    }, {
      key: "createWheelEvent",
      value: function createWheelEvent(from) {
        var event = this.allocateEvent(FederatedWheelEvent);
        this.copyWheelData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        var existedHTML = this.getExistedHTML(event);
        var $el = this.context.contextService.getDomElement();
        event.target = existedHTML || this.isNativeEventFromCanvas($el, event.nativeEvent) && this.pickTarget(event);
        return event;
      }
    }, {
      key: "trackingData",
      value: function trackingData(id3) {
        if (!this.mappingState.trackingData[id3]) {
          this.mappingState.trackingData[id3] = {
            pressTargetsByButton: {},
            clicksByButton: {},
            overTarget: null
          };
        }
        return this.mappingState.trackingData[id3];
      }
    }, {
      key: "cloneWheelEvent",
      value: function cloneWheelEvent(from) {
        var event = this.allocateEvent(FederatedWheelEvent);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from.originalEvent;
        this.copyWheelData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.target = from.target;
        event.path = from.composedPath().slice();
        event.type = from.type;
        return event;
      }
    }, {
      key: "clonePointerEvent",
      value: function clonePointerEvent(from, type) {
        var event = this.allocateEvent(FederatedPointerEvent);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from.originalEvent;
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.target = from.target;
        event.path = from.composedPath().slice();
        event.type = type !== null && type !== void 0 ? type : event.type;
        return event;
      }
    }, {
      key: "copyPointerData",
      value: function copyPointerData(from, to) {
        to.pointerId = from.pointerId;
        to.width = from.width;
        to.height = from.height;
        to.isPrimary = from.isPrimary;
        to.pointerType = from.pointerType;
        to.pressure = from.pressure;
        to.tangentialPressure = from.tangentialPressure;
        to.tiltX = from.tiltX;
        to.tiltY = from.tiltY;
        to.twist = from.twist;
      }
    }, {
      key: "copyMouseData",
      value: function copyMouseData(from, to) {
        to.altKey = from.altKey;
        to.button = from.button;
        to.buttons = from.buttons;
        to.ctrlKey = from.ctrlKey;
        to.metaKey = from.metaKey;
        to.shiftKey = from.shiftKey;
        to.client.copyFrom(from.client);
        to.movement.copyFrom(from.movement);
        to.canvas.copyFrom(from.canvas);
        to.screen.copyFrom(from.screen);
        to.global.copyFrom(from.global);
        to.offset.copyFrom(from.offset);
      }
    }, {
      key: "copyWheelData",
      value: function copyWheelData(from, to) {
        to.deltaMode = from.deltaMode;
        to.deltaX = from.deltaX;
        to.deltaY = from.deltaY;
        to.deltaZ = from.deltaZ;
      }
    }, {
      key: "copyData",
      value: function copyData(from, to) {
        to.isTrusted = from.isTrusted;
        to.timeStamp = clock.now();
        to.type = from.type;
        to.detail = from.detail;
        to.view = from.view;
        to.page.copyFrom(from.page);
        to.viewport.copyFrom(from.viewport);
      }
    }, {
      key: "allocateEvent",
      value: function allocateEvent(constructor) {
        if (!this.eventPool.has(constructor)) {
          this.eventPool.set(constructor, []);
        }
        var event = this.eventPool.get(constructor).pop() || new constructor(this);
        event.eventPhase = event.NONE;
        event.currentTarget = null;
        event.path = [];
        event.target = null;
        return event;
      }
    }, {
      key: "freeEvent",
      value: function freeEvent(event) {
        if (event.manager !== this) throw new Error("It is illegal to free an event not managed by this EventBoundary!");
        var constructor = event.constructor;
        if (!this.eventPool.has(constructor)) {
          this.eventPool.set(constructor, []);
        }
        this.eventPool.get(constructor).push(event);
      }
    }, {
      key: "notifyTarget",
      value: function notifyTarget(e, type) {
        type = type !== null && type !== void 0 ? type : e.type;
        var key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? "".concat(type, "capture") : type;
        this.notifyListeners(e, key);
        if (e.eventPhase === e.AT_TARGET) {
          this.notifyListeners(e, type);
        }
      }
    }, {
      key: "notifyListeners",
      value: function notifyListeners(e, type) {
        var emitter = e.currentTarget.emitter;
        var listeners = emitter._events[type];
        if (!listeners) return;
        if ("fn" in listeners) {
          if (listeners.once) {
            emitter.removeListener(type, listeners.fn, void 0, true);
          }
          listeners.fn.call(e.currentTarget || listeners.context, e);
        } else {
          for (var i = 0; i < listeners.length && !e.propagationImmediatelyStopped; i++) {
            if (listeners[i].once) {
              emitter.removeListener(type, listeners[i].fn, void 0, true);
            }
            listeners[i].fn.call(e.currentTarget || listeners[i].context, e);
          }
        }
      }
      /**
       * some detached nodes may exist in propagation path, need to skip them
       */
    }, {
      key: "findMountedTarget",
      value: function findMountedTarget(propagationPath) {
        if (!propagationPath) {
          return null;
        }
        var currentTarget = propagationPath[propagationPath.length - 1];
        for (var i = propagationPath.length - 2; i >= 0; i--) {
          var target = propagationPath[i];
          if (target === this.rootTarget || Node.isNode(target) && target.parentNode === currentTarget) {
            currentTarget = propagationPath[i];
          } else {
            break;
          }
        }
        return currentTarget;
      }
    }, {
      key: "getCursor",
      value: function getCursor(target) {
        var tmp2 = target;
        while (tmp2) {
          var cursor = isElement(tmp2) && tmp2.getAttribute("cursor");
          if (cursor) {
            return cursor;
          }
          tmp2 = Node.isNode(tmp2) && tmp2.parentNode;
        }
      }
    }]);
  })();
  var OffscreenCanvasCreator = /* @__PURE__ */ (function() {
    function OffscreenCanvasCreator2() {
      _classCallCheck(this, OffscreenCanvasCreator2);
    }
    return _createClass(OffscreenCanvasCreator2, [{
      key: "getOrCreateCanvas",
      value: function getOrCreateCanvas(offscreenCanvas, contextAttributes) {
        if (this.canvas) {
          return this.canvas;
        }
        if (offscreenCanvas || runtime.offscreenCanvas) {
          this.canvas = offscreenCanvas || runtime.offscreenCanvas;
          this.context = this.canvas.getContext("2d", _objectSpread2({
            willReadFrequently: true
          }, contextAttributes));
        } else {
          try {
            this.canvas = new window.OffscreenCanvas(0, 0);
            this.context = this.canvas.getContext("2d", _objectSpread2({
              willReadFrequently: true
            }, contextAttributes));
            if (!this.context || !this.context.measureText) {
              this.canvas = document.createElement("canvas");
              this.context = this.canvas.getContext("2d");
            }
          } catch (_unused) {
            this.canvas = document.createElement("canvas");
            this.context = this.canvas.getContext("2d", _objectSpread2({
              willReadFrequently: true
            }, contextAttributes));
          }
        }
        this.canvas.width = 10;
        this.canvas.height = 10;
        return this.canvas;
      }
    }, {
      key: "getOrCreateContext",
      value: function getOrCreateContext(offscreenCanvas, contextAttributes) {
        if (this.context) {
          return this.context;
        }
        this.getOrCreateCanvas(offscreenCanvas, contextAttributes);
        return this.context;
      }
    }], [{
      key: "createCanvas",
      value: (
        /**
         * @returns new canvas instance
         */
        function createCanvas2() {
          try {
            return new window.OffscreenCanvas(0, 0);
          } catch (_unused2) {
          }
          try {
            return document.createElement("canvas");
          } catch (_unused3) {
          }
          return null;
        }
      )
    }]);
  })();
  var RenderReason = /* @__PURE__ */ (function(RenderReason2) {
    RenderReason2[RenderReason2["CAMERA_CHANGED"] = 0] = "CAMERA_CHANGED";
    RenderReason2[RenderReason2["DISPLAY_OBJECT_CHANGED"] = 1] = "DISPLAY_OBJECT_CHANGED";
    RenderReason2[RenderReason2["NONE"] = 2] = "NONE";
    return RenderReason2;
  })({});
  var RenderingService = /* @__PURE__ */ (function() {
    function RenderingService2(globalRuntime, context) {
      _classCallCheck(this, RenderingService2);
      this.inited = false;
      this.stats = {
        /**
         * total display objects in scenegraph
         */
        total: 0,
        /**
         * number of display objects need to render in current frame
         */
        rendered: 0
      };
      this.zIndexCounter = 0;
      this.hooks = {
        /**
         * called before any frame rendered
         */
        init: new SyncHook(),
        initAsync: new AsyncParallelHook(),
        /**
         * only dirty object which has sth changed will be rendered
         */
        dirtycheck: new SyncWaterfallHook(),
        /**
         * do culling
         */
        cull: new SyncWaterfallHook(),
        /**
         * called at beginning of each frame, won't get called if nothing to re-render
         */
        beginFrame: new SyncHook(),
        /**
         * called before every dirty object get rendered
         */
        beforeRender: new SyncHook(),
        /**
         * called when every dirty object rendering even it's culled
         */
        render: new SyncHook(),
        /**
         * called after every dirty object get rendered
         */
        afterRender: new SyncHook(),
        /**
         * commit - draw the result on the canvas
         */
        endFrame: new SyncHook(),
        destroy: new SyncHook(),
        /**
         * use async but faster method such as GPU-based picking in `g-plugin-device-renderer`
         */
        pick: new AsyncSeriesWaterfallHook(),
        /**
         * Unsafe but sync version of pick.
         */
        pickSync: new SyncWaterfallHook(),
        /**
         * used in event system
         */
        pointerDown: new SyncHook(),
        pointerUp: new SyncHook(),
        pointerMove: new SyncHook(),
        pointerOut: new SyncHook(),
        pointerOver: new SyncHook(),
        pointerWheel: new SyncHook(),
        pointerCancel: new SyncHook(),
        click: new SyncHook()
      };
      this.globalRuntime = globalRuntime;
      this.context = context;
    }
    return _createClass(RenderingService2, [{
      key: "init",
      value: function init(callback) {
        var _this2 = this;
        var context = _objectSpread2(_objectSpread2({}, this.globalRuntime), this.context);
        this.context.renderingPlugins.forEach(function(plugin) {
          plugin.apply(context, _this2.globalRuntime);
        });
        this.hooks.init.call();
        if (this.hooks.initAsync.getCallbacksNum() === 0) {
          this.inited = true;
          callback();
        } else {
          this.hooks.initAsync.promise().then(function() {
            _this2.inited = true;
            callback();
          })["catch"](function(err) {
          });
        }
      }
    }, {
      key: "getStats",
      value: function getStats() {
        return this.stats;
      }
      /**
       * Meet the following conditions:
       * * disable DirtyRectangleRendering
       * * camera changed
       */
    }, {
      key: "disableDirtyRectangleRendering",
      value: function disableDirtyRectangleRendering() {
        var renderer = this.context.config.renderer;
        var _renderer$getConfig = renderer.getConfig(), enableDirtyRectangleRendering = _renderer$getConfig.enableDirtyRectangleRendering;
        return !enableDirtyRectangleRendering || this.context.renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED);
      }
    }, {
      key: "render",
      value: function render(canvasConfig, frame2, rerenderCallback) {
        var _this2 = this;
        this.stats.total = 0;
        this.stats.rendered = 0;
        this.zIndexCounter = 0;
        var renderingContext = this.context.renderingContext;
        this.globalRuntime.sceneGraphService.syncHierarchy(renderingContext.root);
        this.globalRuntime.sceneGraphService.triggerPendingEvents();
        if (renderingContext.renderReasons.size && this.inited) {
          renderingContext.dirtyRectangleRenderingDisabled = this.disableDirtyRectangleRendering();
          var onlyCameraChanged = renderingContext.renderReasons.size === 1 && renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED);
          var shouldTriggerRenderHooks = !canvasConfig.disableRenderHooks || !onlyCameraChanged;
          if (shouldTriggerRenderHooks) {
            this.renderDisplayObject(renderingContext.root, canvasConfig, renderingContext);
          }
          this.hooks.beginFrame.call(frame2);
          if (shouldTriggerRenderHooks) {
            renderingContext.renderListCurrentFrame.forEach(function(object) {
              _this2.hooks.beforeRender.call(object);
              _this2.hooks.render.call(object);
              _this2.hooks.afterRender.call(object);
            });
          }
          this.hooks.endFrame.call(frame2);
          renderingContext.renderListCurrentFrame = [];
          renderingContext.renderReasons.clear();
          rerenderCallback();
        }
      }
    }, {
      key: "renderDisplayObject",
      value: function renderDisplayObject(displayObject, canvasConfig, renderingContext) {
        var self2 = this;
        var _canvasConfig$rendere = canvasConfig.renderer.getConfig(), enableDirtyCheck = _canvasConfig$rendere.enableDirtyCheck, enableCulling = _canvasConfig$rendere.enableCulling;
        function internalRenderSingleDisplayObject(object) {
          var renderable = object.renderable, sortable = object.sortable;
          var objectChanged = enableDirtyCheck ? (
            // @ts-ignore
            renderable.dirty || renderingContext.dirtyRectangleRenderingDisabled ? object : null
          ) : object;
          var objectToRender = null;
          if (objectChanged) {
            objectToRender = enableCulling ? self2.hooks.cull.call(objectChanged, self2.context.camera) : objectChanged;
            if (objectToRender) {
              self2.stats.rendered += 1;
              renderingContext.renderListCurrentFrame.push(objectToRender);
            }
          }
          object.dirty(false);
          sortable.renderOrder = self2.zIndexCounter;
          self2.zIndexCounter += 1;
          self2.stats.total += 1;
          if (sortable.dirty) {
            self2.sort(object, sortable);
            sortable.dirty = false;
            sortable.dirtyChildren = [];
            sortable.dirtyReason = void 0;
          }
        }
        var stack = [displayObject];
        while (stack.length > 0) {
          var _currentObject$sortab;
          var currentObject = stack.pop();
          internalRenderSingleDisplayObject(currentObject);
          var objects = ((_currentObject$sortab = currentObject.sortable) === null || _currentObject$sortab === void 0 || (_currentObject$sortab = _currentObject$sortab.sorted) === null || _currentObject$sortab === void 0 ? void 0 : _currentObject$sortab.length) > 0 ? currentObject.sortable.sorted : currentObject.childNodes;
          for (var i = objects.length - 1; i >= 0; i--) {
            stack.push(objects[i]);
          }
        }
      }
    }, {
      key: "sort",
      value: function sort2(displayObject, sortable) {
        var _sortable$sorted, _sortable$sorted2;
        if ((sortable === null || sortable === void 0 || (_sortable$sorted = sortable.sorted) === null || _sortable$sorted === void 0 ? void 0 : _sortable$sorted.length) > 0 && sortable.dirtyReason !== SortReason.Z_INDEX_CHANGED) {
          sortable.dirtyChildren.forEach(function(child) {
            var sortIndex = sortable.sorted.indexOf(child);
            if (sortIndex > -1) {
              sortable.sorted.splice(sortIndex, 1);
            }
            var index2 = displayObject.childNodes.indexOf(child);
            if (index2 > -1) {
              if (sortable.sorted.length === 0) {
                sortable.sorted.push(child);
              } else {
                var _index = sortedIndex(sortable.sorted, child);
                sortable.sorted.splice(_index, 0, child);
              }
            }
          });
        } else {
          sortable.sorted = displayObject.childNodes.slice().sort(sortByZIndex);
        }
        if (((_sortable$sorted2 = sortable.sorted) === null || _sortable$sorted2 === void 0 ? void 0 : _sortable$sorted2.length) > 0 && displayObject.childNodes.filter(function(child) {
          return child.parsedStyle.zIndex;
        }).length === 0) {
          sortable.sorted = [];
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.inited = false;
        this.hooks.destroy.call();
        this.globalRuntime.sceneGraphService.clearPendingEvents();
      }
    }, {
      key: "dirtify",
      value: function dirtify() {
        this.context.renderingContext.renderReasons.add(RenderReason.DISPLAY_OBJECT_CHANGED);
      }
    }]);
  })();
  var ATTRIBUTE_REGEXP = /\[\s*(.*)=(.*)\s*\]/;
  var DefaultSceneGraphSelector = /* @__PURE__ */ (function() {
    function DefaultSceneGraphSelector2() {
      _classCallCheck(this, DefaultSceneGraphSelector2);
    }
    return _createClass(DefaultSceneGraphSelector2, [{
      key: "selectOne",
      value: function selectOne(query, root2) {
        var _this2 = this;
        if (query.startsWith(".")) {
          return root2.find(function(node) {
            return ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this2.getIdOrClassname(query)) > -1;
          });
        }
        if (query.startsWith("#")) {
          return root2.find(function(node) {
            return node.id === _this2.getIdOrClassname(query);
          });
        }
        if (query.startsWith("[")) {
          var _this$getAttribute = this.getAttribute(query), name = _this$getAttribute.name, value = _this$getAttribute.value;
          if (name) {
            return root2.find(function(node) {
              return root2 !== node && (name === "name" ? node.name === value : _this2.attributeToString(node, name) === value);
            });
          }
          return null;
        }
        return root2.find(function(node) {
          return root2 !== node && node.nodeName === query;
        });
      }
    }, {
      key: "selectAll",
      value: function selectAll(query, root2) {
        var _this2 = this;
        if (query.startsWith(".")) {
          return root2.findAll(function(node) {
            return root2 !== node && ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this2.getIdOrClassname(query)) > -1;
          });
        }
        if (query.startsWith("#")) {
          return root2.findAll(function(node) {
            return root2 !== node && node.id === _this2.getIdOrClassname(query);
          });
        }
        if (query.startsWith("[")) {
          var _this$getAttribute2 = this.getAttribute(query), name = _this$getAttribute2.name, value = _this$getAttribute2.value;
          if (name) {
            return root2.findAll(function(node) {
              return root2 !== node && (name === "name" ? node.name === value : _this2.attributeToString(node, name) === value);
            });
          }
          return [];
        }
        return root2.findAll(function(node) {
          return root2 !== node && node.nodeName === query;
        });
      }
    }, {
      key: "is",
      value: function is(query, node) {
        if (query.startsWith(".")) {
          return node.className === this.getIdOrClassname(query);
        }
        if (query.startsWith("#")) {
          return node.id === this.getIdOrClassname(query);
        }
        if (query.startsWith("[")) {
          var _this$getAttribute3 = this.getAttribute(query), name = _this$getAttribute3.name, value = _this$getAttribute3.value;
          return name === "name" ? node.name === value : this.attributeToString(node, name) === value;
        }
        return node.nodeName === query;
      }
    }, {
      key: "getIdOrClassname",
      value: function getIdOrClassname(query) {
        return query.substring(1);
      }
    }, {
      key: "getAttribute",
      value: function getAttribute(query) {
        var matches = query.match(ATTRIBUTE_REGEXP);
        var name = "";
        var value = "";
        if (matches && matches.length > 2) {
          name = matches[1].replace(/"/g, "");
          value = matches[2].replace(/"/g, "");
        }
        return {
          name,
          value
        };
      }
    }, {
      key: "attributeToString",
      value: function attributeToString(node, name) {
        if (!node.getAttribute) {
          return "";
        }
        var value = node.getAttribute(name);
        if ((0, import_util2.isNil)(value)) {
          return "";
        }
        if (value.toString) {
          return value.toString();
        }
        return "";
      }
    }]);
  })();
  var ElementEvent = /* @__PURE__ */ (function(ElementEvent2) {
    ElementEvent2["ATTR_MODIFIED"] = "DOMAttrModified";
    ElementEvent2["INSERTED"] = "DOMNodeInserted";
    ElementEvent2["MOUNTED"] = "DOMNodeInsertedIntoDocument";
    ElementEvent2["REMOVED"] = "removed";
    ElementEvent2["UNMOUNTED"] = "DOMNodeRemovedFromDocument";
    ElementEvent2["REPARENT"] = "reparent";
    ElementEvent2["DESTROY"] = "destroy";
    ElementEvent2["BOUNDS_CHANGED"] = "bounds-changed";
    ElementEvent2["CULLED"] = "culled";
    return ElementEvent2;
  })({});
  var MutationEvent = /* @__PURE__ */ (function(_FederatedEvent) {
    function MutationEvent2(typeArg, relatedNode, prevValue, newValue, attrName, attrChange, prevParsedValue, newParsedValue) {
      var _this2;
      _classCallCheck(this, MutationEvent2);
      _this2 = _callSuper(this, MutationEvent2, [null]);
      _this2.relatedNode = relatedNode;
      _this2.prevValue = prevValue;
      _this2.newValue = newValue;
      _this2.attrName = attrName;
      _this2.attrChange = attrChange;
      _this2.prevParsedValue = prevParsedValue;
      _this2.newParsedValue = newParsedValue;
      _this2.type = typeArg;
      return _this2;
    }
    _inherits(MutationEvent2, _FederatedEvent);
    return _createClass(MutationEvent2);
  })(FederatedEvent);
  MutationEvent.ADDITION = 2;
  MutationEvent.MODIFICATION = 1;
  MutationEvent.REMOVAL = 3;
  var reparentEvent = new MutationEvent(ElementEvent.REPARENT, null, "", "", "", 0, "", "");
  var $vec2Zero = import_gl_matrix2.vec2.create();
  var $vec3Zero = import_gl_matrix2.vec3.create();
  var $vec3One = import_gl_matrix2.vec3.fromValues(1, 1, 1);
  var $mat4Identity = import_gl_matrix2.mat4.create();
  var $vec2 = import_gl_matrix2.vec2.create();
  var $vec3$1 = import_gl_matrix2.vec3.create();
  var $mat4 = import_gl_matrix2.mat4.create();
  var $quat$1 = import_gl_matrix2.quat.create();
  var $setLocalTransform_1 = import_gl_matrix2.vec3.create();
  var $setLocalTransform_2 = import_gl_matrix2.quat.create();
  var $setLocalTransform_3 = import_gl_matrix2.vec3.create();
  var $setLocalPosition = import_gl_matrix2.vec3.create();
  var $setPosition_1 = import_gl_matrix2.vec3.create();
  var $setPosition_ParentInvertMatrix = import_gl_matrix2.mat4.create();
  var $setEulerAngles_InvParentRot = import_gl_matrix2.quat.create();
  var $rotateLocal = import_gl_matrix2.quat.create();
  var $rotate_ParentInvertRotation = import_gl_matrix2.quat.create();
  var $triggerPendingEvents_detail = {
    affectChildren: true
  };
  var DefaultSceneGraphService = /* @__PURE__ */ (function() {
    function DefaultSceneGraphService2(runtime2) {
      _classCallCheck(this, DefaultSceneGraphService2);
      this.pendingEvents = /* @__PURE__ */ new Map();
      this.boundsChangedEvent = new CustomEvent(ElementEvent.BOUNDS_CHANGED);
      this.displayObjectDependencyMap = /* @__PURE__ */ new WeakMap();
      this.runtime = runtime2;
    }
    return _createClass(DefaultSceneGraphService2, [{
      key: "matches",
      value: function matches(query, root2) {
        return this.runtime.sceneGraphSelector.is(query, root2);
      }
    }, {
      key: "querySelector",
      value: function querySelector(query, root2) {
        return this.runtime.sceneGraphSelector.selectOne(query, root2);
      }
    }, {
      key: "querySelectorAll",
      value: function querySelectorAll(query, root2) {
        return this.runtime.sceneGraphSelector.selectAll(query, root2);
      }
    }, {
      key: "attach",
      value: function attach(child, parent, index2) {
        var _sortable$sorted;
        var detached = false;
        if (child.parentNode) {
          detached = child.parentNode !== parent;
          this.detach(child);
        }
        var isChildFragment = child.nodeName === Shape.FRAGMENT;
        var isAttachToFragment = isInFragment(parent);
        child.parentNode = parent;
        var nodes = isChildFragment ? child.childNodes : [child];
        if ((0, import_util2.isNumber)(index2)) {
          nodes.forEach(function(node) {
            parent.childNodes.splice(index2, 0, node);
            node.parentNode = parent;
          });
        } else {
          nodes.forEach(function(node) {
            parent.childNodes.push(node);
            node.parentNode = parent;
          });
        }
        var _ref = parent, sortable = _ref.sortable;
        if (sortable !== null && sortable !== void 0 && (_sortable$sorted = sortable.sorted) !== null && _sortable$sorted !== void 0 && _sortable$sorted.length || sortable.dirty || child.parsedStyle.zIndex) {
          if (sortable.dirtyChildren.indexOf(child) === -1) {
            sortable.dirtyChildren.push(child);
          }
          sortable.dirty = true;
          sortable.dirtyReason = SortReason.ADDED;
        }
        if (isAttachToFragment) return;
        if (isChildFragment) {
          this.dirtifyFragment(child);
        } else {
          var transform = child.transformable;
          if (transform) {
            this.dirtyWorldTransform(child, transform);
          }
        }
        if (detached) {
          var _parent$ownerDocument;
          var enableCancelEventPropagation = ((_parent$ownerDocument = parent.ownerDocument) === null || _parent$ownerDocument === void 0 || (_parent$ownerDocument = _parent$ownerDocument.defaultView) === null || _parent$ownerDocument === void 0 || (_parent$ownerDocument = _parent$ownerDocument.getConfig()) === null || _parent$ownerDocument === void 0 || (_parent$ownerDocument = _parent$ownerDocument.future) === null || _parent$ownerDocument === void 0 ? void 0 : _parent$ownerDocument.experimentalCancelEventPropagation) === true;
          child.dispatchEvent(reparentEvent, enableCancelEventPropagation, enableCancelEventPropagation);
        }
      }
    }, {
      key: "detach",
      value: function detach(child) {
        var _sortable$sorted2, _style;
        if (!child.parentNode) {
          return;
        }
        var transform = child.transformable;
        var _ref2 = child.parentNode, sortable = _ref2.sortable;
        if (sortable !== null && sortable !== void 0 && (_sortable$sorted2 = sortable.sorted) !== null && _sortable$sorted2 !== void 0 && _sortable$sorted2.length || (_style = child.style) !== null && _style !== void 0 && _style.zIndex) {
          if (sortable.dirtyChildren.indexOf(child) === -1) {
            sortable.dirtyChildren.push(child);
          }
          sortable.dirty = true;
          sortable.dirtyReason = SortReason.REMOVED;
        }
        var index2 = child.parentNode.childNodes.indexOf(child);
        if (index2 > -1) {
          child.parentNode.childNodes.splice(index2, 1);
        }
        if (transform) {
          this.dirtyWorldTransform(child, transform);
        }
        child.parentNode = null;
      }
      // #region local-transform ----------------------------------------------------------------
    }, {
      key: "getLocalPosition",
      value: function getLocalPosition(element) {
        return element.transformable.localPosition;
      }
    }, {
      key: "getLocalRotation",
      value: function getLocalRotation(element) {
        return element.transformable.localRotation;
      }
    }, {
      key: "getLocalScale",
      value: function getLocalScale(element) {
        return element.transformable.localScale;
      }
    }, {
      key: "getLocalSkew",
      value: function getLocalSkew(element) {
        return element.transformable.localSkew;
      }
    }, {
      key: "getLocalTransform",
      value: function getLocalTransform(element) {
        var transform = element.transformable;
        updateLocalTransform(transform);
        return transform.localTransform;
      }
      /**
       * move to position in local space
       */
    }, {
      key: "setLocalPosition",
      value: function setLocalPosition(element, position2) {
        var _position$;
        var dirtify = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
        var transform = element.transformable;
        $setLocalPosition[0] = position2[0];
        $setLocalPosition[1] = position2[1];
        $setLocalPosition[2] = (_position$ = position2[2]) !== null && _position$ !== void 0 ? _position$ : 0;
        if (import_gl_matrix2.vec3.equals(transform.localPosition, $setLocalPosition)) {
          return;
        }
        import_gl_matrix2.vec3.copy(transform.localPosition, $setLocalPosition);
        if (dirtify) {
          this.dirtyLocalTransform(element, transform);
        }
      }
      /**
       * translate in local space
       *
       * @example
       * ```
       * translateLocal(x, y, z)
       * translateLocal(vec3(x, y, z))
       * ```
       */
    }, {
      key: "translateLocal",
      value: function translateLocal(element, translation) {
        var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        if (typeof translation === "number") {
          translation = import_gl_matrix2.vec3.fromValues(translation, y3, z);
        }
        var transform = element.transformable;
        if (import_gl_matrix2.vec3.equals(translation, $vec3Zero)) return;
        import_gl_matrix2.vec3.transformQuat(translation, translation, transform.localRotation);
        import_gl_matrix2.vec3.add(transform.localPosition, transform.localPosition, translation);
        this.dirtyLocalTransform(element, transform);
      }
    }, {
      key: "setLocalRotation",
      value: function setLocalRotation(element, rotation, y3, z, w) {
        var dirtify = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
        if (typeof rotation === "number") {
          rotation = import_gl_matrix2.quat.set($quat$1, rotation, y3, z, w);
        }
        var transform = element.transformable;
        import_gl_matrix2.quat.copy(transform.localRotation, rotation);
        if (dirtify) {
          this.dirtyLocalTransform(element, transform);
        }
      }
      /**
       * rotate in local space
       * @see @see https://docs.microsoft.com/en-us/windows/win32/api/directxmath/nf-directxmath-xmquaternionrotationrollpitchyaw
       */
    }, {
      key: "rotateLocal",
      value: function rotateLocal(element, degrees) {
        var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        if (typeof degrees === "number") {
          degrees = import_gl_matrix2.vec3.fromValues(degrees, y3, z);
        }
        var transform = element.transformable;
        import_gl_matrix2.quat.fromEuler($rotateLocal, degrees[0], degrees[1], degrees[2]);
        import_gl_matrix2.quat.mul(transform.localRotation, transform.localRotation, $rotateLocal);
        this.dirtyLocalTransform(element, transform);
      }
    }, {
      key: "setLocalScale",
      value: function setLocalScale(element, scaling) {
        var _scaling$;
        var dirtify = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
        var transform = element.transformable;
        import_gl_matrix2.vec3.set($vec3$1, scaling[0], scaling[1], (_scaling$ = scaling[2]) !== null && _scaling$ !== void 0 ? _scaling$ : transform.localScale[2]);
        if (import_gl_matrix2.vec3.equals($vec3$1, transform.localScale)) {
          return;
        }
        import_gl_matrix2.vec3.copy(transform.localScale, $vec3$1);
        if (dirtify) {
          this.dirtyLocalTransform(element, transform);
        }
      }
      /**
       * scale in local space
       */
    }, {
      key: "scaleLocal",
      value: function scaleLocal(element, scaling) {
        var _scaling$2;
        var transform = element.transformable;
        import_gl_matrix2.vec3.multiply(transform.localScale, transform.localScale, import_gl_matrix2.vec3.set($vec3$1, scaling[0], scaling[1], (_scaling$2 = scaling[2]) !== null && _scaling$2 !== void 0 ? _scaling$2 : 1));
        this.dirtyLocalTransform(element, transform);
      }
    }, {
      key: "setLocalSkew",
      value: function setLocalSkew(element, skew2, y3) {
        var dirtify = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
        if (typeof skew2 === "number") {
          skew2 = import_gl_matrix2.vec2.set($vec2, skew2, y3);
        }
        var transform = element.transformable;
        import_gl_matrix2.vec2.copy(transform.localSkew, skew2);
        if (dirtify) {
          this.dirtyLocalTransform(element, transform);
        }
      }
      /**
       * set euler angles(degrees) in local space
       */
    }, {
      key: "setLocalEulerAngles",
      value: function setLocalEulerAngles(element, degrees) {
        var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        var dirtify = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
        if (typeof degrees === "number") {
          degrees = import_gl_matrix2.vec3.fromValues(degrees, y3, z);
        }
        var transform = element.transformable;
        import_gl_matrix2.quat.fromEuler(transform.localRotation, degrees[0], degrees[1], degrees[2]);
        if (dirtify) {
          this.dirtyLocalTransform(element, transform);
        }
      }
    }, {
      key: "setLocalTransform",
      value: function setLocalTransform(element, transform) {
        var t = import_gl_matrix2.mat4.getTranslation($setLocalTransform_1, transform);
        var r = import_gl_matrix2.mat4.getRotation($setLocalTransform_2, transform);
        var s = import_gl_matrix2.mat4.getScaling($setLocalTransform_3, transform);
        this.setLocalScale(element, s, false);
        this.setLocalPosition(element, t, false);
        this.setLocalRotation(element, r, void 0, void 0, void 0, false);
        this.dirtyLocalTransform(element, element.transformable);
      }
    }, {
      key: "resetLocalTransform",
      value: function resetLocalTransform(element) {
        this.setLocalScale(element, $vec3One, false);
        this.setLocalPosition(element, $vec3Zero, false);
        this.setLocalEulerAngles(element, $vec3Zero, void 0, void 0, false);
        this.setLocalSkew(element, $vec2Zero, void 0, false);
        this.dirtyLocalTransform(element, element.transformable);
      }
      // #endregion local-transform
      // #region transform ----------------------------------------------------------------
    }, {
      key: "getPosition",
      value: function getPosition(element) {
        var transform = element.transformable;
        return import_gl_matrix2.mat4.getTranslation(transform.position, this.getWorldTransform(element, transform));
      }
    }, {
      key: "getRotation",
      value: function getRotation(element) {
        var transform = element.transformable;
        return import_gl_matrix2.mat4.getRotation(transform.rotation, this.getWorldTransform(element, transform));
      }
    }, {
      key: "getScale",
      value: function getScale(element) {
        var transform = element.transformable;
        return import_gl_matrix2.mat4.getScaling(transform.scaling, this.getWorldTransform(element, transform));
      }
    }, {
      key: "getOrigin",
      value: function getOrigin(element) {
        element.getGeometryBounds();
        return element.transformable.origin;
      }
    }, {
      key: "getWorldTransform",
      value: function getWorldTransform(element) {
        var transform = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : element.transformable;
        if (!transform.localDirtyFlag && !transform.dirtyFlag) {
          return transform.worldTransform;
        }
        if (element.parentNode && element.parentNode.transformable) {
          this.getWorldTransform(element.parentNode);
        }
        this.internalUpdateTransform(element);
        return transform.worldTransform;
      }
      /**
       * move to position in world space
       *
       * 对应 g 原版的 move/moveTo
       * @see https://github.com/antvis/g/blob/master/packages/g-base/src/abstract/element.ts#L684-L689
       */
    }, {
      key: "setPosition",
      value: function setPosition(element, position2) {
        var _position$2;
        var transform = element.transformable;
        $setPosition_1[0] = position2[0];
        $setPosition_1[1] = position2[1];
        $setPosition_1[2] = (_position$2 = position2[2]) !== null && _position$2 !== void 0 ? _position$2 : 0;
        if (import_gl_matrix2.vec3.equals(this.getPosition(element), $setPosition_1)) {
          return;
        }
        import_gl_matrix2.vec3.copy(transform.position, $setPosition_1);
        if (element.parentNode === null || !element.parentNode.transformable) {
          import_gl_matrix2.vec3.copy(transform.localPosition, $setPosition_1);
        } else {
          var parentTransform = element.parentNode.transformable;
          import_gl_matrix2.mat4.copy($setPosition_ParentInvertMatrix, parentTransform.worldTransform);
          import_gl_matrix2.mat4.invert($setPosition_ParentInvertMatrix, $setPosition_ParentInvertMatrix);
          import_gl_matrix2.vec3.transformMat4(transform.localPosition, $setPosition_1, $setPosition_ParentInvertMatrix);
        }
        this.dirtyLocalTransform(element, transform);
      }
      /**
       * translate in world space
       *
       * @example
       * ```
       * translate(x, y, z)
       * translate(vec3(x, y, z))
       * ```
       *
       * 对应 g 原版的 translate 2D
       * @see https://github.com/antvis/g/blob/master/packages/g-base/src/abstract/element.ts#L665-L676
       */
    }, {
      key: "translate",
      value: function translate3(element, translation) {
        var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        if (typeof translation === "number") {
          translation = import_gl_matrix2.vec3.set($vec3$1, translation, y3, z);
        }
        if (import_gl_matrix2.vec3.equals(translation, $vec3Zero)) return;
        import_gl_matrix2.vec3.add($vec3$1, this.getPosition(element), translation);
        this.setPosition(element, $vec3$1);
      }
    }, {
      key: "setRotation",
      value: function setRotation(element, rotation, y3, z, w) {
        var transform = element.transformable;
        if (typeof rotation === "number") {
          rotation = import_gl_matrix2.quat.fromValues(rotation, y3, z, w);
        }
        if (element.parentNode === null || !element.parentNode.transformable) {
          this.setLocalRotation(element, rotation);
        } else {
          var parentRot = this.getRotation(element.parentNode);
          import_gl_matrix2.quat.copy($quat$1, parentRot);
          import_gl_matrix2.quat.invert($quat$1, $quat$1);
          import_gl_matrix2.quat.multiply(transform.localRotation, $quat$1, rotation);
          import_gl_matrix2.quat.normalize(transform.localRotation, transform.localRotation);
          this.dirtyLocalTransform(element, transform);
        }
      }
      /**
       * rotate in world space
       */
    }, {
      key: "rotate",
      value: function rotate3(element, degrees) {
        var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        if (typeof degrees === "number") {
          degrees = import_gl_matrix2.vec3.fromValues(degrees, y3, z);
        }
        var transform = element.transformable;
        if (element.parentNode === null || !element.parentNode.transformable) {
          this.rotateLocal(element, degrees);
        } else {
          var rotation = $quat$1;
          import_gl_matrix2.quat.fromEuler(rotation, degrees[0], degrees[1], degrees[2]);
          var rot = this.getRotation(element);
          var parentRot = this.getRotation(element.parentNode);
          import_gl_matrix2.quat.copy($rotate_ParentInvertRotation, parentRot);
          import_gl_matrix2.quat.invert($rotate_ParentInvertRotation, $rotate_ParentInvertRotation);
          import_gl_matrix2.quat.multiply(rotation, $rotate_ParentInvertRotation, rotation);
          import_gl_matrix2.quat.multiply(transform.localRotation, rotation, rot);
          import_gl_matrix2.quat.normalize(transform.localRotation, transform.localRotation);
          this.dirtyLocalTransform(element, transform);
        }
      }
      /**
       * same as pivot in Pixi.js
       *
       * @see https://stackoverflow.com/questions/40748452/how-to-change-css-transform-origin-but-preserve-transformation
       */
    }, {
      key: "setOrigin",
      value: function setOrigin(element, origin) {
        var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        if (typeof origin === "number") {
          origin = [origin, y3, z];
        }
        var transform = element.transformable;
        if (origin[0] === transform.origin[0] && origin[1] === transform.origin[1] && origin[2] === transform.origin[2]) {
          return;
        }
        var originVec = transform.origin;
        originVec[0] = origin[0];
        originVec[1] = origin[1];
        originVec[2] = origin[2] || 0;
        this.dirtyLocalTransform(element, transform);
      }
      /**
       * set euler angles(degrees) in world space
       */
    }, {
      key: "setEulerAngles",
      value: function setEulerAngles(element, degrees) {
        var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        if (typeof degrees === "number") {
          degrees = import_gl_matrix2.vec3.fromValues(degrees, y3, z);
        }
        var transform = element.transformable;
        if (element.parentNode === null || !element.parentNode.transformable) {
          this.setLocalEulerAngles(element, degrees);
        } else {
          import_gl_matrix2.quat.fromEuler(transform.localRotation, degrees[0], degrees[1], degrees[2]);
          var parentRotation = this.getRotation(element.parentNode);
          import_gl_matrix2.quat.copy($setEulerAngles_InvParentRot, import_gl_matrix2.quat.invert($quat$1, parentRotation));
          import_gl_matrix2.quat.mul(transform.localRotation, transform.localRotation, $setEulerAngles_InvParentRot);
          this.dirtyLocalTransform(element, transform);
        }
      }
      // #endregion transform
      // #region bbox ----------------------------------------------------------------
    }, {
      key: "getTransformedGeometryBounds",
      value: function getTransformedGeometryBounds(element) {
        var render = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var existedAABB = arguments.length > 2 ? arguments[2] : void 0;
        var bounds = this.getGeometryBounds(element, render);
        if (!AABB.isEmpty(bounds)) {
          var aabb = existedAABB || new AABB();
          aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
          return aabb;
        }
        return null;
      }
      /**
       * won't account for children
       */
    }, {
      key: "getGeometryBounds",
      value: function getGeometryBounds(element) {
        var render = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var _ref3 = element, geometry = _ref3.geometry;
        if (geometry.dirty) {
          runtime.styleValueRegistry.updateGeometry(element);
        }
        var bounds = render ? geometry.renderBounds : geometry.contentBounds || null;
        return bounds || new AABB();
      }
      /**
       * account for children in world space
       */
    }, {
      key: "getBounds",
      value: function getBounds2(element) {
        var _this2 = this;
        var render = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var _ref4 = element, renderable = _ref4.renderable;
        if (!renderable.boundsDirty && !render && renderable.bounds) {
          return renderable.bounds;
        }
        if (!renderable.renderBoundsDirty && render && renderable.renderBounds) {
          return renderable.renderBounds;
        }
        var existedAABB = render ? renderable.renderBounds : renderable.bounds;
        var aabb = this.getTransformedGeometryBounds(element, render, existedAABB);
        var children = element.childNodes;
        children.forEach(function(child) {
          var childBounds = _this2.getBounds(child, render);
          if (childBounds) {
            if (!aabb) {
              aabb = existedAABB || new AABB();
              aabb.update(childBounds.center, childBounds.halfExtents);
            } else {
              aabb.add(childBounds);
            }
          }
        });
        if (!aabb) {
          aabb = new AABB();
        }
        if (render) {
          var clipped = findClosestClipPathTarget(element);
          if (clipped) {
            var clipPathBounds = clipped.parsedStyle.clipPath.getBounds(render);
            if (!aabb) {
              aabb.update(clipPathBounds.center, clipPathBounds.halfExtents);
            } else if (clipPathBounds) {
              aabb = clipPathBounds.intersection(aabb);
            }
          }
        }
        if (render) {
          renderable.renderBounds = aabb;
          renderable.renderBoundsDirty = false;
        } else {
          renderable.bounds = aabb;
          renderable.boundsDirty = false;
        }
        return aabb;
      }
      /**
       * account for children in local space
       */
    }, {
      key: "getLocalBounds",
      value: function getLocalBounds(element) {
        if (element.parentNode) {
          var parentInvert = $mat4Identity;
          if (element.parentNode.transformable) {
            parentInvert = import_gl_matrix2.mat4.invert($mat4, this.getWorldTransform(element.parentNode));
          }
          var bounds = this.getBounds(element);
          if (!AABB.isEmpty(bounds)) {
            var localBounds = new AABB();
            localBounds.setFromTransformedAABB(bounds, parentInvert);
            return localBounds;
          }
        }
        return this.getBounds(element);
      }
    }, {
      key: "getBoundingClientRect",
      value: function getBoundingClientRect(element) {
        var _element$ownerDocumen;
        var aabb;
        var bounds = this.getGeometryBounds(element);
        if (!AABB.isEmpty(bounds)) {
          aabb = new AABB();
          aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
        }
        var bbox = (_element$ownerDocumen = element.ownerDocument) === null || _element$ownerDocumen === void 0 || (_element$ownerDocumen = _element$ownerDocumen.defaultView) === null || _element$ownerDocumen === void 0 ? void 0 : _element$ownerDocumen.getContextService().getBoundingClientRect();
        if (aabb) {
          var _aabb$getMin = aabb.getMin(), _aabb$getMin2 = _slicedToArray(_aabb$getMin, 2), left = _aabb$getMin2[0], top = _aabb$getMin2[1];
          var _aabb$getMax = aabb.getMax(), _aabb$getMax2 = _slicedToArray(_aabb$getMax, 2), right = _aabb$getMax2[0], bottom = _aabb$getMax2[1];
          return new Rectangle(left + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), top + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0), right - left, bottom - top);
        }
        return new Rectangle((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0, (bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0, 0, 0);
      }
      // #endregion bbox
      // #region other ----------------------------------------------------------------
    }, {
      key: "internalUpdateTransform",
      value: function internalUpdateTransform(element) {
        var _element$parentNode;
        var parentTransform = (_element$parentNode = element.parentNode) === null || _element$parentNode === void 0 ? void 0 : _element$parentNode.transformable;
        updateLocalTransform(element.transformable);
        updateWorldTransform(element.transformable, parentTransform);
      }
    }, {
      key: "internalUpdateElement",
      value: function internalUpdateElement(element, ancestors) {
        var _element$ownerDocumen2, _element$transformabl, _element$renderable, _element$renderable2;
        var enableAttributeUpdateOptimization = ((_element$ownerDocumen2 = element.ownerDocument) === null || _element$ownerDocumen2 === void 0 || (_element$ownerDocumen2 = _element$ownerDocumen2.defaultView) === null || _element$ownerDocumen2 === void 0 || (_element$ownerDocumen2 = _element$ownerDocumen2.getConfig()) === null || _element$ownerDocumen2 === void 0 || (_element$ownerDocumen2 = _element$ownerDocumen2.future) === null || _element$ownerDocumen2 === void 0 ? void 0 : _element$ownerDocumen2.experimentalAttributeUpdateOptimization) === true;
        var parent = ancestors[ancestors.length - 1];
        var transformDirty = (parent === null || parent === void 0 ? void 0 : parent.transformDirty) || ((_element$transformabl = element.transformable) === null || _element$transformabl === void 0 ? void 0 : _element$transformabl.localDirtyFlag);
        if (element.transformable) {
          var _element$transformabl2;
          (_element$transformabl2 = element.transformable).dirtyFlag || (_element$transformabl2.dirtyFlag = transformDirty);
        }
        this.internalUpdateTransform(element);
        if (transformDirty) {
          var _element$dirty;
          (_element$dirty = element.dirty) === null || _element$dirty === void 0 || _element$dirty.call(element, true, true);
        }
        var shapeUpdated = ((_element$renderable = element.renderable) === null || _element$renderable === void 0 ? void 0 : _element$renderable.boundsDirty) || ((_element$renderable2 = element.renderable) === null || _element$renderable2 === void 0 ? void 0 : _element$renderable2.renderBoundsDirty);
        if ((transformDirty || shapeUpdated) && (parent === null || parent === void 0 ? void 0 : parent.shapeUpdated) === false && enableAttributeUpdateOptimization) {
          var tempElIndex = ancestors.length - 1;
          while (tempElIndex >= 0) {
            var _dirty, _ref5;
            var tempEl = ancestors[tempElIndex];
            if (tempEl.shapeUpdated) {
              break;
            }
            (_dirty = (_ref5 = tempEl.node).dirty) === null || _dirty === void 0 || _dirty.call(_ref5, true, true);
            tempEl.shapeUpdated = true;
            tempElIndex -= 1;
          }
        }
        return transformDirty;
      }
    }, {
      key: "syncHierarchy",
      value: function syncHierarchy(rootNode) {
        var _transformable, _transformable2;
        var stack = [rootNode];
        var ancestors = rootNode.parentNode ? [{
          node: rootNode.parentNode,
          transformDirty: ((_transformable = rootNode.parentNode.transformable) === null || _transformable === void 0 ? void 0 : _transformable.localDirtyFlag) || ((_transformable2 = rootNode.parentNode.transformable) === null || _transformable2 === void 0 ? void 0 : _transformable2.dirtyFlag),
          shapeUpdated: false
        }] : [];
        while (stack.length > 0) {
          var node = stack.pop();
          var parent = ancestors[ancestors.length - 1];
          while (ancestors.length > 0 && node.parentNode !== parent.node) {
            parent = ancestors.pop();
          }
          var transformDirty = this.internalUpdateElement(node, ancestors);
          if (node.childNodes.length > 0) {
            for (var i = node.childNodes.length - 1; i >= 0; i--) {
              stack.push(node.childNodes[i]);
            }
            ancestors.push({
              node,
              transformDirty,
              shapeUpdated: false
            });
          }
        }
      }
    }, {
      key: "dirtyLocalTransform",
      value: function dirtyLocalTransform(element, transform) {
        if (isInFragment(element)) return;
        if (!transform.localDirtyFlag) {
          transform.localDirtyFlag = true;
          if (!transform.dirtyFlag) {
            this.dirtyWorldTransform(element, transform);
          }
        }
      }
    }, {
      key: "dirtyWorldTransform",
      value: function dirtyWorldTransform(element, transform) {
        this.dirtifyWorldInternal(element, transform);
        this.dirtyToRoot(element, true);
      }
    }, {
      key: "dirtifyWorldInternal",
      value: function dirtifyWorldInternal(element, transform) {
        var _element$ownerDocumen3, _this2 = this;
        var enableAttributeUpdateOptimization = ((_element$ownerDocumen3 = element.ownerDocument) === null || _element$ownerDocumen3 === void 0 || (_element$ownerDocumen3 = _element$ownerDocumen3.defaultView) === null || _element$ownerDocumen3 === void 0 || (_element$ownerDocumen3 = _element$ownerDocumen3.getConfig()) === null || _element$ownerDocumen3 === void 0 || (_element$ownerDocumen3 = _element$ownerDocumen3.future) === null || _element$ownerDocumen3 === void 0 ? void 0 : _element$ownerDocumen3.experimentalAttributeUpdateOptimization) === true;
        if (!transform.dirtyFlag) {
          transform.dirtyFlag = true;
          element.dirty(true, true);
          if (!enableAttributeUpdateOptimization) {
            element.childNodes.forEach(function(child) {
              var childTransform = child.transformable;
              _this2.dirtifyWorldInternal(child, childTransform);
            });
          }
        }
      }
    }, {
      key: "dirtyToRoot",
      value: function dirtyToRoot(element) {
        var _element$ownerDocumen4;
        var affectChildren = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var p = element;
        var enableAttributeUpdateOptimization = ((_element$ownerDocumen4 = element.ownerDocument) === null || _element$ownerDocumen4 === void 0 || (_element$ownerDocumen4 = _element$ownerDocumen4.defaultView) === null || _element$ownerDocumen4 === void 0 || (_element$ownerDocumen4 = _element$ownerDocumen4.getConfig()) === null || _element$ownerDocumen4 === void 0 || (_element$ownerDocumen4 = _element$ownerDocumen4.future) === null || _element$ownerDocumen4 === void 0 ? void 0 : _element$ownerDocumen4.experimentalAttributeUpdateOptimization) === true;
        while (p) {
          var _dirty2, _ref6;
          (_dirty2 = (_ref6 = p).dirty) === null || _dirty2 === void 0 || _dirty2.call(_ref6, true, true);
          if (enableAttributeUpdateOptimization) {
            break;
          } else {
            p = p.parentNode;
          }
        }
        if (affectChildren) {
          element.forEach(function(e) {
            var _e$dirty;
            (_e$dirty = e.dirty) === null || _e$dirty === void 0 || _e$dirty.call(e, true, true);
          });
        }
        this.informDependentDisplayObjects(element);
        this.pendingEvents.set(element, affectChildren);
      }
    }, {
      key: "dirtifyFragment",
      value: function dirtifyFragment(element) {
        var _dirty3, _ref7;
        var transform = element.transformable;
        if (transform) {
          transform.dirtyFlag = true;
          transform.localDirtyFlag = true;
        }
        (_dirty3 = (_ref7 = element).dirty) === null || _dirty3 === void 0 || _dirty3.call(_ref7, true, true);
        var length = element.childNodes.length;
        for (var i = 0; i < length; i++) {
          this.dirtifyFragment(element.childNodes[i]);
        }
        if (element.nodeName === Shape.FRAGMENT) {
          this.pendingEvents.set(element, false);
        }
      }
    }, {
      key: "triggerPendingEvents",
      value: function triggerPendingEvents() {
        var _this3 = this;
        var triggered = /* @__PURE__ */ new Set();
        var enableCancelEventPropagation;
        var enableAttributeUpdateOptimization;
        var trigger = function trigger2(element, detail) {
          if (!element.isConnected || triggered.has(element) || element.nodeName === Shape.FRAGMENT) {
            return;
          }
          _this3.boundsChangedEvent.detail = detail;
          _this3.boundsChangedEvent.target = element;
          if (element.isMutationObserved) {
            element.dispatchEvent(_this3.boundsChangedEvent);
          } else {
            if (enableCancelEventPropagation === void 0) {
              var _element$ownerDocumen5;
              enableCancelEventPropagation = ((_element$ownerDocumen5 = element.ownerDocument.defaultView) === null || _element$ownerDocumen5 === void 0 || (_element$ownerDocumen5 = _element$ownerDocumen5.getConfig()) === null || _element$ownerDocumen5 === void 0 || (_element$ownerDocumen5 = _element$ownerDocumen5.future) === null || _element$ownerDocumen5 === void 0 ? void 0 : _element$ownerDocumen5.experimentalCancelEventPropagation) === true;
            }
            element.ownerDocument.defaultView.dispatchEvent(_this3.boundsChangedEvent, true, enableCancelEventPropagation);
          }
          triggered.add(element);
        };
        this.pendingEvents.forEach(function(affectChildren, element) {
          if (element.nodeName === Shape.FRAGMENT) {
            return;
          }
          if (enableAttributeUpdateOptimization === void 0) {
            var _element$ownerDocumen6;
            enableAttributeUpdateOptimization = ((_element$ownerDocumen6 = element.ownerDocument) === null || _element$ownerDocumen6 === void 0 || (_element$ownerDocumen6 = _element$ownerDocumen6.defaultView) === null || _element$ownerDocumen6 === void 0 || (_element$ownerDocumen6 = _element$ownerDocumen6.getConfig()) === null || _element$ownerDocumen6 === void 0 || (_element$ownerDocumen6 = _element$ownerDocumen6.future) === null || _element$ownerDocumen6 === void 0 ? void 0 : _element$ownerDocumen6.experimentalAttributeUpdateOptimization) === true;
          }
          $triggerPendingEvents_detail.affectChildren = affectChildren;
          if (enableAttributeUpdateOptimization) {
            trigger(element, $triggerPendingEvents_detail);
          } else {
            if (affectChildren) {
              element.forEach(function(e) {
                trigger(e, $triggerPendingEvents_detail);
              });
            } else {
              trigger(element, $triggerPendingEvents_detail);
            }
          }
        });
        triggered.clear();
        this.clearPendingEvents();
      }
    }, {
      key: "clearPendingEvents",
      value: function clearPendingEvents() {
        this.pendingEvents.clear();
      }
    }, {
      key: "updateDisplayObjectDependency",
      value: function updateDisplayObjectDependency(name, oldPath, newPath, object) {
        if (oldPath && oldPath !== newPath) {
          var oldDependencyMap = this.displayObjectDependencyMap.get(oldPath);
          if (oldDependencyMap && oldDependencyMap[name]) {
            var index2 = oldDependencyMap[name].indexOf(object);
            oldDependencyMap[name].splice(index2, 1);
          }
        }
        if (newPath) {
          var newDependencyMap = this.displayObjectDependencyMap.get(newPath);
          if (!newDependencyMap) {
            this.displayObjectDependencyMap.set(newPath, {});
            newDependencyMap = this.displayObjectDependencyMap.get(newPath);
          }
          if (!newDependencyMap[name]) {
            newDependencyMap[name] = [];
          }
          newDependencyMap[name].push(object);
        }
      }
    }, {
      key: "informDependentDisplayObjects",
      value: function informDependentDisplayObjects(object) {
        var _object$ownerDocument, _this4 = this;
        var dependencyMap = this.displayObjectDependencyMap.get(object);
        if (!dependencyMap) {
          return;
        }
        var enableCancelEventPropagation = (_object$ownerDocument = object.ownerDocument) === null || _object$ownerDocument === void 0 || (_object$ownerDocument = _object$ownerDocument.defaultView) === null || _object$ownerDocument === void 0 || (_object$ownerDocument = _object$ownerDocument.getConfig()) === null || _object$ownerDocument === void 0 || (_object$ownerDocument = _object$ownerDocument.future) === null || _object$ownerDocument === void 0 ? void 0 : _object$ownerDocument.experimentalCancelEventPropagation;
        Object.keys(dependencyMap).forEach(function(name) {
          dependencyMap[name].forEach(function(target) {
            _this4.dirtyToRoot(target, true);
            target.dispatchEvent(new MutationEvent(ElementEvent.ATTR_MODIFIED, target, _this4, _this4, name, MutationEvent.MODIFICATION, _this4, _this4), enableCancelEventPropagation, enableCancelEventPropagation);
            if (target.isCustomElement && target.isConnected) {
              if (target.attributeChangedCallback) {
                target.attributeChangedCallback(name, _this4, _this4);
              }
            }
          });
        });
      }
    }]);
  })();
  var LRU = /* @__PURE__ */ (function() {
    function LRU2(capacity) {
      _classCallCheck(this, LRU2);
      if (capacity <= 0) {
        throw new Error("LRU capacity must be a positive number.");
      }
      this.capacity = capacity;
      this.cache = /* @__PURE__ */ new Map();
    }
    return _createClass(LRU2, [{
      key: "get",
      value: function get9(key) {
        if (!this.cache.has(key)) {
          return void 0;
        }
        var value = this.cache.get(key);
        this.cache["delete"](key);
        this.cache.set(key, value);
        return value;
      }
      /**
       * Adds or updates an item in the cache. Marks the item as recently used.
       * If the cache is full, it removes the least recently used item.
       * @param key The key of the item.
       * @param value The value of the item.
       */
    }, {
      key: "put",
      value: function put(key, value) {
        if (this.cache.has(key)) {
          this.cache["delete"](key);
        }
        this.cache.set(key, value);
        if (this.cache.size > this.capacity) {
          var leastRecentlyUsedKey = this.cache.keys().next().value;
          this.cache["delete"](leastRecentlyUsedKey);
        }
      }
      /**
       * Returns the current number of items in the cache.
       */
    }, {
      key: "len",
      value: function len() {
        return this.cache.size;
      }
      /**
       * Clears all items from the cache.
       */
    }, {
      key: "clear",
      value: function clear() {
        this.cache.clear();
      }
    }]);
  })();
  var TEXT_METRICS = {
    MetricsString: "|\xC9q\xC5",
    BaselineSymbol: "M",
    BaselineMultiplier: 1.4,
    HeightMultiplier: 2,
    Newlines: [
      10,
      // line feed
      13
      // carriage return
    ],
    BreakingSpaces: [
      9,
      // character tabulation
      32,
      // space
      8192,
      // en quad
      8193,
      // em quad
      8194,
      // en space
      8195,
      // em space
      8196,
      // three-per-em space
      8197,
      // four-per-em space
      8198,
      // six-per-em space
      8200,
      // punctuation space
      8201,
      // thin space
      8202,
      // hair space
      8287,
      // medium mathematical space
      12288
      // ideographic space
    ]
  };
  var LATIN_REGEX = /[a-zA-Z0-9\u00C0-\u00D6\u00D8-\u00f6\u00f8-\u00ff!"#$%&'()*+,-./:;]/;
  var regexCannotStartZhCn = /[!%),.:;?\]}¢°·'""†‡›℃∶、。〃〆〕〗〞﹚﹜！＂％＇），．：；？！］｝～]/;
  var regexCannotEndZhCn = /[$(£¥·'"〈《「『【〔〖〝﹙﹛＄（．［｛￡￥]/;
  var regexCannotStartZhTw = /[!),.:;?\]}¢·–—'"•"、。〆〞〕〉》」︰︱︲︳﹐﹑﹒﹓﹔﹕﹖﹘﹚﹜！），．：；？︶︸︺︼︾﹀﹂﹗］｜｝､]/;
  var regexCannotEndZhTw = /[([{£¥'"‵〈《「『〔〝︴﹙﹛（｛︵︷︹︻︽︿﹁﹃﹏]/;
  var regexCannotStartJaJp = /[)\]｝〕〉》」』】〙〗〟'"｠»ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻‐゠–〜?!‼⁇⁈⁉・、:;,。.]/;
  var regexCannotEndJaJp = /[([｛〔〈《「『【〘〖〝'"｟«—...‥〳〴〵]/;
  var regexCannotStartKoKr = /[!%),.:;?\]}¢°'"†‡℃〆〈《「『〕！％），．：；？］｝]/;
  var regexCannotEndKoKr = /[$([{£¥'"々〇〉》」〔＄（［｛｠￥￦#]/;
  var regexCannotStart = new RegExp("".concat(regexCannotStartZhCn.source, "|").concat(regexCannotStartZhTw.source, "|").concat(regexCannotStartJaJp.source, "|").concat(regexCannotStartKoKr.source));
  var regexCannotEnd = new RegExp("".concat(regexCannotEndZhCn.source, "|").concat(regexCannotEndZhTw.source, "|").concat(regexCannotEndJaJp.source, "|").concat(regexCannotEndKoKr.source));
  var TextService = /* @__PURE__ */ (function() {
    function TextService2(runtime2) {
      var _this2 = this;
      _classCallCheck(this, TextService2);
      this.fontMetricsCache = {};
      this.shouldBreakByKinsokuShorui = function(_char, nextChar) {
        if (_this2.isBreakingSpace(nextChar)) return false;
        if (_char) {
          if (regexCannotEnd.exec(nextChar) || regexCannotStart.exec(_char)) {
            return true;
          }
        }
        return false;
      };
      this.trimByKinsokuShorui = function(prev) {
        var next = _toConsumableArray(prev);
        var prevLine = next[next.length - 2];
        if (!prevLine) {
          return prev;
        }
        var lastChar = prevLine[prevLine.length - 1];
        next[next.length - 2] = prevLine.slice(0, -1);
        next[next.length - 1] = lastChar + next[next.length - 1];
        return next;
      };
      this.runtime = runtime2;
      this.charWidthCache = new LRU(100);
    }
    return _createClass(TextService2, [{
      key: "measureFont",
      value: (
        /**
         * A global cache for character widths, keyed by font string.
         * e.g. { '16px Arial': { 'a': 8, 'b': 9 } }
         */
        /**
         * Calculates the ascent, descent and fontSize of a given font-style.
         */
        function measureFont(font, offscreenCanvas) {
          if (this.fontMetricsCache[font]) {
            return this.fontMetricsCache[font];
          }
          var properties = {
            ascent: 0,
            descent: 0,
            fontSize: 0
          };
          var canvas2 = this.runtime.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
          var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas, {
            willReadFrequently: true
          });
          context.font = font;
          var metricsString = TEXT_METRICS.MetricsString + TEXT_METRICS.BaselineSymbol;
          var width2 = Math.ceil(context.measureText(metricsString).width);
          var baseline = Math.ceil(context.measureText(TEXT_METRICS.BaselineSymbol).width);
          var height = TEXT_METRICS.HeightMultiplier * baseline;
          baseline = baseline * TEXT_METRICS.BaselineMultiplier | 0;
          canvas2.width = width2;
          canvas2.height = height;
          context.fillStyle = "#f00";
          context.fillRect(0, 0, width2, height);
          context.font = font;
          context.textBaseline = "alphabetic";
          context.fillStyle = "#000";
          context.fillText(metricsString, 0, baseline);
          var imagedata = context.getImageData(0, 0, width2 || 1, height || 1).data;
          var pixels = imagedata.length;
          var line2 = width2 * 4;
          var i = 0;
          var idx = 0;
          var stop = false;
          for (i = 0; i < baseline; ++i) {
            for (var j = 0; j < line2; j += 4) {
              if (imagedata[idx + j] !== 255) {
                stop = true;
                break;
              }
            }
            if (!stop) {
              idx += line2;
            } else {
              break;
            }
          }
          properties.ascent = baseline - i;
          idx = pixels - line2;
          stop = false;
          for (i = height; i > baseline; --i) {
            for (var _j = 0; _j < line2; _j += 4) {
              if (imagedata[idx + _j] !== 255) {
                stop = true;
                break;
              }
            }
            if (!stop) {
              idx -= line2;
            } else {
              break;
            }
          }
          properties.descent = i - baseline;
          properties.fontSize = properties.ascent + properties.descent;
          this.fontMetricsCache[font] = properties;
          return properties;
        }
      )
    }, {
      key: "measureText",
      value: function measureText(text, parsedStyle, offscreenCanvas) {
        var _parsedStyle$fontSize = parsedStyle.fontSize, fontSize = _parsedStyle$fontSize === void 0 ? 16 : _parsedStyle$fontSize, _parsedStyle$wordWrap = parsedStyle.wordWrap, wordWrap = _parsedStyle$wordWrap === void 0 ? false : _parsedStyle$wordWrap, strokeHeight = parsedStyle.lineHeight, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$textBase = parsedStyle.textBaseline, textBaseline = _parsedStyle$textBase === void 0 ? "alphabetic" : _parsedStyle$textBase, _parsedStyle$textAlig = parsedStyle.textAlign, textAlign = _parsedStyle$textAlig === void 0 ? "start" : _parsedStyle$textAlig, _parsedStyle$letterSp = parsedStyle.letterSpacing, letterSpacing = _parsedStyle$letterSp === void 0 ? 0 : _parsedStyle$letterSp, textPath = parsedStyle.textPath;
        parsedStyle.textPathSide;
        parsedStyle.textPathStartOffset;
        var _parsedStyle$leading = parsedStyle.leading, leading = _parsedStyle$leading === void 0 ? 0 : _parsedStyle$leading;
        var font = toFontString(parsedStyle);
        var fontProperties = this.measureFont(font, offscreenCanvas);
        if (fontProperties.fontSize === 0) {
          fontProperties.fontSize = fontSize;
          fontProperties.ascent = fontSize;
        }
        var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
        context.font = font;
        parsedStyle.isOverflowing = false;
        var outputText = wordWrap ? this.wordWrap(text, parsedStyle, offscreenCanvas) : text;
        var lines = outputText.split(/(?:\r\n|\r|\n)/);
        var lineWidths = new Array(lines.length);
        var maxLineWidth = 0;
        if (textPath) {
          textPath.getTotalLength();
          for (var i = 0; i < lines.length; i++) {
            context.measureText(lines[i]).width + (lines[i].length - 1) * letterSpacing;
          }
        } else {
          for (var _i = 0; _i < lines.length; _i++) {
            var _lineWidth = context.measureText(lines[_i]).width + (lines[_i].length - 1) * letterSpacing;
            lineWidths[_i] = _lineWidth;
            maxLineWidth = Math.max(maxLineWidth, _lineWidth);
          }
          var _width = maxLineWidth + lineWidth;
          var lineHeight = strokeHeight || fontProperties.fontSize + lineWidth;
          var height = Math.max(lineHeight, fontProperties.fontSize + lineWidth) + (lines.length - 1) * (lineHeight + leading);
          lineHeight += leading;
          var offsetY = 0;
          if (textBaseline === "middle") {
            offsetY = -height / 2;
          } else if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
            offsetY = -height;
          } else if (textBaseline === "top" || textBaseline === "hanging") {
            offsetY = 0;
          }
          return {
            font,
            width: _width,
            height,
            lines,
            lineWidths,
            lineHeight,
            maxLineWidth,
            fontProperties,
            lineMetrics: lineWidths.map(function(width2, i2) {
              var offsetX = 0;
              if (textAlign === "center" || textAlign === "middle") {
                offsetX -= width2 / 2;
              } else if (textAlign === "right" || textAlign === "end") {
                offsetX -= width2;
              }
              return new Rectangle(offsetX - lineWidth / 2, offsetY + i2 * lineHeight, width2 + lineWidth, lineHeight);
            })
          };
        }
      }
    }, {
      key: "wordWrap",
      value: function wordWrap(text, parsedStyle, offscreenCanvas) {
        var _this2 = this;
        var chars = Array.from(text);
        if (chars.length === 0) {
          return "";
        }
        var self2 = this;
        var _parsedStyle$wordWrap2 = parsedStyle.wordWrapWidth, wordWrapWidth = _parsedStyle$wordWrap2 === void 0 ? 0 : _parsedStyle$wordWrap2, _parsedStyle$letterSp2 = parsedStyle.letterSpacing, letterSpacing = _parsedStyle$letterSp2 === void 0 ? 0 : _parsedStyle$letterSp2, _parsedStyle$maxLines = parsedStyle.maxLines, maxLines = _parsedStyle$maxLines === void 0 ? Infinity : _parsedStyle$maxLines, textOverflow = parsedStyle.textOverflow;
        var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
        var maxWidth = wordWrapWidth + letterSpacing;
        var ellipsis = "";
        if (textOverflow === "ellipsis") {
          ellipsis = "...";
        } else if (textOverflow && textOverflow !== "clip") {
          ellipsis = textOverflow;
        }
        var lines = [""];
        var currentLineIndex = 0;
        var currentLineWidth = 0;
        var prevLineLastCharIndex = -1;
        var font = toFontString(parsedStyle);
        var charCache = this.charWidthCache.get(font);
        if (!charCache) {
          charCache = new LRU(500);
          this.charWidthCache.put(font, charCache);
        }
        var calcWidth = function calcWidth2(_char2) {
          return _this2.getFromCache(_char2, letterSpacing, charCache, context);
        };
        var ellipsisWidth = calcWidth(ellipsis);
        function findCharIndexClosestWidthThreshold(lineTxt, txtLastCharIndex, txtStartCharIndex, widthThreshold) {
          while (calcWidth(lineTxt) < widthThreshold && txtLastCharIndex < chars.length - 1) {
            if (self2.isNewline(chars[txtLastCharIndex + 1])) {
              break;
            }
            txtLastCharIndex += 1;
            lineTxt += chars[txtLastCharIndex];
          }
          while (calcWidth(lineTxt) > widthThreshold && // @see https://github.com/antvis/G/issues/1932
          txtLastCharIndex >= txtStartCharIndex) {
            txtLastCharIndex -= 1;
            lineTxt = lineTxt.slice(0, -1);
          }
          return {
            lineTxt,
            txtLastCharIndex
          };
        }
        function appendEllipsis(lineIndex, textCharIndex) {
          if (ellipsisWidth <= 0 || ellipsisWidth > maxWidth) {
            return;
          }
          if (!lines[lineIndex]) {
            lines[lineIndex] = ellipsis;
            return;
          }
          var result2 = findCharIndexClosestWidthThreshold(lines[lineIndex], textCharIndex, prevLineLastCharIndex + 1, maxWidth - ellipsisWidth);
          lines[lineIndex] = result2.lineTxt + ellipsis;
        }
        for (var i = 0; i < chars.length; i++) {
          var _char3 = chars[i];
          var prevChar = chars[i - 1];
          var nextChar = chars[i + 1];
          var charWidth = calcWidth(_char3);
          if (this.isNewline(_char3)) {
            if (currentLineIndex + 1 >= maxLines) {
              if (i < chars.length - 1) {
                appendEllipsis(currentLineIndex, i - 1);
              }
              parsedStyle.isOverflowing = true;
              break;
            }
            prevLineLastCharIndex = i - 1;
            currentLineIndex += 1;
            currentLineWidth = 0;
            lines[currentLineIndex] = "";
            continue;
          }
          if (charWidth > maxWidth) {
            appendEllipsis(currentLineIndex, i - 1);
            parsedStyle.isOverflowing = true;
            break;
          }
          if (currentLineWidth > 0 && currentLineWidth + charWidth > maxWidth) {
            var result = findCharIndexClosestWidthThreshold(lines[currentLineIndex], i - 1, prevLineLastCharIndex + 1, maxWidth);
            if (result.txtLastCharIndex !== i - 1) {
              lines[currentLineIndex] = result.lineTxt;
              if (result.txtLastCharIndex === chars.length - 1) {
                break;
              }
              i = result.txtLastCharIndex + 1;
              _char3 = chars[i];
              prevChar = chars[i - 1];
              nextChar = chars[i + 1];
              charWidth = calcWidth(_char3);
            }
            if (currentLineIndex + 1 >= maxLines) {
              appendEllipsis(currentLineIndex, i - 1);
              parsedStyle.isOverflowing = true;
              break;
            }
            prevLineLastCharIndex = i - 1;
            currentLineIndex += 1;
            currentLineWidth = 0;
            lines[currentLineIndex] = "";
            if (this.isBreakingSpace(_char3)) {
              continue;
            }
            if (!this.canBreakInLastChar(_char3)) {
              lines = this.trimToBreakable(lines);
              currentLineWidth = this.sumTextWidthByCache(lines[currentLineIndex] || "", calcWidth);
            }
            if (this.shouldBreakByKinsokuShorui(_char3, nextChar)) {
              lines = this.trimByKinsokuShorui(lines);
              currentLineWidth += calcWidth(prevChar || "");
            }
          }
          currentLineWidth += charWidth;
          lines[currentLineIndex] += _char3;
        }
        return lines.join("\n");
      }
    }, {
      key: "isBreakingSpace",
      value: function isBreakingSpace(_char4) {
        if (typeof _char4 !== "string") {
          return false;
        }
        return TEXT_METRICS.BreakingSpaces.indexOf(_char4.charCodeAt(0)) >= 0;
      }
    }, {
      key: "isNewline",
      value: function isNewline(_char5) {
        if (typeof _char5 !== "string") {
          return false;
        }
        return TEXT_METRICS.Newlines.indexOf(_char5.charCodeAt(0)) >= 0;
      }
    }, {
      key: "trimToBreakable",
      value: function trimToBreakable(prev) {
        var next = _toConsumableArray(prev);
        var prevLine = next[next.length - 2];
        var index2 = this.findBreakableIndex(prevLine);
        if (index2 === -1 || !prevLine) return next;
        var trimmedChar = prevLine.slice(index2, index2 + 1);
        var isTrimmedWithSpace = this.isBreakingSpace(trimmedChar);
        var trimFrom = index2 + 1;
        var trimTo = index2 + (isTrimmedWithSpace ? 0 : 1);
        next[next.length - 1] += prevLine.slice(trimFrom, prevLine.length);
        next[next.length - 2] = prevLine.slice(0, trimTo);
        return next;
      }
    }, {
      key: "canBreakInLastChar",
      value: function canBreakInLastChar(_char6) {
        if (_char6 && LATIN_REGEX.test(_char6)) return false;
        return true;
      }
    }, {
      key: "sumTextWidthByCache",
      value: function sumTextWidthByCache(text, calcWidthWithCache) {
        return text.split("").reduce(function(sum, c2) {
          return sum + calcWidthWithCache(c2);
        }, 0);
      }
    }, {
      key: "findBreakableIndex",
      value: function findBreakableIndex(line2) {
        for (var i = line2.length - 1; i >= 0; i--) {
          if (!LATIN_REGEX.test(line2[i])) return i;
        }
        return -1;
      }
    }, {
      key: "getFromCache",
      value: function getFromCache(key, letterSpacing, cache, context) {
        var width2 = cache.get(key);
        if (typeof width2 !== "number") {
          var spacing = key.length * letterSpacing;
          var metrics = context.measureText(key);
          width2 = metrics.width + spacing;
          cache.put(key, width2);
        }
        return width2;
      }
    }, {
      key: "clearCache",
      value: function clearCache() {
        this.fontMetricsCache = {};
        this.charWidthCache.clear();
      }
    }]);
  })();
  var runtime = {};
  var geometryUpdaterFactory = (function(_ref) {
    var rectUpdater = new RectUpdater();
    var polylineUpdater = new PolylineUpdater();
    return _ref = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_ref, Shape.FRAGMENT, null), Shape.CIRCLE, new CircleUpdater()), Shape.ELLIPSE, new EllipseUpdater()), Shape.RECT, rectUpdater), Shape.IMAGE, rectUpdater), Shape.GROUP, new GroupUpdater()), Shape.LINE, new LineUpdater()), Shape.TEXT, new TextUpdater(runtime)), Shape.POLYLINE, polylineUpdater), Shape.POLYGON, polylineUpdater), _defineProperty(_defineProperty(_defineProperty(_ref, Shape.PATH, new PathUpdater()), Shape.HTML, new HTMLUpdater()), Shape.MESH, null);
  })();
  var CSSPropertySyntaxFactory = (function(_ref2) {
    var color2 = new CSSPropertyColor();
    var length = new CSSPropertyLengthOrPercentage();
    return _ref2 = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_ref2, PropertySyntax.PERCENTAGE, null), PropertySyntax.NUMBER, new CSSPropertyNumber()), PropertySyntax.ANGLE, new CSSPropertyAngle()), PropertySyntax.DEFINED_PATH, new CSSPropertyClipPath()), PropertySyntax.PAINT, color2), PropertySyntax.COLOR, color2), PropertySyntax.FILTER, new CSSPropertyFilter()), PropertySyntax.LENGTH, length), PropertySyntax.LENGTH_PERCENTAGE, length), PropertySyntax.LENGTH_PERCENTAGE_12, new CSSPropertyLengthOrPercentage12()), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_ref2, PropertySyntax.LENGTH_PERCENTAGE_14, new CSSPropertyLengthOrPercentage14()), PropertySyntax.COORDINATE, new CSSPropertyLengthOrPercentage()), PropertySyntax.OFFSET_DISTANCE, new CSSPropertyOffsetDistance()), PropertySyntax.OPACITY_VALUE, new CSSPropertyOpacity()), PropertySyntax.PATH, new CSSPropertyPath()), PropertySyntax.LIST_OF_POINTS, new CSSPropertyPoints()), PropertySyntax.SHADOW_BLUR, new CSSPropertyShadowBlur()), PropertySyntax.TEXT, new CSSPropertyText()), PropertySyntax.TEXT_TRANSFORM, new CSSPropertyTextTransform()), PropertySyntax.TRANSFORM, new CSSPropertyTransform()), _defineProperty(_defineProperty(_defineProperty(_ref2, PropertySyntax.TRANSFORM_ORIGIN, new CSSPropertyTransformOrigin()), PropertySyntax.Z_INDEX, new CSSPropertyZIndex()), PropertySyntax.MARKER, new CSSPropertyMarker());
  })();
  var getGlobalThis = function getGlobalThis2() {
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    return {};
  };
  runtime.CameraContribution = Camera;
  runtime.AnimationTimeline = null;
  runtime.EasingFunction = null;
  runtime.offscreenCanvasCreator = new OffscreenCanvasCreator();
  runtime.sceneGraphSelector = new DefaultSceneGraphSelector();
  runtime.sceneGraphService = new DefaultSceneGraphService(runtime);
  runtime.textService = new TextService(runtime);
  runtime.geometryUpdaterFactory = geometryUpdaterFactory;
  runtime.CSSPropertySyntaxFactory = CSSPropertySyntaxFactory;
  runtime.styleValueRegistry = new DefaultStyleValueRegistry(runtime);
  runtime.layoutRegistry = null;
  runtime.globalThis = getGlobalThis();
  runtime.enableStyleSyntax = true;
  runtime.enableSizeAttenuation = false;
  var entityCounter = 0;
  var insertedEvent = new MutationEvent(ElementEvent.INSERTED, null, "", "", "", 0, "", "");
  var removedEvent = new MutationEvent(ElementEvent.REMOVED, null, "", "", "", 0, "", "");
  var destroyEvent = new CustomEvent(ElementEvent.DESTROY);
  var Element2 = /* @__PURE__ */ (function(_Node) {
    function Element3() {
      var _this2;
      _classCallCheck(this, Element3);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this2 = _callSuper(this, Element3, [].concat(args));
      _this2.entity = entityCounter++;
      _this2.transformable = {
        dirtyFlag: false,
        localDirtyFlag: false,
        localPosition: [0, 0, 0],
        localRotation: [0, 0, 0, 1],
        localScale: [1, 1, 1],
        localTransform: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        localSkew: [0, 0],
        position: [0, 0, 0],
        rotation: [0, 0, 0, 1],
        scaling: [1, 1, 1],
        worldTransform: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        origin: [0, 0, 0]
      };
      _this2.renderable = {
        bounds: void 0,
        boundsDirty: true,
        renderBounds: void 0,
        renderBoundsDirty: true,
        dirtyRenderBounds: void 0,
        dirty: false
      };
      _this2.geometry = {
        contentBounds: void 0,
        renderBounds: void 0,
        dirty: true
      };
      _this2.cullable = {
        strategy: Strategy.Standard,
        visibilityPlaneMask: -1,
        visible: true,
        enable: true
      };
      _this2.sortable = {
        dirty: false,
        sorted: void 0,
        renderOrder: 0,
        dirtyChildren: [],
        dirtyReason: void 0
      };
      _this2.rBushNode = {
        aabb: void 0
      };
      _this2.namespaceURI = "g";
      _this2.scrollLeft = 0;
      _this2.scrollTop = 0;
      _this2.clientTop = 0;
      _this2.clientLeft = 0;
      _this2.style = {};
      _this2.computedStyle = {};
      _this2.parsedStyle = {
        // opacity: '',
        // fillOpacity: '',
        // strokeOpacity: '',
        // transformOrigin: '',
        // visibility: '',
        // pointerEvents: '',
        // lineWidth: '',
        // lineCap: '',
        // lineJoin: '',
        // increasedLineWidthForHitTesting: '',
        // fontSize: '',
        // fontFamily: '',
        // fontStyle: '',
        // fontWeight: '',
        // fontVariant: '',
        // textAlign: '',
        // textBaseline: '',
        // textTransform: '',
      };
      _this2.attributes = {};
      return _this2;
    }
    _inherits(Element3, _Node);
    return _createClass(Element3, [{
      key: "dirty",
      value: (
        /**
         * @param flag - default `true`, whether the object needs to be updated
         * @param updateShape - default `false`, whether the bounding box of the object is updated
         */
        function dirty() {
          var flag = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          var updateShape = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          this.renderable.dirty = flag;
          if (updateShape) {
            this.renderable.boundsDirty = flag;
            this.renderable.renderBoundsDirty = flag;
          }
        }
      )
    }, {
      key: "className",
      get: (
        /**
         * used with `getElementById()`
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/id
         */
        /**
         * used in `getElementsByClassName`
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
         */
        function get9() {
          return this.getAttribute("class") || "";
        }
      ),
      set: function set6(className) {
        this.setAttribute("class", className);
      }
      /**
       * used in `getElementsByName`
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByName
       */
    }, {
      key: "classList",
      get: (
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/classList
         */
        function get9() {
          return this.className.split(" ").filter(function(c2) {
            return c2 !== "";
          });
        }
      )
    }, {
      key: "tagName",
      get: function get9() {
        return this.nodeName;
      }
    }, {
      key: "children",
      get: function get9() {
        return this.childNodes;
      }
    }, {
      key: "childElementCount",
      get: function get9() {
        return this.childNodes.length;
      }
    }, {
      key: "firstElementChild",
      get: function get9() {
        return this.firstChild;
      }
    }, {
      key: "lastElementChild",
      get: function get9() {
        return this.lastChild;
      }
    }, {
      key: "parentElement",
      get: function get9() {
        return this.parentNode;
      }
    }, {
      key: "nextSibling",
      get: function get9() {
        if (this.parentNode) {
          var index2 = this.parentNode.childNodes.indexOf(this);
          return this.parentNode.childNodes[index2 + 1] || null;
        }
        return null;
      }
    }, {
      key: "previousSibling",
      get: function get9() {
        if (this.parentNode) {
          var index2 = this.parentNode.childNodes.indexOf(this);
          return this.parentNode.childNodes[index2 - 1] || null;
        }
        return null;
      }
    }, {
      key: "cloneNode",
      value: function cloneNode(deep2) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "appendChild",
      value: function appendChild(child, index2) {
        var _this$ownerDocument;
        if (child.destroyed) {
          throw new Error(ERROR_MSG_APPEND_DESTROYED_ELEMENT);
        }
        runtime.sceneGraphService.attach(child, this, index2);
        if ((_this$ownerDocument = this.ownerDocument) !== null && _this$ownerDocument !== void 0 && _this$ownerDocument.defaultView) {
          if (!isInFragment(this) && child.nodeName === Shape.FRAGMENT) {
            this.ownerDocument.defaultView.mountFragment(child);
          } else {
            this.ownerDocument.defaultView.mountChildren(child);
          }
        }
        if (this.isMutationObserved) {
          insertedEvent.relatedNode = this;
          child.dispatchEvent(insertedEvent);
        }
        return child;
      }
    }, {
      key: "insertBefore",
      value: function insertBefore(newChild, refChild) {
        if (!refChild) {
          this.appendChild(newChild);
        } else {
          if (newChild.parentElement) {
            newChild.parentElement.removeChild(newChild);
          }
          var index2 = this.childNodes.indexOf(refChild);
          if (index2 === -1) {
            this.appendChild(newChild);
          } else {
            this.appendChild(newChild, index2);
          }
        }
        return newChild;
      }
    }, {
      key: "replaceChild",
      value: function replaceChild(newChild, oldChild) {
        var index2 = this.childNodes.indexOf(oldChild);
        this.removeChild(oldChild);
        this.appendChild(newChild, index2);
        return oldChild;
      }
    }, {
      key: "removeChild",
      value: function removeChild(child) {
        var _this$ownerDocument2, _child$ownerDocument;
        var enableCancelEventPropagation = ((_this$ownerDocument2 = this.ownerDocument) === null || _this$ownerDocument2 === void 0 || (_this$ownerDocument2 = _this$ownerDocument2.defaultView) === null || _this$ownerDocument2 === void 0 || (_this$ownerDocument2 = _this$ownerDocument2.getConfig().future) === null || _this$ownerDocument2 === void 0 ? void 0 : _this$ownerDocument2.experimentalCancelEventPropagation) === true;
        removedEvent.relatedNode = this;
        child.dispatchEvent(removedEvent, enableCancelEventPropagation, enableCancelEventPropagation);
        if ((_child$ownerDocument = child.ownerDocument) !== null && _child$ownerDocument !== void 0 && _child$ownerDocument.defaultView) {
          child.ownerDocument.defaultView.unmountChildren(child);
        }
        runtime.sceneGraphService.detach(child);
        return child;
      }
      /**
       * Remove all children which can be appended to its original parent later again.
       */
    }, {
      key: "removeChildren",
      value: function removeChildren() {
        for (var i = this.childNodes.length - 1; i >= 0; i--) {
          var child = this.childNodes[i];
          this.removeChild(child);
        }
      }
      /**
       * Recursively destroy all children which can not be appended to its original parent later again.
       */
    }, {
      key: "destroyChildren",
      value: function destroyChildren() {
        for (var i = this.childNodes.length - 1; i >= 0; i--) {
          var child = this.childNodes[i];
          if (child.childNodes.length > 0) {
            child.destroyChildren();
          }
          child.destroy();
        }
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/matches
       */
    }, {
      key: "matches",
      value: function matches(selector) {
        return runtime.sceneGraphService.matches(selector, this);
      }
    }, {
      key: "getElementById",
      value: function getElementById(id3) {
        return runtime.sceneGraphService.querySelector("#".concat(id3), this);
      }
    }, {
      key: "getElementsByName",
      value: function getElementsByName(name) {
        return runtime.sceneGraphService.querySelectorAll('[name="'.concat(name, '"]'), this);
      }
    }, {
      key: "getElementsByClassName",
      value: function getElementsByClassName(className) {
        return runtime.sceneGraphService.querySelectorAll(".".concat(className), this);
      }
    }, {
      key: "getElementsByTagName",
      value: function getElementsByTagName(tagName) {
        return runtime.sceneGraphService.querySelectorAll(tagName, this);
      }
    }, {
      key: "querySelector",
      value: function querySelector(selectors) {
        return runtime.sceneGraphService.querySelector(selectors, this);
      }
    }, {
      key: "querySelectorAll",
      value: function querySelectorAll(selectors) {
        return runtime.sceneGraphService.querySelectorAll(selectors, this);
      }
      /**
       * should traverses the element and its parents (heading toward the document root)
       * until it finds a node that matches the specified CSS selector.
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/closest
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#polyfill
       */
    }, {
      key: "closest",
      value: function closest(selectors) {
        var el = this;
        do {
          if (runtime.sceneGraphService.matches(selectors, el)) return el;
          el = el.parentElement;
        } while (el !== null);
        return null;
      }
      /**
       * search in scene group, but should not include itself
       */
    }, {
      key: "find",
      value: function find4(filter) {
        var _this2 = this;
        var target = null;
        this.forEach(function(object) {
          if (object !== _this2 && filter(object)) {
            target = object;
            return false;
          }
          return true;
        });
        return target;
      }
    }, {
      key: "findAll",
      value: function findAll(filter) {
        var _this3 = this;
        var objects = [];
        this.forEach(function(object) {
          if (object !== _this3 && filter(object)) {
            objects.push(object);
          }
        });
        return objects;
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/after
       */
    }, {
      key: "after",
      value: function after() {
        var _this4 = this;
        if (this.parentNode) {
          var index2 = this.parentNode.childNodes.indexOf(this);
          for (var _len2 = arguments.length, nodes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            nodes[_key2] = arguments[_key2];
          }
          nodes.forEach(function(node, i) {
            var _this4$parentNode;
            return (_this4$parentNode = _this4.parentNode) === null || _this4$parentNode === void 0 ? void 0 : _this4$parentNode.appendChild(node, index2 + i + 1);
          });
        }
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/before
       */
    }, {
      key: "before",
      value: function before() {
        if (this.parentNode) {
          var _ref;
          var index2 = this.parentNode.childNodes.indexOf(this);
          for (var _len3 = arguments.length, nodes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            nodes[_key3] = arguments[_key3];
          }
          var first = nodes[0], rest = nodes.slice(1);
          this.parentNode.appendChild(first, index2);
          (_ref = first).after.apply(_ref, _toConsumableArray(rest));
        }
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/replaceWith
       */
    }, {
      key: "replaceWith",
      value: function replaceWith() {
        this.after.apply(this, arguments);
        this.remove();
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/append
       */
    }, {
      key: "append",
      value: function append() {
        var _this5 = this;
        for (var _len4 = arguments.length, nodes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          nodes[_key4] = arguments[_key4];
        }
        nodes.forEach(function(node) {
          return _this5.appendChild(node);
        });
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/prepend
       */
    }, {
      key: "prepend",
      value: function prepend() {
        var _this6 = this;
        for (var _len5 = arguments.length, nodes = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          nodes[_key5] = arguments[_key5];
        }
        nodes.forEach(function(node, i) {
          return _this6.appendChild(node, i);
        });
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/replaceChildren
       */
    }, {
      key: "replaceChildren",
      value: function replaceChildren2() {
        while (this.childNodes.length && this.firstChild) {
          this.removeChild(this.firstChild);
        }
        this.append.apply(this, arguments);
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/remove
       */
    }, {
      key: "remove",
      value: function remove() {
        if (this.parentNode) {
          return this.parentNode.removeChild(this);
        }
        return this;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        var _this$ownerDocument3;
        var enableCancelEventPropagation = ((_this$ownerDocument3 = this.ownerDocument) === null || _this$ownerDocument3 === void 0 || (_this$ownerDocument3 = _this$ownerDocument3.defaultView) === null || _this$ownerDocument3 === void 0 || (_this$ownerDocument3 = _this$ownerDocument3.getConfig().future) === null || _this$ownerDocument3 === void 0 ? void 0 : _this$ownerDocument3.experimentalCancelEventPropagation) === true;
        this.destroyChildren();
        this.dispatchEvent(destroyEvent, enableCancelEventPropagation, enableCancelEventPropagation);
        this.remove();
        this.emitter.removeAllListeners();
        this.destroyed = true;
      }
    }, {
      key: "getGeometryBounds",
      value: function getGeometryBounds() {
        return runtime.sceneGraphService.getGeometryBounds(this);
      }
    }, {
      key: "getRenderBounds",
      value: function getRenderBounds() {
        return runtime.sceneGraphService.getBounds(this, true);
      }
      /**
       * get bounds in world space, account for children
       */
    }, {
      key: "getBounds",
      value: function getBounds2() {
        return runtime.sceneGraphService.getBounds(this);
      }
      /**
       * get bounds in local space, account for children
       */
    }, {
      key: "getLocalBounds",
      value: function getLocalBounds() {
        return runtime.sceneGraphService.getLocalBounds(this);
      }
      /**
       * account for context's bounds in client space,
       * but not accounting for children
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
       */
    }, {
      key: "getBoundingClientRect",
      value: function getBoundingClientRect() {
        return runtime.sceneGraphService.getBoundingClientRect(this);
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getClientRects
       */
    }, {
      key: "getClientRects",
      value: function getClientRects() {
        return [this.getBoundingClientRect()];
      }
    }, {
      key: "computedStyleMap",
      value: (
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/computedStyleMap
         * eg. circle.computedStyleMap().get('fill');
         */
        function computedStyleMap() {
          return new Map(Object.entries(this.computedStyle));
        }
      )
    }, {
      key: "getAttributeNames",
      value: (
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNames
         */
        function getAttributeNames() {
          return Object.keys(this.attributes);
        }
      )
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute
       */
    }, {
      key: "getAttribute",
      value: function getAttribute(name) {
        if (typeof name === "symbol") {
          return void 0;
        }
        var value = this.attributes[name];
        if (value === void 0) {
          return value;
        }
        return value;
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/hasAttribute
       */
    }, {
      key: "hasAttribute",
      value: function hasAttribute(qualifiedName) {
        return this.getAttributeNames().includes(qualifiedName);
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/hasAttributes
       */
    }, {
      key: "hasAttributes",
      value: function hasAttributes() {
        return !!this.getAttributeNames().length;
      }
      /**
       * should use removeAttribute() instead of setting the attribute value to null either directly or using setAttribute(). Many attributes will not behave as expected if you set them to null.
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute
       */
    }, {
      key: "removeAttribute",
      value: function removeAttribute(attributeName) {
        this.setAttribute(attributeName, null);
        delete this.attributes[attributeName];
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute
       */
    }, {
      key: "setAttribute",
      value: function setAttribute(attributeName, value, force, memoize4) {
        this.attributes[attributeName] = value;
      }
    }, {
      key: "getAttributeNS",
      value: function getAttributeNS(namespace, localName) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "getAttributeNode",
      value: function getAttributeNode(qualifiedName) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "getAttributeNodeNS",
      value: function getAttributeNodeNS(namespace, localName) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "hasAttributeNS",
      value: function hasAttributeNS(namespace, localName) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "removeAttributeNS",
      value: function removeAttributeNS(namespace, localName) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "removeAttributeNode",
      value: function removeAttributeNode(attr2) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "setAttributeNS",
      value: function setAttributeNS(namespace, qualifiedName, value) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "setAttributeNode",
      value: function setAttributeNode(attr2) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "setAttributeNodeNS",
      value: function setAttributeNodeNS(attr2) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "toggleAttribute",
      value: function toggleAttribute(qualifiedName, force) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }]);
  })(Node);
  function isDisplayObject(value) {
    return !!(value !== null && value !== void 0 && value.nodeName);
  }
  var Proxy2 = runtime.globalThis.Proxy ? runtime.globalThis.Proxy : function() {
  };
  var attrModifiedEvent = new MutationEvent(ElementEvent.ATTR_MODIFIED, null, null, null, null, MutationEvent.MODIFICATION, null, null);
  var $vec3 = import_gl_matrix2.vec3.create();
  var $quat = import_gl_matrix2.quat.create();
  var DisplayObject = /* @__PURE__ */ (function(_Element) {
    function DisplayObject2(config) {
      var _this2;
      _classCallCheck(this, DisplayObject2);
      _this2 = _callSuper(this, DisplayObject2);
      _this2.isCustomElement = false;
      _this2.isMutationObserved = false;
      _this2.activeAnimations = [];
      _this2.config = config;
      _this2.id = config.id || "";
      _this2.name = config.name || "";
      if (config.className || config["class"]) {
        _this2.className = config.className || config["class"];
      }
      _this2.nodeName = config.type || Shape.GROUP;
      if (config.initialParsedStyle) {
        Object.assign(_this2.parsedStyle, config.initialParsedStyle);
      }
      _this2.initAttributes(config.style);
      if (runtime.enableStyleSyntax) {
        _this2.style = new Proxy2(
          // @ts-ignore
          {
            // ...this.attributes,
            setProperty: function setProperty(propertyName, value) {
              _this2.setAttribute(propertyName, value);
            },
            getPropertyValue: function getPropertyValue(propertyName) {
              return _this2.getAttribute(propertyName);
            },
            removeProperty: function removeProperty(propertyName) {
              _this2.removeAttribute(propertyName);
            },
            item: function item() {
              return "";
            }
          },
          {
            get: function get9(target, name) {
              if (target[name] !== void 0) {
                return target[name];
              }
              return _this2.getAttribute(name);
            },
            set: function set6(_2, prop, value) {
              _this2.setAttribute(prop, value);
              return true;
            }
          }
        );
      }
      return _this2;
    }
    _inherits(DisplayObject2, _Element);
    return _createClass(DisplayObject2, [{
      key: "destroy",
      value: function destroy() {
        _superPropGet(DisplayObject2, "destroy", this, 3)([]);
        this.getAnimations().forEach(function(animation) {
          animation.cancel();
        });
      }
    }, {
      key: "cloneNode",
      value: function cloneNode(deep2, customCloneFunc) {
        var clonedStyle = _objectSpread2({}, this.attributes);
        for (var attributeName in clonedStyle) {
          var attribute = clonedStyle[attributeName];
          if (isDisplayObject(attribute) && // share the same clipPath if possible
          attributeName !== "clipPath" && attributeName !== "offsetPath" && attributeName !== "textPath") {
            clonedStyle[attributeName] = attribute.cloneNode(deep2);
          }
          if (customCloneFunc) {
            clonedStyle[attributeName] = customCloneFunc(attributeName, attribute);
          }
        }
        var cloned = new this.constructor(_objectSpread2(_objectSpread2({}, this.config), {}, {
          style: clonedStyle
        }));
        cloned.setLocalTransform(this.getLocalTransform());
        if (deep2) {
          this.children.forEach(function(child) {
            if (!child.style.isMarker) {
              var clonedChild = child.cloneNode(deep2);
              cloned.appendChild(clonedChild);
            }
          });
        }
        return cloned;
      }
    }, {
      key: "initAttributes",
      value: function initAttributes() {
        var attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var options = {
          forceUpdateGeometry: true
        };
        runtime.styleValueRegistry.processProperties(this, attributes, options);
        this.dirty();
      }
    }, {
      key: "setAttribute",
      value: function setAttribute(name, value) {
        var force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        var memoize4 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
        if ((0, import_util2.isUndefined)(value)) {
          return;
        }
        if (force || value !== this.attributes[name]) {
          this.internalSetAttribute(name, value, {
            memoize: memoize4
          });
          _superPropGet(DisplayObject2, "setAttribute", this, 3)([name, value]);
        }
      }
      /**
       * called when attributes get changed or initialized
       */
    }, {
      key: "internalSetAttribute",
      value: function internalSetAttribute(name, value) {
        var parseOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var oldValue = this.attributes[name];
        var oldParsedValue = this.parsedStyle[name];
        runtime.styleValueRegistry.processProperties(this, _defineProperty({}, name, value), parseOptions);
        this.dirty();
        var newParsedValue = this.parsedStyle[name];
        if (this.isConnected) {
          attrModifiedEvent.relatedNode = this;
          attrModifiedEvent.prevValue = oldValue;
          attrModifiedEvent.newValue = value;
          attrModifiedEvent.attrName = name;
          attrModifiedEvent.prevParsedValue = oldParsedValue;
          attrModifiedEvent.newParsedValue = newParsedValue;
          if (this.isMutationObserved) {
            this.dispatchEvent(attrModifiedEvent);
          } else {
            var _this$ownerDocument$d;
            var enableCancelEventPropagation = ((_this$ownerDocument$d = this.ownerDocument.defaultView.getConfig().future) === null || _this$ownerDocument$d === void 0 ? void 0 : _this$ownerDocument$d.experimentalCancelEventPropagation) === true;
            attrModifiedEvent.target = this;
            this.ownerDocument.defaultView.dispatchEvent(attrModifiedEvent, true, enableCancelEventPropagation);
          }
        }
        if (this.isCustomElement && this.isConnected || !this.isCustomElement) {
          var _attributeChangedCall, _ref;
          (_attributeChangedCall = (_ref = this).attributeChangedCallback) === null || _attributeChangedCall === void 0 || _attributeChangedCall.call(_ref, name, oldValue, value, oldParsedValue, newParsedValue);
        }
      }
      // #region transformable
      /**
       * returns different values than getBoundingClientRect(), as the latter returns value relative to the viewport
       * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement/getBBox
       *
       * FIXME: It is worth noting that getBBox responds to original untransformed values of a drawn object.
       * @see https://www.w3.org/Graphics/SVG/IG/resources/svgprimer.html#getBBox
       */
    }, {
      key: "getBBox",
      value: function getBBox2() {
        var aabb = this.getBounds();
        var _aabb$getMin = aabb.getMin(), _aabb$getMin2 = _slicedToArray(_aabb$getMin, 2), left = _aabb$getMin2[0], top = _aabb$getMin2[1];
        var _aabb$getMax = aabb.getMax(), _aabb$getMax2 = _slicedToArray(_aabb$getMax, 2), right = _aabb$getMax2[0], bottom = _aabb$getMax2[1];
        return new Rectangle(left, top, right - left, bottom - top);
      }
    }, {
      key: "setOrigin",
      value: function setOrigin(position2) {
        var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        runtime.sceneGraphService.setOrigin(this, createVec3(position2, y3, z, false));
        return this;
      }
    }, {
      key: "getOrigin",
      value: function getOrigin() {
        return runtime.sceneGraphService.getOrigin(this);
      }
      /**
       * set position in world space
       */
    }, {
      key: "setPosition",
      value: function setPosition(position2) {
        var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        runtime.sceneGraphService.setPosition(this, createVec3(position2, y3, z, false));
        return this;
      }
      /**
       * set position in local space
       */
    }, {
      key: "setLocalPosition",
      value: function setLocalPosition(position2) {
        var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        runtime.sceneGraphService.setLocalPosition(this, createVec3(position2, y3, z, false));
        return this;
      }
      /**
       * translate in world space
       */
    }, {
      key: "translate",
      value: function translate3(position2) {
        var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        runtime.sceneGraphService.translate(this, createVec3(position2, y3, z, false));
        return this;
      }
      /**
       * translate in local space
       */
    }, {
      key: "translateLocal",
      value: function translateLocal(position2) {
        var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        runtime.sceneGraphService.translateLocal(this, createVec3(position2, y3, z, false));
        return this;
      }
    }, {
      key: "getPosition",
      value: function getPosition() {
        return runtime.sceneGraphService.getPosition(this);
      }
    }, {
      key: "getLocalPosition",
      value: function getLocalPosition() {
        return runtime.sceneGraphService.getLocalPosition(this);
      }
      /**
       * compatible with G 3.0
       *
       * scaling in local space
       * scale(10) = scale(10, 10, 10)
       *
       * we can't set scale in world space
       */
    }, {
      key: "scale",
      value: function scale4(scaling, y3, z) {
        return this.scaleLocal(scaling, y3, z);
      }
    }, {
      key: "scaleLocal",
      value: function scaleLocal(scaling, y3, z) {
        if (typeof scaling === "number") {
          y3 = y3 || scaling;
          z = z || scaling;
          scaling = createVec3(scaling, y3, z, false);
        }
        runtime.sceneGraphService.scaleLocal(this, scaling);
        return this;
      }
      /**
       * set scaling in local space
       */
    }, {
      key: "setLocalScale",
      value: function setLocalScale(scaling, y3, z) {
        if (typeof scaling === "number") {
          y3 = y3 || scaling;
          z = z || scaling;
          scaling = createVec3(scaling, y3, z, false);
        }
        runtime.sceneGraphService.setLocalScale(this, scaling);
        return this;
      }
      /**
       * get scaling in local space
       */
    }, {
      key: "getLocalScale",
      value: function getLocalScale() {
        return runtime.sceneGraphService.getLocalScale(this);
      }
      /**
       * get scaling in world space
       */
    }, {
      key: "getScale",
      value: function getScale() {
        return runtime.sceneGraphService.getScale(this);
      }
      /**
       * only return degrees of Z axis in world space
       */
    }, {
      key: "getEulerAngles",
      value: function getEulerAngles() {
        var _getEuler = getEuler($vec3, runtime.sceneGraphService.getWorldTransform(this)), _getEuler2 = _slicedToArray(_getEuler, 3), ez = _getEuler2[2];
        return rad2deg(ez);
      }
      /**
       * only return degrees of Z axis in local space
       */
    }, {
      key: "getLocalEulerAngles",
      value: function getLocalEulerAngles() {
        var _getEuler3 = getEuler($vec3, runtime.sceneGraphService.getLocalRotation(this)), _getEuler4 = _slicedToArray(_getEuler3, 3), ez = _getEuler4[2];
        return rad2deg(ez);
      }
      /**
       * set euler angles(degrees) in world space
       */
    }, {
      key: "setEulerAngles",
      value: function setEulerAngles(z) {
        runtime.sceneGraphService.setEulerAngles(this, 0, 0, z);
        return this;
      }
      /**
       * set euler angles(degrees) in local space
       */
    }, {
      key: "setLocalEulerAngles",
      value: function setLocalEulerAngles(z) {
        runtime.sceneGraphService.setLocalEulerAngles(this, 0, 0, z);
        return this;
      }
    }, {
      key: "rotateLocal",
      value: function rotateLocal(x3, y3, z) {
        if ((0, import_util2.isNil)(y3) && (0, import_util2.isNil)(z)) {
          runtime.sceneGraphService.rotateLocal(this, 0, 0, x3);
        } else {
          runtime.sceneGraphService.rotateLocal(this, x3, y3, z);
        }
        return this;
      }
    }, {
      key: "rotate",
      value: function rotate3(x3, y3, z) {
        if ((0, import_util2.isNil)(y3) && (0, import_util2.isNil)(z)) {
          runtime.sceneGraphService.rotate(this, 0, 0, x3);
        } else {
          runtime.sceneGraphService.rotate(this, x3, y3, z);
        }
        return this;
      }
    }, {
      key: "setRotation",
      value: function setRotation(rotation, y3, z, w) {
        runtime.sceneGraphService.setRotation(this, rotation, y3, z, w);
        return this;
      }
    }, {
      key: "setLocalRotation",
      value: function setLocalRotation(rotation, y3, z, w) {
        runtime.sceneGraphService.setLocalRotation(this, rotation, y3, z, w);
        return this;
      }
    }, {
      key: "setLocalSkew",
      value: function setLocalSkew(skew2, y3) {
        runtime.sceneGraphService.setLocalSkew(this, skew2, y3);
        return this;
      }
    }, {
      key: "getRotation",
      value: function getRotation() {
        return runtime.sceneGraphService.getRotation(this);
      }
    }, {
      key: "getLocalRotation",
      value: function getLocalRotation() {
        return runtime.sceneGraphService.getLocalRotation(this);
      }
    }, {
      key: "getLocalSkew",
      value: function getLocalSkew() {
        return runtime.sceneGraphService.getLocalSkew(this);
      }
    }, {
      key: "getLocalTransform",
      value: function getLocalTransform() {
        return runtime.sceneGraphService.getLocalTransform(this);
      }
    }, {
      key: "getWorldTransform",
      value: function getWorldTransform() {
        return runtime.sceneGraphService.getWorldTransform(this);
      }
    }, {
      key: "setLocalTransform",
      value: function setLocalTransform(transform) {
        runtime.sceneGraphService.setLocalTransform(this, transform);
        return this;
      }
    }, {
      key: "resetLocalTransform",
      value: function resetLocalTransform() {
        runtime.sceneGraphService.resetLocalTransform(this);
      }
      // #endregion transformable
      // #region animatable
      /**
       * returns an array of all Animation objects affecting this element
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAnimations
       */
    }, {
      key: "getAnimations",
      value: function getAnimations() {
        return this.activeAnimations;
      }
      /**
       * create an animation with WAAPI
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/animate
       */
    }, {
      key: "animate",
      value: function animate2(keyframes, options) {
        var _this$ownerDocument;
        var timeline = (_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : _this$ownerDocument.timeline;
        if (timeline) {
          return timeline.play(this, keyframes, options);
        }
        return null;
      }
      // #endregion animatable
      // #region visible
      /**
       * shortcut for Used value of `visibility`
       */
    }, {
      key: "isVisible",
      value: function isVisible2() {
        var _this$parsedStyle;
        return ((_this$parsedStyle = this.parsedStyle) === null || _this$parsedStyle === void 0 ? void 0 : _this$parsedStyle.visibility) !== "hidden";
      }
    }, {
      key: "interactive",
      get: function get9() {
        return this.isInteractive();
      },
      set: function set6(b) {
        this.style.pointerEvents = b ? "auto" : "none";
      }
    }, {
      key: "isInteractive",
      value: function isInteractive() {
        var _this$parsedStyle2;
        return ((_this$parsedStyle2 = this.parsedStyle) === null || _this$parsedStyle2 === void 0 ? void 0 : _this$parsedStyle2.pointerEvents) !== "none";
      }
    }, {
      key: "isCulled",
      value: function isCulled() {
        return !!(this.cullable && this.cullable.enable && !this.cullable.visible);
      }
      /**
       * bring to front in current group
       */
    }, {
      key: "toFront",
      value: function toFront() {
        if (this.parentNode) {
          this.style.zIndex = Math.max.apply(Math, _toConsumableArray(this.parentNode.children.map(function(child) {
            return Number(child.style.zIndex);
          }))) + 1;
        }
        return this;
      }
      /**
       * send to back in current group
       */
    }, {
      key: "toBack",
      value: function toBack() {
        if (this.parentNode) {
          this.style.zIndex = Math.min.apply(Math, _toConsumableArray(this.parentNode.children.map(function(child) {
            return Number(child.style.zIndex);
          }))) - 1;
        }
        return this;
      }
      // #endregion visible
      // #region deprecated
      /**
       * compatible with G 3.0
       * @alias object.config
       * @deprecated
       */
    }, {
      key: "getConfig",
      value: function getConfig() {
        return this.config;
      }
      /**
       * @alias style
       * @example
       * circle.style.r = 10;
       * const r = circle.style;
       * @deprecated
       */
    }, {
      key: "attr",
      value: function attr2() {
        var _this2 = this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var name = args[0], value = args[1];
        if (!name) {
          return this.attributes;
        }
        if ((0, import_util2.isObject)(name)) {
          Object.keys(name).forEach(function(key) {
            _this2.setAttribute(key, name[key]);
          });
          return this;
        }
        if (args.length === 2) {
          this.setAttribute(name, value);
          return this;
        }
        return this.attributes[name];
      }
      /**
       * return 3x3 matrix in world space
       * @deprecated
       */
    }, {
      key: "getMatrix",
      value: function getMatrix(transformMat4) {
        var transform = transformMat4 || this.getWorldTransform();
        var _mat4$getTranslation = import_gl_matrix2.mat4.getTranslation($vec3, transform), _mat4$getTranslation2 = _slicedToArray(_mat4$getTranslation, 2), tx = _mat4$getTranslation2[0], ty = _mat4$getTranslation2[1];
        var _mat4$getScaling = import_gl_matrix2.mat4.getScaling($vec3, transform), _mat4$getScaling2 = _slicedToArray(_mat4$getScaling, 2), sx = _mat4$getScaling2[0], sy = _mat4$getScaling2[1];
        var rotation = import_gl_matrix2.mat4.getRotation($quat, transform);
        var _getEuler5 = getEuler($vec3, rotation), _getEuler6 = _slicedToArray(_getEuler5, 3), eux = _getEuler6[0], euz = _getEuler6[2];
        return fromRotationTranslationScale(eux || euz, tx, ty, sx, sy);
      }
      /**
       * return 3x3 matrix in local space
       * @deprecated
       */
    }, {
      key: "getLocalMatrix",
      value: function getLocalMatrix() {
        return this.getMatrix(this.getLocalTransform());
      }
      /**
       * set 3x3 matrix in world space
       * @deprecated
       */
    }, {
      key: "setMatrix",
      value: function setMatrix(mat) {
        var _decompose = decompose(mat), _decompose2 = _slicedToArray(_decompose, 5), tx = _decompose2[0], ty = _decompose2[1], scalingX = _decompose2[2], scalingY = _decompose2[3], angle2 = _decompose2[4];
        this.setEulerAngles(angle2).setPosition(tx, ty).setLocalScale(scalingX, scalingY);
      }
      /**
       * set 3x3 matrix in local space
       * @deprecated
       */
    }, {
      key: "setLocalMatrix",
      value: function setLocalMatrix(mat) {
        var _decompose3 = decompose(mat), _decompose4 = _slicedToArray(_decompose3, 5), tx = _decompose4[0], ty = _decompose4[1], scalingX = _decompose4[2], scalingY = _decompose4[3], angle2 = _decompose4[4];
        this.setLocalEulerAngles(angle2).setLocalPosition(tx, ty).setLocalScale(scalingX, scalingY);
      }
      /**
       * Use `visibility: visible` instead.
       * @deprecated
       */
    }, {
      key: "show",
      value: function show2() {
        this.forEach(function(object) {
          object.style.visibility = "visible";
        });
      }
      /**
       * Use `visibility: hidden` instead.
       * @deprecated
       */
    }, {
      key: "hide",
      value: function hide2() {
        this.forEach(function(object) {
          object.style.visibility = "hidden";
        });
      }
      /**
       * Use `childElementCount` instead.
       * @deprecated
       */
    }, {
      key: "getCount",
      value: function getCount() {
        return this.childElementCount;
      }
      /**
       * Use `parentElement` instead.
       * @deprecated
       */
    }, {
      key: "getParent",
      value: function getParent() {
        return this.parentElement;
      }
      /**
       * Use `children` instead.
       * @deprecated
       */
    }, {
      key: "getChildren",
      value: function getChildren() {
        return this.children;
      }
      /**
       * Use `firstElementChild` instead.
       * @deprecated
       */
    }, {
      key: "getFirst",
      value: function getFirst() {
        return this.firstElementChild;
      }
      /**
       * Use `lastElementChild` instead.
       * @deprecated
       */
    }, {
      key: "getLast",
      value: function getLast() {
        return this.lastElementChild;
      }
      /**
       * Use `this.children[index]` instead.
       * @deprecated
       */
    }, {
      key: "getChildByIndex",
      value: function getChildByIndex(index2) {
        return this.children[index2] || null;
      }
      /**
       * Use `appendChild` instead.
       * @deprecated
       */
    }, {
      key: "add",
      value: function add5(child, index2) {
        return this.appendChild(child, index2);
      }
      /**
       * @deprecated
       */
    }, {
      key: "set",
      value: function set6(name, value) {
        this.config[name] = value;
      }
      /**
       * @deprecated
       */
    }, {
      key: "get",
      value: function get9(name) {
        return this.config[name];
      }
      /**
       * Use `setPosition` instead.
       * @deprecated
       */
    }, {
      key: "moveTo",
      value: function moveTo2(position2) {
        var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        this.setPosition(position2, y3, z);
        return this;
      }
      /**
       * Use `setPosition` instead.
       * @deprecated
       */
    }, {
      key: "move",
      value: function move(position2) {
        var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        this.setPosition(position2, y3, z);
        return this;
      }
      /**
       * Use `this.style.zIndex` instead.
       * @deprecated
       */
    }, {
      key: "setZIndex",
      value: function setZIndex(zIndex) {
        this.style.zIndex = zIndex;
        return this;
      }
      // #endregion deprecated
    }]);
  })(Element2);
  DisplayObject.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className", "clipPath", "cursor", "display", "draggable", "droppable", "fill", "fillOpacity", "fillRule", "filter", "increasedLineWidthForHitTesting", "lineCap", "lineDash", "lineDashOffset", "lineJoin", "lineWidth", "miterLimit", "hitArea", "offsetDistance", "offsetPath", "offsetX", "offsetY", "opacity", "pointerEvents", "shadowColor", "shadowType", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "stroke", "strokeOpacity", "strokeWidth", "strokeLinecap", "strokeLineJoin", "strokeDasharray", "strokeDashoffset", "transform", "transformOrigin", "textTransform", "visibility", "zIndex"]);
  var Circle = /* @__PURE__ */ (function(_DisplayObject) {
    function Circle4() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, Circle4);
      return _callSuper(this, Circle4, [_objectSpread2({
        type: Shape.CIRCLE
      }, options)]);
    }
    _inherits(Circle4, _DisplayObject);
    return _createClass(Circle4);
  })(DisplayObject);
  Circle.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["cx", "cy", "cz", "r", "isBillboard", "isSizeAttenuation"]));
  var _excluded$6 = ["style"];
  var CustomElement = /* @__PURE__ */ (function(_DisplayObject) {
    function CustomElement2() {
      var _this2;
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$6);
      _classCallCheck(this, CustomElement2);
      _this2 = _callSuper(this, CustomElement2, [_objectSpread2({
        style
      }, rest)]);
      _this2.isCustomElement = true;
      return _this2;
    }
    _inherits(CustomElement2, _DisplayObject);
    return _createClass(CustomElement2);
  })(DisplayObject);
  CustomElement.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className", "clipPath", "cursor", "draggable", "droppable", "opacity", "pointerEvents", "transform", "transformOrigin", "zIndex", "visibility"]);
  var Ellipse = /* @__PURE__ */ (function(_DisplayObject) {
    function Ellipse3() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, Ellipse3);
      return _callSuper(this, Ellipse3, [_objectSpread2({
        type: Shape.ELLIPSE
      }, options)]);
    }
    _inherits(Ellipse3, _DisplayObject);
    return _createClass(Ellipse3);
  })(DisplayObject);
  Ellipse.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["cx", "cy", "cz", "rx", "ry", "isBillboard", "isSizeAttenuation"]));
  var Fragment = /* @__PURE__ */ (function(_DisplayObject) {
    function Fragment2() {
      _classCallCheck(this, Fragment2);
      return _callSuper(this, Fragment2, [{
        type: Shape.FRAGMENT
      }]);
    }
    _inherits(Fragment2, _DisplayObject);
    return _createClass(Fragment2);
  })(DisplayObject);
  Fragment.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className"]);
  var Group = /* @__PURE__ */ (function(_DisplayObject) {
    function Group2() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, Group2);
      return _callSuper(this, Group2, [_objectSpread2({
        type: Shape.GROUP
      }, options)]);
    }
    _inherits(Group2, _DisplayObject);
    return _createClass(Group2);
  })(DisplayObject);
  Group.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className", "clipPath", "cursor", "draggable", "droppable", "opacity", "pointerEvents", "transform", "transformOrigin", "zIndex", "visibility"]);
  var _excluded$5 = ["style"];
  var HTML = /* @__PURE__ */ (function(_DisplayObject) {
    function HTML3() {
      var _this2;
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$5);
      _classCallCheck(this, HTML3);
      _this2 = _callSuper(this, HTML3, [_objectSpread2({
        type: Shape.HTML,
        style
      }, rest)]);
      _this2.cullable.enable = false;
      return _this2;
    }
    _inherits(HTML3, _DisplayObject);
    return _createClass(HTML3, [{
      key: "getDomElement",
      value: function getDomElement() {
        return this.parsedStyle.$el;
      }
      /**
       * override with $el.getBoundingClientRect
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect
       *
       * ! The calculation logic of the html element should be consistent with that of the canvas element
       */
      // getBoundingClientRect(): Rectangle {
      //   if (this.parsedStyle.$el) {
      //     return this.parsedStyle.$el.getBoundingClientRect();
      //   } else {
      //     const { x, y, width, height } = this.parsedStyle;
      //     return new Rectangle(x, y, width, height);
      //   }
      // }
    }, {
      key: "getClientRects",
      value: function getClientRects() {
        return [this.getBoundingClientRect()];
      }
      // getBounds() {
      //   const clientRect = this.getBoundingClientRect();
      //   // calc context's offset
      //   // @ts-ignore
      //   const canvasRect = this.ownerDocument?.defaultView
      //     ?.getContextService()
      //     .getBoundingClientRect();
      //   const aabb = new AABB();
      //   const minX = clientRect.left - (canvasRect?.left || 0);
      //   const minY = clientRect.top - (canvasRect?.top || 0);
      //   aabb.setMinMax(
      //     [minX, minY, 0],
      //     [minX + clientRect.width, minY + clientRect.height, 0],
      //   );
      //   return aabb;
      // }
    }, {
      key: "getLocalBounds",
      value: function getLocalBounds() {
        if (this.parentNode) {
          var parentInvert = import_gl_matrix2.mat4.invert(import_gl_matrix2.mat4.create(), this.parentNode.getWorldTransform());
          var bounds = this.getBounds();
          if (!AABB.isEmpty(bounds)) {
            var localBounds = new AABB();
            localBounds.setFromTransformedAABB(bounds, parentInvert);
            return localBounds;
          }
        }
        return this.getBounds();
      }
    }]);
  })(DisplayObject);
  HTML.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x", "y", "$el", "innerHTML", "width", "height"]));
  var Image2 = /* @__PURE__ */ (function(_DisplayObject) {
    function Image6() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, Image6);
      return _callSuper(this, Image6, [_objectSpread2({
        type: Shape.IMAGE
      }, options)]);
    }
    _inherits(Image6, _DisplayObject);
    return _createClass(Image6);
  })(DisplayObject);
  Image2.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x", "y", "z", "src", "width", "height", "isBillboard", "billboardRotation", "isSizeAttenuation", "keepAspectRatio"]));
  var _excluded$4 = ["style"];
  var Line = /* @__PURE__ */ (function(_DisplayObject) {
    function Line4() {
      var _this2;
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$4);
      _classCallCheck(this, Line4);
      _this2 = _callSuper(this, Line4, [_objectSpread2({
        type: Shape.LINE,
        style: _objectSpread2({
          x1: 0,
          y1: 0,
          x2: 0,
          y2: 0,
          z1: 0,
          z2: 0
        }, style)
      }, rest)]);
      _this2.markerStartAngle = 0;
      _this2.markerEndAngle = 0;
      var _this$parsedStyle = _this2.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd;
      if (markerStart && isDisplayObject(markerStart)) {
        _this2.markerStartAngle = markerStart.getLocalEulerAngles();
        _this2.appendChild(markerStart);
      }
      if (markerEnd && isDisplayObject(markerEnd)) {
        _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
        _this2.appendChild(markerEnd);
      }
      _this2.transformMarker(true);
      _this2.transformMarker(false);
      return _this2;
    }
    _inherits(Line4, _DisplayObject);
    return _createClass(Line4, [{
      key: "attributeChangedCallback",
      value: function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
        if (attrName === "x1" || attrName === "y1" || attrName === "x2" || attrName === "y2" || attrName === "markerStartOffset" || attrName === "markerEndOffset") {
          this.transformMarker(true);
          this.transformMarker(false);
        } else if (attrName === "markerStart") {
          if (prevParsedValue && isDisplayObject(prevParsedValue)) {
            this.markerStartAngle = 0;
            prevParsedValue.remove();
          }
          if (newParsedValue && isDisplayObject(newParsedValue)) {
            this.markerStartAngle = newParsedValue.getLocalEulerAngles();
            this.appendChild(newParsedValue);
            this.transformMarker(true);
          }
        } else if (attrName === "markerEnd") {
          if (prevParsedValue && isDisplayObject(prevParsedValue)) {
            this.markerEndAngle = 0;
            prevParsedValue.remove();
          }
          if (newParsedValue && isDisplayObject(newParsedValue)) {
            this.markerEndAngle = newParsedValue.getLocalEulerAngles();
            this.appendChild(newParsedValue);
            this.transformMarker(false);
          }
        }
      }
    }, {
      key: "transformMarker",
      value: function transformMarker(isStart) {
        var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset, x1 = _this$parsedStyle2.x1, x22 = _this$parsedStyle2.x2, y1 = _this$parsedStyle2.y1, y22 = _this$parsedStyle2.y2;
        var marker = isStart ? markerStart : markerEnd;
        if (!marker || !isDisplayObject(marker)) {
          return;
        }
        var rad2 = 0;
        var x3;
        var y3;
        var ox;
        var oy;
        var offset;
        var originalAngle;
        if (isStart) {
          ox = x1;
          oy = y1;
          x3 = x22 - x1;
          y3 = y22 - y1;
          offset = markerStartOffset || 0;
          originalAngle = this.markerStartAngle;
        } else {
          ox = x22;
          oy = y22;
          x3 = x1 - x22;
          y3 = y1 - y22;
          offset = markerEndOffset || 0;
          originalAngle = this.markerEndAngle;
        }
        rad2 = Math.atan2(y3, x3);
        marker.setLocalEulerAngles(rad2 * 180 / Math.PI + originalAngle);
        marker.setLocalPosition(ox + Math.cos(rad2) * offset, oy + Math.sin(rad2) * offset);
      }
    }, {
      key: "getPoint",
      value: function getPoint(ratio) {
        var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var _this$parsedStyle3 = this.parsedStyle, x1 = _this$parsedStyle3.x1, y1 = _this$parsedStyle3.y1, x22 = _this$parsedStyle3.x2, y22 = _this$parsedStyle3.y2;
        var _linePointAt = pointAt$3(x1, y1, x22, y22, ratio), x3 = _linePointAt.x, y3 = _linePointAt.y;
        var transformed = import_gl_matrix2.vec3.transformMat4(import_gl_matrix2.vec3.create(), import_gl_matrix2.vec3.fromValues(x3, y3, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
        return new Point(transformed[0], transformed[1]);
      }
    }, {
      key: "getPointAtLength",
      value: function getPointAtLength2(distance6) {
        var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        return this.getPoint(distance6 / this.getTotalLength(), inWorldSpace);
      }
    }, {
      key: "getTotalLength",
      value: function getTotalLength2() {
        var _this$parsedStyle4 = this.parsedStyle, x1 = _this$parsedStyle4.x1, y1 = _this$parsedStyle4.y1, x22 = _this$parsedStyle4.x2, y22 = _this$parsedStyle4.y2;
        return length$4(x1, y1, x22, y22);
      }
    }]);
  })(DisplayObject);
  Line.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x1", "y1", "x2", "y2", "z1", "z2", "isBillboard", "isSizeAttenuation", "markerStart", "markerEnd", "markerStartOffset", "markerEndOffset"]));
  var _excluded$3 = ["style"];
  var Path = /* @__PURE__ */ (function(_DisplayObject) {
    function Path2() {
      var _this2;
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$3);
      _classCallCheck(this, Path2);
      _this2 = _callSuper(this, Path2, [_objectSpread2({
        type: Shape.PATH,
        style,
        initialParsedStyle: {
          miterLimit: 4,
          d: _objectSpread2({}, EMPTY_PARSED_PATH)
        }
      }, rest)]);
      _this2.markerStartAngle = 0;
      _this2.markerEndAngle = 0;
      _this2.markerMidList = [];
      var _this$parsedStyle = _this2.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd, markerMid = _this$parsedStyle.markerMid;
      if (markerStart && isDisplayObject(markerStart)) {
        _this2.markerStartAngle = markerStart.getLocalEulerAngles();
        _this2.appendChild(markerStart);
      }
      if (markerMid && isDisplayObject(markerMid)) {
        _this2.placeMarkerMid(markerMid);
      }
      if (markerEnd && isDisplayObject(markerEnd)) {
        _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
        _this2.appendChild(markerEnd);
      }
      _this2.transformMarker(true);
      _this2.transformMarker(false);
      return _this2;
    }
    _inherits(Path2, _DisplayObject);
    return _createClass(Path2, [{
      key: "attributeChangedCallback",
      value: function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
        if (attrName === "d") {
          this.transformMarker(true);
          this.transformMarker(false);
          this.placeMarkerMid(this.parsedStyle.markerMid);
        } else if (attrName === "markerStartOffset" || attrName === "markerEndOffset") {
          this.transformMarker(true);
          this.transformMarker(false);
        } else if (attrName === "markerStart") {
          if (prevParsedValue && isDisplayObject(prevParsedValue)) {
            this.markerStartAngle = 0;
            prevParsedValue.remove();
          }
          if (newParsedValue && isDisplayObject(newParsedValue)) {
            this.markerStartAngle = newParsedValue.getLocalEulerAngles();
            this.appendChild(newParsedValue);
            this.transformMarker(true);
          }
        } else if (attrName === "markerEnd") {
          if (prevParsedValue && isDisplayObject(prevParsedValue)) {
            this.markerEndAngle = 0;
            prevParsedValue.remove();
          }
          if (newParsedValue && isDisplayObject(newParsedValue)) {
            this.markerEndAngle = newParsedValue.getLocalEulerAngles();
            this.appendChild(newParsedValue);
            this.transformMarker(false);
          }
        } else if (attrName === "markerMid") {
          this.placeMarkerMid(newParsedValue);
        }
      }
    }, {
      key: "transformMarker",
      value: function transformMarker(isStart) {
        var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset;
        var marker = isStart ? markerStart : markerEnd;
        if (!marker || !isDisplayObject(marker)) {
          return;
        }
        var rad2 = 0;
        var x3;
        var y3;
        var ox;
        var oy;
        var offset;
        var originalAngle;
        if (isStart) {
          var _this$getStartTangent = this.getStartTangent(), _this$getStartTangent2 = _slicedToArray(_this$getStartTangent, 2), p1 = _this$getStartTangent2[0], p2 = _this$getStartTangent2[1];
          ox = p2[0];
          oy = p2[1];
          x3 = p1[0] - p2[0];
          y3 = p1[1] - p2[1];
          offset = markerStartOffset || 0;
          originalAngle = this.markerStartAngle;
        } else {
          var _this$getEndTangent = this.getEndTangent(), _this$getEndTangent2 = _slicedToArray(_this$getEndTangent, 2), _p = _this$getEndTangent2[0], _p2 = _this$getEndTangent2[1];
          ox = _p2[0];
          oy = _p2[1];
          x3 = _p[0] - _p2[0];
          y3 = _p[1] - _p2[1];
          offset = markerEndOffset || 0;
          originalAngle = this.markerEndAngle;
        }
        rad2 = Math.atan2(y3, x3);
        marker.setLocalEulerAngles(rad2 * 180 / Math.PI + originalAngle);
        marker.setLocalPosition(ox + Math.cos(rad2) * offset, oy + Math.sin(rad2) * offset);
      }
    }, {
      key: "placeMarkerMid",
      value: function placeMarkerMid(marker) {
        var segments = this.parsedStyle.d.segments;
        this.markerMidList.forEach(function(marker2) {
          marker2.remove();
        });
        if (marker && isDisplayObject(marker)) {
          for (var i = 1; i < segments.length - 1; i++) {
            var _segments$i$currentPo = _slicedToArray(segments[i].currentPoint, 2), ox = _segments$i$currentPo[0], oy = _segments$i$currentPo[1];
            var cloned = i === 1 ? marker : marker.cloneNode(true);
            this.markerMidList.push(cloned);
            this.appendChild(cloned);
            cloned.setLocalPosition(ox, oy);
          }
        }
      }
      /**
       * Returns the total length of the path.
       * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getTotalLength
       */
    }, {
      key: "getTotalLength",
      value: function getTotalLength2() {
        return getOrCalculatePathTotalLength(this);
      }
      /**
       * Returns the point at a given distance along the path.
       * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getPointAtLength
       */
    }, {
      key: "getPointAtLength",
      value: function getPointAtLength$1(distance6) {
        var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var absolutePath = this.parsedStyle.d.absolutePath;
        var _getPointAtLength2 = (0, import_util2.getPointAtLength)(absolutePath, distance6), x3 = _getPointAtLength2.x, y3 = _getPointAtLength2.y;
        var transformed = import_gl_matrix2.vec3.transformMat4(import_gl_matrix2.vec3.create(), import_gl_matrix2.vec3.fromValues(x3, y3, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
        return new Point(transformed[0], transformed[1]);
      }
      /**
       * Returns the point at a given ratio of the total length in path.
       */
    }, {
      key: "getPoint",
      value: function getPoint(ratio) {
        var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        return this.getPointAtLength(ratio * getOrCalculatePathTotalLength(this), inWorldSpace);
      }
      /**
       * Get start tangent vector
       */
    }, {
      key: "getStartTangent",
      value: function getStartTangent() {
        var segments = this.parsedStyle.d.segments;
        var result = [];
        if (segments.length > 1) {
          var startPoint = segments[0].currentPoint;
          var endPoint = segments[1].currentPoint;
          var tangent = segments[1].startTangent;
          result = [];
          if (tangent) {
            result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
            result.push([startPoint[0], startPoint[1]]);
          } else {
            result.push([endPoint[0], endPoint[1]]);
            result.push([startPoint[0], startPoint[1]]);
          }
        }
        return result;
      }
      /**
       * Get end tangent vector
       */
    }, {
      key: "getEndTangent",
      value: function getEndTangent() {
        var segments = this.parsedStyle.d.segments;
        var length = segments.length;
        var result = [];
        if (length > 1) {
          var startPoint = segments[length - 2].currentPoint;
          var endPoint = segments[length - 1].currentPoint;
          var tangent = segments[length - 1].endTangent;
          result = [];
          if (tangent) {
            result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
            result.push([endPoint[0], endPoint[1]]);
          } else {
            result.push([startPoint[0], startPoint[1]]);
            result.push([endPoint[0], endPoint[1]]);
          }
        }
        return result;
      }
    }]);
  })(DisplayObject);
  Path.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["d", "markerStart", "markerMid", "markerEnd", "markerStartOffset", "markerEndOffset", "isBillboard", "isSizeAttenuation"]));
  var _excluded$2 = ["style"];
  var Polygon = /* @__PURE__ */ (function(_DisplayObject) {
    function Polygon3() {
      var _this2;
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$2);
      _classCallCheck(this, Polygon3);
      _this2 = _callSuper(this, Polygon3, [_objectSpread2({
        type: Shape.POLYGON,
        style,
        initialParsedStyle: {
          points: {
            points: [],
            totalLength: 0,
            segments: []
          },
          miterLimit: 4,
          isClosed: true
        }
      }, rest)]);
      _this2.markerStartAngle = 0;
      _this2.markerEndAngle = 0;
      _this2.markerMidList = [];
      var _this$parsedStyle = _this2.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd, markerMid = _this$parsedStyle.markerMid;
      if (markerStart && isDisplayObject(markerStart)) {
        _this2.markerStartAngle = markerStart.getLocalEulerAngles();
        _this2.appendChild(markerStart);
      }
      if (markerMid && isDisplayObject(markerMid)) {
        _this2.placeMarkerMid(markerMid);
      }
      if (markerEnd && isDisplayObject(markerEnd)) {
        _this2.markerEndAngle = markerEnd.getLocalEulerAngles();
        _this2.appendChild(markerEnd);
      }
      _this2.transformMarker(true);
      _this2.transformMarker(false);
      return _this2;
    }
    _inherits(Polygon3, _DisplayObject);
    return _createClass(Polygon3, [{
      key: "attributeChangedCallback",
      value: function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
        if (attrName === "points") {
          this.transformMarker(true);
          this.transformMarker(false);
          this.placeMarkerMid(this.parsedStyle.markerMid);
        } else if (attrName === "markerStartOffset" || attrName === "markerEndOffset") {
          this.transformMarker(true);
          this.transformMarker(false);
        } else if (attrName === "markerStart") {
          if (prevParsedValue && isDisplayObject(prevParsedValue)) {
            this.markerStartAngle = 0;
            prevParsedValue.remove();
          }
          if (newParsedValue && isDisplayObject(newParsedValue)) {
            this.markerStartAngle = newParsedValue.getLocalEulerAngles();
            this.appendChild(newParsedValue);
            this.transformMarker(true);
          }
        } else if (attrName === "markerEnd") {
          if (prevParsedValue && isDisplayObject(prevParsedValue)) {
            this.markerEndAngle = 0;
            prevParsedValue.remove();
          }
          if (newParsedValue && isDisplayObject(newParsedValue)) {
            this.markerEndAngle = newParsedValue.getLocalEulerAngles();
            this.appendChild(newParsedValue);
            this.transformMarker(false);
          }
        } else if (attrName === "markerMid") {
          this.placeMarkerMid(newParsedValue);
        }
      }
    }, {
      key: "transformMarker",
      value: function transformMarker(isStart) {
        var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset, P = _this$parsedStyle2.points;
        var _ref2 = P || {}, points = _ref2.points;
        var marker = isStart ? markerStart : markerEnd;
        if (!marker || !isDisplayObject(marker) || !points) {
          return;
        }
        var rad2 = 0;
        var x3;
        var y3;
        var ox;
        var oy;
        var offset;
        var originalAngle;
        ox = points[0][0];
        oy = points[0][1];
        if (isStart) {
          x3 = points[1][0] - points[0][0];
          y3 = points[1][1] - points[0][1];
          offset = markerStartOffset || 0;
          originalAngle = this.markerStartAngle;
        } else {
          var length = points.length;
          if (!this.parsedStyle.isClosed) {
            ox = points[length - 1][0];
            oy = points[length - 1][1];
            x3 = points[length - 2][0] - points[length - 1][0];
            y3 = points[length - 2][1] - points[length - 1][1];
          } else {
            x3 = points[length - 1][0] - points[0][0];
            y3 = points[length - 1][1] - points[0][1];
          }
          offset = markerEndOffset || 0;
          originalAngle = this.markerEndAngle;
        }
        rad2 = Math.atan2(y3, x3);
        marker.setLocalEulerAngles(rad2 * 180 / Math.PI + originalAngle);
        marker.setLocalPosition(ox + Math.cos(rad2) * offset, oy + Math.sin(rad2) * offset);
      }
    }, {
      key: "placeMarkerMid",
      value: function placeMarkerMid(marker) {
        var P = this.parsedStyle.points;
        var _ref3 = P || {}, points = _ref3.points;
        this.markerMidList.forEach(function(marker2) {
          marker2.remove();
        });
        this.markerMidList = [];
        if (marker && isDisplayObject(marker) && points) {
          for (var i = 1; i < (this.parsedStyle.isClosed ? points.length : points.length - 1); i++) {
            var ox = points[i][0];
            var oy = points[i][1];
            var cloned = i === 1 ? marker : marker.cloneNode(true);
            this.markerMidList.push(cloned);
            this.appendChild(cloned);
            cloned.setLocalPosition(ox, oy);
          }
        }
      }
    }]);
  })(DisplayObject);
  Polygon.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["points", "markerStart", "markerMid", "markerEnd", "markerStartOffset", "markerEndOffset", "isClosed", "isBillboard", "isSizeAttenuation"]));
  var _excluded$1 = ["style"];
  var Polyline = /* @__PURE__ */ (function(_Polygon) {
    function Polyline3() {
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded$1);
      _classCallCheck(this, Polyline3);
      return _callSuper(this, Polyline3, [_objectSpread2({
        type: Shape.POLYLINE,
        style,
        initialParsedStyle: {
          points: {
            points: [],
            totalLength: 0,
            segments: []
          },
          miterLimit: 4,
          isClosed: false
        }
      }, rest)]);
    }
    _inherits(Polyline3, _Polygon);
    return _createClass(Polyline3, [{
      key: "getTotalLength",
      value: function getTotalLength2() {
        return getOrCalculatePolylineTotalLength(this);
      }
    }, {
      key: "getPointAtLength",
      value: function getPointAtLength2(distance6) {
        var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        return this.getPoint(distance6 / this.getTotalLength(), inWorldSpace);
      }
    }, {
      key: "getPoint",
      value: function getPoint(ratio) {
        var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var points = this.parsedStyle.points.points;
        if (this.parsedStyle.points.segments.length === 0) {
          var segments = [];
          var tempLength = 0;
          var segmentT;
          var segmentL;
          var totalLength = this.getTotalLength();
          points.forEach(function(p, i) {
            if (points[i + 1]) {
              segmentT = [0, 0];
              segmentT[0] = tempLength / totalLength;
              segmentL = length$4(p[0], p[1], points[i + 1][0], points[i + 1][1]);
              tempLength += segmentL;
              segmentT[1] = tempLength / totalLength;
              segments.push(segmentT);
            }
          });
          this.parsedStyle.points.segments = segments;
        }
        var subt = 0;
        var index2 = 0;
        this.parsedStyle.points.segments.forEach(function(v, i) {
          if (ratio >= v[0] && ratio <= v[1]) {
            subt = (ratio - v[0]) / (v[1] - v[0]);
            index2 = i;
          }
        });
        var _linePointAt = pointAt$3(points[index2][0], points[index2][1], points[index2 + 1][0], points[index2 + 1][1], subt), x3 = _linePointAt.x, y3 = _linePointAt.y;
        var transformed = import_gl_matrix2.vec3.transformMat4(import_gl_matrix2.vec3.create(), import_gl_matrix2.vec3.fromValues(x3, y3, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
        return new Point(transformed[0], transformed[1]);
      }
    }, {
      key: "getStartTangent",
      value: function getStartTangent() {
        var points = this.parsedStyle.points.points;
        var result = [];
        result.push([points[1][0], points[1][1]]);
        result.push([points[0][0], points[0][1]]);
        return result;
      }
    }, {
      key: "getEndTangent",
      value: function getEndTangent() {
        var points = this.parsedStyle.points.points;
        var l = points.length - 1;
        var result = [];
        result.push([points[l - 1][0], points[l - 1][1]]);
        result.push([points[l][0], points[l][1]]);
        return result;
      }
    }]);
  })(Polygon);
  Polyline.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(Polygon.PARSED_STYLE_LIST), ["points", "markerStart", "markerMid", "markerEnd", "markerStartOffset", "markerEndOffset", "isBillboard"]));
  var Rect = /* @__PURE__ */ (function(_DisplayObject) {
    function Rect3() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, Rect3);
      return _callSuper(this, Rect3, [_objectSpread2({
        type: Shape.RECT
      }, options)]);
    }
    _inherits(Rect3, _DisplayObject);
    return _createClass(Rect3);
  })(DisplayObject);
  Rect.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x", "y", "z", "width", "height", "isBillboard", "isSizeAttenuation", "radius"]));
  var _excluded = ["style"];
  var Text = /* @__PURE__ */ (function(_DisplayObject) {
    function Text3() {
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties(_ref, _excluded);
      _classCallCheck(this, Text3);
      return _callSuper(this, Text3, [_objectSpread2({
        type: Shape.TEXT,
        style: _objectSpread2({
          fill: "black"
        }, style)
      }, rest)]);
    }
    _inherits(Text3, _DisplayObject);
    return _createClass(Text3, [{
      key: "getComputedTextLength",
      value: function getComputedTextLength() {
        var _this$parsedStyle$met;
        this.getGeometryBounds();
        return ((_this$parsedStyle$met = this.parsedStyle.metrics) === null || _this$parsedStyle$met === void 0 ? void 0 : _this$parsedStyle$met.maxLineWidth) || 0;
      }
    }, {
      key: "getLineBoundingRects",
      value: function getLineBoundingRects() {
        var _this$parsedStyle$met2;
        this.getGeometryBounds();
        return ((_this$parsedStyle$met2 = this.parsedStyle.metrics) === null || _this$parsedStyle$met2 === void 0 ? void 0 : _this$parsedStyle$met2.lineMetrics) || [];
      }
    }, {
      key: "isOverflowing",
      value: function isOverflowing() {
        this.getGeometryBounds();
        return !!this.parsedStyle.isOverflowing;
      }
    }]);
  })(DisplayObject);
  Text.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x", "y", "z", "isBillboard", "billboardRotation", "isSizeAttenuation", "text", "textAlign", "textBaseline", "fontStyle", "fontSize", "fontFamily", "fontWeight", "fontVariant", "lineHeight", "letterSpacing", "leading", "wordWrap", "wordWrapWidth", "maxLines", "textOverflow", "isOverflowing", "textPath", "textDecorationLine", "textDecorationColor", "textDecorationStyle", "textPathSide", "textPathStartOffset", "metrics", "dx", "dy"]));
  var CustomElementRegistry = /* @__PURE__ */ (function() {
    function CustomElementRegistry2() {
      _classCallCheck(this, CustomElementRegistry2);
      this.registry = {};
      this.define(Shape.CIRCLE, Circle);
      this.define(Shape.ELLIPSE, Ellipse);
      this.define(Shape.RECT, Rect);
      this.define(Shape.IMAGE, Image2);
      this.define(Shape.LINE, Line);
      this.define(Shape.GROUP, Group);
      this.define(Shape.PATH, Path);
      this.define(Shape.POLYGON, Polygon);
      this.define(Shape.POLYLINE, Polyline);
      this.define(Shape.TEXT, Text);
      this.define(Shape.HTML, HTML);
    }
    return _createClass(CustomElementRegistry2, [{
      key: "define",
      value: function define3(name, constructor) {
        this.registry[name] = constructor;
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/get
       */
    }, {
      key: "get",
      value: function get9(name) {
        return this.registry[name];
      }
    }]);
  })();
  var Document2 = /* @__PURE__ */ (function(_Node) {
    function Document3() {
      var _this2;
      _classCallCheck(this, Document3);
      _this2 = _callSuper(this, Document3);
      _this2.defaultView = null;
      _this2.ownerDocument = null;
      _this2.nodeName = "document";
      try {
        _this2.timeline = new runtime.AnimationTimeline(_this2);
      } catch (_unused) {
      }
      var initialStyle = {};
      BUILT_IN_PROPERTIES.forEach(function(_ref) {
        var n = _ref.n, inh = _ref.inh, d2 = _ref.d;
        if (inh && d2) {
          initialStyle[n] = (0, import_util2.isFunction)(d2) ? d2(Shape.GROUP) : d2;
        }
      });
      _this2.documentElement = new Group({
        id: "g-root",
        style: initialStyle
      });
      _this2.documentElement.ownerDocument = _this2;
      _this2.documentElement.parentNode = _this2;
      _this2.childNodes = [_this2.documentElement];
      return _this2;
    }
    _inherits(Document3, _Node);
    return _createClass(Document3, [{
      key: "children",
      get: function get9() {
        return this.childNodes;
      }
    }, {
      key: "childElementCount",
      get: function get9() {
        return this.childNodes.length;
      }
    }, {
      key: "firstElementChild",
      get: function get9() {
        return this.firstChild;
      }
    }, {
      key: "lastElementChild",
      get: function get9() {
        return this.lastChild;
      }
    }, {
      key: "createElement",
      value: (
        /**
         * @example const circle = document.createElement('circle', { style: { r: 10 } });
         */
        function createElement2(tagName, options) {
          if (tagName === "svg") {
            return this.documentElement;
          }
          var clazz = this.defaultView.customElements.get(tagName);
          if (!clazz) {
            console.warn("Unsupported tagName: ", tagName);
            clazz = tagName === "tspan" ? Text : Group;
          }
          var shape = new clazz(options);
          shape.ownerDocument = this;
          return shape;
        }
      )
    }, {
      key: "createElementNS",
      value: function createElementNS(namespaceURI, tagName, options) {
        return this.createElement(tagName, options);
      }
    }, {
      key: "cloneNode",
      value: function cloneNode(deep2) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        try {
          this.documentElement.destroyChildren();
          this.timeline.destroy();
        } catch (_unused2) {
        }
      }
      /**
       * Picking 2D graphics with RBush based on BBox, fast but inaccurate.
       */
    }, {
      key: "elementsFromBBox",
      value: function elementsFromBBox(minX, minY, maxX, maxY) {
        var rBush = this.defaultView.context.rBushRoot;
        var rBushNodes = rBush.search({
          minX,
          minY,
          maxX,
          maxY
        });
        var hitTestList = [];
        rBushNodes.forEach(function(_ref2) {
          var displayObject = _ref2.displayObject;
          var _displayObject$parsed = displayObject.parsedStyle.pointerEvents, pointerEvents = _displayObject$parsed === void 0 ? "auto" : _displayObject$parsed;
          var isVisibilityAffected = ["auto", "visiblepainted", "visiblefill", "visiblestroke", "visible"].includes(pointerEvents);
          if ((!isVisibilityAffected || isVisibilityAffected && displayObject.isVisible()) && !displayObject.isCulled() && displayObject.isInteractive()) {
            hitTestList.push(displayObject);
          }
        });
        hitTestList.sort(function(a2, b) {
          return b.sortable.renderOrder - a2.sortable.renderOrder;
        });
        return hitTestList;
      }
    }, {
      key: "elementFromPointSync",
      value: function elementFromPointSync(x3, y3) {
        var _this$defaultView$can = this.defaultView.canvas2Viewport({
          x: x3,
          y: y3
        }), viewportX = _this$defaultView$can.x, viewportY = _this$defaultView$can.y;
        var _this$defaultView$get = this.defaultView.getConfig(), width2 = _this$defaultView$get.width, height = _this$defaultView$get.height;
        if (viewportX < 0 || viewportY < 0 || viewportX > width2 || viewportY > height) {
          return null;
        }
        var _this$defaultView$vie = this.defaultView.viewport2Client({
          x: viewportX,
          y: viewportY
        }), clientX = _this$defaultView$vie.x, clientY = _this$defaultView$vie.y;
        var _this$defaultView$get2 = this.defaultView.getRenderingService().hooks.pickSync.call({
          topmost: true,
          position: {
            x: x3,
            y: y3,
            viewportX,
            viewportY,
            clientX,
            clientY
          },
          picked: []
        }), picked = _this$defaultView$get2.picked;
        return picked && picked[0] || this.documentElement;
      }
      /**
       * Do picking with API instead of triggering interactive events.
       *
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementFromPoint
       */
    }, {
      key: "elementFromPoint",
      value: (function() {
        var _elementFromPoint = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(x3, y3) {
          var _this$defaultView$can2, viewportX, viewportY, _this$defaultView$get3, width2, height, _this$defaultView$vie2, clientX, clientY, _yield$this$defaultVi, picked;
          return _regeneratorRuntime().wrap(function(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _this$defaultView$can2 = this.defaultView.canvas2Viewport({
                  x: x3,
                  y: y3
                }), viewportX = _this$defaultView$can2.x, viewportY = _this$defaultView$can2.y;
                _this$defaultView$get3 = this.defaultView.getConfig(), width2 = _this$defaultView$get3.width, height = _this$defaultView$get3.height;
                if (!(viewportX < 0 || viewportY < 0 || viewportX > width2 || viewportY > height)) {
                  _context.next = 1;
                  break;
                }
                return _context.abrupt("return", null);
              case 1:
                _this$defaultView$vie2 = this.defaultView.viewport2Client({
                  x: viewportX,
                  y: viewportY
                }), clientX = _this$defaultView$vie2.x, clientY = _this$defaultView$vie2.y;
                _context.next = 2;
                return this.defaultView.getRenderingService().hooks.pick.promise({
                  topmost: true,
                  position: {
                    x: x3,
                    y: y3,
                    viewportX,
                    viewportY,
                    clientX,
                    clientY
                  },
                  picked: []
                });
              case 2:
                _yield$this$defaultVi = _context.sent;
                picked = _yield$this$defaultVi.picked;
                return _context.abrupt("return", picked && picked[0] || this.documentElement);
              case 3:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
        function elementFromPoint(_x, _x2) {
          return _elementFromPoint.apply(this, arguments);
        }
        return elementFromPoint;
      })()
    }, {
      key: "elementsFromPointSync",
      value: function elementsFromPointSync(x3, y3) {
        var _this$defaultView$can3 = this.defaultView.canvas2Viewport({
          x: x3,
          y: y3
        }), viewportX = _this$defaultView$can3.x, viewportY = _this$defaultView$can3.y;
        var _this$defaultView$get4 = this.defaultView.getConfig(), width2 = _this$defaultView$get4.width, height = _this$defaultView$get4.height;
        if (viewportX < 0 || viewportY < 0 || viewportX > width2 || viewportY > height) {
          return [];
        }
        var _this$defaultView$vie3 = this.defaultView.viewport2Client({
          x: viewportX,
          y: viewportY
        }), clientX = _this$defaultView$vie3.x, clientY = _this$defaultView$vie3.y;
        var _this$defaultView$get5 = this.defaultView.getRenderingService().hooks.pickSync.call({
          topmost: false,
          position: {
            x: x3,
            y: y3,
            viewportX,
            viewportY,
            clientX,
            clientY
          },
          picked: []
        }), picked = _this$defaultView$get5.picked;
        if (picked[picked.length - 1] !== this.documentElement) {
          picked.push(this.documentElement);
        }
        return picked;
      }
      /**
       * Do picking with API instead of triggering interactive events.
       *
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementsFromPoint
       */
    }, {
      key: "elementsFromPoint",
      value: (function() {
        var _elementsFromPoint = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(x3, y3) {
          var _this$defaultView$can4, viewportX, viewportY, _this$defaultView$get6, width2, height, _this$defaultView$vie4, clientX, clientY, _yield$this$defaultVi2, picked;
          return _regeneratorRuntime().wrap(function(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _this$defaultView$can4 = this.defaultView.canvas2Viewport({
                  x: x3,
                  y: y3
                }), viewportX = _this$defaultView$can4.x, viewportY = _this$defaultView$can4.y;
                _this$defaultView$get6 = this.defaultView.getConfig(), width2 = _this$defaultView$get6.width, height = _this$defaultView$get6.height;
                if (!(viewportX < 0 || viewportY < 0 || viewportX > width2 || viewportY > height)) {
                  _context2.next = 1;
                  break;
                }
                return _context2.abrupt("return", []);
              case 1:
                _this$defaultView$vie4 = this.defaultView.viewport2Client({
                  x: viewportX,
                  y: viewportY
                }), clientX = _this$defaultView$vie4.x, clientY = _this$defaultView$vie4.y;
                _context2.next = 2;
                return this.defaultView.getRenderingService().hooks.pick.promise({
                  topmost: false,
                  position: {
                    x: x3,
                    y: y3,
                    viewportX,
                    viewportY,
                    clientX,
                    clientY
                  },
                  picked: []
                });
              case 2:
                _yield$this$defaultVi2 = _context2.sent;
                picked = _yield$this$defaultVi2.picked;
                if (picked[picked.length - 1] !== this.documentElement) {
                  picked.push(this.documentElement);
                }
                return _context2.abrupt("return", picked);
              case 3:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
        function elementsFromPoint(_x3, _x4) {
          return _elementsFromPoint.apply(this, arguments);
        }
        return elementsFromPoint;
      })()
    }, {
      key: "appendChild",
      value: function appendChild(newChild, index2) {
        throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
      }
    }, {
      key: "insertBefore",
      value: function insertBefore(newChild, refChild) {
        throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
      }
    }, {
      key: "removeChild",
      value: function removeChild(oldChild, destroy) {
        throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
      }
    }, {
      key: "replaceChild",
      value: function replaceChild(newChild, oldChild, destroy) {
        throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
      }
    }, {
      key: "append",
      value: function append() {
        throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
      }
    }, {
      key: "prepend",
      value: function prepend() {
        throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
      }
      /**
       * Execute query on documentElement.
       */
    }, {
      key: "getElementById",
      value: function getElementById(id3) {
        return this.documentElement.getElementById(id3);
      }
    }, {
      key: "getElementsByName",
      value: function getElementsByName(name) {
        return this.documentElement.getElementsByName(name);
      }
    }, {
      key: "getElementsByTagName",
      value: function getElementsByTagName(tagName) {
        return this.documentElement.getElementsByTagName(tagName);
      }
    }, {
      key: "getElementsByClassName",
      value: function getElementsByClassName(className) {
        return this.documentElement.getElementsByClassName(className);
      }
    }, {
      key: "querySelector",
      value: function querySelector(selectors) {
        return this.documentElement.querySelector(selectors);
      }
    }, {
      key: "querySelectorAll",
      value: function querySelectorAll(selectors) {
        return this.documentElement.querySelectorAll(selectors);
      }
    }, {
      key: "find",
      value: function find4(filter) {
        return this.documentElement.find(filter);
      }
    }, {
      key: "findAll",
      value: function findAll(filter) {
        return this.documentElement.findAll(filter);
      }
    }]);
  })(Node);
  var CullingPlugin = /* @__PURE__ */ (function() {
    function CullingPlugin2(strategies) {
      _classCallCheck(this, CullingPlugin2);
      this.strategies = strategies;
    }
    return _createClass(CullingPlugin2, [{
      key: "apply",
      value: function apply3(context) {
        var config = context.config, camera = context.camera, renderingService = context.renderingService, renderingContext = context.renderingContext;
        var strategies = this.strategies;
        renderingService.hooks.cull.tap(CullingPlugin2.tag, function(object) {
          if (object) {
            var _config$future;
            var cullable = object.cullable;
            if (strategies.length === 0) {
              cullable.visible = renderingContext.unculledEntities.indexOf(object.entity) > -1;
            } else {
              cullable.visible = strategies.every(function(strategy) {
                return strategy.isVisible(camera, object);
              });
            }
            if (!object.isCulled() && object.isVisible()) {
              return object;
            }
            var enableCancelEventPropagation = ((_config$future = config.future) === null || _config$future === void 0 ? void 0 : _config$future.experimentalCancelEventPropagation) === true;
            object.dispatchEvent(new CustomEvent(ElementEvent.CULLED), enableCancelEventPropagation, enableCancelEventPropagation);
            return null;
          }
          return object;
        });
        renderingService.hooks.afterRender.tap(CullingPlugin2.tag, function(object) {
          object.cullable.visibilityPlaneMask = -1;
        });
      }
    }]);
  })();
  CullingPlugin.tag = "Culling";
  var EventPlugin = /* @__PURE__ */ (function() {
    function EventPlugin2() {
      var _this2 = this;
      _classCallCheck(this, EventPlugin2);
      this.autoPreventDefault = false;
      this.rootPointerEvent = new FederatedPointerEvent(null);
      this.rootWheelEvent = new FederatedWheelEvent(null);
      this.onPointerMove = function(nativeEvent) {
        var _this$context$renderi;
        var canvas2 = (_this$context$renderi = _this2.context.renderingContext.root) === null || _this$context$renderi === void 0 || (_this$context$renderi = _this$context$renderi.ownerDocument) === null || _this$context$renderi === void 0 ? void 0 : _this$context$renderi.defaultView;
        if (canvas2.supportsTouchEvents && nativeEvent.pointerType === "touch") return;
        var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas2);
        var _iterator = _createForOfIteratorHelper(normalizedEvents), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var normalizedEvent = _step.value;
            var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas2, nativeEvent);
            _this2.context.eventService.mapEvent(event);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        _this2.setCursor(_this2.context.eventService.cursor);
      };
      this.onClick = function(nativeEvent) {
        var _this$context$renderi2;
        var canvas2 = (_this$context$renderi2 = _this2.context.renderingContext.root) === null || _this$context$renderi2 === void 0 || (_this$context$renderi2 = _this$context$renderi2.ownerDocument) === null || _this$context$renderi2 === void 0 ? void 0 : _this$context$renderi2.defaultView;
        var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas2);
        var _iterator2 = _createForOfIteratorHelper(normalizedEvents), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var normalizedEvent = _step2.value;
            var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas2, nativeEvent);
            _this2.context.eventService.mapEvent(event);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        _this2.setCursor(_this2.context.eventService.cursor);
      };
    }
    return _createClass(EventPlugin2, [{
      key: "apply",
      value: function apply3(context) {
        var _this2 = this;
        this.context = context;
        var renderingService = context.renderingService;
        var canvas2 = this.context.renderingContext.root.ownerDocument.defaultView;
        this.context.eventService.setPickHandler(function(position2) {
          var _this2$context$render = _this2.context.renderingService.hooks.pickSync.call({
            position: position2,
            picked: [],
            topmost: true
            // we only concern the topmost element
          }), picked = _this2$context$render.picked;
          return picked[0] || null;
        });
        renderingService.hooks.pointerWheel.tap(EventPlugin2.tag, function(nativeEvent) {
          var wheelEvent = _this2.normalizeWheelEvent(nativeEvent);
          _this2.context.eventService.mapEvent(wheelEvent);
        });
        renderingService.hooks.pointerDown.tap(EventPlugin2.tag, function(nativeEvent) {
          if (canvas2.supportsTouchEvents && nativeEvent.pointerType === "touch") return;
          var events = _this2.normalizeToPointerEvent(nativeEvent, canvas2);
          if (_this2.autoPreventDefault && events[0].isNormalized) {
            var cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
            if (cancelable) {
              nativeEvent.preventDefault();
            }
          }
          var _iterator3 = _createForOfIteratorHelper(events), _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
              var event = _step3.value;
              var federatedEvent = _this2.bootstrapEvent(_this2.rootPointerEvent, event, canvas2, nativeEvent);
              _this2.context.eventService.mapEvent(federatedEvent);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          _this2.setCursor(_this2.context.eventService.cursor);
        });
        renderingService.hooks.pointerUp.tap(EventPlugin2.tag, function(nativeEvent) {
          if (canvas2.supportsTouchEvents && nativeEvent.pointerType === "touch") return;
          var $element = _this2.context.contextService.getDomElement();
          var isNativeEventFromCanvas = _this2.context.eventService.isNativeEventFromCanvas($element, nativeEvent);
          var outside = !isNativeEventFromCanvas ? "outside" : "";
          var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas2);
          var _iterator4 = _createForOfIteratorHelper(normalizedEvents), _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
              var normalizedEvent = _step4.value;
              var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas2, nativeEvent);
              event.type += outside;
              _this2.context.eventService.mapEvent(event);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
          _this2.setCursor(_this2.context.eventService.cursor);
        });
        renderingService.hooks.pointerMove.tap(EventPlugin2.tag, this.onPointerMove);
        renderingService.hooks.pointerOver.tap(EventPlugin2.tag, this.onPointerMove);
        renderingService.hooks.pointerOut.tap(EventPlugin2.tag, this.onPointerMove);
        renderingService.hooks.click.tap(EventPlugin2.tag, this.onClick);
        renderingService.hooks.pointerCancel.tap(EventPlugin2.tag, function(nativeEvent) {
          var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas2);
          var _iterator5 = _createForOfIteratorHelper(normalizedEvents), _step5;
          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
              var normalizedEvent = _step5.value;
              var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas2, nativeEvent);
              _this2.context.eventService.mapEvent(event);
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
          _this2.setCursor(_this2.context.eventService.cursor);
        });
      }
    }, {
      key: "bootstrapEvent",
      value: function bootstrapEvent(event, normalizedEvent, view, nativeEvent) {
        event.view = view;
        event.originalEvent = null;
        event.nativeEvent = nativeEvent;
        event.pointerId = normalizedEvent.pointerId;
        event.width = normalizedEvent.width;
        event.height = normalizedEvent.height;
        event.isPrimary = normalizedEvent.isPrimary;
        event.pointerType = normalizedEvent.pointerType;
        event.pressure = normalizedEvent.pressure;
        event.tangentialPressure = normalizedEvent.tangentialPressure;
        event.tiltX = normalizedEvent.tiltX;
        event.tiltY = normalizedEvent.tiltY;
        event.twist = normalizedEvent.twist;
        this.transferMouseData(event, normalizedEvent);
        var _this$context$eventSe = this.context.eventService.client2Viewport({
          x: normalizedEvent.clientX,
          y: normalizedEvent.clientY
        }), x3 = _this$context$eventSe.x, y3 = _this$context$eventSe.y;
        event.viewport.x = x3;
        event.viewport.y = y3;
        var _this$context$eventSe2 = this.context.eventService.viewport2Canvas(event.viewport), canvasX = _this$context$eventSe2.x, canvasY = _this$context$eventSe2.y;
        event.canvas.x = canvasX;
        event.canvas.y = canvasY;
        event.global.copyFrom(event.canvas);
        event.offset.copyFrom(event.canvas);
        event.isTrusted = nativeEvent.isTrusted;
        if (event.type === "pointerleave") {
          event.type = "pointerout";
        }
        if (event.type.startsWith("mouse")) {
          event.type = event.type.replace("mouse", "pointer");
        }
        if (event.type.startsWith("touch")) {
          event.type = TOUCH_TO_POINTER[event.type] || event.type;
        }
        return event;
      }
    }, {
      key: "normalizeWheelEvent",
      value: function normalizeWheelEvent(nativeEvent) {
        var event = this.rootWheelEvent;
        this.transferMouseData(event, nativeEvent);
        event.deltaMode = nativeEvent.deltaMode;
        event.deltaX = nativeEvent.deltaX;
        event.deltaY = nativeEvent.deltaY;
        event.deltaZ = nativeEvent.deltaZ;
        var _this$context$eventSe3 = this.context.eventService.client2Viewport({
          x: nativeEvent.clientX,
          y: nativeEvent.clientY
        }), x3 = _this$context$eventSe3.x, y3 = _this$context$eventSe3.y;
        event.viewport.x = x3;
        event.viewport.y = y3;
        var _this$context$eventSe4 = this.context.eventService.viewport2Canvas(event.viewport), canvasX = _this$context$eventSe4.x, canvasY = _this$context$eventSe4.y;
        event.canvas.x = canvasX;
        event.canvas.y = canvasY;
        event.global.copyFrom(event.canvas);
        event.offset.copyFrom(event.canvas);
        event.nativeEvent = nativeEvent;
        event.type = nativeEvent.type;
        return event;
      }
      /**
       * Transfers base & mouse event data from the nativeEvent to the federated event.
       */
    }, {
      key: "transferMouseData",
      value: function transferMouseData(event, nativeEvent) {
        event.isTrusted = nativeEvent.isTrusted;
        event.srcElement = nativeEvent.srcElement;
        event.timeStamp = clock.now();
        event.type = nativeEvent.type;
        event.altKey = nativeEvent.altKey;
        event.metaKey = nativeEvent.metaKey;
        event.shiftKey = nativeEvent.shiftKey;
        event.ctrlKey = nativeEvent.ctrlKey;
        event.button = nativeEvent.button;
        event.buttons = nativeEvent.buttons;
        event.client.x = nativeEvent.clientX;
        event.client.y = nativeEvent.clientY;
        event.movement.x = nativeEvent.movementX;
        event.movement.y = nativeEvent.movementY;
        event.page.x = nativeEvent.pageX;
        event.page.y = nativeEvent.pageY;
        event.screen.x = nativeEvent.screenX;
        event.screen.y = nativeEvent.screenY;
        event.relatedTarget = null;
      }
    }, {
      key: "setCursor",
      value: function setCursor(cursor) {
        this.context.contextService.applyCursorStyle(cursor || this.context.config.cursor || "default");
      }
    }, {
      key: "normalizeToPointerEvent",
      value: function normalizeToPointerEvent(event, canvas2) {
        var normalizedEvents = [];
        if (canvas2.isTouchEvent(event)) {
          for (var i = 0; i < event.changedTouches.length; i++) {
            var touch = event.changedTouches[i];
            if ((0, import_util2.isUndefined)(touch.button)) touch.button = 0;
            if ((0, import_util2.isUndefined)(touch.buttons)) touch.buttons = 1;
            if ((0, import_util2.isUndefined)(touch.isPrimary)) {
              touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
            }
            if ((0, import_util2.isUndefined)(touch.width)) touch.width = touch.radiusX || 1;
            if ((0, import_util2.isUndefined)(touch.height)) touch.height = touch.radiusY || 1;
            if ((0, import_util2.isUndefined)(touch.tiltX)) touch.tiltX = 0;
            if ((0, import_util2.isUndefined)(touch.tiltY)) touch.tiltY = 0;
            if ((0, import_util2.isUndefined)(touch.pointerType)) touch.pointerType = "touch";
            if ((0, import_util2.isUndefined)(touch.pointerId)) touch.pointerId = touch.identifier || 0;
            if ((0, import_util2.isUndefined)(touch.pressure)) touch.pressure = touch.force || 0.5;
            if ((0, import_util2.isUndefined)(touch.twist)) touch.twist = 0;
            if ((0, import_util2.isUndefined)(touch.tangentialPressure)) touch.tangentialPressure = 0;
            touch.isNormalized = true;
            touch.type = event.type;
            normalizedEvents.push(touch);
          }
        } else if (canvas2.isMouseEvent(event)) {
          var tempEvent = event;
          if ((0, import_util2.isUndefined)(tempEvent.isPrimary)) tempEvent.isPrimary = true;
          if ((0, import_util2.isUndefined)(tempEvent.width)) tempEvent.width = 1;
          if ((0, import_util2.isUndefined)(tempEvent.height)) tempEvent.height = 1;
          if ((0, import_util2.isUndefined)(tempEvent.tiltX)) tempEvent.tiltX = 0;
          if ((0, import_util2.isUndefined)(tempEvent.tiltY)) tempEvent.tiltY = 0;
          if ((0, import_util2.isUndefined)(tempEvent.pointerType)) tempEvent.pointerType = "mouse";
          if ((0, import_util2.isUndefined)(tempEvent.pointerId)) tempEvent.pointerId = MOUSE_POINTER_ID;
          if ((0, import_util2.isUndefined)(tempEvent.pressure)) tempEvent.pressure = 0.5;
          if ((0, import_util2.isUndefined)(tempEvent.twist)) tempEvent.twist = 0;
          if ((0, import_util2.isUndefined)(tempEvent.tangentialPressure)) tempEvent.tangentialPressure = 0;
          tempEvent.isNormalized = true;
          normalizedEvents.push(tempEvent);
        } else {
          normalizedEvents.push(event);
        }
        return normalizedEvents;
      }
    }]);
  })();
  EventPlugin.tag = "Event";
  var shape2D = [Shape.CIRCLE, Shape.ELLIPSE, Shape.IMAGE, Shape.RECT, Shape.LINE, Shape.POLYLINE, Shape.POLYGON, Shape.TEXT, Shape.PATH, Shape.HTML];
  var FrustumCullingStrategy = /* @__PURE__ */ (function() {
    function FrustumCullingStrategy2() {
      _classCallCheck(this, FrustumCullingStrategy2);
    }
    return _createClass(FrustumCullingStrategy2, [{
      key: "isVisible",
      value: function isVisible2(camera, object) {
        var _object$parentNode;
        var cullable = object.cullable;
        if (!cullable.enable) {
          return true;
        }
        var renderBounds = object.getRenderBounds();
        if (AABB.isEmpty(renderBounds)) {
          return false;
        }
        var frustum = camera.getFrustum();
        var parentVisibilityPlaneMask = (_object$parentNode = object.parentNode) === null || _object$parentNode === void 0 || (_object$parentNode = _object$parentNode.cullable) === null || _object$parentNode === void 0 ? void 0 : _object$parentNode.visibilityPlaneMask;
        cullable.visibilityPlaneMask = this.computeVisibilityWithPlaneMask(object, renderBounds, parentVisibilityPlaneMask || Mask.INDETERMINATE, frustum.planes);
        cullable.visible = cullable.visibilityPlaneMask !== Mask.OUTSIDE;
        return cullable.visible;
      }
      /**
       *
       * @see「Optimized View Frustum Culling Algorithms for Bounding Boxes」
       * @see https://github.com/antvis/GWebGPUEngine/issues/3
       *
       * * 基础相交测试 the basic intersection test
       * * 标记 masking @see https://cesium.com/blog/2015/08/04/fast-hierarchical-culling/
       * * TODO: 平面一致性测试 the plane-coherency test
       * * TODO: 支持 mesh 指定自身的剔除策略，参考 Babylon.js @see https://doc.babylonjs.com/how_to/optimizing_your_scene#changing-mesh-culling-strategy
       *
       * @param aabb aabb
       * @param parentPlaneMask mask of parent
       * @param planes planes of frustum
       */
    }, {
      key: "computeVisibilityWithPlaneMask",
      value: function computeVisibilityWithPlaneMask(object, aabb, parentPlaneMask, planes) {
        if (parentPlaneMask === Mask.OUTSIDE || parentPlaneMask === Mask.INSIDE) {
          return parentPlaneMask;
        }
        var mask = Mask.INSIDE;
        var isShape2D = shape2D.indexOf(object.nodeName) > -1;
        for (var k = 0, len = planes.length; k < len; ++k) {
          var flag = 1 << k;
          if ((parentPlaneMask & flag) === 0) {
            continue;
          }
          if (isShape2D && (k === 4 || k === 5)) {
            continue;
          }
          var _planes$k = planes[k], normal = _planes$k.normal, distance6 = _planes$k.distance;
          if (import_gl_matrix2.vec3.dot(normal, aabb.getPositiveFarPoint(planes[k])) + distance6 < 0) {
            return Mask.OUTSIDE;
          }
          if (import_gl_matrix2.vec3.dot(normal, aabb.getNegativeFarPoint(planes[k])) + distance6 < 0) {
            mask |= flag;
          }
        }
        return mask;
      }
    }]);
  })();
  var PrepareRendererPlugin = /* @__PURE__ */ (function() {
    function PrepareRendererPlugin2() {
      _classCallCheck(this, PrepareRendererPlugin2);
      this.syncTasks = /* @__PURE__ */ new Map();
      this.isFirstTimeRendering = true;
      this.syncing = false;
      this.isFirstTimeRenderingFinished = false;
    }
    return _createClass(PrepareRendererPlugin2, [{
      key: "apply",
      value: function apply3(context) {
        var _this2 = this, _runtime$globalThis$r, _config$future;
        var config = context.config, renderingService = context.renderingService, renderingContext = context.renderingContext, rBushRoot = context.rBushRoot;
        var canvas2 = renderingContext.root.ownerDocument.defaultView;
        this.rBush = rBushRoot;
        var handleAttributeChanged = function handleAttributeChanged2(e) {
          renderingService.dirtify();
        };
        var handleBoundsChanged = function handleBoundsChanged2(e) {
          _this2.syncTasks.set(e.target, e.detail.affectChildren);
          renderingService.dirtify();
        };
        var handleMounted = function handleMounted2(e) {
          var object = e.target;
          if (runtime.enableSizeAttenuation) {
            runtime.styleValueRegistry.updateSizeAttenuation(object, canvas2.getCamera().getZoom());
          }
        };
        var handleUnmounted = function handleUnmounted2(e) {
          var object = e.target;
          var rBushNode = object.rBushNode;
          if (rBushNode !== null && rBushNode !== void 0 && rBushNode.aabb) {
            _this2.rBush.remove(rBushNode.aabb);
          }
          _this2.syncTasks["delete"](object);
          runtime.sceneGraphService.dirtyToRoot(object);
          renderingService.dirtify();
        };
        renderingService.hooks.init.tap(PrepareRendererPlugin2.tag, function() {
          canvas2.addEventListener(ElementEvent.MOUNTED, handleMounted);
          canvas2.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
          canvas2.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
          canvas2.addEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
        });
        renderingService.hooks.destroy.tap(PrepareRendererPlugin2.tag, function() {
          canvas2.removeEventListener(ElementEvent.MOUNTED, handleMounted);
          canvas2.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
          canvas2.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
          canvas2.removeEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
          _this2.syncTasks.clear();
        });
        var ric = (_runtime$globalThis$r = runtime.globalThis.requestIdleCallback) !== null && _runtime$globalThis$r !== void 0 ? _runtime$globalThis$r : raf.bind(runtime.globalThis);
        var enableRICSyncRTree = ((_config$future = config.future) === null || _config$future === void 0 ? void 0 : _config$future.experimentalRICSyncRTree) === true;
        renderingService.hooks.endFrame.tap(PrepareRendererPlugin2.tag, function() {
          if (_this2.isFirstTimeRendering) {
            _this2.isFirstTimeRendering = false;
            _this2.syncing = true;
            ric(function() {
              _this2.syncRTree(true);
              _this2.isFirstTimeRenderingFinished = true;
            });
          } else if (enableRICSyncRTree && runtime.globalThis.requestIdleCallback && runtime.globalThis.cancelIdleCallback) {
            runtime.globalThis.cancelIdleCallback(_this2.ricSyncRTreeId);
            _this2.ricSyncRTreeId = runtime.globalThis.requestIdleCallback(function() {
              return _this2.syncRTree();
            });
          } else {
            _this2.syncRTree();
          }
        });
      }
    }, {
      key: "syncNode",
      value: function syncNode(node) {
        var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (!node.isConnected) return;
        var rBushNode = node.rBushNode;
        if (rBushNode.aabb) this.rBush.remove(rBushNode.aabb);
        var renderBounds = node.getRenderBounds();
        if (renderBounds) {
          var renderable = node.renderable;
          if (force) {
            if (!renderable.dirtyRenderBounds) {
              renderable.dirtyRenderBounds = new AABB();
            }
            renderable.dirtyRenderBounds.update(renderBounds.center, renderBounds.halfExtents);
          }
          var _renderBounds$getMin = renderBounds.getMin(), _renderBounds$getMin2 = _slicedToArray(_renderBounds$getMin, 2), minX = _renderBounds$getMin2[0], minY = _renderBounds$getMin2[1];
          var _renderBounds$getMax = renderBounds.getMax(), _renderBounds$getMax2 = _slicedToArray(_renderBounds$getMax, 2), maxX = _renderBounds$getMax2[0], maxY = _renderBounds$getMax2[1];
          if (!rBushNode.aabb) {
            rBushNode.aabb = {};
          }
          rBushNode.aabb.displayObject = node;
          rBushNode.aabb.minX = minX;
          rBushNode.aabb.minY = minY;
          rBushNode.aabb.maxX = maxX;
          rBushNode.aabb.maxY = maxY;
        }
        if (rBushNode.aabb) {
          if (!isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.minX) && !isNaN(rBushNode.aabb.minY)) {
            return rBushNode.aabb;
          }
        }
      }
    }, {
      key: "syncRTree",
      value: function syncRTree() {
        var _this2 = this;
        var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        if (!force && (this.syncing || this.syncTasks.size === 0)) {
          return;
        }
        this.syncing = true;
        var bulk = [];
        var synced = /* @__PURE__ */ new Set();
        var sync = function sync2(node) {
          if (!synced.has(node) && node.renderable) {
            var aabb = _this2.syncNode(node, force);
            if (aabb) {
              bulk.push(aabb);
              synced.add(node);
            }
          }
        };
        this.syncTasks.forEach(function(affectChildren, node) {
          if (affectChildren) {
            node.forEach(sync);
          }
          var parent = node;
          while (parent) {
            sync(parent);
            parent = parent.parentElement;
          }
        });
        this.rBush.load(bulk);
        bulk.length = 0;
        this.syncing = false;
      }
    }]);
  })();
  PrepareRendererPlugin.tag = "Prepare";
  var CanvasEvent = /* @__PURE__ */ (function(CanvasEvent3) {
    CanvasEvent3["READY"] = "ready";
    CanvasEvent3["BEFORE_RENDER"] = "beforerender";
    CanvasEvent3["RERENDER"] = "rerender";
    CanvasEvent3["AFTER_RENDER"] = "afterrender";
    CanvasEvent3["BEFORE_DESTROY"] = "beforedestroy";
    CanvasEvent3["AFTER_DESTROY"] = "afterdestroy";
    CanvasEvent3["RESIZE"] = "resize";
    CanvasEvent3["DIRTY_RECTANGLE"] = "dirtyrectangle";
    CanvasEvent3["RENDERER_CHANGED"] = "rendererchanged";
    return CanvasEvent3;
  })({});
  var DEFAULT_CAMERA_Z = 500;
  var DEFAULT_CAMERA_NEAR = 0.1;
  var DEFAULT_CAMERA_FAR = 1e3;
  var mountedEvent = new CustomEvent(ElementEvent.MOUNTED);
  var unmountedEvent = new CustomEvent(ElementEvent.UNMOUNTED);
  var beforeRenderEvent = new CustomEvent(CanvasEvent.BEFORE_RENDER);
  var rerenderEvent = new CustomEvent(CanvasEvent.RERENDER);
  var afterRenderEvent = new CustomEvent(CanvasEvent.AFTER_RENDER);
  var Canvas = /* @__PURE__ */ (function(_EventTarget) {
    function Canvas3(config) {
      var _this2;
      _classCallCheck(this, Canvas3);
      _this2 = _callSuper(this, Canvas3);
      _this2.Element = DisplayObject;
      _this2.inited = false;
      _this2.context = {};
      var container = config.container, canvas2 = config.canvas, renderer = config.renderer, width2 = config.width, height = config.height, background = config.background, cursor = config.cursor, supportsMutipleCanvasesInOneContainer = config.supportsMutipleCanvasesInOneContainer, _config$cleanUpOnDest = config.cleanUpOnDestroy, cleanUpOnDestroy = _config$cleanUpOnDest === void 0 ? true : _config$cleanUpOnDest, offscreenCanvas = config.offscreenCanvas, devicePixelRatio = config.devicePixelRatio, requestAnimationFrame2 = config.requestAnimationFrame, cancelAnimationFrame2 = config.cancelAnimationFrame, createImage = config.createImage, supportsTouchEvents = config.supportsTouchEvents, supportsPointerEvents = config.supportsPointerEvents, isTouchEvent = config.isTouchEvent, isMouseEvent = config.isMouseEvent, dblClickSpeed = config.dblClickSpeed;
      var canvasWidth = width2;
      var canvasHeight = height;
      var dpr = devicePixelRatio || isBrowser && window.devicePixelRatio || 1;
      dpr = dpr >= 1 ? Math.ceil(dpr) : 1;
      if (canvas2) {
        canvasWidth = width2 || getWidth(canvas2) || canvas2.width / dpr;
        canvasHeight = height || getHeight(canvas2) || canvas2.height / dpr;
      }
      _this2.customElements = new CustomElementRegistry();
      _this2.devicePixelRatio = dpr;
      _this2.requestAnimationFrame = requestAnimationFrame2 !== null && requestAnimationFrame2 !== void 0 ? requestAnimationFrame2 : raf.bind(runtime.globalThis);
      _this2.cancelAnimationFrame = cancelAnimationFrame2 !== null && cancelAnimationFrame2 !== void 0 ? cancelAnimationFrame2 : caf.bind(runtime.globalThis);
      _this2.createImage = createImage !== null && createImage !== void 0 ? createImage : function() {
        return new window.Image();
      };
      _this2.supportsTouchEvents = supportsTouchEvents !== null && supportsTouchEvents !== void 0 ? supportsTouchEvents : "ontouchstart" in runtime.globalThis;
      _this2.supportsPointerEvents = supportsPointerEvents !== null && supportsPointerEvents !== void 0 ? supportsPointerEvents : !!runtime.globalThis.PointerEvent;
      _this2.isTouchEvent = isTouchEvent !== null && isTouchEvent !== void 0 ? isTouchEvent : function(event) {
        return _this2.supportsTouchEvents && event instanceof runtime.globalThis.TouchEvent;
      };
      _this2.isMouseEvent = isMouseEvent !== null && isMouseEvent !== void 0 ? isMouseEvent : function(event) {
        return !runtime.globalThis.MouseEvent || event instanceof runtime.globalThis.MouseEvent && (!_this2.supportsPointerEvents || !(event instanceof runtime.globalThis.PointerEvent));
      };
      if (offscreenCanvas) {
        runtime.offscreenCanvas = offscreenCanvas;
      }
      _this2.document = new Document2();
      _this2.document.defaultView = _this2;
      if (!supportsMutipleCanvasesInOneContainer) {
        cleanExistedCanvas(container, _this2, cleanUpOnDestroy);
      }
      _this2.initRenderingContext(_objectSpread2(_objectSpread2({}, config), {}, {
        width: canvasWidth,
        height: canvasHeight,
        background: background !== null && background !== void 0 ? background : "transparent",
        cursor: cursor !== null && cursor !== void 0 ? cursor : "default",
        cleanUpOnDestroy,
        devicePixelRatio: dpr,
        requestAnimationFrame: _this2.requestAnimationFrame,
        cancelAnimationFrame: _this2.cancelAnimationFrame,
        createImage: _this2.createImage,
        supportsTouchEvents: _this2.supportsTouchEvents,
        supportsPointerEvents: _this2.supportsPointerEvents,
        isTouchEvent: _this2.isTouchEvent,
        isMouseEvent: _this2.isMouseEvent,
        dblClickSpeed: dblClickSpeed !== null && dblClickSpeed !== void 0 ? dblClickSpeed : 200
      }));
      _this2.initDefaultCamera(canvasWidth, canvasHeight, renderer.clipSpaceNearZ);
      _this2.initRenderer(renderer, true);
      return _this2;
    }
    _inherits(Canvas3, _EventTarget);
    return _createClass(Canvas3, [{
      key: "initRenderingContext",
      value: function initRenderingContext(mergedConfig) {
        this.context.config = mergedConfig;
        this.context.renderingContext = {
          /**
           * the root node in scene graph
           */
          root: this.document.documentElement,
          unculledEntities: [],
          renderListCurrentFrame: [],
          renderReasons: /* @__PURE__ */ new Set(),
          force: false,
          dirty: false
        };
      }
    }, {
      key: "initDefaultCamera",
      value: function initDefaultCamera(width2, height, clipSpaceNearZ) {
        var _this2 = this;
        var camera = new runtime.CameraContribution();
        camera.clipSpaceNearZ = clipSpaceNearZ;
        camera.setType(CameraType.EXPLORING, CameraTrackingMode.DEFAULT).setPosition(width2 / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width2 / 2, height / 2, 0).setOrthographic(width2 / -2, width2 / 2, height / 2, height / -2, DEFAULT_CAMERA_NEAR, DEFAULT_CAMERA_FAR);
        camera.canvas = this;
        camera.eventEmitter.on(CameraEvent.UPDATED, function() {
          _this2.context.renderingContext.renderReasons.add(RenderReason.CAMERA_CHANGED);
          if (runtime.enableSizeAttenuation && _this2.getConfig().renderer.getConfig().enableSizeAttenuation) {
            _this2.updateSizeAttenuation();
          }
        });
        this.context.camera = camera;
      }
    }, {
      key: "updateSizeAttenuation",
      value: function updateSizeAttenuation() {
        var zoom = this.getCamera().getZoom();
        this.document.documentElement.forEach(function(node) {
          runtime.styleValueRegistry.updateSizeAttenuation(node, zoom);
        });
      }
    }, {
      key: "getConfig",
      value: function getConfig() {
        return this.context.config;
      }
      /**
       * get the root displayObject in scenegraph
       * @alias this.document.documentElement
       */
    }, {
      key: "getRoot",
      value: function getRoot() {
        return this.document.documentElement;
      }
      /**
       * get the camera of canvas
       */
    }, {
      key: "getCamera",
      value: function getCamera() {
        return this.context.camera;
      }
    }, {
      key: "getContextService",
      value: function getContextService() {
        return this.context.contextService;
      }
    }, {
      key: "getEventService",
      value: function getEventService() {
        return this.context.eventService;
      }
    }, {
      key: "getRenderingService",
      value: function getRenderingService() {
        return this.context.renderingService;
      }
    }, {
      key: "getRenderingContext",
      value: function getRenderingContext() {
        return this.context.renderingContext;
      }
    }, {
      key: "getStats",
      value: function getStats() {
        return this.getRenderingService().getStats();
      }
      // /**
      //  * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle
      //  */
      // getComputedStyle(node: DisplayObject) {
      //   return node.computedStyle;
      // }
    }, {
      key: "ready",
      get: function get9() {
        var _this3 = this;
        if (!this.readyPromise) {
          this.readyPromise = new Promise(function(resolve) {
            _this3.resolveReadyPromise = function() {
              resolve(_this3);
            };
          });
          if (this.inited) {
            this.resolveReadyPromise();
          }
        }
        return this.readyPromise;
      }
      /**
       * @param cleanUp - whether to clean up all the internal services of Canvas
       * @param skipTriggerEvent - whether to skip trigger destroy event
       */
    }, {
      key: "destroy",
      value: function destroy() {
        var _this$getConfig$futur;
        var cleanUp = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        var skipTriggerEvent = arguments.length > 1 ? arguments[1] : void 0;
        memoize.clearCache();
        var enableCancelEventPropagation = ((_this$getConfig$futur = this.getConfig().future) === null || _this$getConfig$futur === void 0 ? void 0 : _this$getConfig$futur.experimentalCancelEventPropagation) === true;
        if (!skipTriggerEvent) {
          this.dispatchEvent(new CustomEvent(CanvasEvent.BEFORE_DESTROY), enableCancelEventPropagation, enableCancelEventPropagation);
        }
        if (this.frameId) {
          this.cancelAnimationFrame(this.frameId);
        }
        var root2 = this.getRoot();
        if (cleanUp) {
          this.unmountChildren(root2);
          this.document.destroy();
          this.getEventService().destroy();
        }
        this.getRenderingService().destroy();
        this.getContextService().destroy();
        if (this.context.rBushRoot) {
          this.context.rBushRoot.clear();
        }
        if (!skipTriggerEvent) {
          this.dispatchEvent(new CustomEvent(CanvasEvent.AFTER_DESTROY), enableCancelEventPropagation, enableCancelEventPropagation);
        }
        var clearEventRetain = function clearEventRetain2(event) {
          event.currentTarget = null;
          event.manager = null;
          event.target = null;
          event.relatedNode = null;
        };
        clearEventRetain(mountedEvent);
        clearEventRetain(unmountedEvent);
        clearEventRetain(beforeRenderEvent);
        clearEventRetain(rerenderEvent);
        clearEventRetain(afterRenderEvent);
        clearEventRetain(attrModifiedEvent);
        clearEventRetain(insertedEvent);
        clearEventRetain(removedEvent);
        clearEventRetain(destroyEvent);
        runtime.textService.clearCache();
      }
      /**
       * compatible with G 3.0
       * @deprecated
       * @alias resize
       */
    }, {
      key: "changeSize",
      value: function changeSize(width2, height) {
        this.resize(width2, height);
      }
    }, {
      key: "resize",
      value: function resize(width2, height) {
        var _canvasConfig$future;
        var canvasConfig = this.context.config;
        canvasConfig.width = width2;
        canvasConfig.height = height;
        this.getContextService().resize(width2, height);
        var camera = this.context.camera;
        var projectionMode = camera.getProjectionMode();
        camera.setPosition(width2 / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width2 / 2, height / 2, 0);
        if (projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
          camera.setOrthographic(width2 / -2, width2 / 2, height / 2, height / -2, camera.getNear(), camera.getFar());
        } else {
          camera.setAspect(width2 / height);
        }
        var enableCancelEventPropagation = ((_canvasConfig$future = canvasConfig.future) === null || _canvasConfig$future === void 0 ? void 0 : _canvasConfig$future.experimentalCancelEventPropagation) === true;
        this.dispatchEvent(new CustomEvent(CanvasEvent.RESIZE, {
          width: width2,
          height
        }), enableCancelEventPropagation, enableCancelEventPropagation);
      }
      // proxy to document.documentElement
    }, {
      key: "appendChild",
      value: function appendChild(child, index2) {
        return this.document.documentElement.appendChild(child, index2);
      }
    }, {
      key: "insertBefore",
      value: function insertBefore(newChild, refChild) {
        return this.document.documentElement.insertBefore(newChild, refChild);
      }
    }, {
      key: "removeChild",
      value: function removeChild(child) {
        return this.document.documentElement.removeChild(child);
      }
      /**
       * Remove all children which can be appended to its original parent later again.
       */
    }, {
      key: "removeChildren",
      value: function removeChildren() {
        this.document.documentElement.removeChildren();
      }
      /**
       * Recursively destroy all children which can not be appended to its original parent later again.
       * But the canvas remains running which means display objects can be appended later.
       */
    }, {
      key: "destroyChildren",
      value: function destroyChildren() {
        this.document.documentElement.destroyChildren();
      }
    }, {
      key: "render",
      value: function render(frame2) {
        var _this$getConfig$futur2, _this4 = this;
        if (frame2) {
          beforeRenderEvent.detail = frame2;
          afterRenderEvent.detail = frame2;
        }
        var enableCancelEventPropagation = ((_this$getConfig$futur2 = this.getConfig().future) === null || _this$getConfig$futur2 === void 0 ? void 0 : _this$getConfig$futur2.experimentalCancelEventPropagation) === true;
        this.dispatchEvent(beforeRenderEvent, enableCancelEventPropagation, enableCancelEventPropagation);
        var renderingService = this.getRenderingService();
        renderingService.render(this.getConfig(), frame2, function() {
          _this4.dispatchEvent(rerenderEvent, enableCancelEventPropagation, enableCancelEventPropagation);
        });
        this.dispatchEvent(afterRenderEvent, enableCancelEventPropagation, enableCancelEventPropagation);
      }
    }, {
      key: "run",
      value: function run4() {
        var _this5 = this;
        var _tick = function tick2(time, frame2) {
          _this5.render(frame2);
          _this5.frameId = _this5.requestAnimationFrame(_tick);
        };
        _tick();
      }
    }, {
      key: "initRenderer",
      value: function initRenderer(renderer) {
        var _this6 = this;
        var firstContentfullPaint = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (!renderer) {
          throw new Error("Renderer is required.");
        }
        this.inited = false;
        this.readyPromise = void 0;
        this.context.rBushRoot = new RBush();
        this.context.renderingPlugins = [];
        this.context.renderingPlugins.push(
          new EventPlugin(),
          new PrepareRendererPlugin(),
          // new DirtyCheckPlugin(),
          new CullingPlugin([new FrustumCullingStrategy()])
        );
        this.loadRendererContainerModule(renderer);
        this.context.contextService = new this.context.ContextService(_objectSpread2(_objectSpread2({}, runtime), this.context));
        this.context.renderingService = new RenderingService(runtime, this.context);
        this.context.eventService = new EventService(runtime, this.context);
        this.context.eventService.init();
        if (this.context.contextService.init) {
          this.context.contextService.init();
          this.initRenderingService(renderer, firstContentfullPaint, true);
        } else {
          this.context.contextService.initAsync().then(function() {
            _this6.initRenderingService(renderer, firstContentfullPaint);
          })["catch"](function(err) {
            console.error(err);
          });
        }
      }
    }, {
      key: "initRenderingService",
      value: function initRenderingService(renderer) {
        var _this7 = this;
        var firstContentfullPaint = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var async = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        this.context.renderingService.init(function() {
          var _this7$getConfig$futu;
          _this7.inited = true;
          var enableCancelEventPropagation = ((_this7$getConfig$futu = _this7.getConfig().future) === null || _this7$getConfig$futu === void 0 ? void 0 : _this7$getConfig$futu.experimentalCancelEventPropagation) === true;
          if (firstContentfullPaint) {
            if (async) {
              _this7.requestAnimationFrame(function() {
                _this7.dispatchEvent(new CustomEvent(CanvasEvent.READY), enableCancelEventPropagation, enableCancelEventPropagation);
              });
            } else {
              _this7.dispatchEvent(new CustomEvent(CanvasEvent.READY), enableCancelEventPropagation, enableCancelEventPropagation);
            }
          } else {
            _this7.dispatchEvent(new CustomEvent(CanvasEvent.RENDERER_CHANGED), enableCancelEventPropagation, enableCancelEventPropagation);
          }
          if (_this7.readyPromise) {
            _this7.resolveReadyPromise();
          }
          if (!firstContentfullPaint) {
            _this7.getRoot().forEach(function(node) {
              var _dirty, _ref;
              (_dirty = (_ref = node).dirty) === null || _dirty === void 0 || _dirty.call(_ref, true, true);
            });
          }
          _this7.mountChildren(_this7.getRoot());
          if (renderer.getConfig().enableAutoRendering) {
            _this7.run();
          }
        });
      }
    }, {
      key: "loadRendererContainerModule",
      value: function loadRendererContainerModule(renderer) {
        var _this8 = this;
        var plugins = renderer.getPlugins();
        plugins.forEach(function(plugin) {
          plugin.context = _this8.context;
          plugin.init(runtime);
        });
      }
    }, {
      key: "setRenderer",
      value: function setRenderer(renderer) {
        var canvasConfig = this.getConfig();
        if (canvasConfig.renderer === renderer) {
          return;
        }
        var oldRenderer = canvasConfig.renderer;
        canvasConfig.renderer = renderer;
        this.destroy(false, true);
        _toConsumableArray((oldRenderer === null || oldRenderer === void 0 ? void 0 : oldRenderer.getPlugins()) || []).reverse().forEach(function(plugin) {
          plugin.destroy(runtime);
        });
        this.initRenderer(renderer);
      }
    }, {
      key: "setCursor",
      value: function setCursor(cursor) {
        var canvasConfig = this.getConfig();
        canvasConfig.cursor = cursor;
        this.getContextService().applyCursorStyle(cursor);
      }
    }, {
      key: "unmountChildren",
      value: function unmountChildren(parent) {
        var _this9 = this;
        parent.childNodes.forEach(function(child) {
          _this9.unmountChildren(child);
        });
        if (this.inited) {
          if (parent.isMutationObserved) {
            parent.dispatchEvent(unmountedEvent);
          } else {
            var _this$getConfig$futur3;
            var enableCancelEventPropagation = ((_this$getConfig$futur3 = this.getConfig().future) === null || _this$getConfig$futur3 === void 0 ? void 0 : _this$getConfig$futur3.experimentalCancelEventPropagation) === true;
            unmountedEvent.target = parent;
            this.dispatchEvent(unmountedEvent, true, enableCancelEventPropagation);
          }
          if (parent !== this.document.documentElement) {
            parent.ownerDocument = null;
          }
          parent.isConnected = false;
        }
        if (parent.isCustomElement) {
          if (parent.disconnectedCallback) {
            parent.disconnectedCallback();
          }
        }
      }
    }, {
      key: "mountChildren",
      value: function mountChildren(child) {
        var _this0 = this;
        var skipTriggerEvent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : isInFragment(child);
        if (this.inited) {
          if (!child.isConnected) {
            child.ownerDocument = this.document;
            child.isConnected = true;
            if (!skipTriggerEvent) {
              if (child.isMutationObserved) {
                child.dispatchEvent(mountedEvent);
              } else {
                var _this$getConfig$futur4;
                var enableCancelEventPropagation = ((_this$getConfig$futur4 = this.getConfig().future) === null || _this$getConfig$futur4 === void 0 ? void 0 : _this$getConfig$futur4.experimentalCancelEventPropagation) === true;
                mountedEvent.target = child;
                this.dispatchEvent(mountedEvent, true, enableCancelEventPropagation);
              }
            }
          }
        } else {
          console.warn("[g]: You are trying to call `canvas.appendChild` before canvas' initialization finished. You can either await `canvas.ready` or listen to `CanvasEvent.READY` manually.", "appended child: ", child.nodeName);
        }
        child.childNodes.forEach(function(c2) {
          _this0.mountChildren(c2, skipTriggerEvent);
        });
        if (child.isCustomElement) {
          if (child.connectedCallback) {
            child.connectedCallback();
          }
        }
      }
    }, {
      key: "mountFragment",
      value: function mountFragment(child) {
        this.mountChildren(child, false);
      }
    }, {
      key: "client2Viewport",
      value: function client2Viewport(client) {
        return this.getEventService().client2Viewport(client);
      }
    }, {
      key: "viewport2Client",
      value: function viewport2Client(canvas2) {
        return this.getEventService().viewport2Client(canvas2);
      }
    }, {
      key: "viewport2Canvas",
      value: function viewport2Canvas(viewport) {
        return this.getEventService().viewport2Canvas(viewport);
      }
    }, {
      key: "canvas2Viewport",
      value: function canvas2Viewport(canvas2) {
        return this.getEventService().canvas2Viewport(canvas2);
      }
      /**
       * @deprecated
       * @alias client2Viewport
       */
    }, {
      key: "getPointByClient",
      value: function getPointByClient(clientX, clientY) {
        return this.client2Viewport({
          x: clientX,
          y: clientY
        });
      }
      /**
       * @deprecated
       * @alias viewport2Client
       */
    }, {
      key: "getClientByPoint",
      value: function getClientByPoint(x3, y3) {
        return this.viewport2Client({
          x: x3,
          y: y3
        });
      }
    }]);
  })(EventTarget);

  // node_modules/@antv/g-camera-api/dist/index.esm.js
  var import_util3 = __toESM(require_lib());
  var import_gl_matrix3 = __toESM(require_cjs());
  var AdvancedCamera = /* @__PURE__ */ (function(_Camera) {
    function AdvancedCamera2() {
      var _this2;
      _classCallCheck(this, AdvancedCamera2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this2 = _callSuper(this, AdvancedCamera2, [].concat(args));
      _this2.landmarks = [];
      return _this2;
    }
    _inherits(AdvancedCamera2, _Camera);
    return _createClass(AdvancedCamera2, [{
      key: "rotate",
      value: (
        /**
         * Changes the azimuth and elevation with respect to the current camera axes
         * @param {Number} azimuth the relative azimuth
         * @param {Number} elevation the relative elevation
         * @param {Number} roll the relative roll
         */
        function rotate3(azimuth, elevation, roll) {
          this.relElevation = getAngle(elevation);
          this.relAzimuth = getAngle(azimuth);
          this.relRoll = getAngle(roll);
          this.elevation += this.relElevation;
          this.azimuth += this.relAzimuth;
          this.roll += this.relRoll;
          if (this.type === CameraType.EXPLORING) {
            var rotX = import_gl_matrix3.quat.setAxisAngle(import_gl_matrix3.quat.create(), [1, 0, 0], deg2rad((this.rotateWorld ? 1 : -1) * this.relElevation));
            var rotY = import_gl_matrix3.quat.setAxisAngle(import_gl_matrix3.quat.create(), [0, 1, 0], deg2rad((this.rotateWorld ? 1 : -1) * this.relAzimuth));
            var rotZ = import_gl_matrix3.quat.setAxisAngle(import_gl_matrix3.quat.create(), [0, 0, 1], deg2rad(this.relRoll));
            var rotQ = import_gl_matrix3.quat.multiply(import_gl_matrix3.quat.create(), rotY, rotX);
            rotQ = import_gl_matrix3.quat.multiply(import_gl_matrix3.quat.create(), rotQ, rotZ);
            var rotMatrix = import_gl_matrix3.mat4.fromQuat(import_gl_matrix3.mat4.create(), rotQ);
            import_gl_matrix3.mat4.translate(this.matrix, this.matrix, [0, 0, -this.distance]);
            import_gl_matrix3.mat4.multiply(this.matrix, this.matrix, rotMatrix);
            import_gl_matrix3.mat4.translate(this.matrix, this.matrix, [0, 0, this.distance]);
          } else {
            if (Math.abs(this.elevation) > 90) {
              return this;
            }
            this.computeMatrix();
          }
          this._getAxes();
          if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
            this._getPosition();
          } else if (this.type === CameraType.TRACKING) {
            this._getFocalPoint();
          }
          this._update();
          return this;
        }
      )
      /**
       * 沿水平(right) & 垂直(up)平移相机
       */
    }, {
      key: "pan",
      value: function pan(tx, ty) {
        var coords = createVec3(tx, ty, 0);
        var pos = import_gl_matrix3.vec3.clone(this.position);
        import_gl_matrix3.vec3.add(pos, pos, import_gl_matrix3.vec3.scale(import_gl_matrix3.vec3.create(), this.right, coords[0]));
        import_gl_matrix3.vec3.add(pos, pos, import_gl_matrix3.vec3.scale(import_gl_matrix3.vec3.create(), this.up, coords[1]));
        this._setPosition(pos);
        this.triggerUpdate();
        return this;
      }
      /**
       * 沿 n 轴移动，当距离视点远时移动速度较快，离视点越近速度越慢
       */
    }, {
      key: "dolly",
      value: function dolly(value) {
        var n = this.forward;
        var pos = import_gl_matrix3.vec3.clone(this.position);
        var step2 = value * this.dollyingStep;
        var updatedDistance = this.distance + value * this.dollyingStep;
        step2 = Math.max(Math.min(updatedDistance, this.maxDistance), this.minDistance) - this.distance;
        pos[0] += step2 * n[0];
        pos[1] += step2 * n[1];
        pos[2] += step2 * n[2];
        this._setPosition(pos);
        if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
          this._getDistance();
        } else if (this.type === CameraType.TRACKING) {
          import_gl_matrix3.vec3.add(this.focalPoint, pos, this.distanceVector);
        }
        this.triggerUpdate();
        return this;
      }
    }, {
      key: "cancelLandmarkAnimation",
      value: function cancelLandmarkAnimation() {
        if (this.landmarkAnimationID !== void 0) {
          this.canvas.cancelAnimationFrame(this.landmarkAnimationID);
        }
      }
    }, {
      key: "createLandmark",
      value: function createLandmark(name) {
        var _position$, _position$2, _focalPoint$, _focalPoint$2;
        var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var _params$position = params.position, position2 = _params$position === void 0 ? this.position : _params$position, _params$focalPoint = params.focalPoint, focalPoint = _params$focalPoint === void 0 ? this.focalPoint : _params$focalPoint, roll = params.roll, zoom = params.zoom;
        var camera = new runtime.CameraContribution();
        camera.setType(this.type, void 0);
        camera.setPosition(position2[0], (_position$ = position2[1]) !== null && _position$ !== void 0 ? _position$ : this.position[1], (_position$2 = position2[2]) !== null && _position$2 !== void 0 ? _position$2 : this.position[2]);
        camera.setFocalPoint(focalPoint[0], (_focalPoint$ = focalPoint[1]) !== null && _focalPoint$ !== void 0 ? _focalPoint$ : this.focalPoint[1], (_focalPoint$2 = focalPoint[2]) !== null && _focalPoint$2 !== void 0 ? _focalPoint$2 : this.focalPoint[2]);
        camera.setRoll(roll !== null && roll !== void 0 ? roll : this.roll);
        camera.setZoom(zoom !== null && zoom !== void 0 ? zoom : this.zoom);
        var landmark = {
          name,
          matrix: import_gl_matrix3.mat4.clone(camera.getWorldTransform()),
          right: import_gl_matrix3.vec3.clone(camera.right),
          up: import_gl_matrix3.vec3.clone(camera.up),
          forward: import_gl_matrix3.vec3.clone(camera.forward),
          position: import_gl_matrix3.vec3.clone(camera.getPosition()),
          focalPoint: import_gl_matrix3.vec3.clone(camera.getFocalPoint()),
          distanceVector: import_gl_matrix3.vec3.clone(camera.getDistanceVector()),
          distance: camera.getDistance(),
          dollyingStep: camera.getDollyingStep(),
          azimuth: camera.getAzimuth(),
          elevation: camera.getElevation(),
          roll: camera.getRoll(),
          relAzimuth: camera.relAzimuth,
          relElevation: camera.relElevation,
          relRoll: camera.relRoll,
          zoom: camera.getZoom()
        };
        this.landmarks.push(landmark);
        return landmark;
      }
    }, {
      key: "gotoLandmark",
      value: function gotoLandmark(name) {
        var _this2 = this;
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var landmark = (0, import_util3.isString)(name) ? this.landmarks.find(function(l) {
          return l.name === name;
        }) : name;
        if (landmark) {
          var _ref = (0, import_util3.isNumber)(options) ? {
            duration: options
          } : options, _ref$easing = _ref.easing, easing = _ref$easing === void 0 ? "linear" : _ref$easing, _ref$duration = _ref.duration, duration = _ref$duration === void 0 ? 100 : _ref$duration, _ref$easingFunction = _ref.easingFunction, easingFunction = _ref$easingFunction === void 0 ? void 0 : _ref$easingFunction, _ref$onfinish = _ref.onfinish, onfinish = _ref$onfinish === void 0 ? void 0 : _ref$onfinish, _ref$onframe = _ref.onframe, onframe = _ref$onframe === void 0 ? void 0 : _ref$onframe;
          var epsilon2 = 0.01;
          this.cancelLandmarkAnimation();
          var destPosition = landmark.position;
          var destFocalPoint = landmark.focalPoint;
          var destZoom = landmark.zoom;
          var destRoll = landmark.roll;
          var easingFunc = easingFunction || runtime.EasingFunction(easing);
          var timeStart;
          var end = function end2() {
            _this2.setFocalPoint(destFocalPoint);
            _this2.setPosition(destPosition);
            _this2.setRoll(destRoll);
            _this2.setZoom(destZoom);
            _this2.computeMatrix();
            _this2.triggerUpdate();
            onfinish === null || onfinish === void 0 || onfinish();
          };
          if (duration === 0) return end();
          var _animate = function animate2(timestamp) {
            if (timeStart === void 0) {
              timeStart = timestamp;
            }
            var elapsed = timestamp - timeStart;
            if (elapsed >= duration) {
              end();
              return;
            }
            var t = easingFunc(elapsed / duration);
            var interFocalPoint = import_gl_matrix3.vec3.create();
            var interPosition = import_gl_matrix3.vec3.create();
            var interZoom = 1;
            var interRoll = 0;
            import_gl_matrix3.vec3.lerp(interFocalPoint, _this2.focalPoint, destFocalPoint, t);
            import_gl_matrix3.vec3.lerp(interPosition, _this2.position, destPosition, t);
            interRoll = _this2.roll * (1 - t) + destRoll * t;
            interZoom = _this2.zoom * (1 - t) + destZoom * t;
            _this2.setFocalPoint(interFocalPoint);
            _this2.setPosition(interPosition);
            _this2.setRoll(interRoll);
            _this2.setZoom(interZoom);
            var dist = import_gl_matrix3.vec3.dist(interFocalPoint, destFocalPoint) + import_gl_matrix3.vec3.dist(interPosition, destPosition);
            if (dist <= epsilon2 && destZoom === void 0 && destRoll === void 0) {
              return end();
            }
            _this2.computeMatrix();
            _this2.triggerUpdate();
            if (elapsed < duration) {
              onframe === null || onframe === void 0 || onframe(t);
              _this2.landmarkAnimationID = _this2.canvas.requestAnimationFrame(_animate);
            }
          };
          this.canvas.requestAnimationFrame(_animate);
        }
      }
      /**
       * Sets the camera to a distance such that the area covered by the bounding box is viewed.
       */
      // shot(displayObject: DisplayObject) {
      //   const aabb = displayObject.getBounds();
      //   if (!AABB.isEmpty(aabb)) {
      //     this.setElevation(0);
      //     this.setAzimuth(0);
      //     this.setRoll(0);
      //     const { halfExtents, center } = aabb;
      //     const maxDim = Math.max(halfExtents[0] * 2, halfExtents[1] * 2);
      //     const cc = center.map((c: number) => Math.round(c * 1000) / 1000) as [number, number, number];
      //     if (maxDim !== 0) {
      //       const d = (1.5 * maxDim) / Math.tan(this.fov * DEG_2_RAD);
      //       this.setPosition([cc[0], cc[1], cc[2] + d]);
      //     }
      //     this.setFocalPoint(cc);
      //   }
      // }
    }]);
  })(Camera);
  runtime.CameraContribution = AdvancedCamera;

  // node_modules/@antv/g-web-animations-api/dist/index.esm.js
  var import_util4 = __toESM(require_lib());
  var AnimationEvent = /* @__PURE__ */ (function(_FederatedEvent) {
    function AnimationEvent2(manager, target, currentTime, timelineTime) {
      var _this2;
      _classCallCheck(this, AnimationEvent2);
      _this2 = _callSuper(this, AnimationEvent2, [manager]);
      _this2.currentTime = currentTime;
      _this2.timelineTime = timelineTime;
      _this2.target = target;
      _this2.type = "finish";
      _this2.bubbles = false;
      _this2.currentTarget = target;
      _this2.defaultPrevented = false;
      _this2.eventPhase = _this2.AT_TARGET;
      _this2.timeStamp = Date.now();
      _this2.currentTime = currentTime;
      _this2.timelineTime = timelineTime;
      return _this2;
    }
    _inherits(AnimationEvent2, _FederatedEvent);
    return _createClass(AnimationEvent2);
  })(FederatedEvent);
  var sequenceNumber = 0;
  var Animation = /* @__PURE__ */ (function() {
    function Animation3(effect2, timeline) {
      var _this$effect;
      _classCallCheck(this, Animation3);
      this.currentTimePending = false;
      this._idle = true;
      this._paused = false;
      this._finishedFlag = true;
      this._currentTime = 0;
      this._playbackRate = 1;
      this._inTimeline = true;
      this.effect = effect2;
      effect2.animation = this;
      this.timeline = timeline;
      this.id = "".concat(sequenceNumber++);
      this._inEffect = !!this.effect.update(0);
      this._totalDuration = Number((_this$effect = this.effect) === null || _this$effect === void 0 ? void 0 : _this$effect.getComputedTiming().endTime);
      this._holdTime = 0;
      this._paused = false;
      this.oldPlayState = "idle";
      this.updatePromises();
    }
    return _createClass(Animation3, [{
      key: "pending",
      get: (
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/effect
         */
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/timeline
         */
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/id
         */
        // animation: InternalAnimation | null;
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/pending
         */
        function get9() {
          return this._startTime === null && !this._paused && this.playbackRate !== 0 || this.currentTimePending;
        }
      )
    }, {
      key: "playState",
      get: function get9() {
        if (this._idle) return "idle";
        if (this._isFinished) return "finished";
        if (this._paused) return "paused";
        return "running";
      }
      /**
       * record previos state
       */
    }, {
      key: "ready",
      get: (
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/ready
         * @example
          animation.pause();
          animation.ready.then(function() {
            // Displays 'running'
            alert(animation.playState);
          });
          animation.play();
         */
        function get9() {
          var _this2 = this;
          if (!this.readyPromise) {
            if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
              this.timeline.animationsWithPromises.push(this);
            }
            this.readyPromise = new Promise(function(resolve, reject) {
              _this2.resolveReadyPromise = function() {
                resolve(_this2);
              };
              _this2.rejectReadyPromise = function() {
                reject(new Error());
              };
            });
            if (!this.pending) {
              this.resolveReadyPromise();
            }
          }
          return this.readyPromise;
        }
      )
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/finished
       * @example
        Promise.all(
          elem.getAnimations().map(
            function(animation) {
              return animation.finished
            }
          )
        ).then(
          function() {
            return elem.remove();
          }
        );
       */
    }, {
      key: "finished",
      get: function get9() {
        var _this2 = this;
        if (!this.finishedPromise) {
          if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
            this.timeline.animationsWithPromises.push(this);
          }
          this.finishedPromise = new Promise(function(resolve, reject) {
            _this2.resolveFinishedPromise = function() {
              resolve(_this2);
            };
            _this2.rejectFinishedPromise = function() {
              reject(new Error());
            };
          });
          if (this.playState === "finished") {
            this.resolveFinishedPromise();
          }
        }
        return this.finishedPromise;
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/onfinish
       */
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/oncancel
       */
      /**
       * get called after each frame when running
       */
    }, {
      key: "currentTime",
      get: function get9() {
        this.updatePromises();
        return this._idle || this.currentTimePending ? null : this._currentTime;
      },
      set: function set6(newTime) {
        newTime = Number(newTime);
        if (isNaN(newTime)) return;
        this.timeline.restart();
        if (!this._paused && this._startTime !== null) {
          var _this$timeline;
          this._startTime = Number((_this$timeline = this.timeline) === null || _this$timeline === void 0 ? void 0 : _this$timeline.currentTime) - newTime / this.playbackRate;
        }
        this.currentTimePending = false;
        if (this._currentTime === newTime) {
          return;
        }
        if (this._idle) {
          this._idle = false;
          this._paused = true;
        }
        this.tickCurrentTime(newTime, true);
        this.timeline.applyDirtiedAnimation(this);
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/startTime
       */
    }, {
      key: "startTime",
      get: function get9() {
        return this._startTime;
      },
      set: function set6(newTime) {
        if (newTime !== null) {
          this.updatePromises();
          newTime = Number(newTime);
          if (isNaN(newTime)) return;
          if (this._paused || this._idle) return;
          this._startTime = newTime;
          this.tickCurrentTime((Number(this.timeline.currentTime) - this._startTime) * this.playbackRate);
          this.timeline.applyDirtiedAnimation(this);
          this.updatePromises();
        }
      }
    }, {
      key: "playbackRate",
      get: function get9() {
        return this._playbackRate;
      },
      set: function set6(value) {
        if (value === this._playbackRate) {
          return;
        }
        this.updatePromises();
        var oldCurrentTime = this.currentTime;
        this._playbackRate = value;
        this.startTime = null;
        if (this.playState !== "paused" && this.playState !== "idle") {
          this._finishedFlag = false;
          this._idle = false;
          this.ensureAlive();
          this.timeline.applyDirtiedAnimation(this);
        }
        if (oldCurrentTime !== null) {
          this.currentTime = oldCurrentTime;
        }
        this.updatePromises();
      }
    }, {
      key: "_isFinished",
      get: function get9() {
        return !this._idle && (this._playbackRate > 0 && Number(this._currentTime) >= this._totalDuration || this._playbackRate < 0 && Number(this._currentTime) <= 0);
      }
    }, {
      key: "totalDuration",
      get: function get9() {
        return this._totalDuration;
      }
    }, {
      key: "_needsTick",
      get: function get9() {
        return this.pending || this.playState === "running" || !this._finishedFlag;
      }
    }, {
      key: "updatePromises",
      value: function updatePromises() {
        var _this$effect$target;
        if ((_this$effect$target = this.effect.target) !== null && _this$effect$target !== void 0 && _this$effect$target.destroyed) {
          this.readyPromise = void 0;
          this.finishedPromise = void 0;
          return false;
        }
        var oldPlayState = this.oldPlayState;
        var newPlayState = this.pending ? "pending" : this.playState;
        if (this.readyPromise && newPlayState !== oldPlayState) {
          if (newPlayState === "idle") {
            this.rejectReadyPromise();
            this.readyPromise = void 0;
          } else if (oldPlayState === "pending") {
            this.resolveReadyPromise();
          } else if (newPlayState === "pending") {
            this.readyPromise = void 0;
          }
        }
        if (this.finishedPromise && newPlayState !== oldPlayState) {
          if (newPlayState === "idle") {
            this.rejectFinishedPromise();
            this.finishedPromise = void 0;
          } else if (newPlayState === "finished") {
            this.resolveFinishedPromise();
          } else if (oldPlayState === "finished") {
            this.finishedPromise = void 0;
          }
        }
        this.oldPlayState = newPlayState;
        return this.readyPromise || this.finishedPromise;
      }
    }, {
      key: "play",
      value: function play() {
        this.updatePromises();
        this._paused = false;
        if (this._isFinished || this._idle) {
          this.rewind();
          this._startTime = null;
        }
        this._finishedFlag = false;
        this._idle = false;
        this.ensureAlive();
        this.timeline.applyDirtiedAnimation(this);
        if (this.timeline.animations.indexOf(this) === -1) {
          this.timeline.animations.push(this);
        }
        this.updatePromises();
      }
    }, {
      key: "pause",
      value: function pause() {
        this.updatePromises();
        if (this.currentTime) {
          this._holdTime = this.currentTime;
        }
        if (!this._isFinished && !this._paused && !this._idle) {
          this.currentTimePending = true;
        } else if (this._idle) {
          this.rewind();
          this._idle = false;
        }
        this._startTime = null;
        this._paused = true;
        this.updatePromises();
      }
    }, {
      key: "finish",
      value: function finish() {
        this.updatePromises();
        if (this._idle) return;
        this.currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
        this._startTime = this._totalDuration - this.currentTime;
        this.currentTimePending = false;
        this.timeline.applyDirtiedAnimation(this);
        this.updatePromises();
      }
    }, {
      key: "cancel",
      value: function cancel() {
        var _this3 = this;
        this.updatePromises();
        if (!this._inEffect) return;
        this._inEffect = false;
        this._idle = true;
        this._paused = false;
        this._finishedFlag = true;
        this._currentTime = 0;
        this._startTime = null;
        this.effect.update(null);
        this.timeline.applyDirtiedAnimation(this);
        this.updatePromises();
        if (this.oncancel) {
          var event = new AnimationEvent(null, this, this.currentTime, null);
          setTimeout(function() {
            _this3.oncancel(event);
          });
        }
      }
    }, {
      key: "reverse",
      value: function reverse() {
        this.updatePromises();
        var oldCurrentTime = this.currentTime;
        this.playbackRate *= -1;
        this.play();
        if (oldCurrentTime !== null) {
          this.currentTime = oldCurrentTime;
        }
        this.updatePromises();
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/updatePlaybackRate
       */
    }, {
      key: "updatePlaybackRate",
      value: function updatePlaybackRate(playbackRate) {
        this.playbackRate = playbackRate;
      }
    }, {
      key: "targetAnimations",
      value: function targetAnimations() {
        var _this$effect2;
        var target = (_this$effect2 = this.effect) === null || _this$effect2 === void 0 ? void 0 : _this$effect2.target;
        return target.getAnimations();
      }
    }, {
      key: "markTarget",
      value: function markTarget() {
        var animations = this.targetAnimations();
        if (animations.indexOf(this) === -1) {
          animations.push(this);
        }
      }
    }, {
      key: "unmarkTarget",
      value: function unmarkTarget() {
        var animations = this.targetAnimations();
        var index2 = animations.indexOf(this);
        if (index2 !== -1) {
          animations.splice(index2, 1);
        }
      }
    }, {
      key: "tick",
      value: function tick2(timelineTime, isAnimationFrame) {
        if (!this._idle && !this._paused) {
          if (this._startTime === null) {
            if (isAnimationFrame) {
              this.startTime = timelineTime - this._currentTime / this.playbackRate;
            }
          } else if (!this._isFinished) {
            this.tickCurrentTime((timelineTime - this._startTime) * this.playbackRate);
          }
        }
        if (isAnimationFrame) {
          this.currentTimePending = false;
          this.fireEvents(timelineTime);
        }
      }
    }, {
      key: "rewind",
      value: function rewind() {
        if (this.playbackRate >= 0) {
          this.currentTime = 0;
        } else if (this._totalDuration < Infinity) {
          this.currentTime = this._totalDuration;
        } else {
          throw new Error("Unable to rewind negative playback rate animation with infinite duration");
        }
      }
    }, {
      key: "persist",
      value: function persist() {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener, options) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "commitStyles",
      value: (
        // replaceState: AnimationReplaceState;
        function commitStyles() {
          throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
        }
      )
    }, {
      key: "ensureAlive",
      value: function ensureAlive() {
        if (this.playbackRate < 0 && this.currentTime === 0) {
          var _this$effect3;
          this._inEffect = !!((_this$effect3 = this.effect) !== null && _this$effect3 !== void 0 && _this$effect3.update(-1));
        } else {
          var _this$effect4;
          this._inEffect = !!((_this$effect4 = this.effect) !== null && _this$effect4 !== void 0 && _this$effect4.update(this.currentTime));
        }
        if (!this._inTimeline && (this._inEffect || !this._finishedFlag)) {
          this._inTimeline = true;
          this.timeline.animations.push(this);
        }
      }
    }, {
      key: "tickCurrentTime",
      value: function tickCurrentTime(newTime, ignoreLimit) {
        if (newTime !== this._currentTime) {
          this._currentTime = newTime;
          if (this._isFinished && !ignoreLimit) {
            this._currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
          }
          this.ensureAlive();
        }
      }
    }, {
      key: "fireEvents",
      value: function fireEvents(baseTime) {
        var _this4 = this;
        if (this._isFinished) {
          if (!this._finishedFlag) {
            if (this.onfinish) {
              var event = new AnimationEvent(null, this, this.currentTime, baseTime);
              setTimeout(function() {
                if (_this4.onfinish) {
                  _this4.onfinish(event);
                }
              });
            }
            this._finishedFlag = true;
          }
        } else {
          if (this.onframe && this.playState === "running") {
            var _event = new AnimationEvent(null, this, this.currentTime, baseTime);
            this.onframe(_event);
          }
          this._finishedFlag = false;
        }
      }
    }]);
  })();
  var NEWTON_ITERATIONS = 4;
  var NEWTON_MIN_SLOPE = 1e-3;
  var SUBDIVISION_PRECISION = 1e-7;
  var SUBDIVISION_MAX_ITERATIONS = 10;
  var kSplineTableSize = 11;
  var kSampleStepSize = 1 / (kSplineTableSize - 1);
  var float32ArraySupported = typeof Float32Array === "function";
  var A = function A2(aA1, aA2) {
    return 1 - 3 * aA2 + 3 * aA1;
  };
  var B = function B2(aA1, aA2) {
    return 3 * aA2 - 6 * aA1;
  };
  var C = function C2(aA1) {
    return 3 * aA1;
  };
  var calcBezier = function calcBezier2(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  };
  var getSlope = function getSlope2(aT, aA1, aA2) {
    return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
  };
  var binarySubdivide = function binarySubdivide2(aX, aA, aB, mX1, mX2) {
    var currentX;
    var currentT;
    var i = 0;
    do {
      currentT = aA + (aB - aA) / 2;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0) aB = currentT;
      else aA = currentT;
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
    return currentT;
  };
  var newtonRaphsonIterate = function newtonRaphsonIterate2(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);
      if (currentSlope === 0) return aGuessT;
      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  };
  var bezier = function bezier2(mX1, mY1, mX2, mY2) {
    if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) throw new Error("bezier x values must be in [0, 1] range");
    if (mX1 === mY1 && mX2 === mY2) return function(t) {
      return t;
    };
    var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
    for (var i = 0; i < kSplineTableSize; ++i) {
      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }
    var getTForX = function getTForX2(aX) {
      var intervalStart = 0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;
      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) intervalStart += kSampleStepSize;
      --currentSample;
      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);
      if (initialSlope >= NEWTON_MIN_SLOPE) return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      if (initialSlope === 0) return guessForT;
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    };
    return function(t) {
      if (t === 0 || t === 1) return t;
      return calcBezier(getTForX(t), mY1, mY2);
    };
  };
  var convertToDash = function convertToDash2(str) {
    str = str.replace(/([A-Z])/g, function(letter) {
      return "-".concat(letter.toLowerCase());
    });
    return str.charAt(0) === "-" ? str.substring(1) : str;
  };
  var Quad = function Quad2(t) {
    return Math.pow(t, 2);
  };
  var Cubic = function Cubic2(t) {
    return Math.pow(t, 3);
  };
  var Quart = function Quart2(t) {
    return Math.pow(t, 4);
  };
  var Quint = function Quint2(t) {
    return Math.pow(t, 5);
  };
  var Expo = function Expo2(t) {
    return Math.pow(t, 6);
  };
  var Sine = function Sine2(t) {
    return 1 - Math.cos(t * Math.PI / 2);
  };
  var Circ = function Circ2(t) {
    return 1 - Math.sqrt(1 - t * t);
  };
  var Back = function Back2(t) {
    return t * t * (3 * t - 2);
  };
  var Bounce = function Bounce2(t) {
    var pow2;
    var b = 4;
    while (t < ((pow2 = Math.pow(2, --b)) - 1) / 11) {
    }
    return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);
  };
  var Elastic = function Elastic2(t) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var _params = _slicedToArray(params, 2), _params$ = _params[0], amplitude = _params$ === void 0 ? 1 : _params$, _params$2 = _params[1], period = _params$2 === void 0 ? 0.5 : _params$2;
    var a2 = (0, import_util4.clamp)(Number(amplitude), 1, 10);
    var p = (0, import_util4.clamp)(Number(period), 0.1, 2);
    if (t === 0 || t === 1) return t;
    return -a2 * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p / (Math.PI * 2) * Math.asin(1 / a2)) * (Math.PI * 2) / p);
  };
  var Spring = function Spring2(t) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var duration = arguments.length > 2 ? arguments[2] : void 0;
    var _params2 = _slicedToArray(params, 4), _params2$ = _params2[0], mass = _params2$ === void 0 ? 1 : _params2$, _params2$2 = _params2[1], stiffness = _params2$2 === void 0 ? 100 : _params2$2, _params2$3 = _params2[2], damping = _params2$3 === void 0 ? 10 : _params2$3, _params2$4 = _params2[3], velocity = _params2$4 === void 0 ? 0 : _params2$4;
    mass = (0, import_util4.clamp)(mass, 0.1, 1e3);
    stiffness = (0, import_util4.clamp)(stiffness, 0.1, 1e3);
    damping = (0, import_util4.clamp)(damping, 0.1, 1e3);
    velocity = (0, import_util4.clamp)(velocity, 0.1, 1e3);
    var w0 = Math.sqrt(stiffness / mass);
    var zeta = damping / (2 * Math.sqrt(stiffness * mass));
    var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
    var a2 = 1;
    var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;
    var progress = duration ? duration * t / 1e3 : t;
    if (zeta < 1) {
      progress = Math.exp(-progress * zeta * w0) * (a2 * Math.cos(wd * progress) + b * Math.sin(wd * progress));
    } else {
      progress = (a2 + b * progress) * Math.exp(-progress * w0);
    }
    if (t === 0 || t === 1) return t;
    return 1 - progress;
  };
  var Steps = function Steps2(t) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var _ref = params, _ref2 = _slicedToArray(_ref, 2), _ref2$ = _ref2[0], steps = _ref2$ === void 0 ? 10 : _ref2$, type = _ref2[1];
    var trunc = type === "start" ? Math.ceil : Math.floor;
    return trunc((0, import_util4.clamp)(t, 0, 1) * steps) / steps;
  };
  var Bezier = function Bezier2(t) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var _params3 = _slicedToArray(params, 4), mX1 = _params3[0], mY1 = _params3[1], mX2 = _params3[2], mY2 = _params3[3];
    return bezier(mX1, mY1, mX2, mY2)(t);
  };
  var easein = bezier(0.42, 0, 1, 1);
  var EaseOut = function EaseOut2(ease2) {
    return function(t) {
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var duration = arguments.length > 2 ? arguments[2] : void 0;
      return 1 - ease2(1 - t, params, duration);
    };
  };
  var EaseInOut = function EaseInOut2(ease2) {
    return function(t) {
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var duration = arguments.length > 2 ? arguments[2] : void 0;
      return t < 0.5 ? ease2(t * 2, params, duration) / 2 : 1 - ease2(t * -2 + 2, params, duration) / 2;
    };
  };
  var EaseOutIn = function EaseOutIn2(ease2) {
    return function(t) {
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var duration = arguments.length > 2 ? arguments[2] : void 0;
      return t < 0.5 ? (1 - ease2(1 - t * 2, params, duration)) / 2 : (ease2(t * 2 - 1, params, duration) + 1) / 2;
    };
  };
  var EasingFunctions = {
    steps: Steps,
    "step-start": function stepStart(t) {
      return Steps(t, [1, "start"]);
    },
    "step-end": function stepEnd(t) {
      return Steps(t, [1, "end"]);
    },
    linear: function linear(t) {
      return t;
    },
    "cubic-bezier": Bezier,
    ease: function ease(t) {
      return Bezier(t, [0.25, 0.1, 0.25, 1]);
    },
    "in": easein,
    out: EaseOut(easein),
    "in-out": EaseInOut(easein),
    "out-in": EaseOutIn(easein),
    "in-quad": Quad,
    "out-quad": EaseOut(Quad),
    "in-out-quad": EaseInOut(Quad),
    "out-in-quad": EaseOutIn(Quad),
    "in-cubic": Cubic,
    "out-cubic": EaseOut(Cubic),
    "in-out-cubic": EaseInOut(Cubic),
    "out-in-cubic": EaseOutIn(Cubic),
    "in-quart": Quart,
    "out-quart": EaseOut(Quart),
    "in-out-quart": EaseInOut(Quart),
    "out-in-quart": EaseOutIn(Quart),
    "in-quint": Quint,
    "out-quint": EaseOut(Quint),
    "in-out-quint": EaseInOut(Quint),
    "out-in-quint": EaseOutIn(Quint),
    "in-expo": Expo,
    "out-expo": EaseOut(Expo),
    "in-out-expo": EaseInOut(Expo),
    "out-in-expo": EaseOutIn(Expo),
    "in-sine": Sine,
    "out-sine": EaseOut(Sine),
    "in-out-sine": EaseInOut(Sine),
    "out-in-sine": EaseOutIn(Sine),
    "in-circ": Circ,
    "out-circ": EaseOut(Circ),
    "in-out-circ": EaseInOut(Circ),
    "out-in-circ": EaseOutIn(Circ),
    "in-back": Back,
    "out-back": EaseOut(Back),
    "in-out-back": EaseInOut(Back),
    "out-in-back": EaseOutIn(Back),
    "in-bounce": Bounce,
    "out-bounce": EaseOut(Bounce),
    "in-out-bounce": EaseInOut(Bounce),
    "out-in-bounce": EaseOutIn(Bounce),
    "in-elastic": Elastic,
    "out-elastic": EaseOut(Elastic),
    "in-out-elastic": EaseInOut(Elastic),
    "out-in-elastic": EaseOutIn(Elastic),
    spring: Spring,
    "spring-in": Spring,
    "spring-out": EaseOut(Spring),
    "spring-in-out": EaseInOut(Spring),
    "spring-out-in": EaseOutIn(Spring)
  };
  var complexEasingSyntax = function complexEasingSyntax2(ease2) {
    return convertToDash(ease2).replace(/^ease-/, "").replace(/(\(|\s).+/, "").toLowerCase().trim();
  };
  var getEasingFunction = function getEasingFunction2(ease2) {
    return EasingFunctions[complexEasingSyntax(ease2)] || EasingFunctions.linear;
  };
  var linear2 = function linear3(x3) {
    return x3;
  };
  var Start = 1;
  var Middle = 0.5;
  var End = 0;
  function step(count, pos) {
    return function(x3) {
      if (x3 >= 1) {
        return 1;
      }
      var stepSize = 1 / count;
      x3 += pos * stepSize;
      return x3 - x3 % stepSize;
    };
  }
  var numberString = "\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*";
  var cubicBezierRe = new RegExp("cubic-bezier\\(".concat(numberString, ",").concat(numberString, ",").concat(numberString, ",").concat(numberString, "\\)"));
  var step1Re = /steps\(\s*(\d+)\s*\)/;
  var step2Re = /steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/;
  function parseEasingFunction(normalizedEasing) {
    var cubicData = cubicBezierRe.exec(normalizedEasing);
    if (cubicData) {
      return bezier.apply(void 0, _toConsumableArray(cubicData.slice(1).map(Number)));
    }
    var step1Data = step1Re.exec(normalizedEasing);
    if (step1Data) {
      return step(Number(step1Data[1]), End);
    }
    var step2Data = step2Re.exec(normalizedEasing);
    if (step2Data) {
      return step(Number(step2Data[1]), {
        start: Start,
        middle: Middle,
        end: End
      }[step2Data[2]]);
    }
    return getEasingFunction(normalizedEasing);
  }
  function calculateActiveDuration(timing) {
    return Math.abs(repeatedDuration(timing) / (timing.playbackRate || 1));
  }
  function repeatedDuration(timing) {
    var _timing$iterations;
    if (timing.duration === 0 || timing.iterations === 0) {
      return 0;
    }
    return (timing.duration === "auto" ? 0 : Number(timing.duration)) * ((_timing$iterations = timing.iterations) !== null && _timing$iterations !== void 0 ? _timing$iterations : 1);
  }
  var PhaseNone = 0;
  var PhaseBefore = 1;
  var PhaseAfter = 2;
  var PhaseActive = 3;
  function calculatePhase(activeDuration, localTime, timing) {
    if (localTime === null) {
      return PhaseNone;
    }
    var endTime = timing.endTime;
    if (localTime < Math.min(timing.delay, endTime)) {
      return PhaseBefore;
    }
    if (localTime >= Math.min(timing.delay + activeDuration + timing.endDelay, endTime)) {
      return PhaseAfter;
    }
    return PhaseActive;
  }
  function calculateActiveTime(activeDuration, fillMode, localTime, phase, delay) {
    switch (phase) {
      case PhaseBefore:
        if (fillMode === "backwards" || fillMode === "both") return 0;
        return null;
      case PhaseActive:
        return localTime - delay;
      case PhaseAfter:
        if (fillMode === "forwards" || fillMode === "both") return activeDuration;
        return null;
      case PhaseNone:
        return null;
    }
  }
  function calculateOverallProgress(iterationDuration, phase, iterations, activeTime, iterationStart) {
    var overallProgress = iterationStart;
    if (iterationDuration === 0) {
      if (phase !== PhaseBefore) {
        overallProgress += iterations;
      }
    } else {
      overallProgress += activeTime / iterationDuration;
    }
    return overallProgress;
  }
  function calculateSimpleIterationProgress(overallProgress, iterationStart, phase, iterations, activeTime, iterationDuration) {
    var simpleIterationProgress = overallProgress === Infinity ? iterationStart % 1 : overallProgress % 1;
    if (simpleIterationProgress === 0 && phase === PhaseAfter && iterations !== 0 && (activeTime !== 0 || iterationDuration === 0)) {
      simpleIterationProgress = 1;
    }
    return simpleIterationProgress;
  }
  function calculateCurrentIteration(phase, iterations, simpleIterationProgress, overallProgress) {
    if (phase === PhaseAfter && iterations === Infinity) {
      return Infinity;
    }
    if (simpleIterationProgress === 1) {
      return Math.floor(overallProgress) - 1;
    }
    return Math.floor(overallProgress);
  }
  function calculateDirectedProgress(playbackDirection, currentIteration, simpleIterationProgress) {
    var currentDirection = playbackDirection;
    if (playbackDirection !== "normal" && playbackDirection !== "reverse") {
      var d2 = currentIteration;
      if (playbackDirection === "alternate-reverse") {
        d2 += 1;
      }
      currentDirection = "normal";
      if (d2 !== Infinity && d2 % 2 !== 0) {
        currentDirection = "reverse";
      }
    }
    if (currentDirection === "normal") {
      return simpleIterationProgress;
    }
    return 1 - simpleIterationProgress;
  }
  function calculateIterationProgress(activeDuration, localTime, timing) {
    var phase = calculatePhase(activeDuration, localTime, timing);
    var activeTime = calculateActiveTime(activeDuration, timing.fill, localTime, phase, timing.delay);
    if (activeTime === null) return null;
    var duration = timing.duration === "auto" ? 0 : timing.duration;
    var overallProgress = calculateOverallProgress(duration, phase, timing.iterations, activeTime, timing.iterationStart);
    var simpleIterationProgress = calculateSimpleIterationProgress(overallProgress, timing.iterationStart, phase, timing.iterations, activeTime, duration);
    var currentIteration = calculateCurrentIteration(phase, timing.iterations, simpleIterationProgress, overallProgress);
    var directedProgress = calculateDirectedProgress(timing.direction, currentIteration, simpleIterationProgress);
    timing.currentIteration = currentIteration;
    timing.progress = directedProgress;
    return timing.easingFunction(directedProgress);
  }
  function convertEffectInput(keyframes, timing, target) {
    var propertySpecificKeyframeGroups = makePropertySpecificKeyframeGroups(keyframes, timing);
    var interpolations = makeInterpolations(propertySpecificKeyframeGroups, target);
    return function(target2, fraction) {
      if (fraction !== null) {
        interpolations.filter(function(interpolation) {
          return fraction >= interpolation.applyFrom && fraction < interpolation.applyTo;
        }).forEach(function(interpolation) {
          var offsetFraction = fraction - interpolation.startOffset;
          var localDuration = interpolation.endOffset - interpolation.startOffset;
          var scaledLocalTime = localDuration === 0 ? 0 : offsetFraction / localDuration;
          target2.setAttribute(
            interpolation.property,
            interpolation.interpolation(scaledLocalTime),
            false,
            false
            // disable memoize
          );
        });
      } else {
        for (var property in propertySpecificKeyframeGroups) if (isNotReservedWord(property)) {
          target2.setAttribute(property, null);
        }
      }
    };
  }
  function isNotReservedWord(member) {
    return member !== "offset" && member !== "easing" && member !== "composite" && member !== "computedOffset";
  }
  function makePropertySpecificKeyframeGroups(keyframes, timing) {
    var propertySpecificKeyframeGroups = {};
    for (var i = 0; i < keyframes.length; i++) {
      for (var member in keyframes[i]) {
        if (isNotReservedWord(member)) {
          var propertySpecificKeyframe = {
            offset: keyframes[i].offset,
            computedOffset: keyframes[i].computedOffset,
            easing: keyframes[i].easing,
            easingFunction: parseEasingFunction(keyframes[i].easing) || timing.easingFunction,
            value: keyframes[i][member]
          };
          propertySpecificKeyframeGroups[member] = propertySpecificKeyframeGroups[member] || [];
          propertySpecificKeyframeGroups[member].push(propertySpecificKeyframe);
        }
      }
    }
    return propertySpecificKeyframeGroups;
  }
  function makeInterpolations(propertySpecificKeyframeGroups, target) {
    var interpolations = [];
    for (var groupName in propertySpecificKeyframeGroups) {
      var keyframes = propertySpecificKeyframeGroups[groupName];
      for (var i = 0; i < keyframes.length - 1; i++) {
        var startIndex = i;
        var endIndex = i + 1;
        var startOffset = keyframes[startIndex].computedOffset;
        var endOffset = keyframes[endIndex].computedOffset;
        var applyFrom = startOffset;
        var applyTo = endOffset;
        if (i === 0) {
          applyFrom = -Infinity;
          if (endOffset === 0) {
            endIndex = startIndex;
          }
        }
        if (i === keyframes.length - 2) {
          applyTo = Infinity;
          if (startOffset === 1) {
            startIndex = endIndex;
          }
        }
        interpolations.push({
          applyFrom,
          applyTo,
          startOffset: keyframes[startIndex].computedOffset,
          endOffset: keyframes[endIndex].computedOffset,
          easingFunction: keyframes[startIndex].easingFunction,
          property: groupName,
          interpolation: propertyInterpolation(groupName, keyframes[startIndex].value, keyframes[endIndex].value, target)
        });
      }
    }
    interpolations.sort(function(leftInterpolation, rightInterpolation) {
      return leftInterpolation.startOffset - rightInterpolation.startOffset;
    });
    return interpolations;
  }
  var InterpolationFactory = function InterpolationFactory2(from, to, convertToString) {
    return function(f) {
      var interpolated = interpolate(from, to, f);
      return (0, import_util4.isNumber)(interpolated) ? interpolated : convertToString(interpolated);
    };
  };
  function propertyInterpolation(property, left, right, target) {
    var metadata = propertyMetadataCache[property];
    if (metadata && metadata.syntax && metadata["int"]) {
      var propertyHandler = runtime.styleValueRegistry.getPropertySyntax(metadata.syntax);
      if (propertyHandler) {
        var parser2 = propertyHandler.parser;
        var usedLeft = parser2 ? parser2(left, target) : left;
        var usedRight = parser2 ? parser2(right, target) : right;
        var interpolationArgs = propertyHandler.mixer(usedLeft, usedRight, target);
        if (interpolationArgs) {
          var interp = InterpolationFactory.apply(void 0, _toConsumableArray(interpolationArgs));
          return function(t) {
            if (t === 0) return left;
            if (t === 1) return right;
            return interp(t);
          };
        }
      }
    }
    return InterpolationFactory(false, true, function(bool) {
      return bool ? right : left;
    });
  }
  function interpolate(from, to, f) {
    if (typeof from === "number" && typeof to === "number") {
      return from * (1 - f) + to * f;
    }
    if (typeof from === "boolean" && typeof to === "boolean" || typeof from === "string" && typeof to === "string") {
      return f < 0.5 ? from : to;
    }
    if (Array.isArray(from) && Array.isArray(to)) {
      var fromLength = from.length;
      var toLength = to.length;
      var length = Math.max(fromLength, toLength);
      var r = [];
      for (var i = 0; i < length; i++) {
        r.push(interpolate(from[i < fromLength ? i : fromLength - 1], to[i < toLength ? i : toLength - 1], f));
      }
      return r;
    }
    throw new Error("Mismatched interpolation arguments ".concat(from, ":").concat(to));
  }
  var AnimationEffectTiming = /* @__PURE__ */ (function() {
    function AnimationEffectTiming2() {
      _classCallCheck(this, AnimationEffectTiming2);
      this.delay = 0;
      this.direction = "normal";
      this.duration = "auto";
      this._easing = "linear";
      this.easingFunction = linear2;
      this.endDelay = 0;
      this.fill = "auto";
      this.iterationStart = 0;
      this.iterations = 1;
      this.currentIteration = null;
      this.progress = null;
    }
    return _createClass(AnimationEffectTiming2, [{
      key: "easing",
      get: function get9() {
        return this._easing;
      },
      set: function set6(value) {
        this.easingFunction = parseEasingFunction(value);
        this._easing = value;
      }
    }]);
  })();
  function convertToArrayForm(effectInput) {
    var normalizedEffectInput = [];
    for (var property in effectInput) {
      if (property in ["easing", "offset", "composite"]) {
        continue;
      }
      var values2 = effectInput[property];
      if (!Array.isArray(values2)) {
        values2 = [values2];
      }
      var numKeyframes = values2.length;
      for (var i = 0; i < numKeyframes; i++) {
        if (!normalizedEffectInput[i]) {
          var keyframe = {};
          if ("offset" in effectInput) {
            keyframe.offset = Number(effectInput.offset);
          }
          if ("easing" in effectInput) {
            keyframe.easing = effectInput.easing;
          }
          if ("composite" in effectInput) {
            keyframe.composite = effectInput.composite;
          }
          normalizedEffectInput[i] = keyframe;
        }
        if (values2[i] !== void 0 && values2[i] !== null) {
          normalizedEffectInput[i][property] = values2[i];
        }
      }
    }
    normalizedEffectInput.sort(function(a2, b) {
      return (a2.computedOffset || 0) - (b.computedOffset || 0);
    });
    return normalizedEffectInput;
  }
  function normalizeKeyframes(effectInput, timing) {
    if (effectInput === null) {
      return [];
    }
    if (!Array.isArray(effectInput)) {
      effectInput = convertToArrayForm(effectInput);
    }
    var keyframes = effectInput.map(function(originalKeyframe) {
      var keyframe = {};
      if (timing !== null && timing !== void 0 && timing.composite) {
        keyframe.composite = "auto";
      }
      for (var member in originalKeyframe) {
        var memberValue = originalKeyframe[member];
        if (member === "offset") {
          if (memberValue !== null) {
            memberValue = Number(memberValue);
            if (!isFinite(memberValue)) throw new Error("Keyframe offsets must be numbers.");
            if (memberValue < 0 || memberValue > 1) throw new Error("Keyframe offsets must be between 0 and 1.");
            keyframe.computedOffset = memberValue;
          }
        } else if (member === "composite") {
          if (["replace", "add", "accumulate", "auto"].indexOf(memberValue) === -1) {
            throw new Error("".concat(memberValue, " compositing is not supported"));
          }
        } else ;
        keyframe[member] = memberValue;
      }
      if (keyframe.offset === void 0) {
        keyframe.offset = null;
      }
      if (keyframe.easing === void 0) {
        keyframe.easing = (timing === null || timing === void 0 ? void 0 : timing.easing) || "linear";
      }
      if (keyframe.composite === void 0) {
        keyframe.composite = "auto";
      }
      return keyframe;
    });
    var everyFrameHasOffset = true;
    var previousOffset = -Infinity;
    for (var i = 0; i < keyframes.length; i++) {
      var offset = keyframes[i].offset;
      if (!(0, import_util4.isNil)(offset)) {
        if (offset < previousOffset) {
          throw new TypeError("Keyframes are not loosely sorted by offset. Sort or specify offsets.");
        }
        previousOffset = offset;
      } else {
        everyFrameHasOffset = false;
      }
    }
    keyframes = keyframes.filter(function(keyframe) {
      return Number(keyframe.offset) >= 0 && Number(keyframe.offset) <= 1;
    });
    function spaceKeyframes() {
      var _keyframes$offset;
      var _keyframes = keyframes, length = _keyframes.length;
      keyframes[length - 1].computedOffset = Number((_keyframes$offset = keyframes[length - 1].offset) !== null && _keyframes$offset !== void 0 ? _keyframes$offset : 1);
      if (length > 1) {
        var _keyframes$0$offset;
        keyframes[0].computedOffset = Number((_keyframes$0$offset = keyframes[0].offset) !== null && _keyframes$0$offset !== void 0 ? _keyframes$0$offset : 0);
      }
      var previousIndex = 0;
      var previousOffset2 = Number(keyframes[0].computedOffset);
      for (var _i = 1; _i < length; _i++) {
        var _offset = keyframes[_i].computedOffset;
        if (!(0, import_util4.isNil)(_offset) && !(0, import_util4.isNil)(previousOffset2)) {
          for (var j = 1; j < _i - previousIndex; j++) keyframes[previousIndex + j].computedOffset = previousOffset2 + (Number(_offset) - previousOffset2) * j / (_i - previousIndex);
          previousIndex = _i;
          previousOffset2 = Number(_offset);
        }
      }
    }
    if (!everyFrameHasOffset) spaceKeyframes();
    return keyframes;
  }
  var fills = "backwards|forwards|both|none".split("|");
  var directions = "reverse|alternate|alternate-reverse".split("|");
  function makeTiming(timingInput, forGroup) {
    var timing = new AnimationEffectTiming();
    if (forGroup) {
      timing.fill = "both";
      timing.duration = "auto";
    }
    if (typeof timingInput === "number" && !isNaN(timingInput)) {
      timing.duration = timingInput;
    } else if (timingInput !== void 0) {
      Object.keys(timingInput).forEach(function(property) {
        if (timingInput[property] !== void 0 && timingInput[property] !== null && timingInput[property] !== "auto") {
          if (typeof timing[property] === "number" || property === "duration") {
            if (typeof timingInput[property] !== "number" || isNaN(timingInput[property])) {
              return;
            }
          }
          if (property === "fill" && fills.indexOf(timingInput[property]) === -1) {
            return;
          }
          if (property === "direction" && directions.indexOf(timingInput[property]) === -1) {
            return;
          }
          timing[property] = timingInput[property];
        }
      });
    }
    return timing;
  }
  function normalizeTimingInput(timingInput, forGroup) {
    timingInput = numericTimingToObject(timingInput !== null && timingInput !== void 0 ? timingInput : {
      duration: "auto"
    });
    return makeTiming(timingInput, forGroup);
  }
  function numericTimingToObject(timingInput) {
    if (typeof timingInput === "number") {
      if (isNaN(timingInput)) {
        timingInput = {
          duration: "auto"
        };
      } else {
        timingInput = {
          duration: timingInput
        };
      }
    }
    return timingInput;
  }
  var KeyframeEffect = /* @__PURE__ */ (function() {
    function KeyframeEffect2(target, effectInput, timingInput) {
      var _this2 = this;
      _classCallCheck(this, KeyframeEffect2);
      this.composite = "replace";
      this.iterationComposite = "replace";
      this.target = target;
      this.timing = normalizeTimingInput(timingInput, false);
      this.timing.effect = this;
      this.timing.activeDuration = calculateActiveDuration(this.timing);
      this.timing.endTime = Math.max(0, this.timing.delay + this.timing.activeDuration + this.timing.endDelay);
      this.normalizedKeyframes = normalizeKeyframes(effectInput, this.timing);
      this.interpolations = convertEffectInput(this.normalizedKeyframes, this.timing, this.target);
      var Proxy3 = runtime.globalThis.Proxy;
      this.computedTiming = Proxy3 ? new Proxy3(this.timing, {
        get: function get9(target2, prop) {
          if (prop === "duration") {
            return target2.duration === "auto" ? 0 : target2.duration;
          }
          if (prop === "fill") {
            return target2.fill === "auto" ? "none" : target2.fill;
          }
          if (prop === "localTime") {
            return _this2.animation && _this2.animation.currentTime || null;
          }
          if (prop === "currentIteration") {
            if (!_this2.animation || _this2.animation.playState !== "running") {
              return null;
            }
            return target2.currentIteration || 0;
          }
          if (prop === "progress") {
            if (!_this2.animation || _this2.animation.playState !== "running") {
              return null;
            }
            return target2.progress || 0;
          }
          return target2[prop];
        },
        set: function set6() {
          return true;
        }
      }) : this.timing;
    }
    return _createClass(KeyframeEffect2, [{
      key: "applyInterpolations",
      value: function applyInterpolations() {
        this.interpolations(this.target, Number(this.timeFraction));
      }
    }, {
      key: "update",
      value: function update(localTime) {
        if (localTime === null) {
          return false;
        }
        this.timeFraction = calculateIterationProgress(this.timing.activeDuration, localTime, this.timing);
        return this.timeFraction !== null;
      }
    }, {
      key: "getKeyframes",
      value: function getKeyframes() {
        return this.normalizedKeyframes;
      }
    }, {
      key: "setKeyframes",
      value: function setKeyframes(keyframes) {
        this.normalizedKeyframes = normalizeKeyframes(keyframes);
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getComputedTiming
       */
    }, {
      key: "getComputedTiming",
      value: function getComputedTiming() {
        return this.computedTiming;
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getTiming
       */
    }, {
      key: "getTiming",
      value: function getTiming() {
        return this.timing;
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/updateTiming
       */
    }, {
      key: "updateTiming",
      value: function updateTiming(timing) {
        var _this2 = this;
        Object.keys(timing || {}).forEach(function(name) {
          _this2.timing[name] = timing[name];
        });
      }
    }]);
  })();
  function compareAnimations(leftAnimation, rightAnimation) {
    return Number(leftAnimation.id) - Number(rightAnimation.id);
  }
  var AnimationTimeline = /* @__PURE__ */ (function() {
    function AnimationTimeline2(document2) {
      var _this2 = this;
      _classCallCheck(this, AnimationTimeline2);
      this.animations = [];
      this.ticking = false;
      this.timelineTicking = false;
      this.hasRestartedThisFrame = false;
      this.animationsWithPromises = [];
      this.inTick = false;
      this.pendingEffects = [];
      this.currentTime = null;
      this.rafId = 0;
      this.rafCallbacks = [];
      this.webAnimationsNextTick = function(t) {
        _this2.currentTime = t;
        _this2.discardAnimations();
        if (_this2.animations.length === 0) {
          _this2.timelineTicking = false;
        } else {
          _this2.requestAnimationFrame(_this2.webAnimationsNextTick);
        }
      };
      this.processRafCallbacks = function(t) {
        var processing = _this2.rafCallbacks;
        _this2.rafCallbacks = [];
        if (t < Number(_this2.currentTime)) t = Number(_this2.currentTime);
        _this2.animations.sort(compareAnimations);
        _this2.animations = _this2.tick(t, true, _this2.animations)[0];
        processing.forEach(function(entry) {
          entry[1](t);
        });
        _this2.applyPendingEffects();
      };
      this.document = document2;
    }
    return _createClass(AnimationTimeline2, [{
      key: "getAnimations",
      value: function getAnimations() {
        this.discardAnimations();
        return this.animations.slice();
      }
    }, {
      key: "isTicking",
      value: function isTicking() {
        return this.inTick;
      }
    }, {
      key: "play",
      value: function play(target, keyframes, options) {
        var effect2 = new KeyframeEffect(target, keyframes, options);
        var animation = new Animation(effect2, this);
        this.animations.push(animation);
        this.restartWebAnimationsNextTick();
        animation.updatePromises();
        animation.play();
        animation.updatePromises();
        return animation;
      }
      // RAF is supposed to be the last script to occur before frame rendering but not
      // all browsers behave like this. This function is for synchonously updating an
      // animation's effects whenever its state is mutated by script to work around
      // incorrect script execution ordering by the browser.
    }, {
      key: "applyDirtiedAnimation",
      value: function applyDirtiedAnimation(animation) {
        var _this2 = this;
        if (this.inTick) {
          return;
        }
        animation.markTarget();
        var animations = animation.targetAnimations();
        animations.sort(compareAnimations);
        var inactiveAnimations = this.tick(Number(this.currentTime), false, animations.slice())[1];
        inactiveAnimations.forEach(function(animation2) {
          var index2 = _this2.animations.indexOf(animation2);
          if (index2 !== -1) {
            _this2.animations.splice(index2, 1);
          }
        });
        this.applyPendingEffects();
      }
    }, {
      key: "restart",
      value: function restart() {
        if (!this.ticking) {
          this.ticking = true;
          this.requestAnimationFrame(function() {
          });
          this.hasRestartedThisFrame = true;
        }
        return this.hasRestartedThisFrame;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.document.defaultView.cancelAnimationFrame(this.frameId);
      }
    }, {
      key: "applyPendingEffects",
      value: function applyPendingEffects() {
        this.pendingEffects.forEach(function(effect2) {
          effect2 === null || effect2 === void 0 || effect2.applyInterpolations();
        });
        this.pendingEffects = [];
      }
    }, {
      key: "updateAnimationsPromises",
      value: function updateAnimationsPromises() {
        this.animationsWithPromises = this.animationsWithPromises.filter(function(animation) {
          return animation.updatePromises();
        });
      }
    }, {
      key: "discardAnimations",
      value: function discardAnimations() {
        this.updateAnimationsPromises();
        this.animations = this.animations.filter(function(animation) {
          return animation.playState !== "finished" && animation.playState !== "idle";
        });
      }
    }, {
      key: "restartWebAnimationsNextTick",
      value: function restartWebAnimationsNextTick() {
        if (!this.timelineTicking) {
          this.timelineTicking = true;
          this.requestAnimationFrame(this.webAnimationsNextTick);
        }
      }
    }, {
      key: "rAF",
      value: function rAF(f) {
        var id3 = this.rafId++;
        if (this.rafCallbacks.length === 0) {
          this.frameId = this.document.defaultView.requestAnimationFrame(this.processRafCallbacks);
        }
        this.rafCallbacks.push([id3, f]);
        return id3;
      }
    }, {
      key: "requestAnimationFrame",
      value: function requestAnimationFrame2(f) {
        var _this3 = this;
        return this.rAF(function(x3) {
          _this3.updateAnimationsPromises();
          f(x3);
          _this3.updateAnimationsPromises();
        });
      }
    }, {
      key: "tick",
      value: function tick2(t, isAnimationFrame, updatingAnimations) {
        var _this4 = this, _this$pendingEffects, _this$pendingEffects2;
        this.inTick = true;
        this.hasRestartedThisFrame = false;
        this.currentTime = t;
        this.ticking = false;
        var newPendingClears = [];
        var newPendingEffects = [];
        var activeAnimations = [];
        var inactiveAnimations = [];
        updatingAnimations.forEach(function(animation) {
          animation.tick(t, isAnimationFrame);
          if (!animation._inEffect) {
            newPendingClears.push(animation.effect);
            animation.unmarkTarget();
          } else {
            newPendingEffects.push(animation.effect);
            animation.markTarget();
          }
          if (animation._needsTick) _this4.ticking = true;
          var alive = animation._inEffect || animation._needsTick;
          animation._inTimeline = alive;
          if (alive) {
            activeAnimations.push(animation);
          } else {
            inactiveAnimations.push(animation);
          }
        });
        (_this$pendingEffects = this.pendingEffects).push.apply(_this$pendingEffects, newPendingClears);
        (_this$pendingEffects2 = this.pendingEffects).push.apply(_this$pendingEffects2, newPendingEffects);
        if (this.ticking) this.requestAnimationFrame(function() {
        });
        this.inTick = false;
        return [activeAnimations, inactiveAnimations];
      }
    }]);
  })();
  runtime.EasingFunction = parseEasingFunction;
  runtime.AnimationTimeline = AnimationTimeline;

  // node_modules/@antv/g6/esm/animations/executor.js
  var import_util7 = __toESM(require_lib());

  // node_modules/@antv/g6/esm/utils/animation.js
  var import_util5 = __toESM(require_lib());

  // node_modules/@antv/g6/esm/constants/animation.js
  var DEFAULT_ANIMATION_OPTIONS = {
    duration: 500
  };
  var DEFAULT_ELEMENTS_ANIMATION_OPTIONS = {
    duration: 1e3,
    easing: "cubic-bezier(0.250, 0.460, 0.450, 0.940)",
    iterations: 1,
    fill: "both"
  };

  // node_modules/@antv/g6/esm/constants/change.js
  var ChangeType;
  (function(ChangeType2) {
    ChangeType2["NodeAdded"] = "NodeAdded";
    ChangeType2["NodeUpdated"] = "NodeUpdated";
    ChangeType2["NodeRemoved"] = "NodeRemoved";
    ChangeType2["EdgeAdded"] = "EdgeAdded";
    ChangeType2["EdgeUpdated"] = "EdgeUpdated";
    ChangeType2["EdgeRemoved"] = "EdgeRemoved";
    ChangeType2["ComboAdded"] = "ComboAdded";
    ChangeType2["ComboUpdated"] = "ComboUpdated";
    ChangeType2["ComboRemoved"] = "ComboRemoved";
  })(ChangeType || (ChangeType = {}));

  // node_modules/@antv/g6/esm/constants/events/animation.js
  var AnimationType;
  (function(AnimationType2) {
    AnimationType2["DRAW"] = "draw";
    AnimationType2["COLLAPSE"] = "collapse";
    AnimationType2["EXPAND"] = "expand";
    AnimationType2["TRANSFORM"] = "transform";
  })(AnimationType || (AnimationType = {}));

  // node_modules/@antv/g6/esm/constants/events/canvas.js
  var CanvasEvent2;
  (function(CanvasEvent3) {
    CanvasEvent3["CLICK"] = "canvas:click";
    CanvasEvent3["DBLCLICK"] = "canvas:dblclick";
    CanvasEvent3["POINTER_OVER"] = "canvas:pointerover";
    CanvasEvent3["POINTER_LEAVE"] = "canvas:pointerleave";
    CanvasEvent3["POINTER_ENTER"] = "canvas:pointerenter";
    CanvasEvent3["POINTER_MOVE"] = "canvas:pointermove";
    CanvasEvent3["POINTER_OUT"] = "canvas:pointerout";
    CanvasEvent3["POINTER_DOWN"] = "canvas:pointerdown";
    CanvasEvent3["POINTER_UP"] = "canvas:pointerup";
    CanvasEvent3["CONTEXT_MENU"] = "canvas:contextmenu";
    CanvasEvent3["DRAG_START"] = "canvas:dragstart";
    CanvasEvent3["DRAG"] = "canvas:drag";
    CanvasEvent3["DRAG_END"] = "canvas:dragend";
    CanvasEvent3["DRAG_ENTER"] = "canvas:dragenter";
    CanvasEvent3["DRAG_OVER"] = "canvas:dragover";
    CanvasEvent3["DRAG_LEAVE"] = "canvas:dragleave";
    CanvasEvent3["DROP"] = "canvas:drop";
    CanvasEvent3["WHEEL"] = "canvas:wheel";
  })(CanvasEvent2 || (CanvasEvent2 = {}));

  // node_modules/@antv/g6/esm/constants/events/combo.js
  var ComboEvent;
  (function(ComboEvent2) {
    ComboEvent2["CLICK"] = "combo:click";
    ComboEvent2["DBLCLICK"] = "combo:dblclick";
    ComboEvent2["POINTER_OVER"] = "combo:pointerover";
    ComboEvent2["POINTER_LEAVE"] = "combo:pointerleave";
    ComboEvent2["POINTER_ENTER"] = "combo:pointerenter";
    ComboEvent2["POINTER_MOVE"] = "combo:pointermove";
    ComboEvent2["POINTER_OUT"] = "combo:pointerout";
    ComboEvent2["POINTER_DOWN"] = "combo:pointerdown";
    ComboEvent2["POINTER_UP"] = "combo:pointerup";
    ComboEvent2["CONTEXT_MENU"] = "combo:contextmenu";
    ComboEvent2["DRAG_START"] = "combo:dragstart";
    ComboEvent2["DRAG"] = "combo:drag";
    ComboEvent2["DRAG_END"] = "combo:dragend";
    ComboEvent2["DRAG_ENTER"] = "combo:dragenter";
    ComboEvent2["DRAG_OVER"] = "combo:dragover";
    ComboEvent2["DRAG_LEAVE"] = "combo:dragleave";
    ComboEvent2["DROP"] = "combo:drop";
  })(ComboEvent || (ComboEvent = {}));

  // node_modules/@antv/g6/esm/constants/events/common.js
  var CommonEvent;
  (function(CommonEvent2) {
    CommonEvent2["CLICK"] = "click";
    CommonEvent2["DBLCLICK"] = "dblclick";
    CommonEvent2["POINTER_OVER"] = "pointerover";
    CommonEvent2["POINTER_LEAVE"] = "pointerleave";
    CommonEvent2["POINTER_ENTER"] = "pointerenter";
    CommonEvent2["POINTER_MOVE"] = "pointermove";
    CommonEvent2["POINTER_OUT"] = "pointerout";
    CommonEvent2["POINTER_DOWN"] = "pointerdown";
    CommonEvent2["POINTER_UP"] = "pointerup";
    CommonEvent2["CONTEXT_MENU"] = "contextmenu";
    CommonEvent2["DRAG_START"] = "dragstart";
    CommonEvent2["DRAG"] = "drag";
    CommonEvent2["DRAG_END"] = "dragend";
    CommonEvent2["DRAG_ENTER"] = "dragenter";
    CommonEvent2["DRAG_OVER"] = "dragover";
    CommonEvent2["DRAG_LEAVE"] = "dragleave";
    CommonEvent2["DROP"] = "drop";
    CommonEvent2["KEY_DOWN"] = "keydown";
    CommonEvent2["KEY_UP"] = "keyup";
    CommonEvent2["WHEEL"] = "wheel";
    CommonEvent2["PINCH"] = "pinch";
  })(CommonEvent || (CommonEvent = {}));

  // node_modules/@antv/g6/esm/constants/events/container.js
  var ContainerEvent;
  (function(ContainerEvent2) {
    ContainerEvent2["KEY_DOWN"] = "keydown";
    ContainerEvent2["KEY_UP"] = "keyup";
  })(ContainerEvent || (ContainerEvent = {}));

  // node_modules/@antv/g6/esm/constants/events/edge.js
  var EdgeEvent;
  (function(EdgeEvent2) {
    EdgeEvent2["CLICK"] = "edge:click";
    EdgeEvent2["DBLCLICK"] = "edge:dblclick";
    EdgeEvent2["POINTER_OVER"] = "edge:pointerover";
    EdgeEvent2["POINTER_LEAVE"] = "edge:pointerleave";
    EdgeEvent2["POINTER_ENTER"] = "edge:pointerenter";
    EdgeEvent2["POINTER_MOVE"] = "edge:pointermove";
    EdgeEvent2["POINTER_OUT"] = "edge:pointerout";
    EdgeEvent2["POINTER_DOWN"] = "edge:pointerdown";
    EdgeEvent2["POINTER_UP"] = "edge:pointerup";
    EdgeEvent2["CONTEXT_MENU"] = "edge:contextmenu";
    EdgeEvent2["DRAG_ENTER"] = "edge:dragenter";
    EdgeEvent2["DRAG_OVER"] = "edge:dragover";
    EdgeEvent2["DRAG_LEAVE"] = "edge:dragleave";
    EdgeEvent2["DROP"] = "edge:drop";
  })(EdgeEvent || (EdgeEvent = {}));

  // node_modules/@antv/g6/esm/constants/events/graph.js
  var GraphEvent;
  (function(GraphEvent2) {
    GraphEvent2["BEFORE_CANVAS_INIT"] = "beforecanvasinit";
    GraphEvent2["AFTER_CANVAS_INIT"] = "aftercanvasinit";
    GraphEvent2["BEFORE_SIZE_CHANGE"] = "beforesizechange";
    GraphEvent2["AFTER_SIZE_CHANGE"] = "aftersizechange";
    GraphEvent2["BEFORE_ELEMENT_CREATE"] = "beforeelementcreate";
    GraphEvent2["AFTER_ELEMENT_CREATE"] = "afterelementcreate";
    GraphEvent2["BEFORE_ELEMENT_UPDATE"] = "beforeelementupdate";
    GraphEvent2["AFTER_ELEMENT_UPDATE"] = "afterelementupdate";
    GraphEvent2["BEFORE_ELEMENT_DESTROY"] = "beforeelementdestroy";
    GraphEvent2["AFTER_ELEMENT_DESTROY"] = "afterelementdestroy";
    GraphEvent2["BEFORE_ELEMENT_TRANSLATE"] = "beforeelementtranslate";
    GraphEvent2["AFTER_ELEMENT_TRANSLATE"] = "afterelementtranslate";
    GraphEvent2["BEFORE_DRAW"] = "beforedraw";
    GraphEvent2["AFTER_DRAW"] = "afterdraw";
    GraphEvent2["BEFORE_RENDER"] = "beforerender";
    GraphEvent2["AFTER_RENDER"] = "afterrender";
    GraphEvent2["BEFORE_ANIMATE"] = "beforeanimate";
    GraphEvent2["AFTER_ANIMATE"] = "afteranimate";
    GraphEvent2["BEFORE_LAYOUT"] = "beforelayout";
    GraphEvent2["AFTER_LAYOUT"] = "afterlayout";
    GraphEvent2["BEFORE_STAGE_LAYOUT"] = "beforestagelayout";
    GraphEvent2["AFTER_STAGE_LAYOUT"] = "afterstagelayout";
    GraphEvent2["BEFORE_TRANSFORM"] = "beforetransform";
    GraphEvent2["AFTER_TRANSFORM"] = "aftertransform";
    GraphEvent2["BATCH_START"] = "batchstart";
    GraphEvent2["BATCH_END"] = "batchend";
    GraphEvent2["BEFORE_DESTROY"] = "beforedestroy";
    GraphEvent2["AFTER_DESTROY"] = "afterdestroy";
    GraphEvent2["BEFORE_RENDERER_CHANGE"] = "beforerendererchange";
    GraphEvent2["AFTER_RENDERER_CHANGE"] = "afterrendererchange";
  })(GraphEvent || (GraphEvent = {}));

  // node_modules/@antv/g6/esm/constants/events/history.js
  var HistoryEvent;
  (function(HistoryEvent2) {
    HistoryEvent2["UNDO"] = "undo";
    HistoryEvent2["REDO"] = "redo";
    HistoryEvent2["CANCEL"] = "cancel";
    HistoryEvent2["ADD"] = "add";
    HistoryEvent2["CLEAR"] = "clear";
    HistoryEvent2["CHANGE"] = "change";
  })(HistoryEvent || (HistoryEvent = {}));

  // node_modules/@antv/g6/esm/constants/events/node.js
  var NodeEvent;
  (function(NodeEvent2) {
    NodeEvent2["CLICK"] = "node:click";
    NodeEvent2["DBLCLICK"] = "node:dblclick";
    NodeEvent2["POINTER_OVER"] = "node:pointerover";
    NodeEvent2["POINTER_LEAVE"] = "node:pointerleave";
    NodeEvent2["POINTER_ENTER"] = "node:pointerenter";
    NodeEvent2["POINTER_MOVE"] = "node:pointermove";
    NodeEvent2["POINTER_OUT"] = "node:pointerout";
    NodeEvent2["POINTER_DOWN"] = "node:pointerdown";
    NodeEvent2["POINTER_UP"] = "node:pointerup";
    NodeEvent2["CONTEXT_MENU"] = "node:contextmenu";
    NodeEvent2["DRAG_START"] = "node:dragstart";
    NodeEvent2["DRAG"] = "node:drag";
    NodeEvent2["DRAG_END"] = "node:dragend";
    NodeEvent2["DRAG_ENTER"] = "node:dragenter";
    NodeEvent2["DRAG_OVER"] = "node:dragover";
    NodeEvent2["DRAG_LEAVE"] = "node:dragleave";
    NodeEvent2["DROP"] = "node:drop";
  })(NodeEvent || (NodeEvent = {}));

  // node_modules/@antv/g6/esm/constants/graphlib.js
  var COMBO_KEY = "combo";
  var TREE_KEY = "tree";

  // node_modules/@antv/g6/esm/constants/registry.js
  var ExtensionCategory;
  (function(ExtensionCategory2) {
    ExtensionCategory2["NODE"] = "node";
    ExtensionCategory2["EDGE"] = "edge";
    ExtensionCategory2["COMBO"] = "combo";
    ExtensionCategory2["THEME"] = "theme";
    ExtensionCategory2["PALETTE"] = "palette";
    ExtensionCategory2["LAYOUT"] = "layout";
    ExtensionCategory2["BEHAVIOR"] = "behavior";
    ExtensionCategory2["PLUGIN"] = "plugin";
    ExtensionCategory2["ANIMATION"] = "animation";
    ExtensionCategory2["TRANSFORM"] = "transform";
    ExtensionCategory2["SHAPE"] = "shape";
  })(ExtensionCategory || (ExtensionCategory = {}));

  // node_modules/@antv/g6/esm/registry/store.js
  var EXTENSION_REGISTRY = {
    animation: {},
    behavior: {},
    combo: {},
    edge: {},
    layout: {},
    node: {},
    palette: {},
    theme: {},
    plugin: {},
    transform: {},
    shape: {}
  };

  // node_modules/@antv/g6/esm/registry/get.js
  function getExtension(category, type) {
    var _a2;
    const extension = (_a2 = EXTENSION_REGISTRY[category]) === null || _a2 === void 0 ? void 0 : _a2[type];
    if (extension) {
      return extension;
    }
    return void 0;
  }

  // node_modules/@antv/g6/esm/version.js
  var version = "5.0.50";

  // node_modules/@antv/g6/esm/utils/print.js
  var BRAND = "G6";
  function format(message) {
    return `[${BRAND} v${version}] ${message}`;
  }
  var print = {
    mute: false,
    debug: (message) => {
      !print.mute && console.debug(format(message));
    },
    info: (message) => {
      !print.mute && console.info(format(message));
    },
    warn: (message) => {
      !print.mute && console.warn(format(message));
    },
    error: (message) => {
      !print.mute && console.error(format(message));
    }
  };

  // node_modules/@antv/g6/esm/utils/theme.js
  function themeOf(options) {
    const { theme } = options;
    if (!theme)
      return {};
    const themeOptions = getExtension(ExtensionCategory.THEME, theme);
    if (themeOptions)
      return themeOptions;
    print.warn(`The theme of ${theme} is not registered.`);
    return {};
  }

  // node_modules/@antv/g6/esm/utils/animation.js
  function createAnimationsProxy(args1, args2) {
    if (Array.isArray(args1) && args1.length === 0)
      return null;
    const sourceAnimation = Array.isArray(args1) ? args1[0] : args1;
    const targetAnimations = Array.isArray(args1) ? args1.slice(1) : args2 || [];
    return new Proxy(sourceAnimation, {
      get(target, propKey) {
        if (typeof target[propKey] === "function" && !["onframe", "onfinish"].includes(propKey)) {
          return (...args) => {
            target[propKey](...args);
            targetAnimations.forEach((animation) => {
              var _a2;
              return (_a2 = animation[propKey]) === null || _a2 === void 0 ? void 0 : _a2.call(animation, ...args);
            });
          };
        }
        if (propKey === "finished") {
          return Promise.all([sourceAnimation.finished, ...targetAnimations.map((animation) => animation.finished)]);
        }
        return Reflect.get(target, propKey);
      },
      set(target, propKey, value) {
        if (!["onframe", "onfinish"].includes(propKey)) {
          targetAnimations.forEach((animation) => {
            animation[propKey] = value;
          });
        }
        return Reflect.set(target, propKey, value);
      }
    });
  }
  function preprocessKeyframes(keyframes) {
    const propertyIndexedKeyframes = keyframes.reduce((acc, kf) => {
      Object.entries(kf).forEach(([key, value]) => {
        if (acc[key] === void 0)
          acc[key] = [value];
        else
          acc[key].push(value);
      });
      return acc;
    }, {});
    Object.entries(propertyIndexedKeyframes).forEach(([key, values2]) => {
      if (
        // 属性值必须在每一帧都存在 / property value must exist in every frame
        values2.length !== keyframes.length || // 属性值不能为空 / property value cannot be empty
        values2.some((value) => (0, import_util5.isNil)(value)) || // 属性值必须不完全一致 / property value must not be exactly the same
        // 属性值可以是保留属性 / property value can be the reserved property
        values2.every((value) => !["sourceNode", "targetNode", "childrenNode"].includes(key) && (0, import_util5.isEqual)(value, values2[0]))
      ) {
        delete propertyIndexedKeyframes[key];
      }
    });
    const output = Object.entries(propertyIndexedKeyframes).reduce((acc, [key, values2]) => {
      values2.forEach((value, index2) => {
        if (!acc[index2])
          acc[index2] = { [key]: value };
        else
          acc[index2][key] = value;
      });
      return acc;
    }, []);
    if (keyframes.length !== 0 && output.length === 0)
      output.push(...[{ _: 0 }, { _: 0 }]);
    return output;
  }
  function inferDefaultValue(name) {
    switch (name) {
      case "opacity":
        return 1;
      case "x":
      case "y":
      case "z":
      case "zIndex":
        return 0;
      case "visibility":
        return "visible";
      case "collapsed":
        return false;
      case "states":
        return [];
      default:
        return void 0;
    }
  }
  function getAnimationOptions(options, localAnimation) {
    const { animation } = options;
    if (animation === false || localAnimation === false)
      return false;
    const effectTiming = Object.assign({}, DEFAULT_ANIMATION_OPTIONS);
    if ((0, import_util5.isObject)(animation))
      Object.assign(effectTiming, animation);
    if ((0, import_util5.isObject)(localAnimation))
      Object.assign(effectTiming, localAnimation);
    return effectTiming;
  }
  function animationOf(options) {
    if (typeof options === "string") {
      const animation = getExtension(ExtensionCategory.ANIMATION, options);
      if (animation)
        return animation;
      print.warn(`The animation of ${options} is not registered.`);
      return [];
    }
    return options;
  }
  function getElementAnimationOptions(options, elementType, stage, localAnimation) {
    var _a2, _b;
    const { animation: globalAnimation } = options;
    if (globalAnimation === false || localAnimation === false)
      return [];
    const userElementAnimation = (_a2 = options === null || options === void 0 ? void 0 : options[elementType]) === null || _a2 === void 0 ? void 0 : _a2.animation;
    if (userElementAnimation === false)
      return [];
    const useElementStageAnimation = userElementAnimation === null || userElementAnimation === void 0 ? void 0 : userElementAnimation[stage];
    if (useElementStageAnimation === false)
      return [];
    const themeElementAnimation = (_b = themeOf(options)[elementType]) === null || _b === void 0 ? void 0 : _b.animation;
    const combine2 = (_2 = []) => animationOf(_2).map((animation) => Object.assign(Object.assign(Object.assign(Object.assign({}, DEFAULT_ELEMENTS_ANIMATION_OPTIONS), (0, import_util5.isObject)(globalAnimation) && globalAnimation), animation), (0, import_util5.isObject)(localAnimation) && localAnimation));
    if (useElementStageAnimation)
      return combine2(useElementStageAnimation);
    if (!themeElementAnimation)
      return [];
    const themeElementStageAnimation = themeElementAnimation[stage];
    if (themeElementStageAnimation === false)
      return [];
    return combine2(themeElementStageAnimation);
  }

  // node_modules/@antv/g6/esm/utils/transform.js
  var import_util6 = __toESM(require_lib());
  function replaceTranslateInTransform(x3, y3, z, transform = []) {
    if (!transform && x3 === 0 && y3 === 0 && z === 0)
      return null;
    if (Array.isArray(transform)) {
      let translateIndex = -1;
      const newTransform = [];
      for (let i = 0; i < transform.length; i++) {
        const t = transform[i];
        if (t[0] === "translate") {
          if (t[1] === x3 && t[2] === y3)
            return null;
          translateIndex = i;
          newTransform.push(["translate", x3, y3]);
        } else if (t[0] === "translate3d") {
          if (t[1] === x3 && t[2] === y3 && t[3] === z)
            return null;
          translateIndex = i;
          newTransform.push(["translate3d", x3, y3, z !== null && z !== void 0 ? z : 0]);
        } else {
          newTransform.push(t);
        }
      }
      if (translateIndex === -1) {
        newTransform.splice(0, 0, (0, import_util6.isNumber)(z) ? ["translate3d", x3, y3, z !== null && z !== void 0 ? z : 0] : ["translate", x3, y3]);
      }
      if (newTransform.length === 0)
        return null;
      return newTransform;
    }
    const removedTranslate = transform ? transform.replace(/translate(3d)?\([^)]*\)/g, "") : "";
    if (z === 0) {
      return `translate(${x3}, ${y3})${removedTranslate}`;
    } else {
      return `translate3d(${x3}, ${y3}, ${z})${removedTranslate}`;
    }
  }

  // node_modules/@antv/g6/esm/animations/executor.js
  var __rest2 = function(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  var executor = (element, keyframes, options) => {
    if (!options.length)
      return null;
    const [originalStyle, modifiedStyle] = keyframes;
    const getKeyframeStyle = (shapeID) => {
      var _a2;
      if (shapeID) {
        const shape = element.getShape(shapeID);
        if (!shape)
          return null;
        const name = `get${(0, import_util7.upperFirst)(shapeID)}Style`;
        const styler = ((_a2 = element === null || element === void 0 ? void 0 : element[name]) === null || _a2 === void 0 ? void 0 : _a2.bind(element)) || ((attrs) => attrs);
        const fromStyle = (styler === null || styler === void 0 ? void 0 : styler(originalStyle)) || {};
        const toStyle = (styler === null || styler === void 0 ? void 0 : styler(modifiedStyle)) || {};
        return { shape, fromStyle, toStyle };
      } else {
        const shape = element;
        return { shape, fromStyle: originalStyle, toStyle: modifiedStyle };
      }
    };
    let mainResult;
    const subResults = options.map((_a2) => {
      var { fields, shape: shapeID, states: enabledStates } = _a2, effectTiming = __rest2(_a2, ["fields", "shape", "states"]);
      const keyframeStyle = getKeyframeStyle(shapeID);
      if (!keyframeStyle)
        return null;
      const { shape, fromStyle, toStyle } = keyframeStyle;
      const keyframes2 = [{}, {}];
      fields.forEach((attr2) => {
        var _a3, _b;
        Object.assign(keyframes2[0], { [attr2]: (_a3 = fromStyle[attr2]) !== null && _a3 !== void 0 ? _a3 : inferDefaultValue(attr2) });
        Object.assign(keyframes2[1], { [attr2]: (_b = toStyle[attr2]) !== null && _b !== void 0 ? _b : inferDefaultValue(attr2) });
      });
      if (keyframes2.some((keyframe) => Object.keys(keyframe).some((attr2) => ["x", "y", "z"].includes(attr2)))) {
        const { x: x3 = 0, y: y3 = 0, z, transform = "" } = shape.attributes || {};
        keyframes2.forEach((keyframe) => {
          var _a3, _b, _c;
          keyframe.transform = replaceTranslateInTransform((_a3 = keyframe.x) !== null && _a3 !== void 0 ? _a3 : x3, (_b = keyframe.y) !== null && _b !== void 0 ? _b : y3, (_c = keyframe.z) !== null && _c !== void 0 ? _c : z, transform);
        });
      }
      const result2 = shape.animate(preprocessKeyframes(keyframes2), effectTiming);
      if (shapeID === void 0)
        mainResult = result2;
      return result2;
    }).filter(Boolean);
    const result = mainResult || (subResults === null || subResults === void 0 ? void 0 : subResults[0]);
    if (!result)
      return null;
    return createAnimationsProxy(result, subResults.filter((result2) => result2 !== result2));
  };

  // node_modules/@antv/g6/esm/animations/index.js
  var Fade = [{ fields: ["opacity"] }];
  var Translate = [{ fields: ["x", "y"] }];
  var NodeCollapse = [{ fields: ["x", "y"] }];
  var NodeExpand = NodeCollapse;
  var PathIn = [{ fields: ["sourceNode", "targetNode"] }];
  var PathOut = PathIn;
  var ComboCollapse = [{ fields: ["childrenNode", "x", "y"] }];
  var ComboExpand = ComboCollapse;

  // node_modules/@antv/g6/esm/behaviors/auto-adapt-label.js
  var import_util29 = __toESM(require_lib());

  // node_modules/@antv/g6/esm/utils/bbox.js
  var import_util8 = __toESM(require_lib());

  // node_modules/@antv/g6/esm/utils/is.js
  function isEdgeData(data2) {
    if ("source" in data2 && "target" in data2)
      return true;
    return false;
  }
  function isVector2(vector) {
    return vector.length === 2;
  }
  function isPoint(p) {
    if (p instanceof Float32Array)
      return true;
    if (Array.isArray(p) && (p.length === 2 || p.length === 3)) {
      return p.every((elem) => typeof elem === "number");
    }
    return false;
  }

  // node_modules/@antv/g6/esm/utils/math.js
  function isBetween(value, min4, max4) {
    return value >= min4 && value <= max4;
  }

  // node_modules/@antv/g6/esm/utils/padding.js
  function parsePadding(padding = 0) {
    if (Array.isArray(padding)) {
      const [top = 0, right = top, bottom = top, left = right] = padding;
      return [top, right, bottom, left];
    }
    return [padding, padding, padding, padding];
  }
  function getVerticalPadding(padding = 0) {
    const parsedPadding = parsePadding(padding);
    return parsedPadding[0] + parsedPadding[2];
  }

  // node_modules/@antv/g6/esm/utils/bbox.js
  function getBBoxWidth(bbox) {
    return bbox.max[0] - bbox.min[0];
  }
  function getBBoxHeight(bbox) {
    return bbox.max[1] - bbox.min[1];
  }
  function getBBoxSize(bbox) {
    return [getBBoxWidth(bbox), getBBoxHeight(bbox)];
  }
  function getNodeBBox(node, padding) {
    const bbox = isPoint(node) ? getPointBBox(node) : node.getShape("key").getBounds();
    return padding ? getExpandedBBox(bbox, padding) : bbox;
  }
  function getPointBBox(point4) {
    const [x3, y3, z = 0] = point4;
    const bbox = new AABB();
    bbox.setMinMax([x3, y3, z], [x3, y3, z]);
    return bbox;
  }
  function getExpandedBBox(bbox, padding) {
    const [top, right, bottom, left] = parsePadding(padding);
    const [minX, minY, minZ] = bbox.min;
    const [maxX, maxY, maxZ] = bbox.max;
    const eBbox = new AABB();
    eBbox.setMinMax([minX - left, minY - top, minZ], [maxX + right, maxY + bottom, maxZ]);
    return eBbox;
  }
  function getCombinedBBox(bboxes) {
    if (bboxes.length === 0)
      return new AABB();
    if (bboxes.length === 1)
      return bboxes[0];
    const bbox = new AABB();
    bbox.setMinMax(bboxes[0].min, bboxes[0].max);
    for (let i = 1; i < bboxes.length; i++) {
      const b2 = bboxes[i];
      bbox.setMinMax([Math.min(bbox.min[0], b2.min[0]), Math.min(bbox.min[1], b2.min[1]), Math.min(bbox.min[2], b2.min[2])], [Math.max(bbox.max[0], b2.max[0]), Math.max(bbox.max[1], b2.max[1]), Math.max(bbox.max[2], b2.max[2])]);
    }
    return bbox;
  }
  function isBBoxInside(bbox1, bbox2) {
    const [minX1, minY1] = bbox1.min;
    const [maxX1, maxY1] = bbox1.max;
    const [minX2, minY2] = bbox2.min;
    const [maxX2, maxY2] = bbox2.max;
    return minX1 >= minX2 && maxX1 <= maxX2 && minY1 >= minY2 && maxY1 <= maxY2;
  }
  function isPointInBBox(point4, bbox) {
    return isBetween(point4[0], bbox.min[0], bbox.max[0]) && isBetween(point4[1], bbox.min[1], bbox.max[1]);
  }
  function isPointOnBBoxBoundary(point4, bbox, extended = false) {
    const { min: [minX, minY], max: [maxX, maxY] } = bbox;
    const onTopOrBottomLine = (point4[1] === minY || point4[1] === maxY) && (extended || isBetween(point4[0], minX, maxX));
    const onLeftOrRightLine = (point4[0] === minX || point4[0] === maxX) && (extended || isBetween(point4[1], minY, maxY));
    return onTopOrBottomLine || onLeftOrRightLine;
  }
  function isPointOutsideBBox(point4, bbox) {
    return !isPointInBBox(point4, bbox);
  }
  function isPointBBoxCenter(point4, bbox) {
    const { center } = bbox;
    return point4[0] === center[0] && point4[1] === center[1];
  }
  function getNearestBoundarySide(p, bbox) {
    const [x3, y3] = p;
    const [minX, minY] = bbox.min;
    const [maxX, maxY] = bbox.max;
    const left = x3 - minX;
    const right = maxX - x3;
    const top = y3 - minY;
    const bottom = maxY - y3;
    const min4 = Math.min(left, right, top, bottom);
    return min4 === left ? "left" : min4 === right ? "right" : min4 === top ? "top" : min4 === bottom ? "bottom" : "left";
  }
  function getNearestBoundaryPoint(p, bbox) {
    const ref = (0, import_util8.clone)(p);
    if (isPointInBBox(p, bbox)) {
      const side = getNearestBoundarySide(p, bbox);
      switch (side) {
        case "left":
          ref[0] = bbox.min[0];
          break;
        case "right":
          ref[0] = bbox.max[0];
          break;
        case "top":
          ref[1] = bbox.min[1];
          break;
        case "bottom":
          ref[1] = bbox.max[1];
          break;
      }
    } else {
      const [x3, y3] = p;
      const [minX, minY] = bbox.min;
      const [maxX, maxY] = bbox.max;
      ref[0] = isBetween(x3, minX, maxX) ? x3 : x3 < minX ? minX : maxX;
      ref[1] = isBetween(y3, minY, maxY) ? y3 : y3 < minY ? minY : maxY;
    }
    return ref;
  }
  function getTriangleCenter(bbox, direction2) {
    const { center } = bbox;
    const [width2, height] = getBBoxSize(bbox);
    const x3 = direction2 === "up" || direction2 === "down" ? center[0] : direction2 === "right" ? center[0] - width2 / 6 : center[0] + width2 / 6;
    const y3 = direction2 === "left" || direction2 === "right" ? center[1] : direction2 === "down" ? center[1] - height / 6 : center[1] + height / 6;
    return [x3, y3];
  }
  function getIncircleRadius(bbox, direction2) {
    let [w, h] = getBBoxSize(bbox);
    [w, h] = direction2 === "up" || direction2 === "down" ? [w, h] : [h, w];
    return (Math.pow(h, 2) - Math.pow(Math.sqrt(Math.pow(w / 2, 2) + Math.pow(h, 2)) - w / 2, 2)) / (2 * h);
  }
  function getBBoxSegments(bbox) {
    const { min: [minX, minY], max: [maxX, maxY] } = bbox;
    const topLeftCorner = [minX, maxY];
    const topRightCorner = [maxX, maxY];
    const bottomRightCorner = [maxX, minY];
    const bottomLeftCorner = [minX, minY];
    const top = [topLeftCorner, topRightCorner];
    const right = [topRightCorner, bottomRightCorner];
    const bottom = [bottomRightCorner, bottomLeftCorner];
    const left = [bottomLeftCorner, topLeftCorner];
    return [top, right, bottom, left];
  }

  // node_modules/@antv/algorithm/es/structs/linked-list.js
  var defaultComparator = function defaultComparator2(a2, b) {
    if (a2 === b) {
      return true;
    }
    return false;
  };
  var LinkedListNode = (
    /** @class */
    (function() {
      function LinkedListNode2(value, next) {
        if (next === void 0) {
          next = null;
        }
        this.value = value;
        this.next = next;
      }
      LinkedListNode2.prototype.toString = function(callback) {
        return callback ? callback(this.value) : "".concat(this.value);
      };
      return LinkedListNode2;
    })()
  );
  var LinkedList = (
    /** @class */
    (function() {
      function LinkedList2(comparator) {
        if (comparator === void 0) {
          comparator = defaultComparator;
        }
        this.head = null;
        this.tail = null;
        this.compare = comparator;
      }
      LinkedList2.prototype.prepend = function(value) {
        var newNode = new LinkedListNode(value, this.head);
        this.head = newNode;
        if (!this.tail) {
          this.tail = newNode;
        }
        return this;
      };
      LinkedList2.prototype.append = function(value) {
        var newNode = new LinkedListNode(value);
        if (!this.head) {
          this.head = newNode;
          this.tail = newNode;
          return this;
        }
        this.tail.next = newNode;
        this.tail = newNode;
        return this;
      };
      LinkedList2.prototype.delete = function(value) {
        if (!this.head) {
          return null;
        }
        var deleteNode = null;
        while (this.head && this.compare(this.head.value, value)) {
          deleteNode = this.head;
          this.head = this.head.next;
        }
        var currentNode = this.head;
        if (currentNode !== null) {
          while (currentNode.next) {
            if (this.compare(currentNode.next.value, value)) {
              deleteNode = currentNode.next;
              currentNode.next = currentNode.next.next;
            } else {
              currentNode = currentNode.next;
            }
          }
        }
        if (this.compare(this.tail.value, value)) {
          this.tail = currentNode;
        }
        return deleteNode;
      };
      LinkedList2.prototype.find = function(_a2) {
        var _b = _a2.value, value = _b === void 0 ? void 0 : _b, _c = _a2.callback, callback = _c === void 0 ? void 0 : _c;
        if (!this.head) {
          return null;
        }
        var currentNode = this.head;
        while (currentNode) {
          if (callback && callback(currentNode.value)) {
            return currentNode;
          }
          if (value !== void 0 && this.compare(currentNode.value, value)) {
            return currentNode;
          }
          currentNode = currentNode.next;
        }
        return null;
      };
      LinkedList2.prototype.deleteTail = function() {
        var deletedTail = this.tail;
        if (this.head === this.tail) {
          this.head = null;
          this.tail = null;
          return deletedTail;
        }
        var currentNode = this.head;
        while (currentNode.next) {
          if (!currentNode.next.next) {
            currentNode.next = null;
          } else {
            currentNode = currentNode.next;
          }
        }
        this.tail = currentNode;
        return deletedTail;
      };
      LinkedList2.prototype.deleteHead = function() {
        if (!this.head) {
          return null;
        }
        var deletedHead = this.head;
        if (this.head.next) {
          this.head = this.head.next;
        } else {
          this.head = null;
          this.tail = null;
        }
        return deletedHead;
      };
      LinkedList2.prototype.fromArray = function(values2) {
        var _this2 = this;
        values2.forEach(function(value) {
          return _this2.append(value);
        });
        return this;
      };
      LinkedList2.prototype.toArray = function() {
        var nodes = [];
        var currentNode = this.head;
        while (currentNode) {
          nodes.push(currentNode);
          currentNode = currentNode.next;
        }
        return nodes;
      };
      LinkedList2.prototype.reverse = function() {
        var currentNode = this.head;
        var prevNode = null;
        var nextNode = null;
        while (currentNode) {
          nextNode = currentNode.next;
          currentNode.next = prevNode;
          prevNode = currentNode;
          currentNode = nextNode;
        }
        this.tail = this.head;
        this.head = prevNode;
      };
      LinkedList2.prototype.toString = function(callback) {
        if (callback === void 0) {
          callback = void 0;
        }
        return this.toArray().map(function(node) {
          return node.toString(callback);
        }).toString();
      };
      return LinkedList2;
    })()
  );
  var linked_list_default = LinkedList;

  // node_modules/@antv/algorithm/es/structs/queue.js
  var Queue = (
    /** @class */
    (function() {
      function Queue2() {
        this.linkedList = new linked_list_default();
      }
      Queue2.prototype.isEmpty = function() {
        return !this.linkedList.head;
      };
      Queue2.prototype.peek = function() {
        if (!this.linkedList.head) {
          return null;
        }
        return this.linkedList.head.value;
      };
      Queue2.prototype.enqueue = function(value) {
        this.linkedList.append(value);
      };
      Queue2.prototype.dequeue = function() {
        var removeHead = this.linkedList.deleteHead();
        return removeHead ? removeHead.value : null;
      };
      Queue2.prototype.toString = function(callback) {
        return this.linkedList.toString(callback);
      };
      return Queue2;
    })()
  );

  // node_modules/@antv/algorithm/es/util.js
  var getNeighbors = function getNeighbors2(nodeId, edges, type) {
    if (edges === void 0) {
      edges = [];
    }
    var currentEdges = edges.filter(function(edge) {
      return edge.source === nodeId || edge.target === nodeId;
    });
    if (type === "target") {
      var neighhborsConverter_1 = function neighhborsConverter_12(edge) {
        return edge.source === nodeId;
      };
      return currentEdges.filter(neighhborsConverter_1).map(function(edge) {
        return edge.target;
      });
    }
    if (type === "source") {
      var neighhborsConverter_2 = function neighhborsConverter_22(edge) {
        return edge.target === nodeId;
      };
      return currentEdges.filter(neighhborsConverter_2).map(function(edge) {
        return edge.source;
      });
    }
    var neighhborsConverter = function neighhborsConverter2(edge) {
      return edge.source === nodeId ? edge.target : edge.source;
    };
    return currentEdges.map(neighhborsConverter);
  };
  var getOutEdgesNodeId = function getOutEdgesNodeId2(nodeId, edges) {
    return edges.filter(function(edge) {
      return edge.source === nodeId;
    });
  };
  var getEdgesByNodeId = function getEdgesByNodeId2(nodeId, edges) {
    return edges.filter(function(edge) {
      return edge.source === nodeId || edge.target === nodeId;
    });
  };

  // node_modules/@antv/algorithm/es/degree.js
  var degree = function degree2(graphData) {
    var degrees = {};
    var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
    nodes.forEach(function(node) {
      degrees[node.id] = {
        degree: 0,
        inDegree: 0,
        outDegree: 0
      };
    });
    edges.forEach(function(edge) {
      degrees[edge.source].degree++;
      degrees[edge.source].outDegree++;
      degrees[edge.target].degree++;
      degrees[edge.target].inDegree++;
    });
    return degrees;
  };
  var degree_default = degree;

  // node_modules/@antv/algorithm/es/dijkstra.js
  init_tslib_es6();

  // node_modules/@antv/algorithm/node_modules/@antv/util/esm/is-type.js
  var toString = {}.toString;
  var isType = function(value, type) {
    return toString.call(value) === "[object " + type + "]";
  };
  var is_type_default = isType;

  // node_modules/@antv/algorithm/node_modules/@antv/util/esm/is-function.js
  var is_function_default = (function(value) {
    return is_type_default(value, "Function");
  });

  // node_modules/@antv/algorithm/node_modules/@antv/util/esm/is-array.js
  var is_array_default = (function(value) {
    return Array.isArray ? Array.isArray(value) : is_type_default(value, "Array");
  });

  // node_modules/@antv/algorithm/node_modules/@antv/util/esm/is-object.js
  var is_object_default = (function(value) {
    var type = typeof value;
    return value !== null && type === "object" || type === "function";
  });

  // node_modules/@antv/algorithm/node_modules/@antv/util/esm/each.js
  function each(elements, func) {
    if (!elements) {
      return;
    }
    var rst;
    if (is_array_default(elements)) {
      for (var i = 0, len = elements.length; i < len; i++) {
        rst = func(elements[i], i);
        if (rst === false) {
          break;
        }
      }
    } else if (is_object_default(elements)) {
      for (var k in elements) {
        if (elements.hasOwnProperty(k)) {
          rst = func(elements[k], k);
          if (rst === false) {
            break;
          }
        }
      }
    }
  }
  var each_default = each;

  // node_modules/@antv/algorithm/node_modules/@antv/util/esm/pull.js
  var arrPrototype = Array.prototype;
  var splice = arrPrototype.splice;
  var indexOf = arrPrototype.indexOf;

  // node_modules/@antv/algorithm/node_modules/@antv/util/esm/pull-at.js
  var splice2 = Array.prototype.splice;

  // node_modules/@antv/algorithm/node_modules/@antv/util/esm/is-string.js
  var is_string_default = (function(str) {
    return is_type_default(str, "String");
  });

  // node_modules/@antv/algorithm/node_modules/@antv/util/esm/is-number.js
  var isNumber5 = function(value) {
    return is_type_default(value, "Number");
  };
  var is_number_default = isNumber5;

  // node_modules/@antv/algorithm/node_modules/@antv/util/esm/is-integer.js
  var isInteger = Number.isInteger ? Number.isInteger : function(num) {
    return is_number_default(num) && num % 1 === 0;
  };

  // node_modules/@antv/algorithm/node_modules/@antv/util/esm/to-degree.js
  var DEGREE = 180 / Math.PI;

  // node_modules/@antv/algorithm/node_modules/@antv/util/esm/to-radian.js
  var RADIAN = Math.PI / 180;

  // node_modules/@antv/algorithm/node_modules/@antv/util/esm/values.js
  var values = Object.values ? function(obj) {
    return Object.values(obj);
  } : function(obj) {
    var result = [];
    each_default(obj, function(value, key) {
      if (!(is_function_default(obj) && key === "prototype")) {
        result.push(value);
      }
    });
    return result;
  };
  var values_default = values;

  // node_modules/@antv/algorithm/node_modules/@antv/util/esm/get-type.js
  var toString2 = {}.toString;

  // node_modules/@antv/algorithm/node_modules/@antv/util/esm/is-prototype.js
  var objectProto = Object.prototype;

  // node_modules/@antv/algorithm/node_modules/@antv/util/esm/clone.js
  var clone2 = function(obj) {
    if (typeof obj !== "object" || obj === null) {
      return obj;
    }
    var rst;
    if (is_array_default(obj)) {
      rst = [];
      for (var i = 0, l = obj.length; i < l; i++) {
        if (typeof obj[i] === "object" && obj[i] != null) {
          rst[i] = clone2(obj[i]);
        } else {
          rst[i] = obj[i];
        }
      }
    } else {
      rst = {};
      for (var k in obj) {
        if (typeof obj[k] === "object" && obj[k] != null) {
          rst[k] = clone2(obj[k]);
        } else {
          rst[k] = obj[k];
        }
      }
    }
    return rst;
  };
  var clone_default = clone2;

  // node_modules/@antv/algorithm/node_modules/@antv/util/esm/memoize.js
  var memoize_default = (function(f, resolver) {
    if (!is_function_default(f)) {
      throw new TypeError("Expected a function");
    }
    var memoized = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var key = resolver ? resolver.apply(this, args) : args[0];
      var cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = f.apply(this, args);
      cache.set(key, result);
      return result;
    };
    memoized.cache = /* @__PURE__ */ new Map();
    return memoized;
  });

  // node_modules/@antv/algorithm/node_modules/@antv/util/esm/measure-text-width.js
  init_tslib_es6();
  var ctx;
  var measure_text_width_default = memoize_default(function(text, font) {
    if (font === void 0) {
      font = {};
    }
    var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
    if (!ctx) {
      ctx = document.createElement("canvas").getContext("2d");
    }
    ctx.font = [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ");
    return ctx.measureText(is_string_default(text) ? text : "").width;
  }, function(text, font) {
    if (font === void 0) {
      font = {};
    }
    return __spreadArrays([text], values_default(font)).join("");
  });

  // node_modules/@antv/algorithm/node_modules/@antv/util/esm/cache.js
  var default_1 = (
    /** @class */
    (function() {
      function default_12() {
        this.map = {};
      }
      default_12.prototype.has = function(key) {
        return this.map[key] !== void 0;
      };
      default_12.prototype.get = function(key, def) {
        var v = this.map[key];
        return v === void 0 ? def : v;
      };
      default_12.prototype.set = function(key, value) {
        this.map[key] = value;
      };
      default_12.prototype.clear = function() {
        this.map = {};
      };
      default_12.prototype.delete = function(key) {
        delete this.map[key];
      };
      default_12.prototype.size = function() {
        return Object.keys(this.map).length;
      };
      return default_12;
    })()
  );

  // node_modules/@antv/algorithm/es/dijkstra.js
  var minVertex = function minVertex2(D, nodes, marks) {
    var minDis = Infinity;
    var minNode;
    for (var i = 0; i < nodes.length; i++) {
      var nodeId = nodes[i].id;
      if (!marks[nodeId] && D[nodeId] <= minDis) {
        minDis = D[nodeId];
        minNode = nodes[i];
      }
    }
    return minNode;
  };
  var dijkstra = function dijkstra2(graphData, source, directed, weightPropertyName) {
    var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
    var nodeIds = [];
    var marks = {};
    var D = {};
    var prevs = {};
    nodes.forEach(function(node, i2) {
      var id3 = node.id;
      nodeIds.push(id3);
      D[id3] = Infinity;
      if (id3 === source) D[id3] = 0;
    });
    var nodeNum = nodes.length;
    var _loop_1 = function _loop_12(i2) {
      var minNode = minVertex(D, nodes, marks);
      var minNodeId = minNode.id;
      marks[minNodeId] = true;
      if (D[minNodeId] === Infinity) return "continue";
      var relatedEdges = [];
      if (directed) relatedEdges = getOutEdgesNodeId(minNodeId, edges);
      else relatedEdges = getEdgesByNodeId(minNodeId, edges);
      relatedEdges.forEach(function(edge) {
        var edgeTarget = edge.target;
        var edgeSource = edge.source;
        var w = edgeTarget === minNodeId ? edgeSource : edgeTarget;
        var weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;
        if (D[w] > D[minNode.id] + weight) {
          D[w] = D[minNode.id] + weight;
          prevs[w] = [minNode.id];
        } else if (D[w] === D[minNode.id] + weight) {
          prevs[w].push(minNode.id);
        }
      });
    };
    for (var i = 0; i < nodeNum; i++) {
      _loop_1(i);
    }
    prevs[source] = [source];
    var paths = {};
    for (var target in D) {
      if (D[target] !== Infinity) {
        findAllPaths(source, target, prevs, paths);
      }
    }
    var path = {};
    for (var target in paths) {
      path[target] = paths[target][0];
    }
    return {
      length: D,
      path,
      allPath: paths
    };
  };
  var dijkstra_default = dijkstra;
  function findAllPaths(source, target, prevs, foundPaths) {
    if (source === target) {
      return [source];
    }
    if (foundPaths[target]) {
      return foundPaths[target];
    }
    var paths = [];
    for (var _i = 0, _a2 = prevs[target]; _i < _a2.length; _i++) {
      var prev = _a2[_i];
      var prevPaths = findAllPaths(source, prev, prevs, foundPaths);
      if (!prevPaths) return;
      for (var _b = 0, prevPaths_1 = prevPaths; _b < prevPaths_1.length; _b++) {
        var prePath = prevPaths_1[_b];
        if (is_array_default(prePath)) paths.push(__spreadArray(__spreadArray([], prePath, true), [target], false));
        else paths.push([prePath, target]);
      }
    }
    foundPaths[target] = paths;
    return foundPaths[target];
  }

  // node_modules/@antv/algorithm/es/find-path.js
  var findShortestPath = function findShortestPath2(graphData, start, end, directed, weightPropertyName) {
    var _a2 = dijkstra_default(graphData, start, directed, weightPropertyName), length = _a2.length, path = _a2.path, allPath = _a2.allPath;
    return {
      length: length[end],
      path: path[end],
      allPath: allPath[end]
    };
  };

  // node_modules/@antv/algorithm/es/utils/vector.js
  var Vector = (
    /** @class */
    (function() {
      function Vector2(arr) {
        this.arr = arr;
      }
      Vector2.prototype.getArr = function() {
        return this.arr || [];
      };
      Vector2.prototype.add = function(otherVector) {
        var _a2;
        var otherArr = otherVector.arr;
        if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length)) {
          return new Vector2(otherArr);
        }
        if (!(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
          return new Vector2(this.arr);
        }
        if (this.arr.length === otherArr.length) {
          var res = [];
          for (var index2 in this.arr) {
            res[index2] = this.arr[index2] + otherArr[index2];
          }
          return new Vector2(res);
        }
      };
      Vector2.prototype.subtract = function(otherVector) {
        var _a2;
        var otherArr = otherVector.arr;
        if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length)) {
          return new Vector2(otherArr);
        }
        if (!(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
          return new Vector2(this.arr);
        }
        if (this.arr.length === otherArr.length) {
          var res = [];
          for (var index2 in this.arr) {
            res[index2] = this.arr[index2] - otherArr[index2];
          }
          return new Vector2(res);
        }
      };
      Vector2.prototype.avg = function(length) {
        var res = [];
        if (length !== 0) {
          for (var index2 in this.arr) {
            res[index2] = this.arr[index2] / length;
          }
        }
        return new Vector2(res);
      };
      Vector2.prototype.negate = function() {
        var res = [];
        for (var index2 in this.arr) {
          res[index2] = -this.arr[index2];
        }
        return new Vector2(res);
      };
      Vector2.prototype.squareEuclideanDistance = function(otherVector) {
        var _a2;
        var otherArr = otherVector.arr;
        if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
          return 0;
        }
        if (this.arr.length === otherArr.length) {
          var res = 0;
          for (var index2 in this.arr) {
            res += Math.pow(this.arr[index2] - otherVector.arr[index2], 2);
          }
          return res;
        }
      };
      Vector2.prototype.euclideanDistance = function(otherVector) {
        var _a2;
        var otherArr = otherVector.arr;
        if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
          return 0;
        }
        if (this.arr.length === otherArr.length) {
          var res = 0;
          for (var index2 in this.arr) {
            res += Math.pow(this.arr[index2] - otherVector.arr[index2], 2);
          }
          return Math.sqrt(res);
        } else {
          console.error("The two vectors are unequal in length.");
        }
      };
      Vector2.prototype.normalize = function() {
        var res = [];
        var cloneArr = clone_default(this.arr);
        cloneArr.sort(function(a2, b) {
          return a2 - b;
        });
        var max4 = cloneArr[cloneArr.length - 1];
        var min4 = cloneArr[0];
        for (var index2 in this.arr) {
          res[index2] = (this.arr[index2] - min4) / (max4 - min4);
        }
        return new Vector2(res);
      };
      Vector2.prototype.norm2 = function() {
        var _a2;
        if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length)) {
          return 0;
        }
        var res = 0;
        for (var index2 in this.arr) {
          res += Math.pow(this.arr[index2], 2);
        }
        return Math.sqrt(res);
      };
      Vector2.prototype.dot = function(otherVector) {
        var _a2;
        var otherArr = otherVector.arr;
        if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
          return 0;
        }
        if (this.arr.length === otherArr.length) {
          var res = 0;
          for (var index2 in this.arr) {
            res += this.arr[index2] * otherVector.arr[index2];
          }
          return res;
        } else {
          console.error("The two vectors are unequal in length.");
        }
      };
      Vector2.prototype.equal = function(otherVector) {
        var _a2;
        var otherArr = otherVector.arr;
        if (((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) !== (otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
          return false;
        }
        for (var index2 in this.arr) {
          if (this.arr[index2] !== otherArr[index2]) {
            return false;
          }
        }
        return true;
      };
      return Vector2;
    })()
  );

  // node_modules/@antv/algorithm/es/types.js
  var DistanceType;
  (function(DistanceType2) {
    DistanceType2["EuclideanDistance"] = "euclideanDistance";
  })(DistanceType || (DistanceType = {}));

  // node_modules/@antv/algorithm/es/structs/union-find.js
  var UnionFind = (
    /** @class */
    (function() {
      function UnionFind2(items) {
        this.count = items.length;
        this.parent = {};
        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
          var i = items_1[_i];
          this.parent[i] = i;
        }
      }
      UnionFind2.prototype.find = function(item) {
        while (this.parent[item] !== item) {
          item = this.parent[item];
        }
        return item;
      };
      UnionFind2.prototype.union = function(a2, b) {
        var rootA = this.find(a2);
        var rootB = this.find(b);
        if (rootA === rootB) return;
        if (rootA < rootB) {
          if (this.parent[b] !== b) this.union(this.parent[b], a2);
          this.parent[b] = this.parent[a2];
        } else {
          if (this.parent[a2] !== a2) this.union(this.parent[a2], b);
          this.parent[a2] = this.parent[b];
        }
      };
      UnionFind2.prototype.connected = function(a2, b) {
        return this.find(a2) === this.find(b);
      };
      return UnionFind2;
    })()
  );

  // node_modules/@antv/algorithm/es/structs/binary-heap.js
  var defaultCompare = function defaultCompare2(a2, b) {
    return a2 - b;
  };
  var MinBinaryHeap = (
    /** @class */
    (function() {
      function MinBinaryHeap2(compareFn) {
        if (compareFn === void 0) {
          compareFn = defaultCompare;
        }
        this.compareFn = compareFn;
        this.list = [];
      }
      MinBinaryHeap2.prototype.getLeft = function(index2) {
        return 2 * index2 + 1;
      };
      MinBinaryHeap2.prototype.getRight = function(index2) {
        return 2 * index2 + 2;
      };
      MinBinaryHeap2.prototype.getParent = function(index2) {
        if (index2 === 0) {
          return null;
        }
        return Math.floor((index2 - 1) / 2);
      };
      MinBinaryHeap2.prototype.isEmpty = function() {
        return this.list.length <= 0;
      };
      MinBinaryHeap2.prototype.top = function() {
        return this.isEmpty() ? void 0 : this.list[0];
      };
      MinBinaryHeap2.prototype.delMin = function() {
        var top = this.top();
        var bottom = this.list.pop();
        if (this.list.length > 0) {
          this.list[0] = bottom;
          this.moveDown(0);
        }
        return top;
      };
      MinBinaryHeap2.prototype.insert = function(value) {
        if (value !== null) {
          this.list.push(value);
          var index2 = this.list.length - 1;
          this.moveUp(index2);
          return true;
        }
        return false;
      };
      MinBinaryHeap2.prototype.moveUp = function(index2) {
        var parent = this.getParent(index2);
        while (index2 && index2 > 0 && this.compareFn(this.list[parent], this.list[index2]) > 0) {
          var tmp2 = this.list[parent];
          this.list[parent] = this.list[index2];
          this.list[index2] = tmp2;
          index2 = parent;
          parent = this.getParent(index2);
        }
      };
      MinBinaryHeap2.prototype.moveDown = function(index2) {
        var _a2;
        var element = index2;
        var left = this.getLeft(index2);
        var right = this.getRight(index2);
        var size2 = this.list.length;
        if (left !== null && left < size2 && this.compareFn(this.list[element], this.list[left]) > 0) {
          element = left;
        } else if (right !== null && right < size2 && this.compareFn(this.list[element], this.list[right]) > 0) {
          element = right;
        }
        if (index2 !== element) {
          _a2 = [this.list[element], this.list[index2]], this.list[index2] = _a2[0], this.list[element] = _a2[1];
          this.moveDown(element);
        }
      };
      return MinBinaryHeap2;
    })()
  );

  // node_modules/@antv/algorithm/es/pageRank.js
  var pageRank = function pageRank2(graphData, epsilon2, linkProb) {
    if (typeof epsilon2 !== "number") epsilon2 = 1e-6;
    if (typeof linkProb !== "number") linkProb = 0.85;
    var distance6 = 1;
    var leakedRank = 0;
    var maxIterations = 1e3;
    var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
    var nodesCount = nodes.length;
    var currentRank;
    var curRanks = {};
    var prevRanks = {};
    for (var j = 0; j < nodesCount; ++j) {
      var node = nodes[j];
      var nodeId = node.id;
      curRanks[nodeId] = 1 / nodesCount;
      prevRanks[nodeId] = 1 / nodesCount;
    }
    var nodeDegree = degree_default(graphData);
    while (maxIterations > 0 && distance6 > epsilon2) {
      leakedRank = 0;
      for (var j = 0; j < nodesCount; ++j) {
        var node = nodes[j];
        var nodeId = node.id;
        currentRank = 0;
        if (nodeDegree[node.id].inDegree === 0) {
          curRanks[nodeId] = 0;
        } else {
          var neighbors = getNeighbors(nodeId, edges, "source");
          for (var i = 0; i < neighbors.length; ++i) {
            var neighbor = neighbors[i];
            var outDegree = nodeDegree[neighbor].outDegree;
            if (outDegree > 0) currentRank += prevRanks[neighbor] / outDegree;
          }
          curRanks[nodeId] = linkProb * currentRank;
          leakedRank += curRanks[nodeId];
        }
      }
      leakedRank = (1 - leakedRank) / nodesCount;
      distance6 = 0;
      for (var j = 0; j < nodesCount; ++j) {
        var node = nodes[j];
        var nodeId = node.id;
        currentRank = curRanks[nodeId] + leakedRank;
        distance6 += Math.abs(currentRank - prevRanks[nodeId]);
        prevRanks[nodeId] = currentRank;
      }
      maxIterations -= 1;
    }
    return prevRanks;
  };
  var pageRank_default = pageRank;

  // node_modules/@antv/algorithm/es/gSpan/struct.js
  var VACANT_EDGE_ID = -1;
  var VACANT_NODE_ID = -1;
  var VACANT_EDGE_LABEL = "-1";
  var VACANT_NODE_LABEL = "-1";
  var VACANT_GRAPH_ID = -1;
  var Edge = (
    /** @class */
    /* @__PURE__ */ (function() {
      function Edge2(id3, from, to, label) {
        if (id3 === void 0) {
          id3 = VACANT_EDGE_ID;
        }
        if (from === void 0) {
          from = VACANT_NODE_ID;
        }
        if (to === void 0) {
          to = VACANT_NODE_ID;
        }
        if (label === void 0) {
          label = VACANT_EDGE_LABEL;
        }
        this.id = id3;
        this.from = from;
        this.to = to;
        this.label = label;
      }
      return Edge2;
    })()
  );
  var Node2 = (
    /** @class */
    (function() {
      function Node3(id3, label) {
        if (id3 === void 0) {
          id3 = VACANT_NODE_ID;
        }
        if (label === void 0) {
          label = VACANT_NODE_LABEL;
        }
        this.id = id3;
        this.label = label;
        this.edges = [];
        this.edgeMap = {};
      }
      Node3.prototype.addEdge = function(edge) {
        this.edges.push(edge);
        this.edgeMap[edge.id] = edge;
      };
      return Node3;
    })()
  );
  var Graph = (
    /** @class */
    (function() {
      function Graph4(id3, edgeIdAutoIncrease, directed) {
        if (id3 === void 0) {
          id3 = VACANT_NODE_ID;
        }
        if (edgeIdAutoIncrease === void 0) {
          edgeIdAutoIncrease = true;
        }
        if (directed === void 0) {
          directed = false;
        }
        this.id = id3;
        this.edgeIdAutoIncrease = edgeIdAutoIncrease;
        this.edges = [];
        this.nodes = [];
        this.nodeMap = {};
        this.edgeMap = {};
        this.nodeLabelMap = {};
        this.edgeLabelMap = {};
        this.counter = 0;
        this.directed = directed;
      }
      Graph4.prototype.getNodeNum = function() {
        return this.nodes.length;
      };
      Graph4.prototype.addNode = function(id3, label) {
        if (this.nodeMap[id3]) return;
        var node = new Node2(id3, label);
        this.nodes.push(node);
        this.nodeMap[id3] = node;
        if (!this.nodeLabelMap[label]) this.nodeLabelMap[label] = [];
        this.nodeLabelMap[label].push(id3);
      };
      Graph4.prototype.addEdge = function(id3, from, to, label) {
        if (this.edgeIdAutoIncrease || id3 === void 0) id3 = this.counter++;
        if (this.nodeMap[from] && this.nodeMap[to] && this.nodeMap[to].edgeMap[id3]) return;
        var edge = new Edge(id3, from, to, label);
        this.edges.push(edge);
        this.edgeMap[id3] = edge;
        this.nodeMap[from].addEdge(edge);
        if (!this.edgeLabelMap[label]) this.edgeLabelMap[label] = [];
        this.edgeLabelMap[label].push(edge);
        if (!this.directed) {
          var rEdge = new Edge(id3, to, from, label);
          this.nodeMap[to].addEdge(rEdge);
          this.edgeLabelMap[label].push(rEdge);
        }
      };
      return Graph4;
    })()
  );

  // node_modules/@antv/algorithm/es/gSpan/gSpan.js
  var DFSedge = (
    /** @class */
    (function() {
      function DFSedge2(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel) {
        this.fromNode = fromNode;
        this.toNode = toNode;
        this.nodeEdgeNodeLabel = {
          nodeLabel1: fromNodeLabel || VACANT_NODE_LABEL,
          edgeLabel: edgeLabel || VACANT_EDGE_LABEL,
          nodeLabel2: toNodeLabel || VACANT_NODE_LABEL
        };
      }
      DFSedge2.prototype.equalTo = function(other) {
        return this.fromNode === other.formNode && this.toNode === other.toNode && this.nodeEdgeNodeLabel === other.nodeEdgeNodeLabel;
      };
      DFSedge2.prototype.notEqualTo = function(other) {
        return !this.equalTo(other);
      };
      return DFSedge2;
    })()
  );
  var DFScode = (
    /** @class */
    (function() {
      function DFScode2() {
        this.rmpath = [];
        this.dfsEdgeList = [];
      }
      DFScode2.prototype.equalTo = function(other) {
        var aLength = this.dfsEdgeList.length;
        var bLength = other.length;
        if (aLength !== bLength) return false;
        for (var i = 0; i < aLength; i++) {
          if (this.dfsEdgeList[i] !== other[i]) return false;
        }
        return true;
      };
      DFScode2.prototype.notEqualTo = function(other) {
        return !this.equalTo(other);
      };
      DFScode2.prototype.pushBack = function(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel) {
        this.dfsEdgeList.push(new DFSedge(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel));
        return this.dfsEdgeList;
      };
      DFScode2.prototype.toGraph = function(graphId, directed) {
        if (graphId === void 0) {
          graphId = VACANT_GRAPH_ID;
        }
        if (directed === void 0) {
          directed = false;
        }
        var graph = new Graph(graphId, true, directed);
        this.dfsEdgeList.forEach(function(dfsEdge) {
          var fromNodeId = dfsEdge.fromNode;
          var toNodeId = dfsEdge.toNode;
          var _a2 = dfsEdge.nodeEdgeNodeLabel, nodeLabel1 = _a2.nodeLabel1, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
          if (nodeLabel1 !== VACANT_NODE_LABEL) graph.addNode(fromNodeId, nodeLabel1);
          if (nodeLabel2 !== VACANT_NODE_LABEL) graph.addNode(toNodeId, nodeLabel2);
          if (nodeLabel1 !== VACANT_NODE_LABEL && nodeLabel2 !== nodeLabel1) graph.addEdge(void 0, fromNodeId, toNodeId, edgeLabel);
        });
        return graph;
      };
      DFScode2.prototype.buildRmpath = function() {
        this.rmpath = [];
        var oldFrom = void 0;
        var selfLength = this.dfsEdgeList.length;
        for (var i = selfLength - 1; i >= 0; i--) {
          var dfsEdge = this.dfsEdgeList[i];
          var fromNodeIdx = dfsEdge.fromNode;
          var toNodeIdx = dfsEdge.toNode;
          if (fromNodeIdx < toNodeIdx && (oldFrom === void 0 || toNodeIdx === oldFrom)) {
            this.rmpath.push(i);
            oldFrom = fromNodeIdx;
          }
        }
        return this.rmpath;
      };
      DFScode2.prototype.getNodeNum = function() {
        var nodeMap = {};
        this.dfsEdgeList.forEach(function(dfsEdge) {
          if (!nodeMap[dfsEdge.fromNode]) nodeMap[dfsEdge.fromNode] = true;
          if (!nodeMap[dfsEdge.toNode]) nodeMap[dfsEdge.toNode] = true;
        });
        return Object.keys(nodeMap).length;
      };
      return DFScode2;
    })()
  );
  var History = (
    /** @class */
    (function() {
      function History3(pdfs) {
        this.his = {};
        this.nodesUsed = {};
        this.edgesUsed = {};
        this.edges = [];
        if (!pdfs) return;
        while (pdfs) {
          var e = pdfs.edge;
          this.edges.push(e);
          this.nodesUsed[e.from] = 1;
          this.nodesUsed[e.to] = 1;
          this.edgesUsed[e.id] = 1;
          pdfs = pdfs.preNode;
        }
        this.edges = this.edges.reverse();
      }
      History3.prototype.hasNode = function(node) {
        return this.nodesUsed[node.id] === 1;
      };
      History3.prototype.hasEdge = function(edge) {
        return this.edgesUsed[edge.id] === 1;
      };
      return History3;
    })()
  );
  var GSpan = (
    /** @class */
    (function() {
      function GSpan2(_a2) {
        var graphs = _a2.graphs, _b = _a2.minSupport, minSupport = _b === void 0 ? 2 : _b, _c = _a2.minNodeNum, minNodeNum = _c === void 0 ? 1 : _c, _d = _a2.maxNodeNum, maxNodeNum = _d === void 0 ? 4 : _d, _e = _a2.top, top = _e === void 0 ? 10 : _e, _f = _a2.directed, directed = _f === void 0 ? false : _f, _g = _a2.verbose, verbose = _g === void 0 ? false : _g;
        this.graphs = graphs;
        this.dfsCode = new DFScode();
        this.support = 0;
        this.frequentSize1Subgraphs = [];
        this.frequentSubgraphs = [];
        this.minSupport = minSupport;
        this.top = top;
        this.directed = directed;
        this.counter = 0;
        this.maxNodeNum = maxNodeNum;
        this.minNodeNum = minNodeNum;
        this.verbose = verbose;
        if (this.maxNodeNum < this.minNodeNum) this.maxNodeNum = this.minNodeNum;
        this.reportDF = [];
      }
      GSpan2.prototype.findForwardRootEdges = function(graph, fromNode) {
        var _this2 = this;
        var result = [];
        var nodeMap = graph.nodeMap;
        fromNode.edges.forEach(function(edge) {
          if (_this2.directed || fromNode.label <= nodeMap[edge.to].label) result.push(edge);
        });
        return result;
      };
      GSpan2.prototype.findBackwardEdge = function(graph, edge1, edge2, history) {
        if (!this.directed && edge1 === edge2) return null;
        var nodeMap = graph.nodeMap;
        var edge2To = nodeMap[edge2.to];
        var edge2ToEdges = edge2To.edges;
        var edgeLength = edge2ToEdges.length;
        for (var i = 0; i < edgeLength; i++) {
          var edge = edge2ToEdges[i];
          if (history.hasEdge(edge) || edge.to !== edge1.from) continue;
          if (!this.directed) {
            if (edge1.label < edge.label || edge1.label === edge.label && nodeMap[edge1.to].label <= nodeMap[edge2.to].label) {
              return edge;
            }
          } else {
            if (nodeMap[edge1.from].label < nodeMap[edge2.to].label || nodeMap[edge1.from].label === nodeMap[edge2.to].label && edge1.label <= edge.label) {
              return edge;
            }
          }
        }
        return null;
      };
      GSpan2.prototype.findForwardPureEdges = function(graph, rightmostEdge, minNodeLabel, history) {
        var result = [];
        var rightmostEdgeToId = rightmostEdge.to;
        var edges = graph.nodeMap[rightmostEdgeToId].edges;
        var edgeLength = edges.length;
        for (var i = 0; i < edgeLength; i++) {
          var edge = edges[i];
          var toNode = graph.nodeMap[edge.to];
          if (minNodeLabel <= toNode.label && !history.hasNode(toNode)) {
            result.push(edge);
          }
        }
        return result;
      };
      GSpan2.prototype.findForwardRmpathEdges = function(graph, rightmostEdge, minNodeLabel, history) {
        var result = [];
        var nodeMap = graph.nodeMap;
        var toNodeLabel = nodeMap[rightmostEdge.to].label;
        var fromNode = nodeMap[rightmostEdge.from];
        var edges = fromNode.edges;
        var edgeLength = edges.length;
        for (var i = 0; i < edgeLength; i++) {
          var edge = edges[i];
          var newToNodeLabel = nodeMap[edge.to].label;
          if (rightmostEdge.to === edge.to || minNodeLabel > newToNodeLabel || history.hasNode(nodeMap[edge.to])) {
            continue;
          }
          if (rightmostEdge.label < edge.label || rightmostEdge.label === edge.label && toNodeLabel <= newToNodeLabel) {
            result.push(edge);
          }
        }
        return result;
      };
      GSpan2.prototype.getSupport = function(projected) {
        var graphMap = {};
        projected.forEach(function(pro) {
          if (!graphMap[pro.graphId]) graphMap[pro.graphId] = true;
        });
        return Object.keys(graphMap).length;
      };
      GSpan2.prototype.findMinLabel = function(obj) {
        var minLabel = void 0;
        Object.keys(obj).forEach(function(nodeEdgeNodeLabel) {
          var _a2 = obj[nodeEdgeNodeLabel], nodeLabel1 = _a2.nodeLabel1, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
          if (!minLabel) {
            minLabel = {
              nodeLabel1,
              edgeLabel,
              nodeLabel2
            };
            return;
          }
          if (nodeLabel1 < minLabel.nodeLabel1 || nodeLabel1 === minLabel.nodeLabel1 && edgeLabel < minLabel.edgeLabel || nodeLabel1 === minLabel.nodeLabel1 && edgeLabel === minLabel.edgeLabel && nodeLabel2 < minLabel.nodeLabel2) {
            minLabel = {
              nodeLabel1,
              edgeLabel,
              nodeLabel2
            };
          }
        });
        return minLabel;
      };
      GSpan2.prototype.isMin = function() {
        var _this2 = this;
        var dfsCode = this.dfsCode;
        if (this.verbose) console.log("isMin checking", dfsCode);
        if (dfsCode.dfsEdgeList.length === 1) return true;
        var directed = this.directed;
        var graph = dfsCode.toGraph(VACANT_GRAPH_ID, directed);
        var nodeMap = graph.nodeMap;
        var dfsCodeMin = new DFScode();
        var root2 = {};
        graph.nodes.forEach(function(node) {
          var forwardEdges = _this2.findForwardRootEdges(graph, node);
          forwardEdges.forEach(function(edge) {
            var otherNode = nodeMap[edge.to];
            var nodeEdgeNodeLabel = "".concat(node.label, "-").concat(edge.label, "-").concat(otherNode.label);
            if (!root2[nodeEdgeNodeLabel]) root2[nodeEdgeNodeLabel] = {
              projected: [],
              nodeLabel1: node.label,
              edgeLabel: edge.label,
              nodeLabel2: otherNode.label
            };
            var pdfs = {
              graphId: graph.id,
              edge,
              preNode: null
            };
            root2[nodeEdgeNodeLabel].projected.push(pdfs);
          });
        });
        var minLabel = this.findMinLabel(root2);
        if (!minLabel) return;
        dfsCodeMin.dfsEdgeList.push(new DFSedge(0, 1, minLabel.nodeLabel1, minLabel.edgeLabel, minLabel.nodeLabel2));
        var projectIsMin = function projectIsMin2(projected) {
          var rmpath = dfsCodeMin.buildRmpath();
          var minNodeLabel = dfsCodeMin.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1;
          var maxToC = dfsCodeMin.dfsEdgeList[rmpath[0]].toNode;
          var backwardRoot = {};
          var flag = false, newTo = 0;
          var end = directed ? -1 : 0;
          var _loop_1 = function _loop_12(i2) {
            if (flag) return "break";
            projected.forEach(function(p) {
              var history = new History(p);
              var backwardEdge = _this2.findBackwardEdge(graph, history.edges[rmpath[i2]], history.edges[rmpath[0]], history);
              if (backwardEdge) {
                if (!backwardRoot[backwardEdge.label]) {
                  backwardRoot[backwardEdge.label] = {
                    projected: [],
                    edgeLabel: backwardEdge.label
                  };
                }
                backwardRoot[backwardEdge.label].projected.push({
                  graphId: graph.id,
                  edge: backwardRoot,
                  preNode: p
                });
                newTo = dfsCodeMin.dfsEdgeList[rmpath[i2]].fromNode;
                flag = true;
              }
            });
          };
          for (var i = rmpath.length - 1; i > end; i--) {
            var state_1 = _loop_1(i);
            if (state_1 === "break") break;
          }
          if (flag) {
            var minBackwardEdgeLabel = _this2.findMinLabel(backwardRoot);
            dfsCodeMin.dfsEdgeList.push(new DFSedge(maxToC, newTo, VACANT_NODE_LABEL, minBackwardEdgeLabel.edgeLabel, VACANT_NODE_LABEL));
            var idx_1 = dfsCodeMin.dfsEdgeList.length - 1;
            if (_this2.dfsCode.dfsEdgeList[idx_1] !== dfsCodeMin.dfsEdgeList[idx_1]) return false;
            return projectIsMin2(backwardRoot[minBackwardEdgeLabel.edgeLabel].projected);
          }
          var forwardRoot = {};
          flag = false;
          var newFrom = 0;
          projected.forEach(function(p) {
            var history = new History(p);
            var forwardPureEdges = _this2.findForwardPureEdges(graph, history.edges[rmpath[0]], minNodeLabel, history);
            if (forwardPureEdges.length > 0) {
              flag = true;
              newFrom = maxToC;
              forwardPureEdges.forEach(function(edge) {
                var key2 = "".concat(edge.label, "-").concat(nodeMap[edge.to].label);
                if (!forwardRoot[key2]) forwardRoot[key2] = {
                  projected: [],
                  edgeLabel: edge.label,
                  nodeLabel2: nodeMap[edge.to].label
                };
                forwardRoot[key2].projected.push({
                  graphId: graph.id,
                  edge,
                  preNode: p
                });
              });
            }
          });
          var pathLength = rmpath.length;
          var _loop_2 = function _loop_22(i2) {
            if (flag) return "break";
            var value = rmpath[i2];
            projected.forEach(function(p) {
              var history = new History(p);
              var forwardRmpathEdges = _this2.findForwardRmpathEdges(graph, history.edges[value], minNodeLabel, history);
              if (forwardRmpathEdges.length > 0) {
                flag = true;
                newFrom = dfsCodeMin.dfsEdgeList[value].fromNode;
                forwardRmpathEdges.forEach(function(edge) {
                  var key2 = "".concat(edge.label, "-").concat(nodeMap[edge.to].label);
                  if (!forwardRoot[key2]) forwardRoot[key2] = {
                    projected: [],
                    edgeLabel: edge.label,
                    nodeLabel2: nodeMap[edge.to].label
                  };
                  forwardRoot[key2].projected.push({
                    graphId: graph.id,
                    edge,
                    preNode: p
                  });
                });
              }
            });
          };
          for (var i = 0; i < pathLength; i++) {
            var state_2 = _loop_2(i);
            if (state_2 === "break") break;
          }
          if (!flag) return true;
          var forwardMinEdgeNodeLabel = _this2.findMinLabel(forwardRoot);
          dfsCodeMin.dfsEdgeList.push(new DFSedge(newFrom, maxToC + 1, VACANT_NODE_LABEL, forwardMinEdgeNodeLabel.edgeLabel, forwardMinEdgeNodeLabel.nodeLabel2));
          var idx = dfsCodeMin.dfsEdgeList.length - 1;
          if (dfsCode.dfsEdgeList[idx] !== dfsCodeMin.dfsEdgeList[idx]) return false;
          return projectIsMin2(forwardRoot["".concat(forwardMinEdgeNodeLabel.edgeLabel, "-").concat(forwardMinEdgeNodeLabel.nodeLabel2)].projected);
        };
        var key = "".concat(minLabel.nodeLabel1, "-").concat(minLabel.edgeLabel, "-").concat(minLabel.nodeLabel2);
        return projectIsMin(root2[key].projected);
      };
      GSpan2.prototype.report = function() {
        if (this.dfsCode.getNodeNum() < this.minNodeNum) return;
        this.counter++;
        var graph = this.dfsCode.toGraph(this.counter, this.directed);
        this.frequentSubgraphs.push(clone_default(graph));
      };
      GSpan2.prototype.subGraphMining = function(projected) {
        var _this2 = this;
        var support = this.getSupport(projected);
        if (support < this.minSupport) return;
        if (!this.isMin()) return;
        this.report();
        var nodeNum = this.dfsCode.getNodeNum();
        var rmpath = this.dfsCode.buildRmpath();
        var maxToC = this.dfsCode.dfsEdgeList[rmpath[0]].toNode;
        var minNodeLabel = this.dfsCode.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1;
        var forwardRoot = {};
        var backwardRoot = {};
        projected.forEach(function(p) {
          var graph = _this2.graphs[p.graphId];
          var nodeMap = graph.nodeMap;
          var history = new History(p);
          for (var i = rmpath.length - 1; i >= 0; i--) {
            var backwardEdge = _this2.findBackwardEdge(graph, history.edges[rmpath[i]], history.edges[rmpath[0]], history);
            if (backwardEdge) {
              var key = "".concat(_this2.dfsCode.dfsEdgeList[rmpath[i]].fromNode, "-").concat(backwardEdge.label);
              if (!backwardRoot[key]) backwardRoot[key] = {
                projected: [],
                toNodeId: _this2.dfsCode.dfsEdgeList[rmpath[i]].fromNode,
                edgeLabel: backwardEdge.label
              };
              backwardRoot[key].projected.push({
                graphId: p.graphId,
                edge: backwardEdge,
                preNode: p
              });
            }
          }
          if (nodeNum >= _this2.maxNodeNum) return;
          var forwardPureEdges = _this2.findForwardPureEdges(graph, history.edges[rmpath[0]], minNodeLabel, history);
          forwardPureEdges.forEach(function(edge) {
            var key2 = "".concat(maxToC, "-").concat(edge.label, "-").concat(nodeMap[edge.to].label);
            if (!forwardRoot[key2]) forwardRoot[key2] = {
              projected: [],
              fromNodeId: maxToC,
              edgeLabel: edge.label,
              nodeLabel2: nodeMap[edge.to].label
            };
            forwardRoot[key2].projected.push({
              graphId: p.graphId,
              edge,
              preNode: p
            });
          });
          var _loop_3 = function _loop_32(i2) {
            var forwardRmpathEdges = _this2.findForwardRmpathEdges(graph, history.edges[rmpath[i2]], minNodeLabel, history);
            forwardRmpathEdges.forEach(function(edge) {
              var key2 = "".concat(_this2.dfsCode.dfsEdgeList[rmpath[i2]].fromNode, "-").concat(edge.label, "-").concat(nodeMap[edge.to].label);
              if (!forwardRoot[key2]) forwardRoot[key2] = {
                projected: [],
                fromNodeId: _this2.dfsCode.dfsEdgeList[rmpath[i2]].fromNode,
                edgeLabel: edge.label,
                nodeLabel2: nodeMap[edge.to].label
              };
              forwardRoot[key2].projected.push({
                graphId: p.graphId,
                edge,
                preNode: p
              });
            });
          };
          for (var i = 0; i < rmpath.length; i++) {
            _loop_3(i);
          }
        });
        Object.keys(backwardRoot).forEach(function(key) {
          var _a2 = backwardRoot[key], toNodeId = _a2.toNodeId, edgeLabel = _a2.edgeLabel;
          _this2.dfsCode.dfsEdgeList.push(new DFSedge(maxToC, toNodeId, "-1", edgeLabel, "-1"));
          _this2.subGraphMining(backwardRoot[key].projected);
          _this2.dfsCode.dfsEdgeList.pop();
        });
        Object.keys(forwardRoot).forEach(function(key) {
          var _a2 = forwardRoot[key], fromNodeId = _a2.fromNodeId, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
          _this2.dfsCode.dfsEdgeList.push(new DFSedge(fromNodeId, maxToC + 1, VACANT_NODE_LABEL, edgeLabel, nodeLabel2));
          _this2.subGraphMining(forwardRoot[key].projected);
          _this2.dfsCode.dfsEdgeList.pop();
        });
      };
      GSpan2.prototype.generate1EdgeFrequentSubGraphs = function() {
        var graphs = this.graphs;
        var directed = this.directed;
        var minSupport = this.minSupport;
        var frequentSize1Subgraphs = this.frequentSize1Subgraphs;
        var nodeLabelCounter = {}, nodeEdgeNodeCounter = {};
        var nodeLableCounted = {};
        var nodeEdgeNodeLabelCounted = {};
        Object.keys(graphs).forEach(function(key) {
          var graph = graphs[key];
          var nodeMap = graph.nodeMap;
          graph.nodes.forEach(function(node, i) {
            var nodeLabel = node.label;
            var graphNodeKey = "".concat(key, "-").concat(nodeLabel);
            if (!nodeLableCounted[graphNodeKey]) {
              var counter = nodeLabelCounter[nodeLabel] || 0;
              counter++;
              nodeLabelCounter[nodeLabel] = counter;
            }
            nodeLableCounted[graphNodeKey] = {
              graphKey: key,
              label: nodeLabel
            };
            node.edges.forEach(function(edge) {
              var nodeLabel1 = nodeLabel;
              var nodeLabel2 = nodeMap[edge.to].label;
              if (!directed && nodeLabel1 > nodeLabel2) {
                var tmp2 = nodeLabel2;
                nodeLabel2 = nodeLabel1;
                nodeLabel1 = tmp2;
              }
              var edgeLabel = edge.label;
              var graphNodeEdgeNodeKey = "".concat(key, "-").concat(nodeLabel1, "-").concat(edgeLabel, "-").concat(nodeLabel2);
              var nodeEdgeNodeKey = "".concat(nodeLabel1, "-").concat(edgeLabel, "-").concat(nodeLabel2);
              if (!nodeEdgeNodeCounter[nodeEdgeNodeKey]) {
                var counter2 = nodeEdgeNodeCounter[nodeEdgeNodeKey] || 0;
                counter2++;
                nodeEdgeNodeCounter[nodeEdgeNodeKey] = counter2;
              }
              nodeEdgeNodeLabelCounted[graphNodeEdgeNodeKey] = {
                graphId: key,
                nodeLabel1,
                edgeLabel,
                nodeLabel2
              };
            });
          });
        });
        Object.keys(nodeLabelCounter).forEach(function(label) {
          var count = nodeLabelCounter[label];
          if (count < minSupport) return;
          var g = {
            nodes: [],
            edges: []
          };
          g.nodes.push({
            id: "0",
            label
          });
          frequentSize1Subgraphs.push(g);
        });
        return frequentSize1Subgraphs;
      };
      GSpan2.prototype.run = function() {
        var _this2 = this;
        this.frequentSize1Subgraphs = this.generate1EdgeFrequentSubGraphs();
        if (this.maxNodeNum < 2) return;
        var graphs = this.graphs;
        var directed = this.directed;
        var root2 = {};
        Object.keys(graphs).forEach(function(graphId) {
          var graph = graphs[graphId];
          var nodeMap = graph.nodeMap;
          graph.nodes.forEach(function(node) {
            var forwardRootEdges = _this2.findForwardRootEdges(graph, node);
            forwardRootEdges.forEach(function(edge) {
              var toNode = nodeMap[edge.to];
              var nodeEdgeNodeLabel = "".concat(node.label, "-").concat(edge.label, "-").concat(toNode.label);
              if (!root2[nodeEdgeNodeLabel]) root2[nodeEdgeNodeLabel] = {
                projected: [],
                nodeLabel1: node.label,
                edgeLabel: edge.label,
                nodeLabel2: toNode.label
              };
              var pdfs = {
                graphId,
                edge,
                preNode: null
              };
              root2[nodeEdgeNodeLabel].projected.push(pdfs);
            });
          });
        });
        Object.keys(root2).forEach(function(nodeEdgeNodeLabel) {
          var _a2 = root2[nodeEdgeNodeLabel], projected = _a2.projected, nodeLabel1 = _a2.nodeLabel1, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
          _this2.dfsCode.dfsEdgeList.push(new DFSedge(0, 1, nodeLabel1, edgeLabel, nodeLabel2));
          _this2.subGraphMining(projected);
          _this2.dfsCode.dfsEdgeList.pop();
        });
      };
      return GSpan2;
    })()
  );

  // node_modules/@antv/algorithm/es/structs/stack.js
  var Stack = (
    /** @class */
    (function() {
      function Stack2(maxStep) {
        if (maxStep === void 0) {
          maxStep = 10;
        }
        this.linkedList = new linked_list_default();
        this.maxStep = maxStep;
      }
      Object.defineProperty(Stack2.prototype, "length", {
        get: function get9() {
          return this.linkedList.toArray().length;
        },
        enumerable: false,
        configurable: true
      });
      Stack2.prototype.isEmpty = function() {
        return !this.linkedList.head;
      };
      Stack2.prototype.isMaxStack = function() {
        return this.toArray().length >= this.maxStep;
      };
      Stack2.prototype.peek = function() {
        if (this.isEmpty()) {
          return null;
        }
        return this.linkedList.head.value;
      };
      Stack2.prototype.push = function(value) {
        this.linkedList.prepend(value);
        if (this.length > this.maxStep) {
          this.linkedList.deleteTail();
        }
      };
      Stack2.prototype.pop = function() {
        var removeHead = this.linkedList.deleteHead();
        return removeHead ? removeHead.value : null;
      };
      Stack2.prototype.toArray = function() {
        return this.linkedList.toArray().map(function(node) {
          return node.value;
        });
      };
      Stack2.prototype.clear = function() {
        while (!this.isEmpty()) {
          this.pop();
        }
      };
      return Stack2;
    })()
  );

  // node_modules/@antv/g6/esm/utils/id.js
  function idOf(data2) {
    if (data2.id !== void 0)
      return data2.id;
    if (data2.source !== void 0 && data2.target !== void 0)
      return `${data2.source}-${data2.target}`;
    throw new Error(format("The datum does not have available id."));
  }
  function parentIdOf(data2) {
    return data2.combo;
  }
  function idsOf(data2, flat) {
    const ids = {
      nodes: (data2.nodes || []).map(idOf),
      edges: (data2.edges || []).map(idOf),
      combos: (data2.combos || []).map(idOf)
    };
    return flat ? Object.values(ids).flat() : ids;
  }

  // node_modules/@antv/g6/esm/utils/centrality.js
  var getNodeCentralities = (graphData, getRelatedEdgesData, centrality) => {
    var _a2;
    switch (centrality.type) {
      case "degree": {
        const centralityResult = /* @__PURE__ */ new Map();
        (_a2 = graphData.nodes) === null || _a2 === void 0 ? void 0 : _a2.forEach((node) => {
          const degree3 = getRelatedEdgesData(idOf(node), centrality.direction).length;
          centralityResult.set(idOf(node), degree3);
        });
        return centralityResult;
      }
      case "betweenness":
        return computeNodeBetweennessCentrality(graphData, centrality.directed, centrality.weightPropertyName);
      case "closeness":
        return computeNodeClosenessCentrality(graphData, centrality.directed, centrality.weightPropertyName);
      case "eigenvector":
        return computeNodeEigenvectorCentrality(graphData, centrality.directed);
      case "pagerank":
        return computeNodePageRankCentrality(graphData, centrality.epsilon, centrality.linkProb);
      default:
        return initCentralityResult(graphData);
    }
  };
  var initCentralityResult = (graphData) => {
    var _a2;
    const centralityResult = /* @__PURE__ */ new Map();
    (_a2 = graphData.nodes) === null || _a2 === void 0 ? void 0 : _a2.forEach((node) => {
      centralityResult.set(idOf(node), 0);
    });
    return centralityResult;
  };
  var computeNodeBetweennessCentrality = (graphData, directed, weightPropertyName) => {
    const centralityResult = initCentralityResult(graphData);
    const { nodes = [] } = graphData;
    nodes.forEach((source) => {
      nodes.forEach((target) => {
        if (source !== target) {
          const { allPath } = findShortestPath(graphData, idOf(source), idOf(target), directed, weightPropertyName);
          const pathCount = allPath.length;
          allPath.flat().forEach((nodeId) => {
            if (nodeId !== idOf(source) && nodeId !== idOf(target)) {
              centralityResult.set(nodeId, centralityResult.get(nodeId) + 1 / pathCount);
            }
          });
        }
      });
    });
    return centralityResult;
  };
  var computeNodeClosenessCentrality = (graphData, directed, weightPropertyName) => {
    const centralityResult = /* @__PURE__ */ new Map();
    const { nodes = [] } = graphData;
    nodes.forEach((source) => {
      const totalLength = nodes.reduce((acc, target) => {
        if (source !== target) {
          const { length } = findShortestPath(graphData, idOf(source), idOf(target), directed, weightPropertyName);
          acc += length;
        }
        return acc;
      }, 0);
      centralityResult.set(idOf(source), 1 / totalLength);
    });
    return centralityResult;
  };
  var computeNodePageRankCentrality = (graphData, epsilon2, linkProb) => {
    var _a2;
    const centralityResult = /* @__PURE__ */ new Map();
    const data2 = pageRank_default(graphData, epsilon2, linkProb);
    (_a2 = graphData.nodes) === null || _a2 === void 0 ? void 0 : _a2.forEach((node) => {
      centralityResult.set(idOf(node), data2[idOf(node)]);
    });
    return centralityResult;
  };
  var computeNodeEigenvectorCentrality = (graphData, directed) => {
    const { nodes = [] } = graphData;
    const adjacencyMatrix = createAdjacencyMatrix(graphData, directed);
    const eigenvector = powerIteration(adjacencyMatrix, nodes.length);
    const centralityResult = /* @__PURE__ */ new Map();
    nodes.forEach((node, index2) => {
      centralityResult.set(idOf(node), eigenvector[index2]);
    });
    return centralityResult;
  };
  var createAdjacencyMatrix = (graphData, directed) => {
    const { nodes = [], edges = [] } = graphData;
    const matrix3 = Array(nodes.length).fill(null).map(() => Array(nodes.length).fill(0));
    edges.forEach(({ source, target }) => {
      const uIndex = nodes.findIndex((node) => idOf(node) === source);
      const vIndex = nodes.findIndex((node) => idOf(node) === target);
      if (directed) {
        matrix3[uIndex][vIndex] = 1;
      } else {
        matrix3[uIndex][vIndex] = 1;
        matrix3[vIndex][uIndex] = 1;
      }
    });
    return matrix3;
  };
  var powerIteration = (matrix3, numNodes, maxIterations = 100, tolerance2 = 1e-6) => {
    let eigenvector = Array(numNodes).fill(1);
    let diff = Infinity;
    for (let iter = 0; iter < maxIterations && diff > tolerance2; iter++) {
      const newEigenvector = Array(numNodes).fill(0);
      for (let i = 0; i < numNodes; i++) {
        for (let j = 0; j < numNodes; j++) {
          newEigenvector[i] += matrix3[i][j] * eigenvector[j];
        }
      }
      const norm = Math.sqrt(newEigenvector.reduce((sum, val) => sum + val * val, 0));
      for (let i = 0; i < numNodes; i++) {
        newEigenvector[i] /= norm;
      }
      diff = Math.sqrt(newEigenvector.reduce((sum, val, index2) => sum + (val - eigenvector[index2]) * val, 0));
      eigenvector = newEigenvector;
    }
    return eigenvector;
  };

  // node_modules/@antv/g6/esm/utils/diff.js
  var import_util28 = __toESM(require_lib());
  function arrayDiff(original, modified, key, comparator = import_util28.isEqual) {
    const originalMap = new Map(original.map((d2) => [key(d2), d2]));
    const modifiedMap = new Map(modified.map((d2) => [key(d2), d2]));
    const originalSet = new Set(originalMap.keys());
    const modifiedSet = new Set(modifiedMap.keys());
    const enter = [];
    const update = [];
    const exit = [];
    const keep = [];
    modifiedSet.forEach((key2) => {
      if (originalSet.has(key2)) {
        if (!comparator(originalMap.get(key2), modifiedMap.get(key2))) {
          update.push(modifiedMap.get(key2));
        } else {
          keep.push(modifiedMap.get(key2));
        }
      } else {
        enter.push(modifiedMap.get(key2));
      }
    });
    originalSet.forEach((key2) => {
      if (!modifiedSet.has(key2)) {
        exit.push(originalMap.get(key2));
      }
    });
    return { enter, exit, keep, update };
  }

  // node_modules/@antv/g6/esm/utils/visibility.js
  function setVisibility(shape, value, filter) {
    const callback = (node) => {
      if (filter && !filter(node))
        return;
      node.style.visibility = value;
    };
    shape.forEach((node) => {
      callback(node);
    });
  }

  // node_modules/@antv/g6/esm/utils/extension.js
  function parseExtensions(graph, category, extensions) {
    const counter = {};
    const getKey = (type) => {
      if (!(type in counter))
        counter[type] = 0;
      return `${category}-${type}-${counter[type]++}`;
    };
    return extensions.map((extension) => {
      if (typeof extension === "string") {
        return { type: extension, key: getKey(extension) };
      }
      if (typeof extension === "function") {
        return extension.call(graph);
      }
      if (extension.key)
        return extension;
      return Object.assign(Object.assign({}, extension), { key: getKey(extension.type) });
    });
  }

  // node_modules/@antv/g6/esm/registry/extension/index.js
  var ExtensionController = class {
    constructor(context) {
      this.extensions = [];
      this.extensionMap = {};
      this.context = context;
    }
    setExtensions(extensions) {
      const stdExtensions = parseExtensions(this.context.graph, this.category, extensions);
      const { enter, update, exit, keep } = arrayDiff(this.extensions, stdExtensions, (extension) => extension.key);
      this.createExtensions(enter);
      this.updateExtensions([...update, ...keep]);
      this.destroyExtensions(exit);
      this.extensions = stdExtensions;
    }
    createExtension(extension) {
      const { category } = this;
      const { key, type } = extension;
      const Ctor = getExtension(category, type);
      if (!Ctor)
        return print.warn(`The extension ${type} of ${category} is not registered.`);
      const instance = new Ctor(this.context, extension);
      instance.initialized = true;
      this.extensionMap[key] = instance;
    }
    createExtensions(extensions) {
      extensions.forEach((extension) => this.createExtension(extension));
    }
    updateExtension(extension) {
      const { key } = extension;
      const instance = this.extensionMap[key];
      if (instance) {
        instance.update(extension);
      }
    }
    updateExtensions(extensions) {
      extensions.forEach((extension) => this.updateExtension(extension));
    }
    destroyExtension(key) {
      const instance = this.extensionMap[key];
      if (!instance)
        return;
      if (instance.initialized && !instance.destroyed) {
        instance.destroy();
      }
      delete this.extensionMap[key];
    }
    destroyExtensions(extensions) {
      extensions.forEach(({ key }) => this.destroyExtension(key));
    }
    destroy() {
      this.destroyExtensions(this.extensions);
      this.context = {};
      this.extensions = [];
      this.extensionMap = {};
    }
  };
  var BaseExtension = class {
    constructor(context, options) {
      this.events = [];
      this.initialized = false;
      this.destroyed = false;
      this.context = context;
      this.options = options;
    }
    update(options) {
      this.options = Object.assign(this.options, options);
    }
    destroy() {
      this.context = {};
      this.options = {};
      this.destroyed = true;
    }
  };

  // node_modules/@antv/g6/esm/behaviors/base-behavior.js
  var BaseBehavior = class extends BaseExtension {
  };

  // node_modules/@antv/g6/esm/behaviors/auto-adapt-label.js
  var AutoAdaptLabel = class _AutoAdaptLabel extends BaseBehavior {
    constructor(context, options) {
      super(context, Object.assign({}, _AutoAdaptLabel.defaultOptions, options));
      this.isOverlapping = (bbox, bboxes) => {
        return bboxes.some((b) => bbox.intersects(b));
      };
      this.occupiedBounds = [];
      this.detectLabelCollision = (elements) => {
        const viewport = this.context.viewport;
        const res = { show: [], hide: [] };
        this.occupiedBounds = [];
        elements.forEach((element) => {
          const labelBounds = element.getShape("label").getRenderBounds();
          if (viewport.isInViewport(labelBounds, true) && !this.isOverlapping(labelBounds, this.occupiedBounds)) {
            res.show.push(element);
            this.occupiedBounds.push(getExpandedBBox(labelBounds, this.options.padding));
          } else {
            res.hide.push(element);
          }
        });
        return res;
      };
      this.hideLabelIfExceedViewport = (prevElementsInView, currentElementsInView) => {
        const { exit } = arrayDiff(prevElementsInView, currentElementsInView, (d2) => d2.id);
        exit === null || exit === void 0 ? void 0 : exit.forEach(this.hideLabel);
      };
      this.nodeCentralities = /* @__PURE__ */ new Map();
      this.sortNodesByCentrality = (nodes, centrality) => {
        const { model } = this.context;
        const graphData = model.getData();
        const getRelatedEdgesData = model.getRelatedEdgesData.bind(model);
        const nodesWithCentrality = nodes.map((node) => {
          if (!this.nodeCentralities.has(node.id)) {
            this.nodeCentralities = getNodeCentralities(graphData, getRelatedEdgesData, centrality);
          }
          return { node, centrality: this.nodeCentralities.get(node.id) };
        });
        return nodesWithCentrality.sort((a2, b) => b.centrality - a2.centrality).map((item) => item.node);
      };
      this.sortLabelElementsInView = (labelElements) => {
        const { sort: sort2, sortNode, sortCombo, sortEdge } = this.options;
        const { model } = this.context;
        if ((0, import_util29.isFunction)(sort2))
          return labelElements.sort((a2, b) => sort2(model.getElementDataById(a2.id), model.getElementDataById(b.id)));
        const { node: nodes = [], edge: edges = [], combo: combos = [] } = (0, import_util29.groupBy)(labelElements, (el) => el.type);
        const sortedCombos = (0, import_util29.isFunction)(sortCombo) ? combos.sort((a2, b) => sortCombo(...model.getComboData([a2.id, b.id]))) : combos;
        const sortedNodes = (0, import_util29.isFunction)(sortNode) ? nodes.sort((a2, b) => sortNode(...model.getNodeData([a2.id, b.id]))) : this.sortNodesByCentrality(nodes, sortNode);
        const sortedEdges = (0, import_util29.isFunction)(sortEdge) ? edges.sort((a2, b) => sortEdge(...model.getEdgeData([a2.id, b.id]))) : edges;
        return [...sortedCombos, ...sortedNodes, ...sortedEdges];
      };
      this.labelElementsInView = [];
      this.isFirstRender = true;
      this.onToggleVisibility = (event) => {
        var _a2;
        if (((_a2 = event.data) === null || _a2 === void 0 ? void 0 : _a2.stage) === "zIndex")
          return;
        if (!this.validate(event)) {
          if (this.hiddenElements.size > 0) {
            this.hiddenElements.forEach(this.showLabel);
            this.hiddenElements.clear();
          }
          return;
        }
        const labelElementsInView = this.isFirstRender ? this.getLabelElements() : this.getLabelElementsInView();
        this.hideLabelIfExceedViewport(this.labelElementsInView, labelElementsInView);
        this.labelElementsInView = labelElementsInView;
        const sortedElements = this.sortLabelElementsInView(this.labelElementsInView);
        const { show: show2, hide: hide2 } = this.detectLabelCollision(sortedElements);
        for (let i = show2.length - 1; i >= 0; i--) {
          this.showLabel(show2[i]);
        }
        hide2.forEach(this.hideLabel);
      };
      this.hiddenElements = /* @__PURE__ */ new Map();
      this.hideLabel = (element) => {
        const label = element.getShape("label");
        if (label)
          setVisibility(label, "hidden");
        this.hiddenElements.set(element.id, element);
      };
      this.showLabel = (element) => {
        const label = element.getShape("label");
        if (label)
          setVisibility(label, "visible");
        element.toFront();
        this.hiddenElements.delete(element.id);
      };
      this.onTransform = (0, import_util29.throttle)(this.onToggleVisibility, this.options.throttle, { leading: true });
      this.enableToggle = true;
      this.toggle = (event) => {
        if (!this.enableToggle)
          return;
        this.onToggleVisibility(event);
      };
      this.onBeforeRender = () => {
        this.enableToggle = false;
      };
      this.onAfterRender = (event) => {
        this.onToggleVisibility(event);
        this.enableToggle = true;
      };
      this.bindEvents();
    }
    update(options) {
      this.unbindEvents();
      super.update(options);
      this.bindEvents();
      this.onToggleVisibility({});
    }
    getLabelElements() {
      const { elementMap } = this.context.element;
      const elements = [];
      for (const key in elementMap) {
        const element = elementMap[key];
        if (element.isVisible() && element.getShape("label")) {
          elements.push(element);
        }
      }
      return elements;
    }
    getLabelElementsInView() {
      const viewport = this.context.viewport;
      return this.getLabelElements().filter((node) => viewport.isInViewport(node.getShape("key").getRenderBounds()));
    }
    bindEvents() {
      const { graph } = this.context;
      graph.on(GraphEvent.BEFORE_RENDER, this.onBeforeRender);
      graph.on(GraphEvent.AFTER_RENDER, this.onAfterRender);
      graph.on(GraphEvent.AFTER_DRAW, this.toggle);
      graph.on(GraphEvent.AFTER_LAYOUT, this.toggle);
      graph.on(GraphEvent.AFTER_TRANSFORM, this.onTransform);
    }
    unbindEvents() {
      const { graph } = this.context;
      graph.off(GraphEvent.BEFORE_RENDER, this.onBeforeRender);
      graph.off(GraphEvent.AFTER_RENDER, this.onAfterRender);
      graph.off(GraphEvent.AFTER_DRAW, this.toggle);
      graph.off(GraphEvent.AFTER_LAYOUT, this.toggle);
      graph.off(GraphEvent.AFTER_TRANSFORM, this.onTransform);
    }
    validate(event) {
      if (this.destroyed)
        return false;
      const { enable } = this.options;
      if ((0, import_util29.isFunction)(enable))
        return enable(event);
      return !!enable;
    }
    destroy() {
      this.unbindEvents();
      super.destroy();
    }
  };
  AutoAdaptLabel.defaultOptions = {
    enable: true,
    throttle: 100,
    padding: 0,
    sortNode: { type: "degree" }
  };

  // node_modules/@antv/g6/esm/behaviors/brush-select.js
  var import_util32 = __toESM(require_lib());

  // node_modules/@antv/g6/esm/utils/point.js
  var import_util30 = __toESM(require_lib());

  // node_modules/@antv/g6/esm/utils/vector.js
  var VECTOR_ZERO = [0, 0, 0];
  function add(a2, b) {
    return a2.map((v, i) => v + b[i]);
  }
  function subtract(a2, b) {
    return a2.map((v, i) => v - b[i]);
  }
  function multiply(a2, b) {
    if (typeof b === "number")
      return a2.map((v) => v * b);
    return a2.map((v, i) => v * b[i]);
  }
  function divide(a2, b) {
    if (typeof b === "number")
      return a2.map((v) => v / b);
    return a2.map((v, i) => v / b[i]);
  }
  function dot2(a2, b) {
    return a2.reduce((sum, v, i) => sum + v * b[i], 0);
  }
  function cross(a2, b) {
    const a22 = toVector3(a2);
    const b2 = toVector3(b);
    return [a22[1] * b2[2] - a22[2] * b2[1], a22[2] * b2[0] - a22[0] * b2[2], a22[0] * b2[1] - a22[1] * b2[0]];
  }
  function scale2(a2, s) {
    return a2.map((v) => v * s);
  }
  function distance2(a2, b) {
    return Math.sqrt(a2.reduce((sum, v, i) => sum + Math.pow(v - b[i] || 0, 2), 0));
  }
  function manhattanDistance(a2, b) {
    return a2.reduce((sum, v, i) => sum + Math.abs(v - b[i]), 0);
  }
  function normalize2(a2) {
    const length = a2.reduce((sum, v) => sum + Math.pow(v, 2), 0);
    return a2.map((v) => v / Math.sqrt(length));
  }
  function angle(a2, b, clockwise = false) {
    const determinant2 = a2[0] * b[1] - a2[1] * b[0];
    let angle2 = Math.acos(multiply(a2, b).reduce((sum, v) => sum + v, 0) / (distance2(a2, VECTOR_ZERO) * distance2(b, VECTOR_ZERO)));
    if (clockwise && determinant2 < 0) {
      angle2 = 2 * Math.PI - angle2;
    }
    return angle2;
  }
  function perpendicular(a2, clockwise = true) {
    return clockwise ? [-a2[1], a2[0]] : [a2[1], -a2[0]];
  }
  function mod2(a2, b) {
    return a2.map((v) => v % b);
  }
  function toVector2(a2) {
    return [a2[0], a2[1]];
  }
  function toVector3(a2) {
    return isVector2(a2) ? [a2[0], a2[1], 0] : a2;
  }
  function rad(a2) {
    const [x3, y3] = a2;
    if (!x3 && !y3)
      return 0;
    return Math.atan2(y3, x3);
  }
  function rotate2(a2, angle2) {
    const [dx, dy] = a2;
    if (angle2 % 360 === 0)
      return [dx, dy];
    const rad2 = angle2 * Math.PI / 180;
    const cos = Math.cos(rad2);
    const sin = Math.sin(rad2);
    return [dx * cos - dy * sin, dx * sin + dy * cos];
  }

  // node_modules/@antv/g6/esm/utils/line.js
  function isLinesParallel(l1, l2) {
    const [p1, p2] = l1;
    const [p3, p4] = l2;
    const v1 = subtract(p1, p2);
    const v2 = subtract(p3, p4);
    return cross(v1, v2).every((v) => v === 0);
  }
  function getLinesIntersection(l1, l2, extended = false) {
    if (isLinesParallel(l1, l2))
      return void 0;
    const [p1, p2] = l1;
    const [p3, p4] = l2;
    const t = ((p1[0] - p3[0]) * (p3[1] - p4[1]) - (p1[1] - p3[1]) * (p3[0] - p4[0])) / ((p1[0] - p2[0]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] - p4[0]));
    const u = p4[0] - p3[0] ? (p1[0] - p3[0] + t * (p2[0] - p1[0])) / (p4[0] - p3[0]) : (p1[1] - p3[1] + t * (p2[1] - p1[1])) / (p4[1] - p3[1]);
    if (!extended && (!isBetween(t, 0, 1) || !isBetween(u, 0, 1)))
      return void 0;
    return [p1[0] + t * (p2[0] - p1[0]), p1[1] + t * (p2[1] - p1[1])];
  }

  // node_modules/@antv/g6/esm/utils/placement.js
  function parsePlacement(placement) {
    if (Array.isArray(placement)) {
      return isBetween(placement[0], 0, 1) && isBetween(placement[1], 0, 1) ? placement : [0.5, 0.5];
    }
    const direction2 = placement.split("-");
    const x3 = direction2.includes("left") ? 0 : direction2.includes("right") ? 1 : 0.5;
    const y3 = direction2.includes("top") ? 0 : direction2.includes("bottom") ? 1 : 0.5;
    return [x3, y3];
  }

  // node_modules/@antv/g6/esm/utils/position.js
  function positionOf(datum) {
    const { x: x3 = 0, y: y3 = 0, z = 0 } = datum.style || {};
    return [+x3, +y3, +z];
  }
  function hasPosition(datum) {
    const { x: x3, y: y3, z } = datum.style || {};
    return x3 !== void 0 || y3 !== void 0 || z !== void 0;
  }
  function getXYByRelativePlacement(bbox, placement) {
    const [x3, y3] = placement;
    const { min: min4, max: max4 } = bbox;
    return [min4[0] + x3 * (max4[0] - min4[0]), min4[1] + y3 * (max4[1] - min4[1])];
  }
  function getXYByPlacement(bbox, placement = "center") {
    const relativePlacement = parsePlacement(placement);
    return getXYByRelativePlacement(bbox, relativePlacement);
  }

  // node_modules/@antv/g6/esm/utils/point.js
  function parsePoint(point4) {
    var _a2;
    return [point4.x, point4.y, (_a2 = point4.z) !== null && _a2 !== void 0 ? _a2 : 0];
  }
  function toPointObject(point4) {
    var _a2;
    return { x: point4[0], y: point4[1], z: (_a2 = point4[2]) !== null && _a2 !== void 0 ? _a2 : 0 };
  }
  function round(point4, digits = 0) {
    return point4.map((p) => parseFloat(p.toFixed(digits)));
  }
  function moveTo(p, ref, distance6, reverse = false) {
    if ((0, import_util30.isEqual)(p, ref))
      return p;
    const direction2 = reverse ? subtract(p, ref) : subtract(ref, p);
    const normalizedDirection = normalize2(direction2);
    const moveVector = [normalizedDirection[0] * distance6, normalizedDirection[1] * distance6];
    return add(toVector2(p), moveVector);
  }
  function isHorizontal(p1, p2) {
    return p1[1] === p2[1];
  }
  function isVertical(p1, p2) {
    return p1[0] === p2[0];
  }
  function isOrthogonal(p1, p2) {
    return isHorizontal(p1, p2) || isVertical(p1, p2);
  }
  function isCollinear(p1, p2, p3) {
    return isLinesParallel([p1, p2], [p2, p3]);
  }
  function getSymmetricPoint(p, center) {
    return [2 * center[0] - p[0], 2 * center[1] - p[1]];
  }
  function getPolygonIntersectPoint(p, center, points, isRelativePos = true, useExtendedLine = false) {
    for (let i = 0; i < points.length; i++) {
      let start = points[i];
      let end = points[(i + 1) % points.length];
      if (isRelativePos) {
        start = add(center, start);
        end = add(center, end);
      }
      const refP = useExtendedLine ? getSymmetricPoint(p, center) : p;
      const intersect2 = getLinesIntersection([center, refP], [start, end]);
      if (intersect2) {
        return {
          point: intersect2,
          line: [start, end]
        };
      }
    }
    return {
      point: center,
      line: void 0
    };
  }
  function isPointInPolygon(point4, points, start, end) {
    const x3 = point4[0];
    const y3 = point4[1];
    let inside = false;
    if (start === void 0)
      start = 0;
    if (end === void 0)
      end = points.length;
    const len = end - start;
    for (let i = 0, j = len - 1; i < len; j = i++) {
      const xi = points[i + start][0];
      const yi = points[i + start][1];
      const xj = points[j + start][0];
      const yj = points[j + start][1];
      const intersect2 = yi > y3 !== yj > y3 && x3 < (xj - xi) * (y3 - yi) / (yj - yi) + xi;
      if (intersect2)
        inside = !inside;
    }
    return inside;
  }
  function getRectIntersectPoint(p, bbox, useExtendedLine = false) {
    const center = getXYByPlacement(bbox, "center");
    const corners = [
      getXYByPlacement(bbox, "left-top"),
      getXYByPlacement(bbox, "right-top"),
      getXYByPlacement(bbox, "right-bottom"),
      getXYByPlacement(bbox, "left-bottom")
    ];
    return getPolygonIntersectPoint(p, center, corners, false, useExtendedLine).point;
  }
  function getEllipseIntersectPoint(p, bbox, useExtendedLine = false) {
    const center = bbox.center;
    const refP = useExtendedLine ? getSymmetricPoint(p, center) : p;
    const vec = subtract(refP, bbox.center);
    const angle2 = Math.atan2(vec[1], vec[0]);
    if (isNaN(angle2))
      return center;
    const rx = getBBoxWidth(bbox) / 2;
    const ry = getBBoxHeight(bbox) / 2;
    const intersectX = center[0] + rx * Math.cos(angle2);
    const intersectY = center[1] + ry * Math.sin(angle2);
    return [intersectX, intersectY];
  }
  function findNearestPoints(group1, group2) {
    let minDistance = Infinity;
    let nearestPoints = [group1[0], group2[0]];
    group1.forEach((p1) => {
      group2.forEach((p2) => {
        const dist = distance2(p1, p2);
        if (dist < minDistance) {
          minDistance = dist;
          nearestPoints = [p1, p2];
        }
      });
    });
    return nearestPoints;
  }
  function findNearestLine(point4, lines) {
    let minDistance = Infinity;
    let nearestLine = [
      [0, 0],
      [0, 0]
    ];
    lines.forEach((line2) => {
      const distance6 = getDistanceToLine(point4, line2);
      if (distance6 < minDistance) {
        minDistance = distance6;
        nearestLine = line2;
      }
    });
    return nearestLine;
  }
  function getDistanceToLine(point4, line2) {
    const nearestPoint2 = findNearestPointOnLine(point4, line2);
    return distance2(point4, nearestPoint2);
  }
  function findNearestPointOnLine(point4, line2) {
    const [x1, y1] = line2[0];
    const [x22, y22] = line2[1];
    const [x3, y3] = point4;
    const px = x22 - x1;
    const py = y22 - y1;
    if (px === 0 && py === 0) {
      return [x1, y1];
    }
    let u = ((x3 - x1) * px + (y3 - y1) * py) / (px * px + py * py);
    if (u > 1) {
      u = 1;
    } else if (u < 0) {
      u = 0;
    }
    const x4 = x1 + u * px;
    const y4 = y1 + u * py;
    return [x4, y4];
  }
  function centerOf(points) {
    const totalPosition = points.reduce((acc, p) => add(acc, p), [0, 0]);
    return divide(totalPosition, points.length);
  }
  function sortByClockwise(points, clockwise = true) {
    const center = centerOf(points);
    return points.sort(([x1, y1], [x22, y22]) => {
      const angle1 = Math.atan2(y1 - center[1], x1 - center[0]);
      const angle2 = Math.atan2(y22 - center[1], x22 - center[0]);
      return clockwise ? angle2 - angle1 : angle1 - angle2;
    });
  }
  function getBoundingPoints(start, end) {
    return [start, [start[0], end[1]], end, [end[0], start[1]]];
  }

  // node_modules/@antv/g6/esm/utils/shortcut.js
  var import_util31 = __toESM(require_lib());

  // node_modules/@antv/g6/esm/utils/pinch.js
  var PinchHandler = class _PinchHandler {
    constructor(emitter, phase, callback) {
      this.phase = phase;
      this.pointerByTouch = [];
      this.initialDistance = null;
      this.emitter = emitter;
      if (_PinchHandler.instance) {
        _PinchHandler.callbacks[this.phase].push(callback);
        return _PinchHandler.instance;
      }
      this.onPointerDown = this.onPointerDown.bind(this);
      this.onPointerMove = this.onPointerMove.bind(this);
      this.onPointerUp = this.onPointerUp.bind(this);
      this.bindEvents();
      _PinchHandler.instance = this;
      _PinchHandler.callbacks[this.phase].push(callback);
    }
    bindEvents() {
      const { emitter } = this;
      emitter.on(CommonEvent.POINTER_DOWN, this.onPointerDown);
      emitter.on(CommonEvent.POINTER_MOVE, this.onPointerMove);
      emitter.on(CommonEvent.POINTER_UP, this.onPointerUp);
    }
    /**
     * <zh/> 更新指定指针的位置
     *
     * <en/> Update position of specified pointer
     * @param pointerId - <zh/> 指针唯一标识符 | <en/> Pointer unique identifier<sup>1</sup>
     * @param x - <zh/> 新的X坐标 | <en/> New X coordinate
     * @param y - <zh/> 新的Y坐标 | <en/> New Y coordinate
     */
    updatePointerPosition(pointerId, x3, y3) {
      const index2 = this.pointerByTouch.findIndex((p) => p.pointerId === pointerId);
      if (index2 >= 0) {
        this.pointerByTouch[index2] = { x: x3, y: y3, pointerId };
      }
    }
    /**
     * <zh/> 处理指针按下事件
     *
     * <en/> Handle pointer down event
     * @param event - <zh/> 指针事件对象 | <en/> Pointer event object
     * @remarks
     * <zh/> 当检测到两个触摸点时记录初始距离
     *
     * <en/> Record initial distance when detecting two touch points
     */
    onPointerDown(event) {
      const { x: x3, y: y3 } = event.client || {};
      if (x3 === void 0 || y3 === void 0)
        return;
      this.pointerByTouch.push({ x: x3, y: y3, pointerId: event.pointerId });
      if (event.pointerType === "touch" && this.pointerByTouch.length === 2) {
        _PinchHandler.isPinching = true;
        const dx = this.pointerByTouch[0].x - this.pointerByTouch[1].x;
        const dy = this.pointerByTouch[0].y - this.pointerByTouch[1].y;
        this.initialDistance = Math.sqrt(dx * dx + dy * dy);
        _PinchHandler.callbacks.pinchstart.forEach((cb) => cb(event, { scale: 0 }));
      }
    }
    /**
     * <zh/> 处理指针移动事件
     *
     * <en/> Handle pointer move event
     * @param event - <zh/> 指针事件对象 | <en/> Pointer event object
     * @remarks
     * <zh/> 当存在两个有效触摸点时计算缩放比例
     *
     * <en/> Calculate zoom ratio when two valid touch points exist
     */
    onPointerMove(event) {
      if (this.pointerByTouch.length !== 2 || this.initialDistance === null)
        return;
      const { x: x3, y: y3 } = event.client || {};
      if (x3 === void 0 || y3 === void 0)
        return;
      this.updatePointerPosition(event.pointerId, x3, y3);
      const dx = this.pointerByTouch[0].x - this.pointerByTouch[1].x;
      const dy = this.pointerByTouch[0].y - this.pointerByTouch[1].y;
      const currentDistance = Math.sqrt(dx * dx + dy * dy);
      const ratio = currentDistance / this.initialDistance;
      _PinchHandler.callbacks.pinchmove.forEach((cb) => cb(event, { scale: (ratio - 1) * 5 }));
    }
    /**
     * <zh/> 处理指针抬起事件
     *
     * <en/> Handle pointer up event
     * @param event
     * @remarks
     * <zh/> 重置触摸状态和初始距离
     *
     * <en/> Reset touch state and initial distance
     */
    onPointerUp(event) {
      var _a2;
      _PinchHandler.callbacks.pinchend.forEach((cb) => cb(event, { scale: 0 }));
      _PinchHandler.isPinching = false;
      this.initialDistance = null;
      this.pointerByTouch = [];
      (_a2 = _PinchHandler.instance) === null || _a2 === void 0 ? void 0 : _a2.tryDestroy();
    }
    /**
     * <zh/> 销毁捏合手势相关监听
     *
     * <en/> Destroy pinch gesture listeners
     * @remarks
     * <zh/> 移除指针按下、移动、抬起事件的监听
     *
     * <en/> Remove listeners for pointer down, move, and up events
     */
    destroy() {
      this.emitter.off(CommonEvent.POINTER_DOWN, this.onPointerDown);
      this.emitter.off(CommonEvent.POINTER_MOVE, this.onPointerMove);
      this.emitter.off(CommonEvent.POINTER_UP, this.onPointerUp);
      _PinchHandler.instance = null;
    }
    /**
     * <zh/> 解绑指定阶段的手势回调
     * <en/> Unregister gesture callback for specific phase
     * @param phase - <zh/> 手势阶段：开始(pinchstart)/移动(pinchmove)/结束(pinchend) | <en/> Gesture phase: start/move/end
     * @param callback - <zh/> 要解绑的回调函数 | <en/> Callback function to unregister
     * @remarks
     * <zh/> 从指定阶段的回调列表中移除特定回调，当所有回调都解绑后自动销毁事件监听
     * <en/> Remove specific callback from the phase's callback list, auto-destroy event listeners when all callbacks are unregistered
     */
    off(phase, callback) {
      const index2 = _PinchHandler.callbacks[phase].indexOf(callback);
      if (index2 > -1)
        _PinchHandler.callbacks[phase].splice(index2, 1);
      this.tryDestroy();
    }
    /**
     * <zh/> 尝试销毁手势处理器
     * <en/> Attempt to destroy the gesture handler
     * @remarks
     * <zh/> 当所有阶段（开始/移动/结束）的回调列表都为空时，执行实际销毁操作
     * <en/> Perform actual destruction when all phase (pinchstart/pinchmove/pinchend) callback lists are empty
     * <zh/> 自动解除事件监听并重置单例实例
     * <en/> Automatically remove event listeners and reset singleton instance
     */
    tryDestroy() {
      if (Object.values(_PinchHandler.callbacks).every((arr) => arr.length === 0)) {
        this.destroy();
      }
    }
  };
  PinchHandler.isPinching = false;
  PinchHandler.instance = null;
  PinchHandler.callbacks = { pinchstart: [], pinchmove: [], pinchend: [] };

  // node_modules/@antv/g6/esm/utils/shortcut.js
  var lowerCaseKeys = (keys) => keys.map((key) => (0, import_util31.isString)(key) ? key.toLocaleLowerCase() : key);
  var Shortcut = class {
    constructor(emitter) {
      this.map = /* @__PURE__ */ new Map();
      this.boundHandlePinch = () => {
      };
      this.recordKey = /* @__PURE__ */ new Set();
      this.onKeyDown = (event) => {
        if (!(event === null || event === void 0 ? void 0 : event.key))
          return;
        this.recordKey.add(event.key);
        this.trigger(event);
      };
      this.onKeyUp = (event) => {
        if (!(event === null || event === void 0 ? void 0 : event.key))
          return;
        this.recordKey.delete(event.key);
      };
      this.onWheel = (event) => {
        this.triggerExtendKey(CommonEvent.WHEEL, event);
      };
      this.onDrag = (event) => {
        this.triggerExtendKey(CommonEvent.DRAG, event);
      };
      this.handlePinch = (event, options) => {
        this.triggerExtendKey(CommonEvent.PINCH, Object.assign(Object.assign({}, event), options));
      };
      this.onFocus = () => {
        this.recordKey.clear();
      };
      this.emitter = emitter;
      this.bindEvents();
    }
    bind(key, handler) {
      if (key.length === 0)
        return;
      if (key.includes(CommonEvent.PINCH) && !this.pinchHandler) {
        this.boundHandlePinch = this.handlePinch.bind(this);
        this.pinchHandler = new PinchHandler(this.emitter, "pinchmove", this.boundHandlePinch);
      }
      this.map.set(key, handler);
    }
    unbind(key, handler) {
      this.map.forEach((h, k) => {
        if ((0, import_util31.isEqual)(k, key)) {
          if (!handler || handler === h)
            this.map.delete(k);
        }
      });
    }
    unbindAll() {
      this.map.clear();
    }
    match(key) {
      const recordKeyList = lowerCaseKeys(Array.from(this.recordKey)).sort();
      const keyList = lowerCaseKeys(key).sort();
      return (0, import_util31.isEqual)(recordKeyList, keyList);
    }
    bindEvents() {
      var _a2;
      const { emitter } = this;
      emitter.on(CommonEvent.KEY_DOWN, this.onKeyDown);
      emitter.on(CommonEvent.KEY_UP, this.onKeyUp);
      emitter.on(CommonEvent.WHEEL, this.onWheel);
      emitter.on(CommonEvent.DRAG, this.onDrag);
      (_a2 = globalThis.addEventListener) === null || _a2 === void 0 ? void 0 : _a2.call(globalThis, "focus", this.onFocus);
    }
    trigger(event) {
      this.map.forEach((handler, key) => {
        if (this.match(key))
          handler(event);
      });
    }
    /**
     * <zh/> 扩展 wheel, drag 操作
     *
     * <en/> Extend wheel, drag operations
     * @param eventType - event name
     * @param event - event
     */
    triggerExtendKey(eventType, event) {
      this.map.forEach((handler, key) => {
        if (key.includes(eventType)) {
          if ((0, import_util31.isEqual)(Array.from(this.recordKey), key.filter((k) => k !== eventType))) {
            handler(event);
          }
        }
      });
    }
    destroy() {
      var _a2, _b;
      this.unbindAll();
      this.emitter.off(CommonEvent.KEY_DOWN, this.onKeyDown);
      this.emitter.off(CommonEvent.KEY_UP, this.onKeyUp);
      this.emitter.off(CommonEvent.WHEEL, this.onWheel);
      this.emitter.off(CommonEvent.DRAG, this.onDrag);
      (_a2 = this.pinchHandler) === null || _a2 === void 0 ? void 0 : _a2.off("pinchmove", this.boundHandlePinch);
      (_b = globalThis.removeEventListener) === null || _b === void 0 ? void 0 : _b.call(globalThis, "blur", this.onFocus);
    }
  };

  // node_modules/@antv/g6/esm/behaviors/brush-select.js
  var BrushSelect = class _BrushSelect extends BaseBehavior {
    constructor(context, options) {
      super(context, (0, import_util32.deepMix)({}, _BrushSelect.defaultOptions, options));
      this.shortcut = new Shortcut(context.graph);
      this.onPointerDown = this.onPointerDown.bind(this);
      this.onPointerMove = this.onPointerMove.bind(this);
      this.onPointerUp = this.onPointerUp.bind(this);
      this.clearStates = this.clearStates.bind(this);
      this.bindEvents();
    }
    /**
     * Triggered when the pointer is pressed
     * @param event - Pointer event
     * @internal
     */
    onPointerDown(event) {
      if (!this.validate(event) || !this.isKeydown() || this.startPoint)
        return;
      const { canvas: canvas2, graph } = this.context;
      const style = Object.assign({}, this.options.style);
      if (this.options.style.lineWidth) {
        style.lineWidth = +this.options.style.lineWidth / graph.getZoom();
      }
      this.rectShape = new Rect({ id: "g6-brush-select", style });
      canvas2.appendChild(this.rectShape);
      this.startPoint = [event.canvas.x, event.canvas.y];
    }
    /**
     * Triggered when the pointer is moved
     * @param event - Pointer event
     * @internal
     */
    onPointerMove(event) {
      var _a2;
      if (!this.startPoint)
        return;
      const { immediately, mode } = this.options;
      this.endPoint = getCursorPoint(event, this.context.graph);
      (_a2 = this.rectShape) === null || _a2 === void 0 ? void 0 : _a2.attr({
        x: Math.min(this.endPoint[0], this.startPoint[0]),
        y: Math.min(this.endPoint[1], this.startPoint[1]),
        width: Math.abs(this.endPoint[0] - this.startPoint[0]),
        height: Math.abs(this.endPoint[1] - this.startPoint[1])
      });
      if (immediately && mode === "default")
        this.updateElementsStates(getBoundingPoints(this.startPoint, this.endPoint));
    }
    /**
     * Triggered when the pointer is released
     * @param event - Pointer event
     * @internal
     */
    onPointerUp(event) {
      if (!this.startPoint)
        return;
      if (!this.endPoint) {
        this.clearBrush();
        return;
      }
      this.endPoint = getCursorPoint(event, this.context.graph);
      this.updateElementsStates(getBoundingPoints(this.startPoint, this.endPoint));
      this.clearBrush();
    }
    /**
     * <zh/> 清除状态
     *
     * <en/> Clear state
     * @internal
     */
    clearStates() {
      if (this.endPoint)
        return;
      this.clearElementsStates();
    }
    /**
     * <zh/> 清除画布上所有元素的状态
     *
     * <en/> Clear the state of all elements on the canvas
     * @internal
     */
    clearElementsStates() {
      const { graph } = this.context;
      const states = Object.values(graph.getData()).reduce((acc, data2) => {
        return Object.assign({}, acc, data2.reduce((acc2, datum) => {
          var _a2;
          const restStates = (_a2 = datum.states || []) === null || _a2 === void 0 ? void 0 : _a2.filter((state) => state !== this.options.state);
          acc2[idOf(datum)] = restStates;
          return acc2;
        }, {}));
      }, {});
      graph.setElementState(states, this.options.animation);
    }
    /**
     * <zh/> 更新选中的元素状态
     *
     * <en/> Update the state of the selected elements
     * @param points - <zh/> 框选区域的顶点 | <en/> The vertex of the selection area
     * @internal
     */
    updateElementsStates(points) {
      const { graph } = this.context;
      const { enableElements, state, mode, onSelect } = this.options;
      const selectedIds = this.selector(graph, points, enableElements);
      let states = {};
      switch (mode) {
        case "union":
          selectedIds.forEach((id3) => {
            states[id3] = [...graph.getElementState(id3), state];
          });
          break;
        case "diff":
          selectedIds.forEach((id3) => {
            const prevStates = graph.getElementState(id3);
            states[id3] = prevStates.includes(state) ? prevStates.filter((s) => s !== state) : [...prevStates, state];
          });
          break;
        case "intersect":
          selectedIds.forEach((id3) => {
            const prevStates = graph.getElementState(id3);
            states[id3] = prevStates.includes(state) ? [state] : [];
          });
          break;
        case "default":
        default:
          selectedIds.forEach((id3) => {
            states[id3] = [state];
          });
          break;
      }
      if ((0, import_util32.isFunction)(onSelect))
        states = onSelect(states);
      graph.setElementState(states, this.options.animation);
    }
    /**
     * <zh/> 查找画布上在指定区域内显示的元素。当节点的包围盒中心在矩形内时，节点被选中；当边的两端节点在矩形内时，边被选中；当 combo 的包围盒中心在矩形内时，combo 被选中。
     *
     * <en/> Find the elements displayed in the specified area on the canvas. A node is selected if the center of its bbox is inside the rect; An edge is selected if both end nodes are inside the rect ;A combo is selected if the center of its bbox is inside the rect.
     * @param graph - <zh/> 图实例 | <en/> Graph instance
     * @param points - <zh/> 框选区域的顶点 | <en/> The vertex of the selection area
     * @param itemTypes - <zh/> 元素类型 | <en/> Element type
     * @returns <zh/> 选中的元素 ID 数组 | <en/> Selected element ID array
     * @internal
     */
    selector(graph, points, itemTypes) {
      if (!itemTypes || itemTypes.length === 0)
        return [];
      const elements = [];
      const graphData = graph.getData();
      itemTypes.forEach((itemType) => {
        graphData[`${itemType}s`].forEach((datum) => {
          const id3 = idOf(datum);
          if (graph.getElementVisibility(id3) !== "hidden" && isPointInPolygon(graph.getElementPosition(id3), points)) {
            elements.push(id3);
          }
        });
      });
      if (itemTypes.includes("edge")) {
        const edges = graphData.edges;
        edges === null || edges === void 0 ? void 0 : edges.forEach((edge) => {
          const { source, target } = edge;
          if (elements.includes(source) && elements.includes(target)) {
            elements.push(idOf(edge));
          }
        });
      }
      return elements;
    }
    clearBrush() {
      var _a2;
      (_a2 = this.rectShape) === null || _a2 === void 0 ? void 0 : _a2.remove();
      this.rectShape = void 0;
      this.startPoint = void 0;
      this.endPoint = void 0;
    }
    /**
     * <zh/> 当前按键是否和 trigger 配置一致
     *
     * <en/> Is the current key consistent with the trigger configuration
     * @returns <zh/> 是否一致 | <en/> Is consistent
     * @internal
     */
    isKeydown() {
      const { trigger } = this.options;
      const keys = Array.isArray(trigger) ? trigger : [trigger];
      return this.shortcut.match(keys.filter((key) => key !== "drag"));
    }
    /**
     * <zh/> 验证是否启用框选
     *
     * <en/> Verify whether brush select is enabled
     * @param event - <zh/> 事件 | <en/> Event
     * @returns <zh/> 是否启用 | <en/> Whether to enable
     * @internal
     */
    validate(event) {
      if (this.destroyed)
        return false;
      const { enable } = this.options;
      if ((0, import_util32.isFunction)(enable))
        return enable(event);
      return !!enable;
    }
    bindEvents() {
      const { graph } = this.context;
      graph.on(CommonEvent.POINTER_DOWN, this.onPointerDown);
      graph.on(CommonEvent.POINTER_MOVE, this.onPointerMove);
      graph.on(CommonEvent.POINTER_UP, this.onPointerUp);
      graph.on(CanvasEvent2.CLICK, this.clearStates);
    }
    unbindEvents() {
      const { graph } = this.context;
      graph.off(CommonEvent.POINTER_DOWN, this.onPointerDown);
      graph.off(CommonEvent.POINTER_MOVE, this.onPointerMove);
      graph.off(CommonEvent.POINTER_UP, this.onPointerUp);
      graph.off(CanvasEvent2.CLICK, this.clearStates);
    }
    /**
     * <zh/> 更新配置项
     *
     * <en/> Update configuration
     * @param options - <zh/> 配置项 | <en/> Options
     * @internal
     */
    update(options) {
      this.unbindEvents();
      this.options = (0, import_util32.deepMix)(this.options, options);
      this.bindEvents();
    }
    /**
     * <zh/> 销毁
     *
     * <en/> Destroy
     * @internal
     */
    destroy() {
      this.unbindEvents();
      super.destroy();
    }
  };
  BrushSelect.defaultOptions = {
    animation: false,
    enable: true,
    enableElements: ["node", "combo", "edge"],
    immediately: false,
    mode: "default",
    state: "selected",
    trigger: ["shift"],
    style: {
      width: 0,
      height: 0,
      lineWidth: 1,
      fill: "#1677FF",
      stroke: "#1677FF",
      fillOpacity: 0.1,
      zIndex: 2,
      pointerEvents: "none"
    }
  };
  var getCursorPoint = (event, graph) => {
    if ((event.targetType === "node" || event.targetType === "combo") && !(event.nativeEvent.target instanceof HTMLCanvasElement)) {
      const [x3, y3] = graph.getCanvasByClient([event.client.x, event.client.y]);
      return [x3, y3];
    }
    return [event.canvas.x, event.canvas.y];
  };

  // node_modules/@antv/g6/esm/behaviors/click-select.js
  var import_util33 = __toESM(require_lib());

  // node_modules/@antv/g6/esm/constants/element.js
  var ICON_SIZE_RATIO = 0.8;
  var ELEMENT_TYPES = ["node", "edge", "combo"];

  // node_modules/@antv/g6/esm/utils/traverse.js
  function dfs(node, visitor, navigator, mode, depth = 0) {
    if (mode === "TB")
      visitor(node, depth);
    const children = navigator(node);
    if (children) {
      for (const child of children) {
        dfs(child, visitor, navigator, mode, depth + 1);
      }
    }
    if (mode === "BT")
      visitor(node, depth);
  }
  function bfs(node, visitor, navigator) {
    const queue = [[node, 0]];
    while (queue.length) {
      const [current2, depth] = queue.shift();
      visitor(current2, depth);
      const children = navigator(current2);
      if (children) {
        for (const child of children) {
          queue.push([child, depth + 1]);
        }
      }
    }
  }

  // node_modules/@antv/g6/esm/utils/relation.js
  function getElementNthDegreeIds(graph, elementType, elementId, degree3, direction2 = "both") {
    if (elementType === "combo" || elementType === "node") {
      return getNodeNthDegreeIds(graph, elementId, degree3, direction2);
    }
    const edgeData = graph.getEdgeData(elementId);
    if (!edgeData)
      return [];
    const sourceRelations = getNodeNthDegreeIds(graph, edgeData.source, degree3 - 1, direction2);
    const targetRelations = getNodeNthDegreeIds(graph, edgeData.target, degree3 - 1, direction2);
    return Array.from(/* @__PURE__ */ new Set([...sourceRelations, ...targetRelations, elementId]));
  }
  function getNodeNthDegreeIds(graph, startNodeId, degree3, direction2 = "both") {
    const visitedNodes = /* @__PURE__ */ new Set();
    const visitedEdges = /* @__PURE__ */ new Set();
    const relations = /* @__PURE__ */ new Set();
    bfs(startNodeId, (nodeId, depth) => {
      if (depth > degree3)
        return;
      relations.add(nodeId);
      graph.getRelatedEdgesData(nodeId, direction2).forEach((edge) => {
        const edgeId = idOf(edge);
        if (!visitedEdges.has(edgeId) && depth < degree3) {
          relations.add(edgeId);
          visitedEdges.add(edgeId);
        }
      });
    }, (nodeId) => {
      return graph.getRelatedEdgesData(nodeId, direction2).map((edge) => edge.source === nodeId ? edge.target : edge.source).filter((neighborNodeId) => {
        if (!visitedNodes.has(neighborNodeId)) {
          visitedNodes.add(neighborNodeId);
          return true;
        }
        return false;
      });
    });
    return Array.from(relations);
  }

  // node_modules/@antv/g6/esm/utils/state.js
  function statesOf(datum) {
    return datum.states || [];
  }

  // node_modules/@antv/g6/esm/behaviors/click-select.js
  var __awaiter2 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var ClickSelect = class _ClickSelect extends BaseBehavior {
    constructor(context, options) {
      super(context, Object.assign({}, _ClickSelect.defaultOptions, options));
      this.onClickSelect = (event) => __awaiter2(this, void 0, void 0, function* () {
        var _a2, _b;
        if (!this.validate(event))
          return;
        yield this.updateState(event);
        (_b = (_a2 = this.options).onClick) === null || _b === void 0 ? void 0 : _b.call(_a2, event);
      });
      this.onClickCanvas = (event) => __awaiter2(this, void 0, void 0, function* () {
        var _a2, _b;
        if (!this.validate(event))
          return;
        yield this.clearState();
        (_b = (_a2 = this.options).onClick) === null || _b === void 0 ? void 0 : _b.call(_a2, event);
      });
      this.shortcut = new Shortcut(context.graph);
      this.bindEvents();
    }
    bindEvents() {
      const { graph } = this.context;
      this.unbindEvents();
      ELEMENT_TYPES.forEach((type) => {
        graph.on(`${type}:${CommonEvent.CLICK}`, this.onClickSelect);
      });
      graph.on(CanvasEvent2.CLICK, this.onClickCanvas);
    }
    get isMultipleSelect() {
      const { multiple, trigger } = this.options;
      return multiple && this.shortcut.match(trigger);
    }
    getNeighborIds(event) {
      const { target, targetType } = event;
      const { graph } = this.context;
      const { degree: degree3 } = this.options;
      return getElementNthDegreeIds(graph, targetType, target.id, typeof degree3 === "function" ? degree3(event) : degree3).filter((id3) => id3 !== target.id);
    }
    updateState(event) {
      return __awaiter2(this, void 0, void 0, function* () {
        const { state: selectState, unselectedState, neighborState, animation } = this.options;
        if (!selectState && !neighborState && !unselectedState)
          return;
        const { target } = event;
        const { graph } = this.context;
        const datum = graph.getElementData(target.id);
        const type = statesOf(datum).includes(selectState) ? "unselect" : "select";
        const states = {};
        const isMultipleSelect = this.isMultipleSelect;
        const click = [target.id];
        const neighbor = this.getNeighborIds(event);
        if (!isMultipleSelect) {
          if (type === "select") {
            Object.assign(states, this.getClearStates(!!unselectedState));
            const addState = (list, state) => {
              list.forEach((id3) => {
                if (!states[id3])
                  states[id3] = graph.getElementState(id3);
                states[id3].push(state);
              });
            };
            addState(click, selectState);
            addState(neighbor, neighborState);
            if (unselectedState) {
              Object.keys(states).forEach((id3) => {
                if (!click.includes(id3) && !neighbor.includes(id3))
                  states[id3].push(unselectedState);
              });
            }
          } else
            Object.assign(states, this.getClearStates());
        } else {
          Object.assign(states, this.getDataStates());
          if (type === "select") {
            const addState = (list, state) => {
              list.forEach((id3) => {
                const dataStatesSet = new Set(graph.getElementState(id3));
                dataStatesSet.add(state);
                dataStatesSet.delete(unselectedState);
                states[id3] = Array.from(dataStatesSet);
              });
            };
            addState(click, selectState);
            addState(neighbor, neighborState);
            if (unselectedState) {
              Object.keys(states).forEach((id3) => {
                const _states = states[id3];
                if (!_states.includes(selectState) && !_states.includes(neighborState) && !_states.includes(unselectedState)) {
                  states[id3].push(unselectedState);
                }
              });
            }
          } else {
            const targetState = states[target.id];
            states[target.id] = targetState.filter((s) => s !== selectState && s !== neighborState);
            if (!targetState.includes(unselectedState))
              states[target.id].push(unselectedState);
            neighbor.forEach((id3) => {
              states[id3] = states[id3].filter((s) => s !== neighborState);
              if (!states[id3].includes(selectState))
                states[id3].push(unselectedState);
            });
          }
        }
        yield graph.setElementState(states, animation);
      });
    }
    getDataStates() {
      const { graph } = this.context;
      const { nodes, edges, combos } = graph.getData();
      const states = {};
      [...nodes, ...edges, ...combos].forEach((data2) => {
        states[idOf(data2)] = statesOf(data2);
      });
      return states;
    }
    /**
     * <zh/> 获取需要清除的状态
     *
     * <en/> Get the states that need to be cleared
     * @param complete - <zh/> 是否返回所有状态 | <en/> Whether to return all states
     * @returns - <zh/> 需要清除的状态 | <en/> States that need to be cleared
     */
    getClearStates(complete = false) {
      const { graph } = this.context;
      const { state, unselectedState, neighborState } = this.options;
      const statesToClear = /* @__PURE__ */ new Set([state, unselectedState, neighborState]);
      const { nodes, edges, combos } = graph.getData();
      const states = {};
      [...nodes, ...edges, ...combos].forEach((data2) => {
        const datumStates = statesOf(data2);
        const newStates = datumStates.filter((s) => !statesToClear.has(s));
        if (complete)
          states[idOf(data2)] = newStates;
        else if (newStates.length !== datumStates.length)
          states[idOf(data2)] = newStates;
      });
      return states;
    }
    clearState() {
      return __awaiter2(this, void 0, void 0, function* () {
        const { graph } = this.context;
        yield graph.setElementState(this.getClearStates(), this.options.animation);
      });
    }
    validate(event) {
      if (this.destroyed)
        return false;
      const { enable } = this.options;
      if ((0, import_util33.isFunction)(enable))
        return enable(event);
      return !!enable;
    }
    unbindEvents() {
      const { graph } = this.context;
      ELEMENT_TYPES.forEach((type) => {
        graph.off(`${type}:${CommonEvent.CLICK}`, this.onClickSelect);
      });
      graph.off(CanvasEvent2.CLICK, this.onClickCanvas);
    }
    destroy() {
      this.unbindEvents();
      super.destroy();
    }
  };
  ClickSelect.defaultOptions = {
    animation: true,
    enable: true,
    multiple: false,
    trigger: ["shift"],
    state: "selected",
    neighborState: "selected",
    unselectedState: void 0,
    degree: 0
  };

  // node_modules/@antv/g6/esm/behaviors/collapse-expand.js
  var import_util53 = __toESM(require_lib());

  // node_modules/@antv/g6/esm/utils/collapsibility.js
  function isCollapsed(nodeLike) {
    var _a2;
    return !!((_a2 = nodeLike.style) === null || _a2 === void 0 ? void 0 : _a2.collapsed);
  }

  // node_modules/@antv/g6/esm/utils/element.js
  var import_util52 = __toESM(require_lib());

  // node_modules/@antv/g6/esm/elements/combos/base-combo.js
  var import_util47 = __toESM(require_lib());

  // node_modules/@antv/g6/esm/utils/prefix.js
  var import_util34 = __toESM(require_lib());
  function startsWith(str, prefix) {
    if (!str.startsWith(prefix))
      return false;
    const nextChart = str[prefix.length];
    return nextChart >= "A" && nextChart <= "Z";
  }
  function addPrefix(str, prefix) {
    return `${prefix}${(0, import_util34.upperFirst)(str)}`;
  }
  function removePrefix(string, prefix, lowercaseFirstLetter = true) {
    if (!prefix)
      return string;
    if (!startsWith(string, prefix))
      return string;
    const str = string.slice(prefix.length);
    return lowercaseFirstLetter ? (0, import_util34.lowerFirst)(str) : str;
  }
  function subStyleProps(style, prefix) {
    const subStyle = Object.entries(style).reduce((acc, [key, value]) => {
      if (key === "className" || key === "class")
        return acc;
      if (startsWith(key, prefix)) {
        Object.assign(acc, { [removePrefix(key, prefix)]: value });
      }
      return acc;
    }, {});
    if ("opacity" in style) {
      const subOpacityKey = addPrefix("opacity", prefix);
      const opacity = style.opacity;
      if (subOpacityKey in style) {
        const subOpacity = style[subOpacityKey];
        Object.assign(subStyle, { opacity: opacity * subOpacity });
      } else
        Object.assign(subStyle, { opacity });
    }
    return subStyle;
  }
  function subObject(obj, prefix) {
    const prefixLength = prefix.length;
    return Object.keys(obj).reduce((acc, key) => {
      if (key.startsWith(prefix)) {
        const newKey = key.slice(prefixLength);
        acc[newKey] = obj[key];
      }
      return acc;
    }, {});
  }
  function omitStyleProps(style, prefix) {
    const prefixArray = typeof prefix === "string" ? [prefix] : prefix;
    const omitStyle = {};
    Object.keys(style).forEach((key) => {
      if (!prefixArray.find((p) => key.startsWith(p))) {
        omitStyle[key] = style[key];
      }
    });
    return omitStyle;
  }

  // node_modules/@antv/g6/esm/utils/size.js
  function parseSize(size2 = 0) {
    if (typeof size2 === "number")
      return [size2, size2, size2];
    const [x3, y3 = x3, z = x3] = size2;
    return [x3, y3, z];
  }

  // node_modules/@antv/g6/esm/utils/style.js
  var __rest3 = function(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  function computeElementCallbackStyle(callableStyle, context) {
    const { datum, graph } = context;
    if (typeof callableStyle === "function")
      return callableStyle.call(graph, datum);
    return Object.fromEntries(Object.entries(callableStyle).map(([key, style]) => {
      if (typeof style === "function")
        return [key, style.call(graph, datum)];
      return [key, style];
    }));
  }
  function mergeOptions(defaultOptions4, modifiedOptions) {
    const s1 = (defaultOptions4 === null || defaultOptions4 === void 0 ? void 0 : defaultOptions4.style) || {};
    const s2 = (modifiedOptions === null || modifiedOptions === void 0 ? void 0 : modifiedOptions.style) || {};
    for (const key in s1) {
      if (!(key in s2))
        s2[key] = s1[key];
    }
    return Object.assign({}, defaultOptions4, modifiedOptions, {
      style: s2
    });
  }
  function getSubShapeStyle(style) {
    const { x: x3, y: y3, z, class: cls, className, transform, transformOrigin, zIndex, visibility: visibility2 } = style, rest = __rest3(style, ["x", "y", "z", "class", "className", "transform", "transformOrigin", "zIndex", "visibility"]);
    return rest;
  }

  // node_modules/@antv/g6/esm/utils/node.js
  function inferIconStyle(size2, iconStyle) {
    const stdSize = parseSize(size2);
    let style = {};
    if (iconStyle.text && !iconStyle.fontSize)
      style = { fontSize: Math.min(...stdSize) * 0.5 };
    if (iconStyle.src && (!iconStyle.width || !iconStyle.height))
      style = { width: stdSize[0] * 0.5, height: stdSize[1] * 0.5 };
    return style;
  }

  // node_modules/@antv/g6/esm/utils/palette.js
  var import_util35 = __toESM(require_lib());
  function parsePalette(palette) {
    if (!palette)
      return void 0;
    if (
      // 色板名 palette name
      typeof palette === "string" || // 插值函数 interpolate function
      typeof palette === "function" || // 颜色数组 color array
      Array.isArray(palette)
    ) {
      return {
        type: "group",
        field: (d2) => d2.id,
        color: palette,
        invert: false
      };
    }
    return palette;
  }
  function assignColorByPalette(data2, palette) {
    if (!palette)
      return {};
    const { type, color: colorPalette, field, invert } = palette;
    const assignColor = (args) => {
      const palette2 = typeof colorPalette === "string" ? getExtension("palette", colorPalette) : colorPalette;
      if (typeof palette2 === "function") {
        const result = {};
        args.forEach(([id3, value]) => {
          result[id3] = palette2(invert ? 1 - value : value);
        });
        return result;
      } else if (Array.isArray(palette2)) {
        const colors = invert ? [...palette2].reverse() : palette2;
        const result = {};
        args.forEach(([id3, index2]) => {
          result[id3] = colors[index2 % palette2.length];
        });
        return result;
      }
      return {};
    };
    const parseField = (field2, datum) => {
      var _a2;
      return typeof field2 === "string" ? (_a2 = datum.data) === null || _a2 === void 0 ? void 0 : _a2[field2] : field2 === null || field2 === void 0 ? void 0 : field2(datum);
    };
    if (type === "group") {
      const groupData = (0, import_util35.groupBy)(data2, (datum) => {
        if (!field)
          return "default";
        const key = parseField(field, datum);
        return key ? String(key) : "default";
      });
      const groupKeys = Object.keys(groupData);
      const assignResult = assignColor(groupKeys.map((key, index2) => [key, index2]));
      const result = {};
      Object.entries(groupData).forEach(([groupKey, groupData2]) => {
        groupData2.forEach((datum) => {
          result[idOf(datum)] = assignResult[groupKey];
        });
      });
      return result;
    } else if (type === "value") {
      const [min4, max4] = data2.reduce(([min5, max5], datum) => {
        const value = parseField(field, datum);
        if (typeof value !== "number")
          throw new Error(format(`Palette field ${field} is not a number`));
        return [Math.min(min5, value), Math.max(max5, value)];
      }, [Infinity, -Infinity]);
      const range = max4 - min4;
      return assignColor(data2.map((datum) => [datum.id, (parseField(field, datum) - min4) / range]));
    }
  }
  function getPaletteColors(colorPalette) {
    const palette = typeof colorPalette === "string" ? getExtension("palette", colorPalette) : colorPalette;
    if (typeof palette === "function")
      return void 0;
    return palette;
  }

  // node_modules/@antv/g6/esm/utils/text.js
  function getWordWrapWidthWithBase(length, maxWidth) {
    let wordWrapWidth = 2 * length;
    if (typeof maxWidth === "string") {
      wordWrapWidth = length * Number(maxWidth.replace("%", "")) / 100;
    } else if (typeof maxWidth === "number") {
      wordWrapWidth = maxWidth;
    }
    if (isNaN(wordWrapWidth))
      wordWrapWidth = 2 * length;
    return wordWrapWidth;
  }
  function getWordWrapWidthByBox(keyShapeBox, maxWidth, zoom = 1, enableBalanceShape = false) {
    const balanceZoom = enableBalanceShape ? zoom : 1;
    const keyShapeWidth = (keyShapeBox.max[0] - keyShapeBox.min[0]) * balanceZoom;
    return getWordWrapWidthWithBase(keyShapeWidth, maxWidth);
  }
  function getWordWrapWidthByEnds(points, maxWidth, zoom = 1) {
    const dist = distance2(points[0], points[1]) * zoom;
    return getWordWrapWidthWithBase(dist, maxWidth);
  }

  // node_modules/@antv/g6/esm/elements/shapes/base-shape.js
  var import_util36 = __toESM(require_lib());
  var BaseShape = class extends CustomElement {
    constructor(options) {
      applyTransform(options.style);
      super(options);
      this.shapeMap = {};
      this.animateMap = {};
      this.render(this.attributes, this);
      this.setVisibility();
      this.bindEvents();
    }
    /**
     * <zh/> 解析后的属性
     *
     * <en/> parsed attributes
     * @returns <zh/> 解析后的属性 | <en/> parsed attributes
     * @internal
     */
    get parsedAttributes() {
      return this.attributes;
    }
    /**
     * <zh/> 创建、更新或删除图形
     *
     * <en/> create, update or remove shape
     * @param className - <zh/> 图形名称 | <en/> shape name
     * @param Ctor - <zh/> 图形类型 | <en/> shape type
     * @param style - <zh/> 图形样式。若要删除图形，传入 false | <en/> shape style. Pass false to remove the shape
     * @param container - <zh/> 容器 | <en/> container
     * @param hooks - <zh/> 钩子函数 | <en/> hooks
     * @returns <zh/> 图形实例 | <en/> shape instance
     */
    upsert(className, Ctor, style, container, hooks) {
      var _a2, _b, _c, _d, _e, _f, _g, _h;
      const target = this.shapeMap[className];
      if (style === false) {
        if (target) {
          (_a2 = hooks === null || hooks === void 0 ? void 0 : hooks.beforeDestroy) === null || _a2 === void 0 ? void 0 : _a2.call(hooks, target);
          container.removeChild(target);
          delete this.shapeMap[className];
          (_b = hooks === null || hooks === void 0 ? void 0 : hooks.afterDestroy) === null || _b === void 0 ? void 0 : _b.call(hooks, target);
        }
        return;
      }
      const _Ctor = typeof Ctor === "string" ? getExtension(ExtensionCategory.SHAPE, Ctor) : Ctor;
      if (!_Ctor) {
        throw new Error(format(`Shape ${Ctor} not found`));
      }
      if (!target || target.destroyed || !(target instanceof _Ctor)) {
        if (target) {
          (_c = hooks === null || hooks === void 0 ? void 0 : hooks.beforeDestroy) === null || _c === void 0 ? void 0 : _c.call(hooks, target);
          target === null || target === void 0 ? void 0 : target.destroy();
          (_d = hooks === null || hooks === void 0 ? void 0 : hooks.afterDestroy) === null || _d === void 0 ? void 0 : _d.call(hooks, target);
        }
        (_e = hooks === null || hooks === void 0 ? void 0 : hooks.beforeCreate) === null || _e === void 0 ? void 0 : _e.call(hooks);
        const instance = new _Ctor({ className, style });
        container.appendChild(instance);
        this.shapeMap[className] = instance;
        (_f = hooks === null || hooks === void 0 ? void 0 : hooks.afterCreate) === null || _f === void 0 ? void 0 : _f.call(hooks, instance);
        return instance;
      }
      (_g = hooks === null || hooks === void 0 ? void 0 : hooks.beforeUpdate) === null || _g === void 0 ? void 0 : _g.call(hooks, target);
      updateStyle(target, style);
      (_h = hooks === null || hooks === void 0 ? void 0 : hooks.afterUpdate) === null || _h === void 0 ? void 0 : _h.call(hooks, target);
      return target;
    }
    update(attr2 = {}) {
      const attributes = Object.assign({}, this.attributes, attr2);
      applyTransform(attributes);
      setAttributes(this, attributes);
      this.render(attributes, this);
      this.setVisibility();
    }
    bindEvents() {
    }
    /**
     * <zh/> 从给定的属性对象中提取图形样式属性。删除特定的属性，如位置、变换和类名
     *
     * <en/> Extracts the shape styles from a given attribute object.
     * Removes specific styles like position, transformation, and class name.
     * @param style - <zh/> 属性对象 | <en/> attribute object
     * @returns <zh/> 仅包含样式属性的对象 | <en/> An object containing only the style properties.
     */
    getGraphicStyle(style) {
      return getSubShapeStyle(style);
    }
    /**
     * Get the prefix pairs for composite shapes used to handle animation
     * @returns tuples array where each tuple contains a key corresponding to a method `get${key}Style` and its shape prefix
     * @internal
     */
    get compositeShapes() {
      return [
        ["badges", "badge-"],
        ["ports", "port-"]
      ];
    }
    animate(keyframes, options) {
      if (keyframes.length === 0)
        return null;
      const animationMap = [];
      if (keyframes[0].x !== void 0 || keyframes[0].y !== void 0 || keyframes[0].z !== void 0) {
        const { x: _x = 0, y: _y = 0, z: _z = 0 } = this.attributes;
        keyframes.forEach((keyframe) => {
          const { x: x3 = _x, y: y3 = _y, z = _z } = keyframe;
          Object.assign(keyframe, { transform: z ? [["translate3d", x3, y3, z]] : [["translate", x3, y3]] });
        });
      }
      const result = super.animate(keyframes, options);
      if (result) {
        releaseAnimation(this, result);
        animationMap.push(result);
      }
      if (Array.isArray(keyframes) && keyframes.length > 0) {
        const skippedAttrs = ["transform", "transformOrigin", "x", "y", "z", "zIndex"];
        if (Object.keys(keyframes[0]).some((attr2) => !skippedAttrs.includes(attr2))) {
          Object.entries(this.shapeMap).forEach(([key, shape]) => {
            const methodName = `get${(0, import_util36.upperFirst)(key)}Style`;
            const method = this[methodName];
            if ((0, import_util36.isFunction)(method)) {
              const subKeyframes = keyframes.map((style) => method.call(this, Object.assign(Object.assign({}, this.attributes), style)));
              const result2 = shape.animate(preprocessKeyframes(subKeyframes), options);
              if (result2) {
                releaseAnimation(shape, result2);
                animationMap.push(result2);
              }
            }
          });
          const handleCompositeShapeAnimation = (shapeSet, name) => {
            if (!(0, import_util36.isEmpty)(shapeSet)) {
              const methodName = `get${(0, import_util36.upperFirst)(name)}Style`;
              const method = this[methodName];
              if ((0, import_util36.isFunction)(method)) {
                const itemsKeyframes = keyframes.map((style) => method.call(this, Object.assign(Object.assign({}, this.attributes), style)));
                Object.entries(itemsKeyframes[0]).map(([key]) => {
                  const subKeyframes = itemsKeyframes.map((styles) => styles[key]);
                  const shape = shapeSet[key];
                  if (shape) {
                    const result2 = shape.animate(preprocessKeyframes(subKeyframes), options);
                    if (result2) {
                      releaseAnimation(shape, result2);
                      animationMap.push(result2);
                    }
                  }
                });
              }
            }
          };
          this.compositeShapes.forEach(([key, prefix]) => {
            const shapeSet = subObject(this.shapeMap, prefix);
            handleCompositeShapeAnimation(shapeSet, key);
          });
        }
      }
      return createAnimationsProxy(animationMap);
    }
    getShape(name) {
      return this.shapeMap[name];
    }
    setVisibility() {
      const { visibility: visibility2 } = this.attributes;
      setVisibility(this, visibility2);
    }
    destroy() {
      this.shapeMap = {};
      this.animateMap = {};
      super.destroy();
    }
  };
  function releaseAnimation(target, animation) {
    animation === null || animation === void 0 ? void 0 : animation.finished.then(() => {
      const index2 = target.activeAnimations.findIndex((_2) => _2 === animation);
      if (index2 > -1)
        target.activeAnimations.splice(index2, 1);
    });
  }
  function applyTransform(style) {
    if (!style)
      return {};
    if ("x" in style || "y" in style || "z" in style) {
      const { x: x3 = 0, y: y3 = 0, z, transform } = style;
      const newTransform = replaceTranslateInTransform(x3, y3, z, transform);
      if (newTransform)
        style.transform = newTransform;
    }
    return style;
  }

  // node_modules/@antv/g6/esm/elements/shapes/label.js
  var __rest4 = function(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  var Label = class _Label extends BaseShape {
    constructor(options) {
      super(mergeOptions({ style: _Label.defaultStyleProps }, options));
    }
    isTextStyle(key) {
      return startsWith(key, "label");
    }
    isBackgroundStyle(key) {
      return startsWith(key, "background");
    }
    getTextStyle(attributes) {
      const _a2 = this.getGraphicStyle(attributes), { padding } = _a2, style = __rest4(_a2, ["padding"]);
      return omitStyleProps(style, "background");
    }
    getBackgroundStyle(attributes) {
      if (attributes.background === false)
        return false;
      const style = this.getGraphicStyle(attributes);
      const { wordWrap, wordWrapWidth, padding } = style;
      const backgroundStyle = subStyleProps(style, "background");
      const { min: [minX, minY], center: [centerX, centerY], halfExtents: [halfWidth, halfHeight] } = this.shapeMap.text.getGeometryBounds();
      const [top, right, bottom, left] = parsePadding(padding);
      const totalWidth = halfWidth * 2 + left + right;
      const { width: width2, height } = backgroundStyle;
      if (width2 && height) {
        Object.assign(backgroundStyle, { x: centerX - Number(width2) / 2, y: centerY - Number(height) / 2 });
      } else {
        Object.assign(backgroundStyle, {
          x: minX - left,
          y: minY - top,
          width: wordWrap ? Math.min(totalWidth, wordWrapWidth + left + right) : totalWidth,
          height: halfHeight * 2 + top + bottom
        });
      }
      const { radius } = backgroundStyle;
      if (typeof radius === "string" && radius.endsWith("%")) {
        const percentage = Number(radius.replace("%", "")) / 100;
        backgroundStyle.radius = Math.min(+backgroundStyle.width, +backgroundStyle.height) * percentage;
      }
      return backgroundStyle;
    }
    render(attributes = this.parsedAttributes, container = this) {
      this.upsert("text", Text, this.getTextStyle(attributes), container);
      this.upsert("background", Rect, this.getBackgroundStyle(attributes), container);
    }
    getGeometryBounds() {
      const shape = this.getShape("background") || this.getShape("text");
      return shape.getGeometryBounds();
    }
  };
  Label.defaultStyleProps = {
    padding: 0,
    fontSize: 12,
    fontFamily: "system-ui, sans-serif",
    wordWrap: true,
    maxLines: 1,
    wordWrapWidth: 128,
    textOverflow: "...",
    textBaseline: "middle",
    backgroundOpacity: 0.75,
    backgroundZIndex: -1,
    backgroundLineWidth: 0
  };

  // node_modules/@antv/g6/esm/elements/shapes/badge.js
  var Badge = class _Badge extends BaseShape {
    constructor(options) {
      super(mergeOptions({ style: _Badge.defaultStyleProps }, options));
    }
    getBadgeStyle(attributes) {
      return this.getGraphicStyle(attributes);
    }
    render(attributes = this.parsedAttributes, container = this) {
      this.upsert("label", Label, this.getBadgeStyle(attributes), container);
    }
    getGeometryBounds() {
      const labelShape = this.getShape("label");
      const shape = labelShape.getShape("background") || labelShape.getShape("text");
      return shape.getGeometryBounds();
    }
  };
  Badge.defaultStyleProps = {
    padding: [2, 4, 2, 4],
    fontSize: 10,
    wordWrap: false,
    backgroundRadius: "50%",
    backgroundOpacity: 1
  };

  // node_modules/@antv/g6/esm/utils/polygon.js
  var import_util37 = __toESM(require_lib());

  // node_modules/@antv/g6/esm/utils/path.js
  function pointsToPath(points, isClose = true) {
    const path = [];
    points.forEach((point4, index2) => {
      path.push([index2 === 0 ? "M" : "L", ...point4]);
    });
    if (isClose) {
      path.push(["Z"]);
    }
    return path;
  }
  var PATH_COMMANDS = {
    M: ["x", "y"],
    m: ["dx", "dy"],
    H: ["x"],
    h: ["dx"],
    V: ["y"],
    v: ["dy"],
    L: ["x", "y"],
    l: ["dx", "dy"],
    Z: [],
    z: [],
    C: ["x1", "y1", "x2", "y2", "x", "y"],
    c: ["dx1", "dy1", "dx2", "dy2", "dx", "dy"],
    S: ["x2", "y2", "x", "y"],
    s: ["dx2", "dy2", "dx", "dy"],
    Q: ["x1", "y1", "x", "y"],
    q: ["dx1", "dy1", "dx", "dy"],
    T: ["x", "y"],
    t: ["dx", "dy"],
    A: ["rx", "ry", "rotation", "large-arc", "sweep", "x", "y"],
    a: ["rx", "ry", "rotation", "large-arc", "sweep", "dx", "dy"]
  };
  function parsePath2(path) {
    const items = path.replace(/[\n\r]/g, "").replace(/-/g, " -").replace(/(\d*\.)(\d+)(?=\.)/g, "$1$2 ").trim().split(/\s*,|\s+/);
    const segments = [];
    let currentCommand = "";
    let currentElement = {};
    while (items.length > 0) {
      let it = items.shift();
      if (it in PATH_COMMANDS) {
        currentCommand = it;
      } else {
        items.unshift(it);
      }
      currentElement = { type: currentCommand };
      PATH_COMMANDS[currentCommand].forEach((prop) => {
        it = items.shift();
        currentElement[prop] = it;
      });
      if (currentCommand === "M") {
        currentCommand = "L";
      } else if (currentCommand === "m") {
        currentCommand = "l";
      }
      const [type, ...values2] = Object.values(currentElement);
      segments.push([type, ...values2.map(Number)]);
    }
    return segments;
  }
  function pathToPoints(path) {
    const points = [];
    const segments = typeof path === "string" ? parsePath2(path) : path;
    segments.forEach((seg) => {
      const command = seg[0];
      if (command === "Z") {
        points.push(points[0]);
        return;
      }
      if (command !== "A") {
        for (let i = 1; i < seg.length; i = i + 2) {
          points.push([seg[i], seg[i + 1], 0]);
        }
      } else {
        const length = seg.length;
        points.push([seg[length - 2], seg[length - 1], 0]);
      }
    });
    return points;
  }
  var getClosedSpline = (points) => {
    if (points.length < 2)
      return [
        ["M", 0, 0],
        ["L", 0, 0]
      ];
    const first = points[0];
    const second = points[1];
    const last2 = points[points.length - 1];
    const lastSecond = points[points.length - 2];
    points.unshift(lastSecond, last2);
    points.push(first, second);
    const closedPath = [["M", last2[0], last2[1]]];
    for (let i = 1; i < points.length - 2; i += 1) {
      const [x0, y0] = points[i - 1];
      const [x1, y1] = points[i];
      const [x22, y22] = points[i + 1];
      const [x3, y3] = i !== points.length - 2 ? points[i + 2] : [x22, y22];
      const cp1x = x1 + (x22 - x0) / 6;
      const cp1y = y1 + (y22 - y0) / 6;
      const cp2x = x22 - (x3 - x1) / 6;
      const cp2y = y22 - (y3 - y1) / 6;
      closedPath.push(["C", cp1x, cp1y, cp2x, cp2y, x22, y22]);
    }
    return closedPath;
  };

  // node_modules/@antv/g6/esm/utils/polygon.js
  function getPolygonTextStyleByPlacement(bounds, placement, offsetX, offsetY, closeToContour, path, autoRotate) {
    const [x3, y3] = getXYByPlacement(bounds, placement);
    const style = {
      textAlign: placement === "left" ? "right" : placement === "right" ? "left" : "center",
      textBaseline: placement === "top" ? "bottom" : placement === "bottom" ? "top" : "middle",
      transform: [["translate", x3 + offsetX, y3 + offsetY]]
    };
    if (placement === "center" || !closeToContour)
      return style;
    const points = pathToPoints(path);
    if (!points || points.length <= 3)
      return style;
    const lines = points.map((point4, index2) => {
      const p1 = point4;
      const p2 = points[(index2 + 1) % points.length];
      if ((0, import_util37.isEqual)(p1, p2))
        return null;
      return [p1, p2];
    }).filter(Boolean);
    const line2 = findNearestLine([x3, y3], lines);
    const intersection = findNearestPointOnLine([x3, y3], line2);
    if (intersection && line2) {
      style.transform = [["translate", intersection[0] + offsetX, intersection[1] + offsetY]];
      if (autoRotate) {
        const angle2 = Math.atan((line2[0][1] - line2[1][1]) / (line2[0][0] - line2[1][0]));
        style.transform.push(["rotate", angle2 / Math.PI * 180]);
        style.textAlign = "center";
        if (placement === "right" || placement === "left") {
          if (angle2 > 0) {
            style.textBaseline = placement === "right" ? "bottom" : "top";
          } else {
            style.textBaseline = placement === "right" ? "top" : "bottom";
          }
        }
      }
    }
    return style;
  }

  // node_modules/@antv/g6/esm/elements/shapes/contour.js
  var __rest5 = function(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  var Contour = class _Contour extends BaseShape {
    constructor(options) {
      super(mergeOptions({ style: _Contour.defaultStyleProps }, options));
    }
    getLabelStyle(attributes) {
      if (!attributes.label || !attributes.d || attributes.d.length === 0)
        return false;
      const _a2 = subStyleProps(this.getGraphicStyle(attributes), "label"), { maxWidth, offsetX, offsetY, autoRotate, placement, closeToPath } = _a2, labelStyle = __rest5(_a2, ["maxWidth", "offsetX", "offsetY", "autoRotate", "placement", "closeToPath"]);
      const key = this.shapeMap.key;
      const keyBounds = key === null || key === void 0 ? void 0 : key.getRenderBounds();
      return Object.assign(getPolygonTextStyleByPlacement(keyBounds, placement, offsetX, offsetY, closeToPath, attributes.d, autoRotate), { wordWrapWidth: getWordWrapWidthByBox(keyBounds, maxWidth) }, labelStyle);
    }
    getKeyStyle(attributes) {
      return this.getGraphicStyle(attributes);
    }
    render(attributes, container) {
      this.upsert("key", Path, this.getKeyStyle(attributes), container);
      this.upsert("label", Label, this.getLabelStyle(attributes), container);
    }
  };
  Contour.defaultStyleProps = {
    label: true,
    labelPlacement: "bottom",
    labelCloseToPath: true,
    labelAutoRotate: true,
    labelOffsetX: 0,
    labelOffsetY: 0
  };

  // node_modules/@antv/g6/esm/utils/shape.js
  function getDescendantShapes(shape) {
    const succeeds = [];
    const traverse2 = (shape2) => {
      if (shape2 === null || shape2 === void 0 ? void 0 : shape2.children.length) {
        shape2.children.forEach((child) => {
          succeeds.push(child);
          traverse2(child);
        });
      }
    };
    traverse2(shape);
    return succeeds;
  }
  function getAncestorShapes(shape) {
    const ancestors = [];
    let currentNode = shape.parentNode;
    while (currentNode) {
      ancestors.push(currentNode);
      currentNode = currentNode.parentNode;
    }
    return ancestors;
  }

  // node_modules/@antv/g6/esm/elements/shapes/image.js
  var Image3 = class extends Image2 {
    constructor(options) {
      super(options);
      this.onMounted = () => {
        this.handleRadius();
      };
      this.onAttrModified = () => {
        this.handleRadius();
      };
      current = this;
      this.isMutationObserved = true;
      this.addEventListener(ElementEvent.MOUNTED, this.onMounted);
      this.addEventListener(ElementEvent.ATTR_MODIFIED, this.onAttrModified);
    }
    handleRadius() {
      const { radius, clipPath, width: width2 = 0, height = 0 } = this.attributes;
      if (radius && width2 && height) {
        const [x3, y3] = this.getBounds().min;
        const clipPathStyle = { x: x3, y: y3, radius, width: width2, height };
        if (clipPath) {
          Object.assign(this.parsedStyle.clipPath.style, clipPathStyle);
        } else {
          const rect2 = new Rect({ style: clipPathStyle });
          this.style.clipPath = rect2;
        }
      } else {
        if (clipPath)
          this.style.clipPath = null;
      }
    }
  };
  var ImagesWeakMap = /* @__PURE__ */ new WeakMap();
  var current = null;
  var connectImage = (target) => {
    if (current && getAncestorShapes(current).includes(target)) {
      const images = ImagesWeakMap.get(target);
      if (images) {
        if (!images.includes(current))
          images.push(current);
      } else
        ImagesWeakMap.set(target, [current]);
    }
  };
  var dispatchPositionChange = (target) => {
    const image = ImagesWeakMap.get(target);
    if (image) {
      image.forEach((i) => i.handleRadius());
    }
  };

  // node_modules/@antv/g6/esm/elements/shapes/icon.js
  var Icon = class extends BaseShape {
    constructor(options) {
      super(options);
    }
    isImage() {
      const { src } = this.attributes;
      return !!src;
    }
    getIconStyle(attributes = this.attributes) {
      const { width: width2 = 0, height = 0 } = attributes;
      const style = this.getGraphicStyle(attributes);
      if (this.isImage()) {
        return Object.assign({ x: -width2 / 2, y: -height / 2 }, style);
      }
      return Object.assign({ textBaseline: "middle", textAlign: "center" }, style);
    }
    render(attributes = this.attributes, container = this) {
      this.upsert("icon", this.isImage() ? Image3 : Text, this.getIconStyle(attributes), container);
    }
  };

  // node_modules/@antv/g6/esm/elements/base-element.js
  var BaseElement = class extends BaseShape {
    get context() {
      return this.config.context;
    }
    get parsedAttributes() {
      return this.attributes;
    }
    /**
     * <zh/> 动画帧执行函数
     *
     * <en/> Animation frame execution function
     */
    onframe() {
    }
    animate(keyframes, options) {
      const animation = super.animate(keyframes, options);
      if (animation) {
        animation.onframe = () => this.onframe();
        animation.finished.then(() => this.onframe());
      }
      return animation;
    }
  };

  // node_modules/@antv/g6/esm/elements/nodes/base-node.js
  var __rest6 = function(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  var BaseNode = class _BaseNode extends BaseElement {
    constructor(options) {
      super(mergeOptions({ style: _BaseNode.defaultStyleProps }, options));
      this.type = "node";
    }
    getSize(attributes = this.attributes) {
      const { size: size2 } = attributes;
      return parseSize(size2);
    }
    getKeyStyle(attributes) {
      const style = this.getGraphicStyle(attributes);
      return Object.assign(omitStyleProps(style, ["label", "halo", "icon", "badge", "port"]));
    }
    getLabelStyle(attributes) {
      if (attributes.label === false || !attributes.labelText)
        return false;
      const _a2 = subStyleProps(this.getGraphicStyle(attributes), "label"), { placement, maxWidth, offsetX, offsetY } = _a2, labelStyle = __rest6(_a2, ["placement", "maxWidth", "offsetX", "offsetY"]);
      const keyBounds = this.getShape("key").getLocalBounds();
      return Object.assign(getTextStyleByPlacement(keyBounds, placement, offsetX, offsetY), { wordWrapWidth: getWordWrapWidthByBox(keyBounds, maxWidth) }, labelStyle);
    }
    getHaloStyle(attributes) {
      if (attributes.halo === false)
        return false;
      const _a2 = this.getKeyStyle(attributes), { fill } = _a2, keyStyle = __rest6(_a2, ["fill"]);
      const haloStyle = subStyleProps(this.getGraphicStyle(attributes), "halo");
      return Object.assign(Object.assign(Object.assign({}, keyStyle), { stroke: fill }), haloStyle);
    }
    getIconStyle(attributes) {
      if (attributes.icon === false || !attributes.iconText && !attributes.iconSrc)
        return false;
      const iconStyle = subStyleProps(this.getGraphicStyle(attributes), "icon");
      return Object.assign(inferIconStyle(attributes.size, iconStyle), iconStyle);
    }
    getBadgesStyle(attributes) {
      var _a2;
      const badges = subObject(this.shapeMap, "badge-");
      const badgesShapeStyle = {};
      Object.keys(badges).forEach((key) => {
        badgesShapeStyle[key] = false;
      });
      if (attributes.badge === false || !((_a2 = attributes.badges) === null || _a2 === void 0 ? void 0 : _a2.length))
        return badgesShapeStyle;
      const { badges: badgeOptions = [], badgePalette, opacity = 1 } = attributes, restAttributes = __rest6(attributes, ["badges", "badgePalette", "opacity"]);
      const colors = getPaletteColors(badgePalette);
      const badgeStyle = subStyleProps(this.getGraphicStyle(restAttributes), "badge");
      badgeOptions.forEach((option, i) => {
        badgesShapeStyle[i] = Object.assign(Object.assign({ backgroundFill: colors ? colors[i % (colors === null || colors === void 0 ? void 0 : colors.length)] : void 0, opacity }, badgeStyle), this.getBadgeStyle(option));
      });
      return badgesShapeStyle;
    }
    getBadgeStyle(style) {
      const keyShape = this.getShape("key");
      const { placement = "top", offsetX, offsetY } = style, restStyle = __rest6(style, ["placement", "offsetX", "offsetY"]);
      const textStyle = getTextStyleByPlacement(keyShape.getLocalBounds(), placement, offsetX, offsetY, true);
      return Object.assign(Object.assign({}, textStyle), restStyle);
    }
    getPortsStyle(attributes) {
      var _a2;
      const ports = this.getPorts();
      const portsShapeStyle = {};
      Object.keys(ports).forEach((key) => {
        portsShapeStyle[key] = false;
      });
      if (attributes.port === false || !((_a2 = attributes.ports) === null || _a2 === void 0 ? void 0 : _a2.length))
        return portsShapeStyle;
      const portStyle = subStyleProps(this.getGraphicStyle(attributes), "port");
      const { ports: portOptions = [] } = attributes;
      portOptions.forEach((option, index2) => {
        const key = option.key || index2;
        const mergedStyle = Object.assign(Object.assign({}, portStyle), option);
        if (isSimplePort(mergedStyle)) {
          portsShapeStyle[key] = false;
        } else {
          const [x3, y3] = this.getPortXY(attributes, option);
          portsShapeStyle[key] = Object.assign({ transform: [["translate", x3, y3]] }, mergedStyle);
        }
      });
      return portsShapeStyle;
    }
    getPortXY(attributes, style) {
      const { placement = "left" } = style;
      const keyShape = this.getShape("key");
      return getPortXYByPlacement(getBoundsInOffscreen(this.context, keyShape), placement);
    }
    /**
     * Get the ports for the node.
     * @returns Ports shape map.
     */
    getPorts() {
      return subObject(this.shapeMap, "port-");
    }
    /**
     * Get the center point of the node.
     * @returns The center point of the node.
     */
    getCenter() {
      return this.getShape("key").getBounds().center;
    }
    /**
     * Get the point on the outer contour of the node that is the intersection with a line starting in the center the ending in the point `p`.
     * @param point - The point to intersect with the node.
     * @param useExtendedLine - Whether to use the extended line.
     * @returns The intersection point.
     */
    getIntersectPoint(point4, useExtendedLine = false) {
      const keyShapeBounds = this.getShape("key").getBounds();
      return getRectIntersectPoint(point4, keyShapeBounds, useExtendedLine);
    }
    drawHaloShape(attributes, container) {
      const style = this.getHaloStyle(attributes);
      const keyShape = this.getShape("key");
      this.upsert("halo", keyShape.constructor, style, container);
    }
    drawIconShape(attributes, container) {
      const style = this.getIconStyle(attributes);
      this.upsert("icon", Icon, style, container);
      connectImage(this);
    }
    drawBadgeShapes(attributes, container) {
      const badgesStyle = this.getBadgesStyle(attributes);
      Object.keys(badgesStyle).forEach((key) => {
        const style = badgesStyle[key];
        this.upsert(`badge-${key}`, Badge, style, container);
      });
    }
    drawPortShapes(attributes, container) {
      const portsStyle = this.getPortsStyle(attributes);
      Object.keys(portsStyle).forEach((key) => {
        const style = portsStyle[key];
        const shapeKey = `port-${key}`;
        this.upsert(shapeKey, Circle, style, container);
      });
    }
    drawLabelShape(attributes, container) {
      const style = this.getLabelStyle(attributes);
      this.upsert("label", Label, style, container);
    }
    // 用于装饰抽象方法 / Used to decorate abstract methods
    _drawKeyShape(attributes, container) {
      return this.drawKeyShape(attributes, container);
    }
    render(attributes = this.parsedAttributes, container = this) {
      this._drawKeyShape(attributes, container);
      if (!this.getShape("key"))
        return;
      this.drawHaloShape(attributes, container);
      this.drawIconShape(attributes, container);
      this.drawBadgeShapes(attributes, container);
      this.drawLabelShape(attributes, container);
      this.drawPortShapes(attributes, container);
    }
    update(attr2) {
      super.update(attr2);
      if (attr2 && ("x" in attr2 || "y" in attr2 || "z" in attr2)) {
        dispatchPositionChange(this);
      }
    }
    onframe() {
      this.drawBadgeShapes(this.parsedAttributes, this);
      this.drawLabelShape(this.parsedAttributes, this);
    }
  };
  BaseNode.defaultStyleProps = {
    x: 0,
    y: 0,
    size: 32,
    droppable: true,
    draggable: true,
    port: true,
    ports: [],
    portZIndex: 2,
    portLinkToCenter: false,
    badge: true,
    badges: [],
    badgeZIndex: 3,
    halo: false,
    haloDroppable: false,
    haloLineDash: 0,
    haloLineWidth: 12,
    haloStrokeOpacity: 0.25,
    haloPointerEvents: "none",
    haloZIndex: -1,
    icon: true,
    iconZIndex: 1,
    label: true,
    labelIsBillboard: true,
    labelMaxWidth: "200%",
    labelPlacement: "bottom",
    labelWordWrap: false,
    labelZIndex: 0
  };
  function getBoundsInOffscreen(context, shape) {
    if (!context)
      return shape.getLocalBounds();
    const canvas2 = context.canvas.getLayer();
    const substitute2 = shape.cloneNode();
    setVisibility(substitute2, "hidden");
    canvas2.appendChild(substitute2);
    const bounds = substitute2.getLocalBounds();
    substitute2.destroy();
    return bounds;
  }

  // node_modules/@antv/g6/esm/elements/nodes/circle.js
  var Circle2 = class _Circle extends BaseNode {
    constructor(options) {
      super(mergeOptions({ style: _Circle.defaultStyleProps }, options));
    }
    drawKeyShape(attributes, container) {
      return this.upsert("key", Circle, this.getKeyStyle(attributes), container);
    }
    getKeyStyle(attributes) {
      const keyStyle = super.getKeyStyle(attributes);
      return Object.assign(Object.assign({}, keyStyle), { r: Math.min(...this.getSize(attributes)) / 2 });
    }
    getIconStyle(attributes) {
      const style = super.getIconStyle(attributes);
      const { r } = this.getShape("key").attributes;
      const size2 = r * 2 * ICON_SIZE_RATIO;
      return style ? Object.assign({ width: size2, height: size2 }, style) : false;
    }
    getIntersectPoint(point4, useExtendedLine = false) {
      const keyShapeBounds = this.getShape("key").getBounds();
      return getEllipseIntersectPoint(point4, keyShapeBounds, useExtendedLine);
    }
  };
  Circle2.defaultStyleProps = {
    size: 32
  };

  // node_modules/@antv/g6/esm/elements/shapes/polygon.js
  var Polygon2 = class extends BaseNode {
    constructor(options) {
      super(options);
    }
    get parsedAttributes() {
      return this.attributes;
    }
    drawKeyShape(attributes, container) {
      return this.upsert("key", Polygon, this.getKeyStyle(attributes), container);
    }
    getKeyStyle(attributes) {
      const keyStyle = super.getKeyStyle(attributes);
      return Object.assign(Object.assign({}, keyStyle), { points: this.getPoints(attributes) });
    }
    getIntersectPoint(point4, useExtendedLine = false) {
      var _a2, _b;
      const { points } = this.getShape("key").attributes;
      const center = [+(((_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.x) || 0), +(((_b = this.attributes) === null || _b === void 0 ? void 0 : _b.y) || 0)];
      return getPolygonIntersectPoint(point4, center, points, true, useExtendedLine).point;
    }
  };

  // node_modules/@antv/g6/esm/elements/nodes/diamond.js
  var Diamond = class extends Polygon2 {
    constructor(options) {
      super(options);
    }
    getPoints(attributes) {
      const [width2, height] = this.getSize(attributes);
      return getDiamondPoints(width2, height);
    }
  };

  // node_modules/@antv/g6/esm/elements/nodes/donut.js
  var import_util38 = __toESM(require_lib());
  var __rest7 = function(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  var Donut = class _Donut extends Circle2 {
    constructor(options) {
      super(mergeOptions({ style: _Donut.defaultStyleProps }, options));
    }
    parseOuterR() {
      const { size: size2 } = this.parsedAttributes;
      return Math.min(...parseSize(size2)) / 2;
    }
    parseInnerR() {
      const { innerR } = this.parsedAttributes;
      return (0, import_util38.isString)(innerR) ? parseInt(innerR) / 100 * this.parseOuterR() : innerR;
    }
    drawDonutShape(attributes, container) {
      const { donuts } = attributes;
      if (!(donuts === null || donuts === void 0 ? void 0 : donuts.length))
        return;
      const parsedDonuts = donuts.map((round3) => (0, import_util38.isNumber)(round3) ? { value: round3 } : round3);
      const style = subStyleProps(this.getGraphicStyle(attributes), "donut");
      const colors = getPaletteColors(attributes.donutPalette);
      if (!colors)
        return;
      const sum = parsedDonuts.reduce((acc, cur) => {
        var _a2;
        return acc + ((_a2 = cur.value) !== null && _a2 !== void 0 ? _a2 : 0);
      }, 0);
      const outerR = this.parseOuterR();
      const innerR = this.parseInnerR();
      let start = 0;
      parsedDonuts.forEach((round3, index2) => {
        const { value = 0, color: color2 = colors[index2 % colors.length] } = round3, roundStyle = __rest7(round3, ["value", "color"]);
        const angle2 = (sum === 0 ? 1 / parsedDonuts.length : value / sum) * 360;
        this.upsert(`round${index2}`, Path, Object.assign(Object.assign(Object.assign({}, style), { d: arc(outerR, innerR, start, start + angle2), fill: color2 }), roundStyle), container);
        start += angle2;
      });
    }
    render(attributes, container = this) {
      super.render(attributes, container);
      this.drawDonutShape(attributes, container);
    }
  };
  Donut.defaultStyleProps = {
    innerR: "50%",
    donuts: [],
    donutPalette: "tableau"
  };
  var point = (x3, y3, r, angel) => [x3 + Math.sin(angel) * r, y3 - Math.cos(angel) * r];
  var full = (x3, y3, R, r) => {
    if (r <= 0 || R <= r) {
      return [["M", x3 - R, y3], ["A", R, R, 0, 1, 1, x3 + R, y3], ["A", R, R, 0, 1, 1, x3 - R, y3], ["Z"]];
    }
    return [
      ["M", x3 - R, y3],
      ["A", R, R, 0, 1, 1, x3 + R, y3],
      ["A", R, R, 0, 1, 1, x3 - R, y3],
      ["Z"],
      ["M", x3 + r, y3],
      ["A", r, r, 0, 1, 0, x3 - r, y3],
      ["A", r, r, 0, 1, 0, x3 + r, y3],
      ["Z"]
    ];
  };
  var part = (x3, y3, R, r, start, end) => {
    const [s, e] = [start / 360 * 2 * Math.PI, end / 360 * 2 * Math.PI];
    const P = [point(x3, y3, r, s), point(x3, y3, R, s), point(x3, y3, R, e), point(x3, y3, r, e)];
    const flag = e - s > Math.PI ? 1 : 0;
    return [
      ["M", P[0][0], P[0][1]],
      ["L", P[1][0], P[1][1]],
      ["A", R, R, 0, flag, 1, P[2][0], P[2][1]],
      ["L", P[3][0], P[3][1]],
      ["A", r, r, 0, flag, 0, P[0][0], P[0][1]],
      ["Z"]
    ];
  };
  var arc = (R = 0, r = 0, start, end) => {
    const [x3, y3] = [0, 0];
    if (Math.abs(start - end) % 360 < 1e-6)
      return full(x3, y3, R, r);
    return part(x3, y3, R, r, start, end);
  };

  // node_modules/@antv/g6/esm/elements/nodes/ellipse.js
  var Ellipse2 = class _Ellipse extends BaseNode {
    constructor(options) {
      super(mergeOptions({ style: _Ellipse.defaultStyleProps }, options));
    }
    drawKeyShape(attributes, container) {
      return this.upsert("key", Ellipse, this.getKeyStyle(attributes), container);
    }
    getKeyStyle(attributes) {
      const keyStyle = super.getKeyStyle(attributes);
      const [majorAxis, minorAxis] = this.getSize(attributes);
      return Object.assign(Object.assign({}, keyStyle), { rx: majorAxis / 2, ry: minorAxis / 2 });
    }
    getIconStyle(attributes) {
      const style = super.getIconStyle(attributes);
      const { rx, ry } = this.getShape("key").attributes;
      const size2 = Math.min(+rx, +ry) * 2 * ICON_SIZE_RATIO;
      return style ? Object.assign({ width: size2, height: size2 }, style) : false;
    }
    getIntersectPoint(point4, useExtendedLine = false) {
      const keyShapeBounds = this.getShape("key").getBounds();
      return getEllipseIntersectPoint(point4, keyShapeBounds, useExtendedLine);
    }
  };
  Ellipse2.defaultStyleProps = {
    size: [45, 35]
  };

  // node_modules/@antv/g6/esm/elements/nodes/hexagon.js
  var Hexagon = class extends Polygon2 {
    constructor(options) {
      super(options);
    }
    getOuterR(attributes) {
      return attributes.outerR || Math.min(...this.getSize(attributes)) / 2;
    }
    getPoints(attributes) {
      return getHexagonPoints(this.getOuterR(attributes));
    }
    getIconStyle(attributes) {
      const style = super.getIconStyle(attributes);
      const size2 = this.getOuterR(attributes) * ICON_SIZE_RATIO;
      return style ? Object.assign({ width: size2, height: size2 }, style) : false;
    }
  };

  // node_modules/@antv/g-plugin-canvas-path-generator/dist/index.esm.js
  var import_util39 = __toESM(require_lib());
  function generatePath$6(context, parsedStyle) {
    var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, r = parsedStyle.r;
    context.arc(cx, cy, r, 0, Math.PI * 2, false);
  }
  function generatePath$5(context, parsedStyle) {
    var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, rx = parsedStyle.rx, ry = parsedStyle.ry;
    if (context.ellipse) {
      context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);
    } else {
      var r = rx > ry ? rx : ry;
      var scaleX2 = rx > ry ? 1 : rx / ry;
      var scaleY2 = rx > ry ? ry / rx : 1;
      context.save();
      context.scale(scaleX2, scaleY2);
      context.arc(cx, cy, r, 0, Math.PI * 2);
    }
  }
  function generatePath$4(context, parsedStyle) {
    var x1 = parsedStyle.x1, y1 = parsedStyle.y1, x22 = parsedStyle.x2, y22 = parsedStyle.y2, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
    var startOffsetX = 0;
    var startOffsetY = 0;
    var endOffsetX = 0;
    var endOffsetY = 0;
    var rad2 = 0;
    var x3;
    var y3;
    if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
      x3 = x22 - x1;
      y3 = y22 - y1;
      rad2 = Math.atan2(y3, x3);
      startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
      startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
    }
    if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
      x3 = x1 - x22;
      y3 = y1 - y22;
      rad2 = Math.atan2(y3, x3);
      endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
      endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
    }
    context.moveTo(x1 + startOffsetX, y1 + startOffsetY);
    context.lineTo(x22 + endOffsetX, y22 + endOffsetY);
  }
  function generatePath$3(context, parsedStyle) {
    var markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
    var _parsedStyle$d = parsedStyle.d, absolutePath = _parsedStyle$d.absolutePath, segments = _parsedStyle$d.segments;
    var startOffsetX = 0;
    var startOffsetY = 0;
    var endOffsetX = 0;
    var endOffsetY = 0;
    var rad2 = 0;
    var x3;
    var y3;
    if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
      var _getStartTangent = markerStart.parentNode.getStartTangent(), _getStartTangent2 = _slicedToArray(_getStartTangent, 2), p1 = _getStartTangent2[0], p2 = _getStartTangent2[1];
      x3 = p1[0] - p2[0];
      y3 = p1[1] - p2[1];
      rad2 = Math.atan2(y3, x3);
      startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
      startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
    }
    if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
      var _getEndTangent = markerEnd.parentNode.getEndTangent(), _getEndTangent2 = _slicedToArray(_getEndTangent, 2), _p = _getEndTangent2[0], _p2 = _getEndTangent2[1];
      x3 = _p[0] - _p2[0];
      y3 = _p[1] - _p2[1];
      rad2 = Math.atan2(y3, x3);
      endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
      endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
    }
    for (var i = 0; i < absolutePath.length; i++) {
      var params = absolutePath[i];
      var command = params[0];
      var nextSegment = absolutePath[i + 1];
      var useStartOffset = i === 0 && (startOffsetX !== 0 || startOffsetY !== 0);
      var useEndOffset = (i === absolutePath.length - 1 || nextSegment && (nextSegment[0] === "M" || nextSegment[0] === "Z")) && endOffsetX !== 0 && endOffsetY !== 0;
      var _ref = useStartOffset ? [startOffsetX, startOffsetY] : [0, 0], _ref2 = _slicedToArray(_ref, 2), startOffsetXTemp = _ref2[0], startOffsetYTemp = _ref2[1];
      var _ref3 = useEndOffset ? [endOffsetX, endOffsetY] : [0, 0], _ref4 = _slicedToArray(_ref3, 2), endOffsetXTemp = _ref4[0], endOffsetYTemp = _ref4[1];
      switch (command) {
        case "M":
          context.moveTo(params[1] + startOffsetXTemp, params[2] + startOffsetYTemp);
          break;
        case "L":
          context.lineTo(params[1] + endOffsetXTemp, params[2] + endOffsetYTemp);
          break;
        case "Q":
          context.quadraticCurveTo(params[1], params[2], params[3] + endOffsetXTemp, params[4] + endOffsetYTemp);
          break;
        case "C":
          context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] + endOffsetXTemp, params[6] + endOffsetYTemp);
          break;
        case "A": {
          var arcParams = segments[i].arcParams;
          var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;
          if (context.ellipse) {
            context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, !!(1 - sweepFlag));
          } else {
            var r = rx > ry ? rx : ry;
            var scaleX2 = rx > ry ? 1 : rx / ry;
            var scaleY2 = rx > ry ? ry / rx : 1;
            context.translate(cx, cy);
            context.rotate(xRotation);
            context.scale(scaleX2, scaleY2);
            context.arc(0, 0, r, startAngle, endAngle, !!(1 - sweepFlag));
            context.scale(1 / scaleX2, 1 / scaleY2);
            context.rotate(-xRotation);
            context.translate(-cx, -cy);
          }
          if (useEndOffset) {
            context.lineTo(params[6] + endOffsetX, params[7] + endOffsetY);
          }
          break;
        }
        case "Z":
          context.closePath();
          break;
      }
    }
  }
  function generatePath$2(context, parsedStyle) {
    var markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
    var points = parsedStyle.points.points;
    var length = points.length;
    var x1 = points[0][0];
    var y1 = points[0][1];
    var x22 = points[length - 1][0];
    var y22 = points[length - 1][1];
    var startOffsetX = 0;
    var startOffsetY = 0;
    var endOffsetX = 0;
    var endOffsetY = 0;
    var rad2 = 0;
    var x3;
    var y3;
    if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
      x3 = points[1][0] - points[0][0];
      y3 = points[1][1] - points[0][1];
      rad2 = Math.atan2(y3, x3);
      startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
      startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
    }
    if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
      x3 = points[length - 1][0] - points[0][0];
      y3 = points[length - 1][1] - points[0][1];
      rad2 = Math.atan2(y3, x3);
      endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
      endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
    }
    context.moveTo(x1 + (startOffsetX || endOffsetX), y1 + (startOffsetY || endOffsetY));
    for (var i = 1; i < length - 1; i++) {
      var point4 = points[i];
      context.lineTo(point4[0], point4[1]);
    }
    context.lineTo(x22, y22);
  }
  function generatePath$1(context, parsedStyle) {
    var markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
    var points = parsedStyle.points.points;
    var length = points.length;
    var x1 = points[0][0];
    var y1 = points[0][1];
    var x22 = points[length - 1][0];
    var y22 = points[length - 1][1];
    var startOffsetX = 0;
    var startOffsetY = 0;
    var endOffsetX = 0;
    var endOffsetY = 0;
    var rad2 = 0;
    var x3;
    var y3;
    if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
      x3 = points[1][0] - points[0][0];
      y3 = points[1][1] - points[0][1];
      rad2 = Math.atan2(y3, x3);
      startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
      startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
    }
    if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
      x3 = points[length - 2][0] - points[length - 1][0];
      y3 = points[length - 2][1] - points[length - 1][1];
      rad2 = Math.atan2(y3, x3);
      endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
      endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
    }
    context.moveTo(x1 + startOffsetX, y1 + startOffsetY);
    for (var i = 1; i < length - 1; i++) {
      var point4 = points[i];
      context.lineTo(point4[0], point4[1]);
    }
    context.lineTo(x22 + endOffsetX, y22 + endOffsetY);
  }
  function generatePath(context, parsedStyle) {
    var _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, radius = parsedStyle.radius, width2 = parsedStyle.width, height = parsedStyle.height;
    var w = width2;
    var h = height;
    var hasRadius = radius && radius.some(function(r) {
      return r !== 0;
    });
    if (!hasRadius) {
      context.rect(x3, y3, w, h);
    } else {
      var signX = width2 > 0 ? 1 : -1;
      var signY = height > 0 ? 1 : -1;
      var sweepFlag = signX + signY === 0;
      var _radius$map = radius.map(function(r) {
        return (0, import_util39.clamp)(r, 0, Math.min(Math.abs(w) / 2, Math.abs(h) / 2));
      }), _radius$map2 = _slicedToArray(_radius$map, 4), tlr = _radius$map2[0], trr = _radius$map2[1], brr = _radius$map2[2], blr = _radius$map2[3];
      context.moveTo(signX * tlr + x3, y3);
      context.lineTo(w - signX * trr + x3, y3);
      if (trr !== 0) {
        context.arc(w - signX * trr + x3, signY * trr + y3, trr, -signY * Math.PI / 2, signX > 0 ? 0 : Math.PI, sweepFlag);
      }
      context.lineTo(w + x3, h - signY * brr + y3);
      if (brr !== 0) {
        context.arc(w - signX * brr + x3, h - signY * brr + y3, brr, signX > 0 ? 0 : Math.PI, signY > 0 ? Math.PI / 2 : 1.5 * Math.PI, sweepFlag);
      }
      context.lineTo(signX * blr + x3, h + y3);
      if (blr !== 0) {
        context.arc(signX * blr + x3, h - signY * blr + y3, blr, signY > 0 ? Math.PI / 2 : -Math.PI / 2, signX > 0 ? Math.PI : 0, sweepFlag);
      }
      context.lineTo(x3, signY * tlr + y3);
      if (tlr !== 0) {
        context.arc(signX * tlr + x3, signY * tlr + y3, tlr, signX > 0 ? Math.PI : 0, signY > 0 ? Math.PI * 1.5 : Math.PI / 2, sweepFlag);
      }
    }
  }
  var Plugin = /* @__PURE__ */ (function(_AbstractRendererPlug) {
    function Plugin8() {
      var _this2;
      _classCallCheck(this, Plugin8);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this2 = _callSuper(this, Plugin8, [].concat(args));
      _this2.name = "canvas-path-generator";
      return _this2;
    }
    _inherits(Plugin8, _AbstractRendererPlug);
    return _createClass(Plugin8, [{
      key: "init",
      value: function init() {
        var _pathGeneratorFactory;
        var pathGeneratorFactory = (_pathGeneratorFactory = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_pathGeneratorFactory, Shape.CIRCLE, generatePath$6), Shape.ELLIPSE, generatePath$5), Shape.RECT, generatePath), Shape.LINE, generatePath$4), Shape.POLYLINE, generatePath$1), Shape.POLYGON, generatePath$2), Shape.PATH, generatePath$3), Shape.TEXT, void 0), Shape.GROUP, void 0), Shape.IMAGE, void 0), _defineProperty(_defineProperty(_defineProperty(_pathGeneratorFactory, Shape.HTML, void 0), Shape.MESH, void 0), Shape.FRAGMENT, void 0));
        this.context.pathGeneratorFactory = pathGeneratorFactory;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        delete this.context.pathGeneratorFactory;
      }
    }]);
  })(AbstractRendererPlugin);

  // node_modules/@antv/g-plugin-canvas-picker/dist/index.esm.js
  var import_gl_matrix4 = __toESM(require_cjs());
  var import_util40 = __toESM(require_lib());
  var tmpVec3a = import_gl_matrix4.vec3.create();
  var tmpVec3b = import_gl_matrix4.vec3.create();
  var tmpVec3c = import_gl_matrix4.vec3.create();
  var tmpMat4 = import_gl_matrix4.mat4.create();
  var CanvasPickerPlugin = /* @__PURE__ */ (function() {
    function CanvasPickerPlugin2() {
      var _this2 = this;
      _classCallCheck(this, CanvasPickerPlugin2);
      this.isHit = function(displayObject, position2, worldTransform, isClipPath) {
        var pick7 = _this2.context.pointInPathPickerFactory[displayObject.nodeName];
        if (pick7) {
          var invertWorldMat = import_gl_matrix4.mat4.invert(tmpMat4, worldTransform);
          var localPosition = import_gl_matrix4.vec3.transformMat4(tmpVec3b, import_gl_matrix4.vec3.set(tmpVec3c, position2[0], position2[1], 0), invertWorldMat);
          if (pick7(displayObject, new Point(localPosition[0], localPosition[1]), isClipPath, _this2.isPointInPath, _this2.context, _this2.runtime)) {
            return true;
          }
        }
        return false;
      };
      this.isPointInPath = function(displayObject, position2) {
        var context = _this2.runtime.offscreenCanvasCreator.getOrCreateContext(_this2.context.config.offscreenCanvas);
        var generatePath2 = _this2.context.pathGeneratorFactory[displayObject.nodeName];
        if (generatePath2) {
          context.beginPath();
          generatePath2(context, displayObject.parsedStyle);
          context.closePath();
        }
        return context.isPointInPath(position2.x, position2.y);
      };
    }
    return _createClass(CanvasPickerPlugin2, [{
      key: "apply",
      value: function apply3(context, runtime2) {
        var _renderingContext$roo, _this2 = this;
        var renderingService = context.renderingService, renderingContext = context.renderingContext;
        this.context = context;
        this.runtime = runtime2;
        var document2 = (_renderingContext$roo = renderingContext.root) === null || _renderingContext$roo === void 0 ? void 0 : _renderingContext$roo.ownerDocument;
        renderingService.hooks.pick.tapPromise(CanvasPickerPlugin2.tag, /* @__PURE__ */ (function() {
          var _ref = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(result) {
            return _regeneratorRuntime().wrap(function(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", _this2.pick(document2, result));
                case 1:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          return function(_x) {
            return _ref.apply(this, arguments);
          };
        })());
        renderingService.hooks.pickSync.tap(CanvasPickerPlugin2.tag, function(result) {
          return _this2.pick(document2, result);
        });
      }
    }, {
      key: "pick",
      value: function pick7(document2, result) {
        var topmost = result.topmost, _result$position = result.position, x3 = _result$position.x, y3 = _result$position.y;
        var position2 = import_gl_matrix4.vec3.set(tmpVec3a, x3, y3, 0);
        var hitTestList = document2.elementsFromBBox(position2[0], position2[1], position2[0], position2[1]);
        var pickedDisplayObjects = [];
        var _iterator = _createForOfIteratorHelper(hitTestList), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _displayObject = _step.value;
            var worldTransform = _displayObject.getWorldTransform();
            var isHitOriginShape = this.isHit(_displayObject, position2, worldTransform, false);
            if (isHitOriginShape) {
              var clipped = findClosestClipPathTarget(_displayObject);
              if (clipped) {
                var clipPath = clipped.parsedStyle.clipPath;
                var isHitClipPath = this.isHit(clipPath, position2, clipPath.getWorldTransform(), true);
                if (isHitClipPath) {
                  if (topmost) {
                    result.picked = [_displayObject];
                    return result;
                  }
                  pickedDisplayObjects.push(_displayObject);
                }
              } else {
                if (topmost) {
                  result.picked = [_displayObject];
                  return result;
                }
                pickedDisplayObjects.push(_displayObject);
              }
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        result.picked = pickedDisplayObjects;
        return result;
      }
    }]);
  })();
  CanvasPickerPlugin.tag = "CanvasPicker";
  function isPointInPath$8(displayObject, position2, isClipPath) {
    var _ref = displayObject.parsedStyle, _ref$cx = _ref.cx, cx = _ref$cx === void 0 ? 0 : _ref$cx, _ref$cy = _ref.cy, cy = _ref$cy === void 0 ? 0 : _ref$cy, r = _ref.r, fill = _ref.fill, stroke = _ref.stroke, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
    var halfLineWidth = (lineWidth + increasedLineWidthForHitTesting) / 2;
    var absDistance = distance(cx, cy, position2.x, position2.y);
    var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
    if (hasFill && hasStroke || isClipPath) {
      return absDistance <= r + halfLineWidth;
    }
    if (hasFill) {
      return absDistance <= r;
    }
    if (hasStroke) {
      return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;
    }
    return false;
  }
  function ellipseDistance(squareX, squareY, rx, ry) {
    return squareX / (rx * rx) + squareY / (ry * ry);
  }
  function isPointInPath$7(displayObject, position2, isClipPath) {
    var _ref = displayObject.parsedStyle, _ref$cx = _ref.cx, cx = _ref$cx === void 0 ? 0 : _ref$cx, _ref$cy = _ref.cy, cy = _ref$cy === void 0 ? 0 : _ref$cy, rx = _ref.rx, ry = _ref.ry, fill = _ref.fill, stroke = _ref.stroke, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
    var x3 = position2.x, y3 = position2.y;
    var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
    var halfLineWith = (lineWidth + increasedLineWidthForHitTesting) / 2;
    var squareX = (x3 - cx) * (x3 - cx);
    var squareY = (y3 - cy) * (y3 - cy);
    if (hasFill && hasStroke || isClipPath) {
      return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
    }
    if (hasFill) {
      return ellipseDistance(squareX, squareY, rx, ry) <= 1;
    }
    if (hasStroke) {
      return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
    }
    return false;
  }
  function inBox(minX, minY, width2, height, x3, y3) {
    return x3 >= minX && x3 <= minX + width2 && y3 >= minY && y3 <= minY + height;
  }
  function inRect(minX, minY, width2, height, lineWidth, x3, y3) {
    var halfWidth = lineWidth / 2;
    return inBox(minX - halfWidth, minY - halfWidth, width2, lineWidth, x3, y3) || // 上边
    inBox(minX + width2 - halfWidth, minY - halfWidth, lineWidth, height, x3, y3) || // 右边
    inBox(minX + halfWidth, minY + height - halfWidth, width2, lineWidth, x3, y3) || // 下边
    inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x3, y3);
  }
  function inArc(cx, cy, r, startAngle, endAngle, lineWidth, x3, y3) {
    var angle2 = (Math.atan2(y3 - cy, x3 - cx) + Math.PI * 2) % (Math.PI * 2);
    var point4 = {
      x: cx + r * Math.cos(angle2),
      y: cy + r * Math.sin(angle2)
    };
    return distance(point4.x, point4.y, x3, y3) <= lineWidth / 2;
  }
  function inLine(x1, y1, x22, y22, lineWidth, x3, y3) {
    var minX = Math.min(x1, x22);
    var maxX = Math.max(x1, x22);
    var minY = Math.min(y1, y22);
    var maxY = Math.max(y1, y22);
    var halfWidth = lineWidth / 2;
    if (!(x3 >= minX - halfWidth && x3 <= maxX + halfWidth && y3 >= minY - halfWidth && y3 <= maxY + halfWidth)) {
      return false;
    }
    return pointToLine(x1, y1, x22, y22, x3, y3) <= lineWidth / 2;
  }
  function inPolyline(points, lineWidth, x3, y3, isClose) {
    var count = points.length;
    if (count < 2) {
      return false;
    }
    for (var i = 0; i < count - 1; i++) {
      var x1 = points[i][0];
      var y1 = points[i][1];
      var x22 = points[i + 1][0];
      var y22 = points[i + 1][1];
      if (inLine(x1, y1, x22, y22, lineWidth, x3, y3)) {
        return true;
      }
    }
    if (isClose) {
      var first = points[0];
      var last2 = points[count - 1];
      if (inLine(first[0], first[1], last2[0], last2[1], lineWidth, x3, y3)) {
        return true;
      }
    }
    return false;
  }
  var tolerance = 1e-6;
  function dcmp(x3) {
    if (Math.abs(x3) < tolerance) {
      return 0;
    }
    return x3 < 0 ? -1 : 1;
  }
  function onSegment(p1, p2, q) {
    if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
      return true;
    }
    return false;
  }
  function inPolygon(points, x3, y3) {
    var isHit = false;
    var n = points.length;
    if (n <= 2) {
      return false;
    }
    for (var i = 0; i < n; i++) {
      var p1 = points[i];
      var p2 = points[(i + 1) % n];
      if (onSegment(p1, p2, [x3, y3])) {
        return true;
      }
      if (dcmp(p1[1] - y3) > 0 !== dcmp(p2[1] - y3) > 0 && dcmp(x3 - (y3 - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
        isHit = !isHit;
      }
    }
    return isHit;
  }
  function inPolygons(polygons, x3, y3) {
    var isHit = false;
    for (var i = 0; i < polygons.length; i++) {
      var points = polygons[i];
      isHit = inPolygon(points, x3, y3);
      if (isHit) {
        break;
      }
    }
    return isHit;
  }
  function isPointInPath$6(displayObject, position2, isClipPath) {
    var _ref = displayObject.parsedStyle, x1 = _ref.x1, y1 = _ref.y1, x22 = _ref.x2, y22 = _ref.y2, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents, fill = _ref.fill, stroke = _ref.stroke;
    var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasStroke = _isFillOrStrokeAffect2[1];
    if (!hasStroke && !isClipPath || !lineWidth) {
      return false;
    }
    return inLine(x1, y1, x22, y22, lineWidth + increasedLineWidthForHitTesting, position2.x, position2.y);
  }
  function isPointInStroke(segments, lineWidth, px, py, length) {
    var isHit = false;
    var halfWidth = lineWidth / 2;
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box2 = segment.box;
      if (box2 && !inBox(box2.x - halfWidth, box2.y - halfWidth, box2.width + lineWidth, box2.height + lineWidth, px, py)) {
        continue;
      }
      switch (segment.command) {
        // L 和 Z 都是直线， M 不进行拾取
        case "L":
        case "Z":
          isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, px, py);
          if (isHit) {
            return true;
          }
          break;
        case "Q":
          var qDistance = pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], px, py);
          isHit = qDistance <= lineWidth / 2;
          if (isHit) {
            return true;
          }
          break;
        case "C":
          var cDistance = pointDistance$3(
            prePoint[0],
            // 上一段结束位置, 即 C 的起始点
            prePoint[1],
            params[1],
            // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点
            params[2],
            params[3],
            params[4],
            params[5],
            params[6],
            px,
            py,
            length
          );
          isHit = cDistance <= lineWidth / 2;
          if (isHit) {
            return true;
          }
          break;
        case "A":
          if (!segment.cubicParams) {
            segment.cubicParams = (0, import_util40.arcToCubic)(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6], params[7], void 0);
          }
          var args = segment.cubicParams;
          var prePointInCubic = prePoint;
          for (var _i = 0; _i < args.length; _i += 6) {
            var _cDistance = pointDistance$3(
              prePointInCubic[0],
              // 上一段结束位置, 即 C 的起始点
              prePointInCubic[1],
              args[_i],
              args[_i + 1],
              args[_i + 2],
              args[_i + 3],
              args[_i + 4],
              args[_i + 5],
              px,
              py,
              length
            );
            prePointInCubic = [args[_i + 4], args[_i + 5]];
            isHit = _cDistance <= lineWidth / 2;
            if (isHit) {
              return true;
            }
          }
          break;
      }
    }
    return isHit;
  }
  function isPointInPath$5(displayObject, position2, isClipPath, isPointInPath2, renderingPluginContext, runtime2) {
    var _ref = displayObject.parsedStyle, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, stroke = _ref.stroke, fill = _ref.fill, d2 = _ref.d, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
    var segments = d2.segments, hasArc = d2.hasArc, polylines = d2.polylines, polygons = d2.polygons;
    var _isFillOrStrokeAffect = isFillOrStrokeAffected(
      pointerEvents,
      // Only a closed path can be filled.
      (polygons === null || polygons === void 0 ? void 0 : polygons.length) && fill,
      stroke
    ), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
    var totalLength = getOrCalculatePathTotalLength(displayObject);
    var isHit = false;
    if (hasFill || isClipPath) {
      if (hasArc) {
        isHit = isPointInPath2(displayObject, position2);
      } else {
        isHit = inPolygons(polygons, position2.x, position2.y) || inPolygons(polylines, position2.x, position2.y);
      }
      return isHit;
    }
    if (hasStroke || isClipPath) {
      isHit = isPointInStroke(segments, lineWidth + increasedLineWidthForHitTesting, position2.x, position2.y, totalLength);
    }
    return isHit;
  }
  function isPointInPath$4(displayObject, position2, isClipPath) {
    var _ref = displayObject.parsedStyle, stroke = _ref.stroke, fill = _ref.fill, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, points = _ref.points, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
    var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
    var isHit = false;
    if (hasStroke || isClipPath) {
      isHit = inPolyline(points.points, lineWidth + increasedLineWidthForHitTesting, position2.x, position2.y, true);
    }
    if (!isHit && (hasFill || isClipPath)) {
      isHit = inPolygon(points.points, position2.x, position2.y);
    }
    return isHit;
  }
  function isPointInPath$3(displayObject, position2, isClipPath) {
    var _ref = displayObject.parsedStyle, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, points = _ref.points, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents, fill = _ref.fill, stroke = _ref.stroke;
    var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasStroke = _isFillOrStrokeAffect2[1];
    if (!hasStroke && !isClipPath || !lineWidth) {
      return false;
    }
    return inPolyline(points.points, lineWidth + increasedLineWidthForHitTesting, position2.x, position2.y, false);
  }
  function isPointInPath$2(displayObject, position2, isClipPath, isPointInPath2, runtime2) {
    var _ref = displayObject.parsedStyle, radius = _ref.radius, fill = _ref.fill, stroke = _ref.stroke, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, _ref$x = _ref.x, x3 = _ref$x === void 0 ? 0 : _ref$x, _ref$y = _ref.y, y3 = _ref$y === void 0 ? 0 : _ref$y, width2 = _ref.width, height = _ref.height, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
    var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
    var hasRadius = radius && radius.some(function(r) {
      return r !== 0;
    });
    var lineWidthForHitTesting = lineWidth + increasedLineWidthForHitTesting;
    if (!hasRadius) {
      var halfWidth = lineWidthForHitTesting / 2;
      if (hasFill && hasStroke || isClipPath) {
        return inBox(x3 - halfWidth, y3 - halfWidth, width2 + halfWidth, height + halfWidth, position2.x, position2.y);
      }
      if (hasFill) {
        return inBox(x3, y3, width2, height, position2.x, position2.y);
      }
      if (hasStroke) {
        return inRect(x3, y3, width2, height, lineWidthForHitTesting, position2.x, position2.y);
      }
    } else {
      var isHit = false;
      if (hasStroke || isClipPath) {
        isHit = inRectWithRadius(x3, y3, width2, height, radius.map(function(r) {
          return (0, import_util40.clamp)(r, 0, Math.min(Math.abs(width2) / 2, Math.abs(height) / 2));
        }), lineWidthForHitTesting, position2.x, position2.y);
      }
      if (!isHit && (hasFill || isClipPath)) {
        isHit = isPointInPath2(displayObject, position2);
      }
      return isHit;
    }
    return false;
  }
  function inRectWithRadius(minX, minY, width2, height, radiusArray, lineWidth, x3, y3) {
    var _radiusArray = _slicedToArray(radiusArray, 4), tlr = _radiusArray[0], trr = _radiusArray[1], brr = _radiusArray[2], blr = _radiusArray[3];
    return inLine(minX + tlr, minY, minX + width2 - trr, minY, lineWidth, x3, y3) || inLine(minX + width2, minY + trr, minX + width2, minY + height - brr, lineWidth, x3, y3) || inLine(minX + width2 - brr, minY + height, minX + blr, minY + height, lineWidth, x3, y3) || inLine(minX, minY + height - blr, minX, minY + tlr, lineWidth, x3, y3) || inArc(minX + width2 - trr, minY + trr, trr, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x3, y3) || inArc(minX + width2 - brr, minY + height - brr, brr, 0, 0.5 * Math.PI, lineWidth, x3, y3) || inArc(minX + blr, minY + height - blr, blr, 0.5 * Math.PI, Math.PI, lineWidth, x3, y3) || inArc(minX + tlr, minY + tlr, tlr, Math.PI, 1.5 * Math.PI, lineWidth, x3, y3);
  }
  function isPointInPath$1(displayObject, position2, isClipPath, isPointInPath2, renderingPluginContext, runtime2) {
    var _ref = displayObject.parsedStyle, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents, _ref$x = _ref.x, x3 = _ref$x === void 0 ? 0 : _ref$x, _ref$y = _ref.y, y3 = _ref$y === void 0 ? 0 : _ref$y, width2 = _ref.width, height = _ref.height;
    if (pointerEvents === "non-transparent-pixel") {
      var offscreenCanvas = renderingPluginContext.config.offscreenCanvas;
      var canvas2 = runtime2.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
      var context = runtime2.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas, {
        willReadFrequently: true
      });
      canvas2.width = width2;
      canvas2.height = height;
      renderingPluginContext.defaultStyleRendererFactory[Shape.IMAGE].render(context, _objectSpread2(_objectSpread2({}, displayObject.parsedStyle), {}, {
        x: 0,
        y: 0
      }), displayObject, void 0, void 0, void 0);
      var imagedata = context.getImageData(position2.x - x3, position2.y - y3, 1, 1).data;
      return imagedata.every(function(component) {
        return component !== 0;
      });
    }
    return true;
  }
  function isPointInPath(displayObject, position2, isClipPath, isPointInPath2) {
    var bounds = displayObject.getGeometryBounds();
    return position2.x >= bounds.min[0] && position2.y >= bounds.min[1] && position2.x <= bounds.max[0] && position2.y <= bounds.max[1];
  }
  var Plugin2 = /* @__PURE__ */ (function(_AbstractRendererPlug) {
    function Plugin8() {
      var _this2;
      _classCallCheck(this, Plugin8);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this2 = _callSuper(this, Plugin8, [].concat(args));
      _this2.name = "canvas-picker";
      return _this2;
    }
    _inherits(Plugin8, _AbstractRendererPlug);
    return _createClass(Plugin8, [{
      key: "init",
      value: function init() {
        var _pointInPathPickerFac;
        var pointInPathPickerFactory = (_pointInPathPickerFac = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_pointInPathPickerFac, Shape.CIRCLE, isPointInPath$8), Shape.ELLIPSE, isPointInPath$7), Shape.RECT, isPointInPath$2), Shape.LINE, isPointInPath$6), Shape.POLYLINE, isPointInPath$3), Shape.POLYGON, isPointInPath$4), Shape.PATH, isPointInPath$5), Shape.TEXT, isPointInPath), Shape.GROUP, null), Shape.IMAGE, isPointInPath$1), _defineProperty(_defineProperty(_pointInPathPickerFac, Shape.HTML, null), Shape.MESH, null));
        this.context.pointInPathPickerFactory = pointInPathPickerFactory;
        this.addRenderingPlugin(new CanvasPickerPlugin());
      }
    }, {
      key: "destroy",
      value: function destroy() {
        delete this.context.pointInPathPickerFactory;
        this.removeAllRenderingPlugins();
      }
    }]);
  })(AbstractRendererPlugin);

  // node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js
  function _classPrivateFieldBase(e, t) {
    if (!{}.hasOwnProperty.call(e, t)) throw new TypeError("attempted to use private field on non-instance");
    return e;
  }

  // node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js
  var id2 = 0;
  function _classPrivateFieldKey(e) {
    return "__private_" + id2++ + "_" + e;
  }

  // node_modules/@antv/g-plugin-canvas-renderer/dist/index.esm.js
  var import_gl_matrix6 = __toESM(require_cjs());
  var import_util42 = __toESM(require_lib());

  // node_modules/@antv/g-plugin-image-loader/dist/index.esm.js
  var import_util41 = __toESM(require_lib());
  var import_gl_matrix5 = __toESM(require_cjs());
  var RefCountCache = /* @__PURE__ */ (function() {
    function RefCountCache2() {
      _classCallCheck(this, RefCountCache2);
      this.cacheStore = /* @__PURE__ */ new Map();
    }
    return _createClass(RefCountCache2, [{
      key: "onRefAdded",
      value: function onRefAdded2(ref) {
      }
    }, {
      key: "has",
      value: function has(key) {
        return this.cacheStore.has(key);
      }
    }, {
      key: "put",
      value: function put(key, item, ref) {
        if (this.cacheStore.has(key)) {
          return false;
        }
        this.cacheStore.set(key, {
          value: item,
          counter: /* @__PURE__ */ new Set([ref.entity])
        });
        this.onRefAdded(ref);
        return true;
      }
    }, {
      key: "get",
      value: function get9(key, ref) {
        var cacheItem = this.cacheStore.get(key);
        if (!cacheItem) {
          return null;
        }
        if (!cacheItem.counter.has(ref.entity)) {
          cacheItem.counter.add(ref.entity);
          this.onRefAdded(ref);
        }
        return cacheItem.value;
      }
    }, {
      key: "update",
      value: function update(key, value, ref) {
        var cacheItem = this.cacheStore.get(key);
        if (!cacheItem) {
          return false;
        }
        cacheItem.value = _objectSpread2(_objectSpread2({}, cacheItem.value), value);
        if (!cacheItem.counter.has(ref.entity)) {
          cacheItem.counter.add(ref.entity);
          this.onRefAdded(ref);
        }
        return true;
      }
    }, {
      key: "release",
      value: function release(key, ref) {
        var cacheItem = this.cacheStore.get(key);
        if (!cacheItem) {
          return false;
        }
        cacheItem.counter["delete"](ref.entity);
        if (cacheItem.counter.size <= 0) {
          this.cacheStore["delete"](key);
        }
        return true;
      }
    }, {
      key: "releaseRef",
      value: function releaseRef(ref) {
        var _this2 = this;
        Array.from(this.cacheStore.keys()).forEach(function(key) {
          _this2.release(key, ref);
        });
      }
    }, {
      key: "getSize",
      value: function getSize() {
        return this.cacheStore.size;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.cacheStore.clear();
      }
    }]);
  })();
  var tasks = [];
  var nextFrameTasks = [];
  var ImageSlicer = /* @__PURE__ */ (function() {
    function ImageSlicer2() {
      _classCallCheck(this, ImageSlicer2);
    }
    return _createClass(ImageSlicer2, null, [{
      key: "stop",
      value: function stop() {
        var api = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ImageSlicer2.api;
        if (ImageSlicer2.rafId) {
          api.cancelAnimationFrame(ImageSlicer2.rafId);
          ImageSlicer2.rafId = null;
        }
      }
    }, {
      key: "executeTask",
      value: function executeTask() {
        var api = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ImageSlicer2.api;
        if (tasks.length <= 0 && nextFrameTasks.length <= 0) {
          return;
        }
        nextFrameTasks.forEach(function(task) {
          return task();
        });
        nextFrameTasks = tasks.splice(0, ImageSlicer2.TASK_NUM_PER_FRAME);
        ImageSlicer2.rafId = api.requestAnimationFrame(function() {
          ImageSlicer2.executeTask(api);
        });
      }
    }, {
      key: "sliceImage",
      value: function sliceImage(image, sliceWidth, sliceHeight, rerender) {
        var overlap = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
        var api = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : ImageSlicer2.api;
        var imageWidth = image.naturalWidth || image.width;
        var imageHeight = image.naturalHeight || image.height;
        var strideW = sliceWidth - overlap;
        var strideH = sliceHeight - overlap;
        var gridCols = Math.ceil(imageWidth / strideW);
        var gridRows = Math.ceil(imageHeight / strideH);
        var result = {
          tileSize: [sliceWidth, sliceHeight],
          gridSize: [gridRows, gridCols],
          tiles: Array(gridRows).fill(null).map(function() {
            return Array(gridCols).fill(null);
          })
        };
        var _loop = function _loop2(row3) {
          var _loop22 = function _loop23(col2) {
            tasks.push(function() {
              var startX = col2 * strideW;
              var startY = row3 * strideH;
              var _ref = [Math.min(sliceWidth, imageWidth - startX), Math.min(sliceHeight, imageHeight - startY)], tempSliceWidth = _ref[0], tempSliceHeight = _ref[1];
              var sliceCanvas = api.createCanvas();
              sliceCanvas.width = sliceWidth;
              sliceCanvas.height = sliceHeight;
              var sliceCtx = sliceCanvas.getContext("2d");
              sliceCtx.drawImage(image, startX, startY, tempSliceWidth, tempSliceHeight, 0, 0, tempSliceWidth, tempSliceHeight);
              result.tiles[row3][col2] = {
                x: startX,
                y: startY,
                tileX: col2,
                tileY: row3,
                data: sliceCanvas
              };
              rerender();
            });
          };
          for (var col = 0; col < gridCols; col++) {
            _loop22(col);
          }
        };
        for (var row2 = 0; row2 < gridRows; row2++) {
          _loop(row2);
        }
        ImageSlicer2.stop();
        ImageSlicer2.executeTask();
        return result;
      }
    }]);
  })();
  ImageSlicer.TASK_NUM_PER_FRAME = 10;
  var IMAGE_CACHE = new RefCountCache();
  IMAGE_CACHE.onRefAdded = function onRefAdded(ref) {
    var _this2 = this;
    ref.addEventListener(ElementEvent.DESTROY, function() {
      _this2.releaseRef(ref);
    }, {
      once: true
    });
  };
  var ImagePool = /* @__PURE__ */ (function() {
    function ImagePool2(context, runtime2) {
      _classCallCheck(this, ImagePool2);
      this.gradientCache = {};
      this.patternCache = {};
      this.context = context;
      this.runtime = runtime2;
    }
    return _createClass(ImagePool2, [{
      key: "getImageSync",
      value: function getImageSync(src, ref, callback) {
        var imageSource = (0, import_util41.isString)(src) ? src : src.src;
        if (IMAGE_CACHE.has(imageSource)) {
          var imageCache = IMAGE_CACHE.get(imageSource, ref);
          if (imageCache.img.complete) {
            callback === null || callback === void 0 || callback(imageCache);
            return imageCache;
          }
        }
        this.getOrCreateImage(src, ref).then(function(cache) {
          callback === null || callback === void 0 || callback(cache);
        })["catch"](function(reason) {
          console.error(reason);
        });
        return null;
      }
    }, {
      key: "getOrCreateImage",
      value: function getOrCreateImage(src, ref) {
        var _this2 = this;
        var imageSource = (0, import_util41.isString)(src) ? src : src.src;
        if (!(0, import_util41.isString)(src) && !IMAGE_CACHE.has(imageSource)) {
          var imageCache = {
            img: src,
            size: [src.naturalWidth || src.width, src.naturalHeight || src.height],
            tileSize: calculateImageTileSize(src)
          };
          IMAGE_CACHE.put(imageSource, imageCache, ref);
        }
        if (IMAGE_CACHE.has(imageSource)) {
          var _imageCache = IMAGE_CACHE.get(imageSource, ref);
          if (_imageCache.img.complete) {
            return Promise.resolve(_imageCache);
          }
          return new Promise(function(resolve, reject) {
            _imageCache.img.addEventListener("load", function() {
              _imageCache.size = [_imageCache.img.naturalWidth || _imageCache.img.width, _imageCache.img.naturalHeight || _imageCache.img.height];
              _imageCache.tileSize = calculateImageTileSize(_imageCache.img);
              resolve(_imageCache);
            });
            _imageCache.img.addEventListener("error", function(ev) {
              reject(ev);
            });
          });
        }
        return new Promise(function(resolve, reject) {
          var image = _this2.context.config.createImage();
          if (image) {
            var _imageCache2 = {
              img: image,
              size: [0, 0],
              tileSize: calculateImageTileSize(image)
            };
            IMAGE_CACHE.put(imageSource, _imageCache2, ref);
            image.onload = function() {
              _imageCache2.size = [image.naturalWidth || image.width, image.naturalHeight || image.height];
              _imageCache2.tileSize = calculateImageTileSize(_imageCache2.img);
              resolve(_imageCache2);
            };
            image.onerror = function(ev) {
              reject(ev);
            };
            image.crossOrigin = "Anonymous";
            image.src = imageSource;
          }
        });
      }
    }, {
      key: "createDownSampledImage",
      value: (function() {
        var _createDownSampledImage = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(src, ref) {
          var imageCache, enableLargeImageOptimization, _ref, _ref$maxDownSampledIm, maxDownSampledImageSize, _ref$downSamplingRate, downSamplingRateThreshold, createImageBitmapFunc, _imageCache$size, originWidth, originHeight, resizedImage, downSamplingRate, updateCache;
          return _regeneratorRuntime().wrap(function(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.next = 1;
                return this.getOrCreateImage(src, ref);
              case 1:
                imageCache = _context.sent;
                if (!(typeof imageCache.downSamplingRate !== "undefined")) {
                  _context.next = 2;
                  break;
                }
                return _context.abrupt("return", imageCache);
              case 2:
                enableLargeImageOptimization = this.context.config.enableLargeImageOptimization;
                _ref = typeof enableLargeImageOptimization === "boolean" ? {} : enableLargeImageOptimization, _ref$maxDownSampledIm = _ref.maxDownSampledImageSize, maxDownSampledImageSize = _ref$maxDownSampledIm === void 0 ? 2048 : _ref$maxDownSampledIm, _ref$downSamplingRate = _ref.downSamplingRateThreshold, downSamplingRateThreshold = _ref$downSamplingRate === void 0 ? 0.5 : _ref$downSamplingRate;
                createImageBitmapFunc = this.runtime.globalThis.createImageBitmap;
                _imageCache$size = _slicedToArray(imageCache.size, 2), originWidth = _imageCache$size[0], originHeight = _imageCache$size[1];
                resizedImage = imageCache.img;
                downSamplingRate = Math.min((maxDownSampledImageSize + maxDownSampledImageSize) / (originWidth + originHeight), Math.max(0.01, Math.min(downSamplingRateThreshold, 0.5)));
                updateCache = _objectSpread2(_objectSpread2({}, imageCache), {}, {
                  downSamplingRate
                });
                IMAGE_CACHE.update(imageCache.img.src, updateCache, ref);
                if (!createImageBitmapFunc) {
                  _context.next = 7;
                  break;
                }
                _context.prev = 3;
                _context.next = 4;
                return createImageBitmapFunc(imageCache.img, {
                  resizeWidth: originWidth * downSamplingRate,
                  resizeHeight: originHeight * downSamplingRate
                });
              case 4:
                resizedImage = _context.sent;
                _context.next = 6;
                break;
              case 5:
                _context.prev = 5;
                _context["catch"](3);
                downSamplingRate = 1;
              case 6:
                _context.next = 8;
                break;
              case 7:
                downSamplingRate = 1;
              case 8:
                updateCache = _objectSpread2(_objectSpread2({}, this.getImageSync(src, ref)), {}, {
                  downSampled: resizedImage,
                  downSamplingRate
                });
                IMAGE_CACHE.update(imageCache.img.src, updateCache, ref);
                return _context.abrupt("return", updateCache);
              case 9:
              case "end":
                return _context.stop();
            }
          }, _callee, this, [[3, 5]]);
        }));
        function createDownSampledImage(_x, _x2) {
          return _createDownSampledImage.apply(this, arguments);
        }
        return createDownSampledImage;
      })()
    }, {
      key: "createImageTiles",
      value: (function() {
        var _createImageTiles = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(src, tiles, rerender, ref) {
          var imageCache, _ref$ownerDocument$de, requestAnimationFrame2, cancelAnimationFrame2, updateCache;
          return _regeneratorRuntime().wrap(function(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 1;
                return this.getOrCreateImage(src, ref);
              case 1:
                imageCache = _context2.sent;
                _ref$ownerDocument$de = ref.ownerDocument.defaultView, requestAnimationFrame2 = _ref$ownerDocument$de.requestAnimationFrame, cancelAnimationFrame2 = _ref$ownerDocument$de.cancelAnimationFrame;
                ImageSlicer.api = {
                  requestAnimationFrame: requestAnimationFrame2,
                  cancelAnimationFrame: cancelAnimationFrame2,
                  createCanvas: function createCanvas2() {
                    return OffscreenCanvasCreator.createCanvas();
                  }
                };
                updateCache = _objectSpread2(_objectSpread2({}, imageCache), ImageSlicer.sliceImage(imageCache.img, imageCache.tileSize[0], imageCache.tileSize[0], rerender));
                IMAGE_CACHE.update(imageCache.img.src, updateCache, ref);
                return _context2.abrupt("return", updateCache);
              case 2:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
        function createImageTiles(_x3, _x4, _x5, _x6) {
          return _createImageTiles.apply(this, arguments);
        }
        return createImageTiles;
      })()
    }, {
      key: "releaseImage",
      value: function releaseImage(src, ref) {
        IMAGE_CACHE.release((0, import_util41.isString)(src) ? src : src.src, ref);
      }
    }, {
      key: "releaseImageRef",
      value: function releaseImageRef(ref) {
        IMAGE_CACHE.releaseRef(ref);
      }
    }, {
      key: "getOrCreatePatternSync",
      value: function getOrCreatePatternSync(object, pattern, context, $offscreenCanvas, dpr, min4, callback) {
        var patternKey = this.generatePatternKey(pattern);
        if (patternKey && this.patternCache[patternKey]) {
          return this.patternCache[patternKey];
        }
        var image = pattern.image, repetition = pattern.repetition, transform = pattern.transform;
        var src;
        var needScaleWithDPR = false;
        if ((0, import_util41.isString)(image)) {
          var imageCache = this.getImageSync(image, object, callback);
          src = imageCache === null || imageCache === void 0 ? void 0 : imageCache.img;
        } else if ($offscreenCanvas) {
          src = $offscreenCanvas;
          needScaleWithDPR = true;
        } else {
          src = image;
        }
        var canvasPattern = src && context.createPattern(src, repetition);
        if (canvasPattern) {
          var mat;
          if (transform) {
            mat = parsedTransformToMat4(parseTransform(transform), new DisplayObject({}));
          } else {
            mat = import_gl_matrix5.mat4.identity(import_gl_matrix5.mat4.create());
          }
          if (needScaleWithDPR) {
            import_gl_matrix5.mat4.scale(mat, mat, [1 / dpr, 1 / dpr, 1]);
          }
          canvasPattern.setTransform({
            a: mat[0],
            b: mat[1],
            c: mat[4],
            d: mat[5],
            e: mat[12] + min4[0],
            f: mat[13] + min4[1]
          });
        }
        if (patternKey && canvasPattern) {
          this.patternCache[patternKey] = canvasPattern;
        }
        return canvasPattern;
      }
    }, {
      key: "getOrCreateGradient",
      value: function getOrCreateGradient(params, context) {
        var key = this.generateGradientKey(params);
        var type = params.type, steps = params.steps, min4 = params.min, width2 = params.width, height = params.height, angle2 = params.angle, cx = params.cx, cy = params.cy, size2 = params.size;
        if (this.gradientCache[key]) {
          return this.gradientCache[key];
        }
        var gradient = null;
        if (type === GradientType.LinearGradient) {
          var _computeLinearGradien = computeLinearGradient(min4, width2, height, angle2), x1 = _computeLinearGradien.x1, y1 = _computeLinearGradien.y1, x22 = _computeLinearGradien.x2, y22 = _computeLinearGradien.y2;
          gradient = context.createLinearGradient(x1, y1, x22, y22);
        } else if (type === GradientType.RadialGradient) {
          var _computeRadialGradien = computeRadialGradient(min4, width2, height, cx, cy, size2), x3 = _computeRadialGradien.x, y3 = _computeRadialGradien.y, r = _computeRadialGradien.r;
          gradient = context.createRadialGradient(x3, y3, 0, x3, y3, r);
        }
        if (gradient) {
          steps.forEach(function(_ref2) {
            var offset = _ref2.offset, color2 = _ref2.color;
            if (offset.unit === UnitType.kPercentage) {
              var _gradient;
              (_gradient = gradient) === null || _gradient === void 0 || _gradient.addColorStop(offset.value / 100, color2.toString());
            }
          });
          this.gradientCache[key] = gradient;
        }
        return this.gradientCache[key];
      }
    }, {
      key: "generateGradientKey",
      value: function generateGradientKey(params) {
        var type = params.type, min4 = params.min, width2 = params.width, height = params.height, steps = params.steps, angle2 = params.angle, cx = params.cx, cy = params.cy, size2 = params.size;
        return "gradient-".concat(type, "-").concat((angle2 === null || angle2 === void 0 ? void 0 : angle2.toString()) || 0, "-").concat((cx === null || cx === void 0 ? void 0 : cx.toString()) || 0, "-").concat((cy === null || cy === void 0 ? void 0 : cy.toString()) || 0, "-").concat((size2 === null || size2 === void 0 ? void 0 : size2.toString()) || 0, "-").concat(min4[0], "-").concat(min4[1], "-").concat(width2, "-").concat(height, "-").concat(steps.map(function(_ref3) {
          var offset = _ref3.offset, color2 = _ref3.color;
          return "".concat(offset).concat(color2);
        }).join("-"));
      }
    }, {
      key: "generatePatternKey",
      value: function generatePatternKey(pattern) {
        var image = pattern.image, repetition = pattern.repetition;
        if ((0, import_util41.isString)(image)) {
          return "pattern-".concat(image, "-").concat(repetition);
        }
        if (image.nodeName === "rect") {
          return "pattern-".concat(image.entity, "-").concat(repetition);
        }
      }
    }]);
  })();
  ImagePool.isSupportTile = !!OffscreenCanvasCreator.createCanvas();
  function calculateImageTileSize(img) {
    if (!img.complete) {
      return [0, 0];
    }
    var width2 = img.naturalWidth || img.width, height = img.naturalHeight || img.height;
    var tileSize = 256;
    [256, 512].forEach(function(size2) {
      var rows = Math.ceil(height / size2);
      var cols = Math.ceil(width2 / size2);
      if (rows * cols < 1e3) {
        tileSize = size2;
      }
    });
    return [tileSize, tileSize];
  }
  var LoadImagePlugin = /* @__PURE__ */ (function() {
    function LoadImagePlugin2() {
      _classCallCheck(this, LoadImagePlugin2);
    }
    return _createClass(LoadImagePlugin2, [{
      key: "apply",
      value: function apply3(context) {
        var renderingService = context.renderingService, renderingContext = context.renderingContext, imagePool = context.imagePool;
        var canvas2 = renderingContext.root.ownerDocument.defaultView;
        var calculateWithAspectRatio = function calculateWithAspectRatio2(object, imageWidth, imageHeight) {
          var _object$parsedStyle = object.parsedStyle, width2 = _object$parsedStyle.width, height = _object$parsedStyle.height;
          if (width2 && !height) {
            object.setAttribute("height", imageHeight / imageWidth * width2);
          } else if (!width2 && height) {
            object.setAttribute("width", imageWidth / imageHeight * height);
          }
        };
        var handleMounted = function handleMounted2(e) {
          var object = e.target;
          var nodeName = object.nodeName, attributes = object.attributes;
          if (nodeName === Shape.IMAGE) {
            var src = attributes.src, keepAspectRatio = attributes.keepAspectRatio;
            imagePool.getImageSync(src, object, function(_ref) {
              var _ref$img = _ref.img, width2 = _ref$img.width, height = _ref$img.height;
              if (keepAspectRatio) {
                calculateWithAspectRatio(object, width2, height);
              }
              object.renderable.dirty = true;
              renderingService.dirtify();
            });
          }
        };
        var handleAttributeChanged = function handleAttributeChanged2(e) {
          var object = e.target;
          var attrName = e.attrName, prevValue = e.prevValue, newValue = e.newValue;
          if (object.nodeName !== Shape.IMAGE || attrName !== "src") {
            return;
          }
          if (prevValue !== newValue) {
            imagePool.releaseImage(prevValue, object);
          }
          if ((0, import_util41.isString)(newValue)) {
            imagePool.getOrCreateImage(newValue, object).then(function(_ref2) {
              var _ref2$img = _ref2.img, width2 = _ref2$img.width, height = _ref2$img.height;
              if (object.attributes.keepAspectRatio) {
                calculateWithAspectRatio(object, width2, height);
              }
              object.renderable.dirty = true;
              renderingService.dirtify();
            })["catch"](function() {
            });
          }
        };
        renderingService.hooks.init.tap(LoadImagePlugin2.tag, function() {
          canvas2.addEventListener(ElementEvent.MOUNTED, handleMounted);
          canvas2.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        });
        renderingService.hooks.destroy.tap(LoadImagePlugin2.tag, function() {
          canvas2.removeEventListener(ElementEvent.MOUNTED, handleMounted);
          canvas2.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        });
      }
    }]);
  })();
  LoadImagePlugin.tag = "LoadImage";
  var Plugin3 = /* @__PURE__ */ (function(_AbstractRendererPlug) {
    function Plugin8() {
      var _this2;
      _classCallCheck(this, Plugin8);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this2 = _callSuper(this, Plugin8, [].concat(args));
      _this2.name = "image-loader";
      return _this2;
    }
    _inherits(Plugin8, _AbstractRendererPlug);
    return _createClass(Plugin8, [{
      key: "init",
      value: function init(runtime2) {
        this.context.imagePool = new ImagePool(this.context, runtime2);
        this.addRenderingPlugin(new LoadImagePlugin());
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.removeAllRenderingPlugins();
      }
    }]);
  })(AbstractRendererPlugin);

  // node_modules/@antv/g-plugin-canvas-renderer/dist/index.esm.js
  var _renderState = /* @__PURE__ */ _classPrivateFieldKey("renderState");
  var CanvasRendererPlugin = /* @__PURE__ */ (function() {
    function CanvasRendererPlugin2(canvasRendererPluginOptions) {
      _classCallCheck(this, CanvasRendererPlugin2);
      this.removedRBushNodeAABBs = [];
      this.renderQueue = [];
      Object.defineProperty(this, _renderState, {
        writable: true,
        value: {
          restoreStack: [],
          prevObject: null,
          currentContext: /* @__PURE__ */ new Map()
        }
      });
      this.clearFullScreenLastFrame = false;
      this.clearFullScreen = false;
      this.vpMatrix = import_gl_matrix6.mat4.create();
      this.dprMatrix = import_gl_matrix6.mat4.create();
      this.tmpMat4 = import_gl_matrix6.mat4.create();
      this.vec3a = import_gl_matrix6.vec3.create();
      this.vec3b = import_gl_matrix6.vec3.create();
      this.vec3c = import_gl_matrix6.vec3.create();
      this.vec3d = import_gl_matrix6.vec3.create();
      this.canvasRendererPluginOptions = canvasRendererPluginOptions;
    }
    return _createClass(CanvasRendererPlugin2, [{
      key: "apply",
      value: function apply3(context, runtime2) {
        var _this2 = this;
        this.context = context;
        var _this$context = this.context, config = _this$context.config, camera = _this$context.camera, renderingService = _this$context.renderingService, renderingContext = _this$context.renderingContext, rBushRoot = _this$context.rBushRoot, pathGeneratorFactory = _this$context.pathGeneratorFactory;
        var enableRenderingOptimization = config.renderer.getConfig().enableRenderingOptimization;
        config.renderer.getConfig().enableDirtyCheck = false;
        config.renderer.getConfig().enableDirtyRectangleRendering = false;
        this.rBush = rBushRoot;
        this.pathGeneratorFactory = pathGeneratorFactory;
        var contextService = context.contextService;
        var canvas2 = renderingContext.root.ownerDocument.defaultView;
        var handleUnmounted = function handleUnmounted2(e) {
          var object = e.target;
          var rBushNode = object.rBushNode;
          if (rBushNode !== null && rBushNode !== void 0 && rBushNode.aabb) {
            _this2.removedRBushNodeAABBs.push(rBushNode.aabb);
          }
        };
        var handleCulled = function handleCulled2(e) {
          var object = e.target;
          var rBushNode = object.rBushNode;
          if (rBushNode.aabb) {
            _this2.removedRBushNodeAABBs.push(rBushNode.aabb);
          }
        };
        renderingService.hooks.init.tap(CanvasRendererPlugin2.tag, function() {
          canvas2.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
          canvas2.addEventListener(ElementEvent.CULLED, handleCulled);
          var dpr = contextService.getDPR();
          var width2 = config.width, height = config.height;
          var context2 = contextService.getContext();
          _this2.clearRect(context2, 0, 0, width2 * dpr, height * dpr, config.background);
        });
        renderingService.hooks.destroy.tap(CanvasRendererPlugin2.tag, function() {
          canvas2.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
          canvas2.removeEventListener(ElementEvent.CULLED, handleCulled);
          _this2.renderQueue = [];
          _this2.removedRBushNodeAABBs = [];
          _classPrivateFieldBase(_this2, _renderState)[_renderState] = {
            restoreStack: [],
            prevObject: null,
            currentContext: null
          };
        });
        var beforeDraw = function beforeDraw2() {
          var _canvas$context$rende;
          var context2 = contextService.getContext();
          var dpr = contextService.getDPR();
          var width2 = config.width, height = config.height;
          var _this$canvasRendererP = _this2.canvasRendererPluginOptions, dirtyObjectNumThreshold = _this$canvasRendererP.dirtyObjectNumThreshold, dirtyObjectRatioThreshold = _this$canvasRendererP.dirtyObjectRatioThreshold;
          var _renderingService$get = renderingService.getStats(), total = _renderingService$get.total, rendered = _renderingService$get.rendered;
          var ratio = rendered / total;
          _this2.clearFullScreen = _this2.clearFullScreenLastFrame || // @ts-ignore
          !((_canvas$context$rende = canvas2.context.renderingPlugins[1]) !== null && _canvas$context$rende !== void 0 && _canvas$context$rende.isFirstTimeRenderingFinished) || renderingService.disableDirtyRectangleRendering() || rendered > dirtyObjectNumThreshold && ratio > dirtyObjectRatioThreshold;
          if (!context2) {
            return;
          }
          if (typeof context2.resetTransform === "function") {
            context2.resetTransform();
          } else {
            context2.setTransform(1, 0, 0, 1, 0, 0);
          }
          if (_this2.clearFullScreen) {
            _this2.clearRect(context2, 0, 0, width2 * dpr, height * dpr, config.background);
          }
        };
        var renderByZIndex = function renderByZIndex2(object, context2) {
          var stack = [object];
          while (stack.length > 0) {
            var _currentObject$sortab;
            var currentObject = stack.pop();
            if (currentObject.isVisible() && !currentObject.isCulled()) {
              if (enableRenderingOptimization) {
                _this2.renderDisplayObjectOptimized(currentObject, context2, _this2.context, _classPrivateFieldBase(_this2, _renderState)[_renderState], runtime2);
              } else {
                _this2.renderDisplayObject(currentObject, context2, _this2.context, _classPrivateFieldBase(_this2, _renderState)[_renderState], runtime2);
              }
            }
            var objects = ((_currentObject$sortab = currentObject.sortable) === null || _currentObject$sortab === void 0 || (_currentObject$sortab = _currentObject$sortab.sorted) === null || _currentObject$sortab === void 0 ? void 0 : _currentObject$sortab.length) > 0 ? currentObject.sortable.sorted : currentObject.childNodes;
            for (var i = objects.length - 1; i >= 0; i--) {
              stack.push(objects[i]);
            }
          }
        };
        renderingService.hooks.endFrame.tap(CanvasRendererPlugin2.tag, function() {
          beforeDraw();
          if (renderingContext.root.childNodes.length === 0) {
            _this2.clearFullScreenLastFrame = true;
            return;
          }
          enableRenderingOptimization = config.renderer.getConfig().enableRenderingOptimization;
          _classPrivateFieldBase(_this2, _renderState)[_renderState] = {
            restoreStack: [],
            prevObject: null,
            currentContext: _classPrivateFieldBase(_this2, _renderState)[_renderState].currentContext
          };
          _classPrivateFieldBase(_this2, _renderState)[_renderState].currentContext.clear();
          _this2.clearFullScreenLastFrame = false;
          var context2 = contextService.getContext();
          var dpr = contextService.getDPR();
          import_gl_matrix6.mat4.fromScaling(_this2.dprMatrix, [dpr, dpr, 1]);
          import_gl_matrix6.mat4.multiply(_this2.vpMatrix, _this2.dprMatrix, camera.getOrthoMatrix());
          if (_this2.clearFullScreen) {
            if (enableRenderingOptimization) {
              context2.save();
              renderByZIndex(renderingContext.root, context2);
              context2.restore();
            } else {
              renderByZIndex(renderingContext.root, context2);
            }
            _this2.removedRBushNodeAABBs = [];
          } else {
            var dirtyRenderBounds = _this2.safeMergeAABB.apply(_this2, [_this2.mergeDirtyAABBs(_this2.renderQueue)].concat(_toConsumableArray(_this2.removedRBushNodeAABBs.map(function(_ref) {
              var minX = _ref.minX, minY = _ref.minY, maxX = _ref.maxX, maxY = _ref.maxY;
              var aabb = new AABB();
              aabb.setMinMax(
                // vec3.fromValues(minX, minY, 0),
                // vec3.fromValues(maxX, maxY, 0),
                [minX, minY, 0],
                [maxX, maxY, 0]
              );
              return aabb;
            }))));
            _this2.removedRBushNodeAABBs = [];
            if (AABB.isEmpty(dirtyRenderBounds)) {
              _this2.renderQueue = [];
              return;
            }
            var dirtyRect = _this2.convertAABB2Rect(dirtyRenderBounds);
            var x3 = dirtyRect.x, y3 = dirtyRect.y, width2 = dirtyRect.width, height = dirtyRect.height;
            var tl = import_gl_matrix6.vec3.transformMat4(_this2.vec3a, [x3, y3, 0], _this2.vpMatrix);
            var tr = import_gl_matrix6.vec3.transformMat4(_this2.vec3b, [x3 + width2, y3, 0], _this2.vpMatrix);
            var bl = import_gl_matrix6.vec3.transformMat4(_this2.vec3c, [x3, y3 + height, 0], _this2.vpMatrix);
            var br = import_gl_matrix6.vec3.transformMat4(_this2.vec3d, [x3 + width2, y3 + height, 0], _this2.vpMatrix);
            var minx = Math.min(tl[0], tr[0], br[0], bl[0]);
            var miny = Math.min(tl[1], tr[1], br[1], bl[1]);
            var maxx = Math.max(tl[0], tr[0], br[0], bl[0]);
            var maxy = Math.max(tl[1], tr[1], br[1], bl[1]);
            var ix = Math.floor(minx);
            var iy = Math.floor(miny);
            var iwidth = Math.ceil(maxx - minx);
            var iheight = Math.ceil(maxy - miny);
            context2.save();
            _this2.clearRect(context2, ix, iy, iwidth, iheight, config.background);
            context2.beginPath();
            context2.rect(ix, iy, iwidth, iheight);
            context2.clip();
            context2.setTransform(_this2.vpMatrix[0], _this2.vpMatrix[1], _this2.vpMatrix[4], _this2.vpMatrix[5], _this2.vpMatrix[12], _this2.vpMatrix[13]);
            var _config$renderer$getC = config.renderer.getConfig(), enableDirtyRectangleRenderingDebug = _config$renderer$getC.enableDirtyRectangleRenderingDebug;
            if (enableDirtyRectangleRenderingDebug) {
              canvas2.dispatchEvent(new CustomEvent(CanvasEvent.DIRTY_RECTANGLE, {
                dirtyRect: {
                  x: ix,
                  y: iy,
                  width: iwidth,
                  height: iheight
                }
              }));
            }
            var dirtyObjects = _this2.searchDirtyObjects(dirtyRenderBounds);
            dirtyObjects.sort(function(a2, b) {
              return a2.sortable.renderOrder - b.sortable.renderOrder;
            }).forEach(function(object) {
              if (object && object.isVisible() && !object.isCulled()) {
                _this2.renderDisplayObject(object, context2, _this2.context, _classPrivateFieldBase(_this2, _renderState)[_renderState], runtime2);
              }
            });
            context2.restore();
            _this2.renderQueue.forEach(function(object) {
              _this2.saveDirtyAABB(object);
            });
            _this2.renderQueue = [];
          }
          _classPrivateFieldBase(_this2, _renderState)[_renderState].restoreStack.forEach(function() {
            context2.restore();
          });
          _classPrivateFieldBase(_this2, _renderState)[_renderState].restoreStack = [];
        });
        renderingService.hooks.render.tap(CanvasRendererPlugin2.tag, function(object) {
          if (!_this2.clearFullScreen) {
            _this2.renderQueue.push(object);
          }
        });
      }
    }, {
      key: "clearRect",
      value: function clearRect(context, x3, y3, width2, height, background) {
        context.clearRect(x3, y3, width2, height);
        if (background) {
          context.fillStyle = background;
          context.fillRect(x3, y3, width2, height);
        }
      }
    }, {
      key: "renderDisplayObjectOptimized",
      value: function renderDisplayObjectOptimized(object, context, canvasContext, renderState, runtime2) {
        var nodeName = object.nodeName;
        var updateTransform = false;
        var clipDraw = false;
        var styleRenderer = this.context.styleRendererFactory[nodeName];
        var generatePath2 = this.pathGeneratorFactory[nodeName];
        var clipPath = object.parsedStyle.clipPath;
        if (clipPath) {
          updateTransform = !renderState.prevObject || !import_gl_matrix6.mat4.exactEquals(clipPath.getWorldTransform(), renderState.prevObject.getWorldTransform());
          if (updateTransform) {
            this.applyWorldTransform(context, clipPath);
            renderState.prevObject = null;
          }
          var _generatePath = this.pathGeneratorFactory[clipPath.nodeName];
          if (_generatePath) {
            context.save();
            clipDraw = true;
            context.beginPath();
            _generatePath(context, clipPath.parsedStyle);
            context.closePath();
            context.clip();
          }
        }
        if (styleRenderer) {
          updateTransform = !renderState.prevObject || !import_gl_matrix6.mat4.exactEquals(object.getWorldTransform(), renderState.prevObject.getWorldTransform());
          if (updateTransform) {
            this.applyWorldTransform(context, object);
          }
          var forceUpdateStyle = !renderState.prevObject;
          if (!forceUpdateStyle) {
            var prevNodeName = renderState.prevObject.nodeName;
            if (nodeName === Shape.TEXT) {
              forceUpdateStyle = prevNodeName !== Shape.TEXT;
            } else if (nodeName === Shape.IMAGE) {
              forceUpdateStyle = prevNodeName !== Shape.IMAGE;
            } else {
              forceUpdateStyle = prevNodeName === Shape.TEXT || prevNodeName === Shape.IMAGE;
            }
          }
          styleRenderer.applyStyleToContext(context, object, forceUpdateStyle, renderState);
          renderState.prevObject = object;
        }
        if (generatePath2) {
          context.beginPath();
          generatePath2(context, object.parsedStyle);
          if (nodeName !== Shape.LINE && nodeName !== Shape.PATH && nodeName !== Shape.POLYLINE) {
            context.closePath();
          }
        }
        if (styleRenderer) {
          styleRenderer.drawToContext(context, object, _classPrivateFieldBase(this, _renderState)[_renderState], this, runtime2);
        }
        if (clipDraw) {
          context.restore();
        }
        object.dirty(false);
      }
    }, {
      key: "renderDisplayObject",
      value: function renderDisplayObject(object, context, canvasContext, renderState, runtime2) {
        var nodeName = object.nodeName;
        var parent = renderState.restoreStack[renderState.restoreStack.length - 1];
        if (parent && !(object.compareDocumentPosition(parent) & Node.DOCUMENT_POSITION_CONTAINS)) {
          context.restore();
          renderState.restoreStack.pop();
        }
        var styleRenderer = this.context.styleRendererFactory[nodeName];
        var generatePath2 = this.pathGeneratorFactory[nodeName];
        var clipPath = object.parsedStyle.clipPath;
        if (clipPath) {
          this.applyWorldTransform(context, clipPath);
          var _generatePath2 = this.pathGeneratorFactory[clipPath.nodeName];
          if (_generatePath2) {
            context.save();
            renderState.restoreStack.push(object);
            context.beginPath();
            _generatePath2(context, clipPath.parsedStyle);
            context.closePath();
            context.clip();
          }
        }
        if (styleRenderer) {
          this.applyWorldTransform(context, object);
          context.save();
          this.applyAttributesToContext(context, object);
        }
        if (generatePath2) {
          context.beginPath();
          generatePath2(context, object.parsedStyle);
          if (nodeName !== Shape.LINE && nodeName !== Shape.PATH && nodeName !== Shape.POLYLINE) {
            context.closePath();
          }
        }
        if (styleRenderer) {
          styleRenderer.render(context, object.parsedStyle, object, canvasContext, this, runtime2);
          context.restore();
        }
        object.dirty(false);
      }
    }, {
      key: "applyAttributesToContext",
      value: function applyAttributesToContext(context, object) {
        var _ref2 = object.parsedStyle, stroke = _ref2.stroke, fill = _ref2.fill, opacity = _ref2.opacity, lineDash = _ref2.lineDash, lineDashOffset = _ref2.lineDashOffset;
        if (lineDash) {
          context.setLineDash(lineDash);
        }
        if (!(0, import_util42.isNil)(lineDashOffset)) {
          context.lineDashOffset = lineDashOffset;
        }
        if (!(0, import_util42.isNil)(opacity)) {
          context.globalAlpha *= opacity;
        }
        if (!(0, import_util42.isNil)(stroke) && !Array.isArray(stroke) && !stroke.isNone) {
          context.strokeStyle = object.attributes.stroke;
        }
        if (!(0, import_util42.isNil)(fill) && !Array.isArray(fill) && !fill.isNone) {
          context.fillStyle = object.attributes.fill;
        }
      }
    }, {
      key: "convertAABB2Rect",
      value: function convertAABB2Rect(aabb) {
        var min4 = aabb.getMin();
        var max4 = aabb.getMax();
        var minX = Math.floor(min4[0]);
        var minY = Math.floor(min4[1]);
        var maxX = Math.ceil(max4[0]);
        var maxY = Math.ceil(max4[1]);
        var width2 = maxX - minX;
        var height = maxY - minY;
        return {
          x: minX,
          y: minY,
          width: width2,
          height
        };
      }
      /**
       * TODO: merge dirty rectangles with some strategies.
       * For now, we just simply merge all the rectangles into one.
       * @see https://idom.me/articles/841.html
       */
    }, {
      key: "mergeDirtyAABBs",
      value: function mergeDirtyAABBs(dirtyObjects) {
        var aabb = new AABB();
        dirtyObjects.forEach(function(object) {
          var renderBounds = object.getRenderBounds();
          aabb.add(renderBounds);
          var dirtyRenderBounds = object.renderable.dirtyRenderBounds;
          if (dirtyRenderBounds) {
            aabb.add(dirtyRenderBounds);
          }
        });
        return aabb;
      }
    }, {
      key: "searchDirtyObjects",
      value: function searchDirtyObjects(dirtyRectangle) {
        var _dirtyRectangle$getMi = dirtyRectangle.getMin(), _dirtyRectangle$getMi2 = _slicedToArray(_dirtyRectangle$getMi, 2), minX = _dirtyRectangle$getMi2[0], minY = _dirtyRectangle$getMi2[1];
        var _dirtyRectangle$getMa = dirtyRectangle.getMax(), _dirtyRectangle$getMa2 = _slicedToArray(_dirtyRectangle$getMa, 2), maxX = _dirtyRectangle$getMa2[0], maxY = _dirtyRectangle$getMa2[1];
        var rBushNodes = this.rBush.search({
          minX,
          minY,
          maxX,
          maxY
        });
        return rBushNodes.map(function(_ref3) {
          var displayObject = _ref3.displayObject;
          return displayObject;
        });
      }
    }, {
      key: "saveDirtyAABB",
      value: function saveDirtyAABB(object) {
        var renderable = object.renderable;
        if (!renderable.dirtyRenderBounds) {
          renderable.dirtyRenderBounds = new AABB();
        }
        var renderBounds = object.getRenderBounds();
        if (renderBounds) {
          renderable.dirtyRenderBounds.update(renderBounds.center, renderBounds.halfExtents);
        }
      }
    }, {
      key: "applyWorldTransform",
      value: function applyWorldTransform(context, object, matrix3) {
        if (matrix3) {
          import_gl_matrix6.mat4.copy(this.tmpMat4, object.getLocalTransform());
          import_gl_matrix6.mat4.multiply(this.tmpMat4, matrix3, this.tmpMat4);
          import_gl_matrix6.mat4.multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);
        } else {
          import_gl_matrix6.mat4.copy(this.tmpMat4, object.getWorldTransform());
          import_gl_matrix6.mat4.multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);
        }
        context.setTransform(this.tmpMat4[0], this.tmpMat4[1], this.tmpMat4[4], this.tmpMat4[5], this.tmpMat4[12], this.tmpMat4[13]);
      }
    }, {
      key: "safeMergeAABB",
      value: function safeMergeAABB() {
        var merged = new AABB();
        for (var _len = arguments.length, aabbs = new Array(_len), _key = 0; _key < _len; _key++) {
          aabbs[_key] = arguments[_key];
        }
        aabbs.forEach(function(aabb) {
          merged.add(aabb);
        });
        return merged;
      }
    }]);
  })();
  CanvasRendererPlugin.tag = "CanvasRenderer";
  function getPattern(pattern, object, context, canvasContext, plugin, runtime2, imagePool) {
    var $offscreenCanvas;
    var dpr;
    if (pattern.image.nodeName === "rect") {
      var _parsedStyle = pattern.image.parsedStyle, width2 = _parsedStyle.width, height = _parsedStyle.height;
      dpr = canvasContext.contextService.getDPR();
      var offscreenCanvas = canvasContext.config.offscreenCanvas;
      $offscreenCanvas = runtime2.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
      $offscreenCanvas.width = width2 * dpr;
      $offscreenCanvas.height = height * dpr;
      var offscreenCanvasContext = runtime2.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
      var renderState = {
        restoreStack: [],
        prevObject: null,
        currentContext: /* @__PURE__ */ new Map()
      };
      pattern.image.forEach(function(object2) {
        plugin.renderDisplayObject(object2, offscreenCanvasContext, canvasContext, renderState, runtime2);
      });
      renderState.restoreStack.forEach(function() {
        offscreenCanvasContext.restore();
      });
    }
    var canvasPattern = imagePool.getOrCreatePatternSync(object, pattern, context, $offscreenCanvas, dpr, object.getGeometryBounds().min, function() {
      object.dirty();
      canvasContext.renderingService.dirtify();
    });
    return canvasPattern;
  }
  function getColor(parsedColor, object, context, imagePool) {
    var color2;
    if (parsedColor.type === GradientType.LinearGradient || parsedColor.type === GradientType.RadialGradient) {
      var bounds = object.getGeometryBounds();
      var width2 = bounds && bounds.halfExtents[0] * 2 || 1;
      var height = bounds && bounds.halfExtents[1] * 2 || 1;
      var min4 = bounds && bounds.min || [0, 0];
      color2 = imagePool.getOrCreateGradient(_objectSpread2(_objectSpread2({
        type: parsedColor.type
      }, parsedColor.value), {}, {
        min: min4,
        width: width2,
        height
      }), context);
    }
    return color2;
  }
  var SHADOW_NUMBER_STYLE = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"];
  var STROKE_STYLE = ["lineCap", "lineJoin", "miterLimit"];
  var DEFAULT_STYLE = {
    // common
    globalAlpha: 1,
    shadowBlur: 0,
    shadowOffsetX: 0,
    shadowOffsetY: 0,
    shadowColor: "#000",
    filter: "none",
    globalCompositeOperation: "source-over",
    // stroke/fill
    strokeStyle: "#000",
    strokeOpacity: 1,
    lineWidth: 1,
    lineDash: [],
    lineDashOffset: 0,
    lineCap: "butt",
    lineJoin: "miter",
    miterLimit: 10,
    fillStyle: "#000",
    fillOpacity: 1
    // image
  };
  var defaultParsedStyle = {};
  function updateContextIfNotHitCache(context, key, value, cache) {
    var prevValue = cache.has(key) ? cache.get(key) : DEFAULT_STYLE[key];
    if (prevValue !== value) {
      if (key === "lineDash") {
        context.setLineDash(value);
      } else {
        context[key] = value;
      }
      cache.set(key, value);
    }
    return prevValue;
  }
  var OptimizedDefaultRenderer = /* @__PURE__ */ (function() {
    function OptimizedDefaultRenderer2(imagePool) {
      _classCallCheck(this, OptimizedDefaultRenderer2);
      this.imagePool = imagePool;
    }
    return _createClass(OptimizedDefaultRenderer2, [{
      key: "applyAttributesToContext",
      value: function applyAttributesToContext(context, object) {
      }
    }, {
      key: "render",
      value: function render(context, parsedStyle, object, canvasContext, plugin, runtime2) {
      }
      // #region common style
    }, {
      key: "applyCommonStyleToContext",
      value: function applyCommonStyleToContext(context, object, forceUpdate, renderState) {
        var prevStyle = forceUpdate ? defaultParsedStyle : renderState.prevObject.parsedStyle;
        var style = object.parsedStyle;
        if (forceUpdate || style.opacity !== prevStyle.opacity) {
          updateContextIfNotHitCache(context, "globalAlpha", !(0, import_util42.isNil)(style.opacity) ? style.opacity : DEFAULT_STYLE.globalAlpha, renderState.currentContext);
        }
        if (forceUpdate || style.blend !== prevStyle.blend) {
          updateContextIfNotHitCache(
            context,
            "globalCompositeOperation",
            // @ts-ignore
            !(0, import_util42.isNil)(style.blend) ? (
              // @ts-ignore
              style.blend
            ) : DEFAULT_STYLE.globalCompositeOperation,
            renderState.currentContext
          );
        }
      }
      // #endregion common style
      // #region stroke/fill style
    }, {
      key: "applyStrokeFillStyleToContext",
      value: function applyStrokeFillStyleToContext(context, object, forceUpdate, renderState) {
        var prevStyle = forceUpdate ? defaultParsedStyle : renderState.prevObject.parsedStyle;
        var style = object.parsedStyle;
        var _style$lineWidth = style.lineWidth, lineWidth = _style$lineWidth === void 0 ? DEFAULT_STYLE.lineWidth : _style$lineWidth;
        var hasFill = style.fill && !style.fill.isNone;
        var hasStroke = style.stroke && !style.stroke.isNone && lineWidth > 0;
        if (hasStroke) {
          if (forceUpdate || object.attributes.stroke !== renderState.prevObject.attributes.stroke) {
            var value = !(0, import_util42.isNil)(style.stroke) && !Array.isArray(style.stroke) && !style.stroke.isNone ? object.attributes.stroke : DEFAULT_STYLE.strokeStyle;
            updateContextIfNotHitCache(context, "strokeStyle", value, renderState.currentContext);
          }
          if (forceUpdate || style.lineWidth !== prevStyle.lineWidth) {
            updateContextIfNotHitCache(context, "lineWidth", !(0, import_util42.isNil)(style.lineWidth) ? style.lineWidth : DEFAULT_STYLE.lineWidth, renderState.currentContext);
          }
          if (forceUpdate || style.lineDash !== prevStyle.lineDash) {
            updateContextIfNotHitCache(context, "lineDash", style.lineDash || DEFAULT_STYLE.lineDash, renderState.currentContext);
          }
          if (forceUpdate || style.lineDashOffset !== prevStyle.lineDashOffset) {
            updateContextIfNotHitCache(context, "lineDashOffset", !(0, import_util42.isNil)(style.lineDashOffset) ? style.lineDashOffset : DEFAULT_STYLE.lineDashOffset, renderState.currentContext);
          }
          for (var i = 0; i < STROKE_STYLE.length; i++) {
            var styleName = STROKE_STYLE[i];
            if (forceUpdate || style[styleName] !== prevStyle[styleName]) {
              updateContextIfNotHitCache(context, styleName, !(0, import_util42.isNil)(style[styleName]) ? style[styleName] : DEFAULT_STYLE[styleName], renderState.currentContext);
            }
          }
        }
        if (hasFill && (forceUpdate || object.attributes.fill !== renderState.prevObject.attributes.fill)) {
          var _value = !(0, import_util42.isNil)(style.fill) && !Array.isArray(style.fill) && !style.fill.isNone ? object.attributes.fill : DEFAULT_STYLE.fillStyle;
          updateContextIfNotHitCache(context, "fillStyle", _value, renderState.currentContext);
        }
      }
      // #endregion stroke/fill style
    }, {
      key: "applyStyleToContext",
      value: function applyStyleToContext(context, object, forceUpdate, renderState) {
        var nodeName = object.nodeName;
        this.applyCommonStyleToContext(context, object, forceUpdate, renderState);
        if (nodeName === Shape.IMAGE) ;
        else {
          this.applyStrokeFillStyleToContext(context, object, forceUpdate, renderState);
        }
      }
    }, {
      key: "applyShadowAndFilterStyleToContext",
      value: function applyShadowAndFilterStyleToContext(context, object, hasShadow, renderState) {
        var style = object.parsedStyle;
        if (hasShadow) {
          updateContextIfNotHitCache(context, "shadowColor", style.shadowColor.toString(), renderState.currentContext);
          for (var i = 0; i < SHADOW_NUMBER_STYLE.length; i++) {
            var styleName = SHADOW_NUMBER_STYLE[i];
            updateContextIfNotHitCache(context, styleName, style[styleName] || DEFAULT_STYLE[styleName], renderState.currentContext);
          }
        }
        if (style.filter && style.filter.length) {
          updateContextIfNotHitCache(
            context,
            "filter",
            // use raw filter string
            object.attributes.filter,
            renderState.currentContext
          );
        }
      }
    }, {
      key: "clearShadowAndFilterStyleForContext",
      value: function clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState) {
        var onlyClearShadowFilter = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
        if (hasShadow) {
          updateContextIfNotHitCache(context, "shadowColor", DEFAULT_STYLE.shadowColor, renderState.currentContext);
          for (var i = 0; i < SHADOW_NUMBER_STYLE.length; i++) {
            var styleName = SHADOW_NUMBER_STYLE[i];
            updateContextIfNotHitCache(context, styleName, DEFAULT_STYLE[styleName], renderState.currentContext);
          }
        }
        if (hasFilter) {
          if (hasShadow && onlyClearShadowFilter) {
            var oldFilter = context.filter;
            if (!(0, import_util42.isNil)(oldFilter) && oldFilter.indexOf("drop-shadow") > -1) {
              updateContextIfNotHitCache(context, "filter", oldFilter.replace(/drop-shadow\([^)]*\)/, "").trim() || DEFAULT_STYLE.filter, renderState.currentContext);
            }
          } else {
            updateContextIfNotHitCache(context, "filter", DEFAULT_STYLE.filter, renderState.currentContext);
          }
        }
      }
    }, {
      key: "fillToContext",
      value: function fillToContext(context, object, renderState, plugin, runtime2) {
        var _this2 = this;
        var _object$parsedStyle = object.parsedStyle, fill = _object$parsedStyle.fill, fillRule = _object$parsedStyle.fillRule;
        var resetStyle = null;
        if (Array.isArray(fill) && fill.length > 0) {
          fill.forEach(function(gradient) {
            var prevStyle = updateContextIfNotHitCache(context, "fillStyle", getColor(gradient, object, context, _this2.imagePool), renderState.currentContext);
            resetStyle = resetStyle !== null && resetStyle !== void 0 ? resetStyle : prevStyle;
            if (fillRule) {
              context.fill(fillRule);
            } else {
              context.fill();
            }
          });
        } else {
          if (isPattern(fill)) {
            var pattern = getPattern(fill, object, context, object.ownerDocument.defaultView.context, plugin, runtime2, this.imagePool);
            if (pattern) {
              context.fillStyle = pattern;
              resetStyle = true;
            }
          }
          if (fillRule) {
            context.fill(fillRule);
          } else {
            context.fill();
          }
        }
        if (resetStyle !== null) {
          updateContextIfNotHitCache(context, "fillStyle", resetStyle, renderState.currentContext);
        }
      }
    }, {
      key: "strokeToContext",
      value: function strokeToContext(context, object, renderState, plugin, runtime2) {
        var _this2 = this;
        var stroke = object.parsedStyle.stroke;
        var resetStyle = null;
        if (Array.isArray(stroke) && stroke.length > 0) {
          stroke.forEach(function(gradient) {
            var prevStyle2 = updateContextIfNotHitCache(context, "strokeStyle", getColor(gradient, object, context, _this2.imagePool), renderState.currentContext);
            resetStyle = resetStyle !== null && resetStyle !== void 0 ? resetStyle : prevStyle2;
            context.stroke();
          });
        } else {
          if (isPattern(stroke)) {
            var pattern = getPattern(stroke, object, context, object.ownerDocument.defaultView.context, plugin, runtime2, this.imagePool);
            if (pattern) {
              var prevStyle = updateContextIfNotHitCache(context, "strokeStyle", pattern, renderState.currentContext);
              resetStyle = resetStyle !== null && resetStyle !== void 0 ? resetStyle : prevStyle;
            }
          }
          context.stroke();
        }
        if (resetStyle !== null) {
          updateContextIfNotHitCache(context, "strokeStyle", resetStyle, renderState.currentContext);
        }
      }
    }, {
      key: "drawToContext",
      value: function drawToContext(context, object, renderState, plugin, runtime2) {
        var _style$fill;
        var nodeName = object.nodeName;
        var style = object.parsedStyle;
        var _style$opacity = style.opacity, opacity = _style$opacity === void 0 ? DEFAULT_STYLE.globalAlpha : _style$opacity, _style$fillOpacity = style.fillOpacity, fillOpacity = _style$fillOpacity === void 0 ? DEFAULT_STYLE.fillOpacity : _style$fillOpacity, _style$strokeOpacity = style.strokeOpacity, strokeOpacity = _style$strokeOpacity === void 0 ? DEFAULT_STYLE.strokeOpacity : _style$strokeOpacity, _style$lineWidth2 = style.lineWidth, lineWidth = _style$lineWidth2 === void 0 ? DEFAULT_STYLE.lineWidth : _style$lineWidth2;
        var hasFill = style.fill && !style.fill.isNone;
        var hasStroke = style.stroke && !style.stroke.isNone && lineWidth > 0;
        if (!hasFill && !hasStroke) {
          return;
        }
        var hasShadow = !(0, import_util42.isNil)(style.shadowColor) && style.shadowBlur > 0;
        var isInnerShadow = style.shadowType === "inner";
        var isFillTransparent = ((_style$fill = style.fill) === null || _style$fill === void 0 ? void 0 : _style$fill.alpha) === 0;
        var hasFilter = !!(style.filter && style.filter.length);
        var shouldDrawShadowWithStroke = hasShadow && hasStroke && (nodeName === Shape.PATH || nodeName === Shape.LINE || nodeName === Shape.POLYLINE || isFillTransparent || isInnerShadow);
        var originGlobalAlpha = null;
        if (hasFill) {
          if (!shouldDrawShadowWithStroke) {
            this.applyShadowAndFilterStyleToContext(context, object, hasShadow, renderState);
          }
          var updateOpacity = opacity * fillOpacity;
          originGlobalAlpha = updateContextIfNotHitCache(context, "globalAlpha", updateOpacity, renderState.currentContext);
          this.fillToContext(context, object, renderState, plugin, runtime2);
          if (!shouldDrawShadowWithStroke) {
            this.clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState);
          }
        }
        if (hasStroke) {
          var clearShadowAndFilter = false;
          var _updateOpacity = opacity * strokeOpacity;
          var prevOpacity = updateContextIfNotHitCache(context, "globalAlpha", _updateOpacity, renderState.currentContext);
          originGlobalAlpha = hasFill ? originGlobalAlpha : prevOpacity;
          if (shouldDrawShadowWithStroke) {
            this.applyShadowAndFilterStyleToContext(context, object, hasShadow, renderState);
            clearShadowAndFilter = true;
            if (isInnerShadow) {
              var originBlend = context.globalCompositeOperation;
              context.globalCompositeOperation = "source-atop";
              this.strokeToContext(context, object, renderState, plugin, runtime2);
              context.globalCompositeOperation = originBlend;
              this.clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState, true);
            }
          }
          this.strokeToContext(context, object, renderState, plugin, runtime2);
          if (clearShadowAndFilter) {
            this.clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState);
          }
        }
        if (originGlobalAlpha !== null) {
          updateContextIfNotHitCache(context, "globalAlpha", originGlobalAlpha, renderState.currentContext);
        }
      }
    }]);
  })();
  var DefaultRenderer = /* @__PURE__ */ (function(_OptimizedDefaultRend) {
    function DefaultRenderer2() {
      _classCallCheck(this, DefaultRenderer2);
      return _callSuper(this, DefaultRenderer2, arguments);
    }
    _inherits(DefaultRenderer2, _OptimizedDefaultRend);
    return _createClass(DefaultRenderer2, [{
      key: "render",
      value: function render(context, parsedStyle, object, canvasContext, plugin, runtime2) {
        var fill = parsedStyle.fill, fillRule = parsedStyle.fillRule, _parsedStyle$opacity = parsedStyle.opacity, opacity = _parsedStyle$opacity === void 0 ? 1 : _parsedStyle$opacity, _parsedStyle$fillOpac = parsedStyle.fillOpacity, fillOpacity = _parsedStyle$fillOpac === void 0 ? 1 : _parsedStyle$fillOpac, stroke = parsedStyle.stroke, _parsedStyle$strokeOp = parsedStyle.strokeOpacity, strokeOpacity = _parsedStyle$strokeOp === void 0 ? 1 : _parsedStyle$strokeOp, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, lineCap = parsedStyle.lineCap, lineJoin = parsedStyle.lineJoin, shadowType = parsedStyle.shadowType, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur, filter = parsedStyle.filter, miterLimit = parsedStyle.miterLimit;
        var hasFill = fill && !fill.isNone;
        var hasStroke = stroke && !stroke.isNone && lineWidth > 0;
        var isFillTransparent = (fill === null || fill === void 0 ? void 0 : fill.alpha) === 0;
        var hasFilter = !!(filter && filter.length);
        var hasShadow = !(0, import_util42.isNil)(shadowColor) && shadowBlur > 0;
        var nodeName = object.nodeName;
        var isInnerShadow = shadowType === "inner";
        var shouldDrawShadowWithStroke = hasStroke && hasShadow && (nodeName === Shape.PATH || nodeName === Shape.LINE || nodeName === Shape.POLYLINE || isFillTransparent || isInnerShadow);
        if (hasFill) {
          context.globalAlpha = opacity * fillOpacity;
          if (!shouldDrawShadowWithStroke) {
            setShadowAndFilter(object, context, hasShadow);
          }
          applyFill(context, object, fill, fillRule, canvasContext, plugin, runtime2, this.imagePool);
          if (!shouldDrawShadowWithStroke) {
            this.clearShadowAndFilter(context, hasFilter, hasShadow);
          }
        }
        if (hasStroke) {
          context.globalAlpha = opacity * strokeOpacity;
          context.lineWidth = lineWidth;
          if (!(0, import_util42.isNil)(miterLimit)) {
            context.miterLimit = miterLimit;
          }
          if (!(0, import_util42.isNil)(lineCap)) {
            context.lineCap = lineCap;
          }
          if (!(0, import_util42.isNil)(lineJoin)) {
            context.lineJoin = lineJoin;
          }
          if (shouldDrawShadowWithStroke) {
            if (isInnerShadow) {
              context.globalCompositeOperation = "source-atop";
            }
            setShadowAndFilter(object, context, true);
            if (isInnerShadow) {
              applyStroke(context, object, stroke, canvasContext, plugin, runtime2, this.imagePool);
              context.globalCompositeOperation = DEFAULT_STYLE.globalCompositeOperation;
              this.clearShadowAndFilter(context, hasFilter, true);
            }
          }
          applyStroke(context, object, stroke, canvasContext, plugin, runtime2, this.imagePool);
        }
      }
    }, {
      key: "clearShadowAndFilter",
      value: function clearShadowAndFilter(context, hasFilter, hasShadow) {
        if (hasShadow) {
          context.shadowColor = "transparent";
          context.shadowBlur = 0;
        }
        if (hasFilter) {
          var oldFilter = context.filter;
          if (!(0, import_util42.isNil)(oldFilter) && oldFilter.indexOf("drop-shadow") > -1) {
            context.filter = oldFilter.replace(/drop-shadow\([^)]*\)/, "").trim() || "none";
          }
        }
      }
    }]);
  })(OptimizedDefaultRenderer);
  function setShadowAndFilter(object, context, hasShadow) {
    var _object$parsedStyle = object.parsedStyle, filter = _object$parsedStyle.filter, shadowColor = _object$parsedStyle.shadowColor, shadowBlur = _object$parsedStyle.shadowBlur, shadowOffsetX = _object$parsedStyle.shadowOffsetX, shadowOffsetY = _object$parsedStyle.shadowOffsetY;
    if (filter && filter.length) {
      context.filter = object.style.filter;
    }
    if (hasShadow) {
      context.shadowColor = shadowColor.toString();
      context.shadowBlur = shadowBlur || 0;
      context.shadowOffsetX = shadowOffsetX || 0;
      context.shadowOffsetY = shadowOffsetY || 0;
    }
  }
  function applyFill(context, object, fill, fillRule, canvasContext, plugin, runtime2, imagePool) {
    var skipFill = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : false;
    if (Array.isArray(fill)) {
      fill.forEach(function(gradient) {
        context.fillStyle = getColor(gradient, object, context, imagePool);
        if (!skipFill) {
          fillRule ? context.fill(fillRule) : context.fill();
        }
      });
    } else {
      if (isPattern(fill)) {
        context.fillStyle = getPattern(fill, object, context, canvasContext, plugin, runtime2, imagePool);
      }
      if (!skipFill) {
        fillRule ? context.fill(fillRule) : context.fill();
      }
    }
  }
  function applyStroke(context, object, stroke, canvasContext, plugin, runtime2, imagePool) {
    var skipStroke = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
    if (Array.isArray(stroke)) {
      stroke.forEach(function(gradient) {
        context.strokeStyle = getColor(gradient, object, context, imagePool);
        if (!skipStroke) {
          context.stroke();
        }
      });
    } else {
      if (isPattern(stroke)) {
        context.strokeStyle = getPattern(stroke, object, context, canvasContext, plugin, runtime2, imagePool);
      }
      if (!skipStroke) {
        context.stroke();
      }
    }
  }
  function calculateOverlapRect(rect1, rect2) {
    var _rect = _slicedToArray(rect1, 4), x1 = _rect[0], y1 = _rect[1], w1 = _rect[2], h1 = _rect[3];
    var _rect2 = _slicedToArray(rect2, 4), x22 = _rect2[0], y22 = _rect2[1], w2 = _rect2[2], h2 = _rect2[3];
    var overlapLeft = Math.max(x1, x22);
    var overlapTop = Math.max(y1, y22);
    var overlapRight = Math.min(x1 + w1, x22 + w2);
    var overlapBottom = Math.min(y1 + h1, y22 + h2);
    if (overlapRight <= overlapLeft || overlapBottom <= overlapTop) {
      return null;
    }
    return [overlapLeft, overlapTop, overlapRight - overlapLeft, overlapBottom - overlapTop];
  }
  function transformRect(rect2, matrix3) {
    var tl = import_gl_matrix6.vec3.transformMat4(import_gl_matrix6.vec3.create(), [rect2[0], rect2[1], 0], matrix3);
    var tr = import_gl_matrix6.vec3.transformMat4(import_gl_matrix6.vec3.create(), [rect2[0] + rect2[2], rect2[1], 0], matrix3);
    var bl = import_gl_matrix6.vec3.transformMat4(import_gl_matrix6.vec3.create(), [rect2[0], rect2[1] + rect2[3], 0], matrix3);
    var br = import_gl_matrix6.vec3.transformMat4(import_gl_matrix6.vec3.create(), [rect2[0] + rect2[2], rect2[1] + rect2[3], 0], matrix3);
    return [Math.min(tl[0], tr[0], bl[0], br[0]), Math.min(tl[1], tr[1], bl[1], br[1]), Math.max(tl[0], tr[0], bl[0], br[0]) - Math.min(tl[0], tr[0], bl[0], br[0]), Math.max(tl[1], tr[1], bl[1], br[1]) - Math.min(tl[1], tr[1], bl[1], br[1])];
  }
  var ImageRenderer = /* @__PURE__ */ (function(_DefaultRenderer) {
    function ImageRenderer2() {
      _classCallCheck(this, ImageRenderer2);
      return _callSuper(this, ImageRenderer2, arguments);
    }
    _inherits(ImageRenderer2, _DefaultRenderer);
    return _createClass(ImageRenderer2, [{
      key: "renderDownSampled",
      value: function renderDownSampled(context, parsedStyle, object, data2) {
        var src = data2.src, imageCache = data2.imageCache;
        if (!imageCache.downSampled) {
          this.imagePool.createDownSampledImage(src, object).then(function() {
            if (!object.ownerDocument) {
              return;
            }
            object.dirty();
            object.ownerDocument.defaultView.context.renderingService.dirtify();
          })["catch"](function(reason) {
            console.error(reason);
          });
          return;
        }
        context.drawImage(imageCache.downSampled, Math.floor(data2.drawRect[0]), Math.floor(data2.drawRect[1]), Math.ceil(data2.drawRect[2]), Math.ceil(data2.drawRect[3]));
      }
    }, {
      key: "renderTile",
      value: function renderTile(context, parsedStyle, object, data2) {
        var src = data2.src, imageCache = data2.imageCache, imageRect = data2.imageRect, drawRect = data2.drawRect;
        var originalSize = imageCache.size;
        var _context$getTransform = context.getTransform(), a2 = _context$getTransform.a, b = _context$getTransform.b, c2 = _context$getTransform.c, d2 = _context$getTransform.d, e = _context$getTransform.e, f = _context$getTransform.f;
        context.resetTransform();
        if (!(imageCache !== null && imageCache !== void 0 && imageCache.gridSize)) {
          this.imagePool.createImageTiles(src, [], function() {
            if (!object.ownerDocument) {
              return;
            }
            object.dirty();
            object.ownerDocument.defaultView.context.renderingService.dirtify();
          }, object)["catch"](function(reason) {
            console.error(reason);
          });
          return;
        }
        var scaleToOrigin = [originalSize[0] / imageRect[2], originalSize[1] / imageRect[3]];
        var scaledTileSize = [imageCache.tileSize[0] / scaleToOrigin[0], imageCache.tileSize[1] / scaleToOrigin[1]];
        var _ref = [Math.floor((drawRect[0] - imageRect[0]) / scaledTileSize[0]), Math.ceil((drawRect[0] + drawRect[2] - imageRect[0]) / scaledTileSize[0])], startTileX = _ref[0], endTileX = _ref[1];
        var _ref2 = [Math.floor((drawRect[1] - imageRect[1]) / scaledTileSize[1]), Math.ceil((drawRect[1] + drawRect[3] - imageRect[1]) / scaledTileSize[1])], startTileY = _ref2[0], endTileY = _ref2[1];
        for (var tileY = startTileY; tileY <= endTileY; tileY++) {
          for (var tileX = startTileX; tileX <= endTileX; tileX++) {
            var item = imageCache.tiles[tileY][tileX];
            if (item) {
              var tileRect = [Math.floor(imageRect[0] + item.tileX * scaledTileSize[0]), Math.floor(imageRect[1] + item.tileY * scaledTileSize[1]), Math.ceil(scaledTileSize[0]), Math.ceil(scaledTileSize[1])];
              context.drawImage(item.data, tileRect[0], tileRect[1], tileRect[2], tileRect[3]);
            }
          }
        }
        context.setTransform(a2, b, c2, d2, e, f);
      }
    }, {
      key: "render",
      value: function render(context, parsedStyle, object) {
        var _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, width2 = parsedStyle.width, height = parsedStyle.height, src = parsedStyle.src, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur;
        var imageCache = this.imagePool.getImageSync(src, object);
        var image = imageCache === null || imageCache === void 0 ? void 0 : imageCache.img;
        var iw = width2;
        var ih = height;
        if (!image) {
          return;
        }
        iw || (iw = image.width);
        ih || (ih = image.height);
        var hasShadow = !(0, import_util42.isNil)(shadowColor) && shadowBlur > 0;
        setShadowAndFilter(object, context, hasShadow);
        try {
          var _object$ownerDocument = object.ownerDocument.defaultView.getContextService().getDomElement(), viewWidth = _object$ownerDocument.width, viewHeight = _object$ownerDocument.height;
          var currentTransform = context.getTransform();
          var a2 = currentTransform.a, b = currentTransform.b, c2 = currentTransform.c, d2 = currentTransform.d, e = currentTransform.e, f = currentTransform.f;
          var transformMatrix = import_gl_matrix6.mat4.fromValues(a2, c2, 0, 0, b, d2, 0, 0, 0, 0, 1, 0, e, f, 0, 1);
          var imageRect = transformRect([x3, y3, iw, ih], transformMatrix);
          var drawRect = calculateOverlapRect([0, 0, viewWidth, viewHeight], imageRect);
          if (!drawRect) {
            return;
          }
          if (!object.ownerDocument.defaultView.getConfig().enableLargeImageOptimization) {
            ImageRenderer2.renderFull(context, parsedStyle, object, {
              image,
              drawRect: [x3, y3, iw, ih]
            });
            return;
          }
          var sizeOfOrigin = imageRect[2] / imageCache.size[0];
          if (sizeOfOrigin < (imageCache.downSamplingRate || 0.5)) {
            this.renderDownSampled(context, parsedStyle, object, {
              src,
              imageCache,
              drawRect: [x3, y3, iw, ih]
            });
            return;
          }
          if (!ImagePool.isSupportTile) {
            ImageRenderer2.renderFull(context, parsedStyle, object, {
              image,
              drawRect: [x3, y3, iw, ih]
            });
            return;
          }
          this.renderTile(context, parsedStyle, object, {
            src,
            imageCache,
            imageRect,
            drawRect
          });
        } catch (_unused) {
        }
      }
      // ---
    }, {
      key: "drawToContext",
      value: function drawToContext(context, object, renderState, plugin, runtime2) {
        this.render(context, object.parsedStyle, object);
      }
    }], [{
      key: "renderFull",
      value: function renderFull(context, parsedStyle, object, data2) {
        context.drawImage(data2.image, Math.floor(data2.drawRect[0]), Math.floor(data2.drawRect[1]), Math.ceil(data2.drawRect[2]), Math.ceil(data2.drawRect[3]));
      }
    }]);
  })(DefaultRenderer);
  var TextRenderer = /* @__PURE__ */ (function(_DefaultRenderer) {
    function TextRenderer2() {
      _classCallCheck(this, TextRenderer2);
      return _callSuper(this, TextRenderer2, arguments);
    }
    _inherits(TextRenderer2, _DefaultRenderer);
    return _createClass(TextRenderer2, [{
      key: "render",
      value: function render(context, parsedStyle, object, canvasContext, plugin, runtime2) {
        object.getBounds();
        var _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$textAlig = parsedStyle.textAlign, textAlign = _parsedStyle$textAlig === void 0 ? "start" : _parsedStyle$textAlig, _parsedStyle$textBase = parsedStyle.textBaseline, textBaseline = _parsedStyle$textBase === void 0 ? "alphabetic" : _parsedStyle$textBase, _parsedStyle$lineJoin = parsedStyle.lineJoin, lineJoin = _parsedStyle$lineJoin === void 0 ? "miter" : _parsedStyle$lineJoin, _parsedStyle$miterLim = parsedStyle.miterLimit, miterLimit = _parsedStyle$miterLim === void 0 ? 10 : _parsedStyle$miterLim, _parsedStyle$letterSp = parsedStyle.letterSpacing, letterSpacing = _parsedStyle$letterSp === void 0 ? 0 : _parsedStyle$letterSp, stroke = parsedStyle.stroke, fill = parsedStyle.fill, fillRule = parsedStyle.fillRule, _parsedStyle$fillOpac = parsedStyle.fillOpacity, fillOpacity = _parsedStyle$fillOpac === void 0 ? 1 : _parsedStyle$fillOpac, _parsedStyle$strokeOp = parsedStyle.strokeOpacity, strokeOpacity = _parsedStyle$strokeOp === void 0 ? 1 : _parsedStyle$strokeOp, _parsedStyle$opacity = parsedStyle.opacity, opacity = _parsedStyle$opacity === void 0 ? 1 : _parsedStyle$opacity, metrics = parsedStyle.metrics, _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, dx = parsedStyle.dx, dy = parsedStyle.dy, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur;
        var font = metrics.font, lines = metrics.lines, height = metrics.height, lineHeight = metrics.lineHeight, lineMetrics = metrics.lineMetrics;
        context.font = font;
        context.lineWidth = lineWidth;
        context.textAlign = textAlign === "middle" ? "center" : textAlign;
        var formattedTextBaseline = textBaseline;
        if (formattedTextBaseline === "alphabetic") {
          formattedTextBaseline = "bottom";
        }
        context.lineJoin = lineJoin;
        if (!(0, import_util42.isNil)(miterLimit)) {
          context.miterLimit = miterLimit;
        }
        var linePositionY = y3;
        if (textBaseline === "middle") {
          linePositionY += -height / 2 - lineHeight / 2;
        } else if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
          linePositionY += -height;
        } else if (textBaseline === "top" || textBaseline === "hanging") {
          linePositionY += -lineHeight;
        }
        var offsetX = x3 + (dx || 0);
        linePositionY += dy || 0;
        if (lines.length === 1) {
          if (formattedTextBaseline === "bottom") {
            formattedTextBaseline = "middle";
            linePositionY -= 0.5 * height;
          } else if (formattedTextBaseline === "top") {
            formattedTextBaseline = "middle";
            linePositionY += 0.5 * height;
          }
        }
        context.textBaseline = formattedTextBaseline;
        var hasShadow = !(0, import_util42.isNil)(shadowColor) && shadowBlur > 0;
        setShadowAndFilter(object, context, hasShadow);
        for (var i = 0; i < lines.length; i++) {
          var linePositionX = lineWidth / 2 + offsetX;
          linePositionY += lineHeight;
          if (!(0, import_util42.isNil)(stroke) && !stroke.isNone && lineWidth) {
            this.drawLetterSpacing(context, object, lines[i], lineMetrics[i], textAlign, linePositionX, linePositionY, letterSpacing, fill, fillRule, fillOpacity, stroke, strokeOpacity, opacity, true, canvasContext, plugin, runtime2);
          }
          if (!(0, import_util42.isNil)(fill)) {
            this.drawLetterSpacing(context, object, lines[i], lineMetrics[i], textAlign, linePositionX, linePositionY, letterSpacing, fill, fillRule, fillOpacity, stroke, strokeOpacity, opacity, false, canvasContext, plugin, runtime2);
          }
        }
      }
    }, {
      key: "drawLetterSpacing",
      value: function drawLetterSpacing(context, object, text, lineMetrics, textAlign, x3, y3, letterSpacing, fill, fillRule, fillOpacity, stroke, strokeOpacity, opacity, isStroke, canvasContext, plugin, runtime2) {
        if (letterSpacing === 0) {
          if (isStroke) {
            this.strokeText(context, object, text, x3, y3, stroke, strokeOpacity, canvasContext, plugin, runtime2);
          } else {
            this.fillText(context, object, text, x3, y3, fill, fillRule, fillOpacity, opacity, canvasContext, plugin, runtime2);
          }
          return;
        }
        var currentTextAlign = context.textAlign;
        context.textAlign = "left";
        var currentPosition = x3;
        if (textAlign === "center" || textAlign === "middle") {
          currentPosition = x3 - lineMetrics.width / 2;
        } else if (textAlign === "right" || textAlign === "end") {
          currentPosition = x3 - lineMetrics.width;
        }
        var stringArray = Array.from(text);
        var previousWidth = context.measureText(text).width;
        var currentWidth = 0;
        for (var i = 0; i < stringArray.length; ++i) {
          var currentChar = stringArray[i];
          if (isStroke) {
            this.strokeText(context, object, currentChar, currentPosition, y3, stroke, strokeOpacity, canvasContext, plugin, runtime2);
          } else {
            this.fillText(context, object, currentChar, currentPosition, y3, fill, fillRule, fillOpacity, opacity, canvasContext, plugin, runtime2);
          }
          currentWidth = context.measureText(text.substring(i + 1)).width;
          currentPosition += previousWidth - currentWidth + letterSpacing;
          previousWidth = currentWidth;
        }
        context.textAlign = currentTextAlign;
      }
    }, {
      key: "fillText",
      value: function fillText(context, object, text, x3, y3, fill, fillRule, fillOpacity, opacity, canvasContext, plugin, runtime2) {
        applyFill(context, object, fill, fillRule, canvasContext, plugin, runtime2, this.imagePool, true);
        var currentGlobalAlpha;
        var applyOpacity = !(0, import_util42.isNil)(fillOpacity) && fillOpacity !== 1;
        if (applyOpacity) {
          currentGlobalAlpha = context.globalAlpha;
          context.globalAlpha = fillOpacity * opacity;
        }
        context.fillText(text, x3, y3);
        if (applyOpacity) {
          context.globalAlpha = currentGlobalAlpha;
        }
      }
    }, {
      key: "strokeText",
      value: function strokeText(context, object, text, x3, y3, stroke, strokeOpacity, canvasContext, plugin, runtime2) {
        applyStroke(context, object, stroke, canvasContext, plugin, runtime2, this.imagePool, true);
        var currentGlobalAlpha;
        var applyOpacity = !(0, import_util42.isNil)(strokeOpacity) && strokeOpacity !== 1;
        if (applyOpacity) {
          currentGlobalAlpha = context.globalAlpha;
          context.globalAlpha = strokeOpacity;
        }
        context.strokeText(text, x3, y3);
        if (applyOpacity) {
          context.globalAlpha = currentGlobalAlpha;
        }
      }
      // ---
    }, {
      key: "drawToContext",
      value: function drawToContext(context, object, renderState, plugin, runtime2) {
        this.render(context, object.parsedStyle, object, object.ownerDocument.defaultView.context, plugin, runtime2);
      }
    }]);
  })(DefaultRenderer);
  var Plugin4 = /* @__PURE__ */ (function(_AbstractRendererPlug) {
    function Plugin8() {
      var _this2;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, Plugin8);
      _this2 = _callSuper(this, Plugin8);
      _this2.name = "canvas-renderer";
      _this2.options = options;
      return _this2;
    }
    _inherits(Plugin8, _AbstractRendererPlug);
    return _createClass(Plugin8, [{
      key: "init",
      value: function init() {
        var _defaultStyleRenderer;
        var canvasRendererPluginOptions = _objectSpread2({
          dirtyObjectNumThreshold: 500,
          dirtyObjectRatioThreshold: 0.8
        }, this.options);
        var imagePool = this.context.imagePool;
        var defaultRenderer = new DefaultRenderer(imagePool);
        var defaultStyleRendererFactory = (_defaultStyleRenderer = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defaultStyleRenderer, Shape.CIRCLE, defaultRenderer), Shape.ELLIPSE, defaultRenderer), Shape.RECT, defaultRenderer), Shape.IMAGE, new ImageRenderer(imagePool)), Shape.TEXT, new TextRenderer(imagePool)), Shape.LINE, defaultRenderer), Shape.POLYLINE, defaultRenderer), Shape.POLYGON, defaultRenderer), Shape.PATH, defaultRenderer), Shape.GROUP, void 0), _defineProperty(_defineProperty(_defineProperty(_defaultStyleRenderer, Shape.HTML, void 0), Shape.MESH, void 0), Shape.FRAGMENT, void 0));
        this.context.defaultStyleRendererFactory = defaultStyleRendererFactory;
        this.context.styleRendererFactory = defaultStyleRendererFactory;
        this.addRenderingPlugin(new CanvasRendererPlugin(canvasRendererPluginOptions));
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.removeAllRenderingPlugins();
        delete this.context.defaultStyleRendererFactory;
        delete this.context.styleRendererFactory;
      }
    }]);
  })(AbstractRendererPlugin);

  // node_modules/@antv/g-plugin-dom-interaction/dist/index.esm.js
  var DOMInteractionPlugin = /* @__PURE__ */ (function() {
    function DOMInteractionPlugin2() {
      _classCallCheck(this, DOMInteractionPlugin2);
    }
    return _createClass(DOMInteractionPlugin2, [{
      key: "apply",
      value: function apply3(context, runtime2) {
        var _this2 = this;
        var renderingService = context.renderingService, renderingContext = context.renderingContext, config = context.config;
        this.context = context;
        var canvas2 = renderingContext.root.ownerDocument.defaultView;
        var onPointerMove = function onPointerMove2(ev) {
          renderingService.hooks.pointerMove.call(ev);
        };
        var onPointerUp = function onPointerUp2(ev) {
          renderingService.hooks.pointerUp.call(ev);
        };
        var onPointerDown = function onPointerDown2(ev) {
          renderingService.hooks.pointerDown.call(ev);
        };
        var onPointerOver = function onPointerOver2(ev) {
          renderingService.hooks.pointerOver.call(ev);
        };
        var onPointerOut = function onPointerOut2(ev) {
          renderingService.hooks.pointerOut.call(ev);
        };
        var onPointerCancel = function onPointerCancel2(ev) {
          renderingService.hooks.pointerCancel.call(ev);
        };
        var onPointerWheel = function onPointerWheel2(ev) {
          renderingService.hooks.pointerWheel.call(ev);
        };
        var onClick = function onClick2(ev) {
          renderingService.hooks.click.call(ev);
        };
        var addPointerEventListener = function addPointerEventListener2($el) {
          runtime2.globalThis.document.addEventListener("pointermove", onPointerMove, true);
          $el.addEventListener("pointerdown", onPointerDown, true);
          $el.addEventListener("pointerleave", onPointerOut, true);
          $el.addEventListener("pointerover", onPointerOver, true);
          runtime2.globalThis.addEventListener("pointerup", onPointerUp, true);
          runtime2.globalThis.addEventListener("pointercancel", onPointerCancel, true);
        };
        var addTouchEventListener = function addTouchEventListener2($el) {
          $el.addEventListener("touchstart", onPointerDown, true);
          $el.addEventListener("touchend", onPointerUp, true);
          $el.addEventListener("touchmove", onPointerMove, true);
          $el.addEventListener("touchcancel", onPointerCancel, true);
        };
        var addMouseEventListener = function addMouseEventListener2($el) {
          runtime2.globalThis.document.addEventListener("mousemove", onPointerMove, true);
          $el.addEventListener("mousedown", onPointerDown, true);
          $el.addEventListener("mouseout", onPointerOut, true);
          $el.addEventListener("mouseover", onPointerOver, true);
          runtime2.globalThis.addEventListener("mouseup", onPointerUp, true);
        };
        var removePointerEventListener = function removePointerEventListener2($el) {
          runtime2.globalThis.document.removeEventListener("pointermove", onPointerMove, true);
          $el.removeEventListener("pointerdown", onPointerDown, true);
          $el.removeEventListener("pointerleave", onPointerOut, true);
          $el.removeEventListener("pointerover", onPointerOver, true);
          runtime2.globalThis.removeEventListener("pointerup", onPointerUp, true);
          runtime2.globalThis.removeEventListener("pointercancel", onPointerCancel, true);
        };
        var removeTouchEventListener = function removeTouchEventListener2($el) {
          $el.removeEventListener("touchstart", onPointerDown, true);
          $el.removeEventListener("touchend", onPointerUp, true);
          $el.removeEventListener("touchmove", onPointerMove, true);
          $el.removeEventListener("touchcancel", onPointerCancel, true);
        };
        var removeMouseEventListener = function removeMouseEventListener2($el) {
          runtime2.globalThis.document.removeEventListener("mousemove", onPointerMove, true);
          $el.removeEventListener("mousedown", onPointerDown, true);
          $el.removeEventListener("mouseout", onPointerOut, true);
          $el.removeEventListener("mouseover", onPointerOver, true);
          runtime2.globalThis.removeEventListener("mouseup", onPointerUp, true);
        };
        renderingService.hooks.init.tap(DOMInteractionPlugin2.tag, function() {
          var $el = _this2.context.contextService.getDomElement();
          if (runtime2.globalThis.navigator.msPointerEnabled) {
            $el.style.msContentZooming = "none";
            $el.style.msTouchAction = "none";
          } else if (canvas2.supportsPointerEvents) {
            $el.style.touchAction = "none";
          }
          if (canvas2.supportsPointerEvents) {
            addPointerEventListener($el);
          } else {
            addMouseEventListener($el);
          }
          if (canvas2.supportsTouchEvents) {
            addTouchEventListener($el);
          }
          if (config.useNativeClickEvent) {
            $el.addEventListener("click", onClick, true);
          }
          $el.addEventListener("wheel", onPointerWheel, {
            passive: true,
            capture: true
          });
        });
        renderingService.hooks.destroy.tap(DOMInteractionPlugin2.tag, function() {
          var $el = _this2.context.contextService.getDomElement();
          if (runtime2.globalThis.navigator.msPointerEnabled) {
            $el.style.msContentZooming = "";
            $el.style.msTouchAction = "";
          } else if (canvas2.supportsPointerEvents) {
            $el.style.touchAction = "";
          }
          if (canvas2.supportsPointerEvents) {
            removePointerEventListener($el);
          } else {
            removeMouseEventListener($el);
          }
          if (canvas2.supportsTouchEvents) {
            removeTouchEventListener($el);
          }
          if (config.useNativeClickEvent) {
            $el.removeEventListener("click", onClick, true);
          }
          $el.removeEventListener("wheel", onPointerWheel, true);
        });
      }
    }]);
  })();
  DOMInteractionPlugin.tag = "DOMInteraction";
  var Plugin5 = /* @__PURE__ */ (function(_AbstractRendererPlug) {
    function Plugin8() {
      var _this2;
      _classCallCheck(this, Plugin8);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this2 = _callSuper(this, Plugin8, [].concat(args));
      _this2.name = "dom-interaction";
      return _this2;
    }
    _inherits(Plugin8, _AbstractRendererPlug);
    return _createClass(Plugin8, [{
      key: "init",
      value: function init() {
        this.addRenderingPlugin(new DOMInteractionPlugin());
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.removeAllRenderingPlugins();
      }
    }]);
  })(AbstractRendererPlugin);

  // node_modules/@antv/g-plugin-html-renderer/dist/index.esm.js
  var import_util43 = __toESM(require_lib());
  var CANVAS_CAMERA_ID = "g-canvas-camera";
  var HTMLRenderingPlugin = /* @__PURE__ */ (function() {
    function HTMLRenderingPlugin2() {
      _classCallCheck(this, HTMLRenderingPlugin2);
      this.displayObjectHTMLElementMap = /* @__PURE__ */ new WeakMap();
    }
    return _createClass(HTMLRenderingPlugin2, [{
      key: "joinTransformMatrix",
      value: (
        /**
         * ! The reason for adding `offset` is that the `transform-origin` coordinate system of DOM is the local coordinate system of the element, while the `transform-origin` coordinate system of canvas drawing is the local coordinate system of the element's parent element. At the same time, the `transform` attribute value of the DOM element does not include `transform-origin`.
         */
        function joinTransformMatrix(matrix3) {
          var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
          return "matrix(".concat([matrix3[0], matrix3[1], matrix3[4], matrix3[5], matrix3[12] + offset[0], matrix3[13] + offset[1]].join(","), ")");
        }
      )
    }, {
      key: "apply",
      value: function apply3(context, runtime2) {
        var _this2 = this;
        var camera = context.camera, renderingContext = context.renderingContext, renderingService = context.renderingService;
        this.context = context;
        var canvas2 = renderingContext.root.ownerDocument.defaultView;
        var nativeHTMLMap = canvas2.context.eventService.nativeHTMLMap;
        var setTransform = function setTransform2(object, $el) {
          $el.style.transform = _this2.joinTransformMatrix(object.getWorldTransform(), object.getOrigin());
        };
        var handleMounted = function handleMounted2(e) {
          var object = e.target;
          if (object.nodeName === Shape.HTML) {
            if (!_this2.$camera) {
              _this2.$camera = _this2.createCamera(camera);
            }
            var $el = _this2.getOrCreateEl(object);
            _this2.$camera.appendChild($el);
            Object.keys(object.attributes).forEach(function(name) {
              _this2.updateAttribute(name, object);
            });
            setTransform(object, $el);
            nativeHTMLMap.set($el, object);
          }
        };
        var handleUnmounted = function handleUnmounted2(e) {
          var object = e.target;
          if (object.nodeName === Shape.HTML && _this2.$camera) {
            var $el = _this2.getOrCreateEl(object);
            if ($el) {
              $el.remove();
              nativeHTMLMap["delete"]($el);
            }
          }
        };
        var handleAttributeChanged = function handleAttributeChanged2(e) {
          var object = e.target;
          if (object.nodeName === Shape.HTML) {
            var attrName = e.attrName;
            _this2.updateAttribute(attrName, object);
          }
        };
        var handleBoundsChanged = function handleBoundsChanged2(e) {
          var object = e.target;
          var nodes = object.nodeName === Shape.FRAGMENT ? object.childNodes : [object];
          nodes.forEach(function(node) {
            if (node.nodeName === Shape.HTML) {
              var $el = _this2.getOrCreateEl(node);
              setTransform(node, $el);
            }
          });
        };
        var handleCanvasResize = function handleCanvasResize2() {
          if (_this2.$camera) {
            var _this$context$config = _this2.context.config, width2 = _this$context$config.width, height = _this$context$config.height;
            _this2.$camera.parentElement.style.width = "".concat(width2 || 0, "px");
            _this2.$camera.parentElement.style.height = "".concat(height || 0, "px");
          }
        };
        renderingService.hooks.init.tap(HTMLRenderingPlugin2.tag, function() {
          canvas2.addEventListener(CanvasEvent.RESIZE, handleCanvasResize);
          canvas2.addEventListener(ElementEvent.MOUNTED, handleMounted);
          canvas2.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
          canvas2.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
          canvas2.addEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
        });
        renderingService.hooks.endFrame.tap(HTMLRenderingPlugin2.tag, function() {
          if (_this2.$camera && renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED)) {
            _this2.$camera.style.transform = _this2.joinTransformMatrix(camera.getOrthoMatrix());
          }
        });
        renderingService.hooks.destroy.tap(HTMLRenderingPlugin2.tag, function() {
          if (_this2.$camera) {
            _this2.$camera.remove();
          }
          canvas2.removeEventListener(CanvasEvent.RESIZE, handleCanvasResize);
          canvas2.removeEventListener(ElementEvent.MOUNTED, handleMounted);
          canvas2.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
          canvas2.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
          canvas2.removeEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
        });
      }
    }, {
      key: "createCamera",
      value: function createCamera(camera) {
        var _this$context$config2 = this.context.config, doc = _this$context$config2.document, width2 = _this$context$config2.width, height = _this$context$config2.height;
        var $canvas = this.context.contextService.getDomElement();
        var $container = $canvas.parentNode;
        if ($container) {
          var cameraId = CANVAS_CAMERA_ID;
          var $existedCamera = $container.querySelector("#".concat(cameraId));
          if (!$existedCamera) {
            var $cameraContainer = (doc || document).createElement("div");
            $cameraContainer.style.overflow = "hidden";
            $cameraContainer.style.pointerEvents = "none";
            $cameraContainer.style.position = "absolute";
            $cameraContainer.style.left = "0px";
            $cameraContainer.style.top = "0px";
            $cameraContainer.style.width = "".concat(width2 || 0, "px");
            $cameraContainer.style.height = "".concat(height || 0, "px");
            var $camera = (doc || document).createElement("div");
            $existedCamera = $camera;
            $camera.id = cameraId;
            $camera.style.position = "absolute";
            $camera.style.left = "".concat($canvas.offsetLeft || 0, "px");
            $camera.style.top = "".concat($canvas.offsetTop || 0, "px");
            $camera.style.transformOrigin = "left top";
            $camera.style.transform = this.joinTransformMatrix(camera.getOrthoMatrix());
            $camera.style.pointerEvents = "none";
            $camera.style.width = "100%";
            $camera.style.height = "100%";
            $cameraContainer.appendChild($camera);
            $container.appendChild($cameraContainer);
          }
          return $existedCamera;
        }
        return null;
      }
    }, {
      key: "getOrCreateEl",
      value: function getOrCreateEl(object) {
        var doc = this.context.config.document;
        var $existedElement = this.displayObjectHTMLElementMap.get(object);
        if (!$existedElement) {
          $existedElement = (doc || document).createElement("div");
          object.parsedStyle.$el = $existedElement;
          this.displayObjectHTMLElementMap.set(object, $existedElement);
          if (object.id) {
            $existedElement.id = object.id;
          }
          if (object.name) {
            $existedElement.setAttribute("name", object.name);
          }
          if (object.className) {
            $existedElement.className = object.className;
          }
          $existedElement.style.position = "absolute";
          $existedElement.style["will-change"] = "transform";
          $existedElement.style.transform = this.joinTransformMatrix(object.getWorldTransform(), object.getOrigin());
        }
        return $existedElement;
      }
    }, {
      key: "updateAttribute",
      value: function updateAttribute(name, object) {
        var $el = this.getOrCreateEl(object);
        switch (name) {
          case "innerHTML":
            var innerHTML = object.parsedStyle.innerHTML;
            if ((0, import_util43.isString)(innerHTML)) {
              $el.innerHTML = innerHTML;
            } else {
              $el.innerHTML = "";
              $el.appendChild(innerHTML);
            }
            break;
          case "x":
            $el.style.left = "".concat(object.parsedStyle.x, "px");
            break;
          case "y":
            $el.style.top = "".concat(object.parsedStyle.y, "px");
            break;
          case "transformOrigin":
            var transformOrigin = object.parsedStyle.transformOrigin;
            $el.style["transform-origin"] = "".concat(transformOrigin[0].buildCSSText(null, null, ""), " ").concat(transformOrigin[1].buildCSSText(null, null, ""));
            break;
          case "width":
            var width2 = object.parsedStyle.width;
            $el.style.width = (0, import_util43.isNumber)(width2) ? "".concat(width2, "px") : width2.toString();
            break;
          case "height":
            var height = object.parsedStyle.height;
            $el.style.height = (0, import_util43.isNumber)(height) ? "".concat(height, "px") : height.toString();
            break;
          case "zIndex":
            var zIndex = object.parsedStyle.zIndex;
            $el.style["z-index"] = "".concat(zIndex);
            break;
          case "visibility":
            var visibility2 = object.parsedStyle.visibility;
            $el.style.visibility = visibility2;
            break;
          case "pointerEvents":
            var _object$parsedStyle$p = object.parsedStyle.pointerEvents, pointerEvents = _object$parsedStyle$p === void 0 ? "auto" : _object$parsedStyle$p;
            $el.style.pointerEvents = pointerEvents;
            break;
          case "opacity":
            var opacity = object.parsedStyle.opacity;
            $el.style.opacity = "".concat(opacity);
            break;
          case "fill":
            var fill = object.parsedStyle.fill;
            var color2 = "";
            if (isCSSRGB(fill)) {
              if (fill.isNone) {
                color2 = "transparent";
              } else {
                color2 = object.getAttribute("fill");
              }
            } else if (Array.isArray(fill)) {
              color2 = object.getAttribute("fill");
            } else if (isPattern(fill)) ;
            $el.style.background = color2;
            break;
          case "stroke":
            var stroke = object.parsedStyle.stroke;
            var borderColor = "";
            if (isCSSRGB(stroke)) {
              if (stroke.isNone) {
                borderColor = "transparent";
              } else {
                borderColor = object.getAttribute("stroke");
              }
            } else if (Array.isArray(stroke)) {
              borderColor = object.getAttribute("stroke");
            } else if (isPattern(stroke)) ;
            $el.style["border-color"] = borderColor;
            $el.style["border-style"] = "solid";
            break;
          case "lineWidth":
            var lineWidth = object.parsedStyle.lineWidth;
            $el.style["border-width"] = "".concat(lineWidth || 0, "px");
            break;
          case "lineDash":
            $el.style["border-style"] = "dashed";
            break;
          case "filter":
            var filter = object.style.filter;
            $el.style.filter = filter;
            break;
          default:
            if (!(0, import_util43.isNil)(object.style[name]) && object.style[name] !== "") {
              $el.style[name] = object.style[name];
            }
        }
      }
    }]);
  })();
  HTMLRenderingPlugin.tag = "HTMLRendering";
  var Plugin6 = /* @__PURE__ */ (function(_AbstractRendererPlug) {
    function Plugin8() {
      var _this2;
      _classCallCheck(this, Plugin8);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this2 = _callSuper(this, Plugin8, [].concat(args));
      _this2.name = "html-renderer";
      return _this2;
    }
    _inherits(Plugin8, _AbstractRendererPlug);
    return _createClass(Plugin8, [{
      key: "init",
      value: function init() {
        this.addRenderingPlugin(new HTMLRenderingPlugin());
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.removeAllRenderingPlugins();
      }
    }]);
  })(AbstractRendererPlugin);

  // node_modules/@antv/g-canvas/dist/index.esm.js
  var import_util44 = __toESM(require_lib());
  var Canvas2DContextService = /* @__PURE__ */ (function() {
    function Canvas2DContextService2(context) {
      _classCallCheck(this, Canvas2DContextService2);
      this.renderingContext = context.renderingContext;
      this.canvasConfig = context.config;
    }
    return _createClass(Canvas2DContextService2, [{
      key: "init",
      value: function init() {
        var _this$canvasConfig = this.canvasConfig, container = _this$canvasConfig.container, canvas2 = _this$canvasConfig.canvas;
        if (canvas2) {
          this.$canvas = canvas2;
          if (container && canvas2.parentElement !== container) {
            container.appendChild(canvas2);
          }
          this.$container = canvas2.parentElement;
          this.canvasConfig.container = this.$container;
        } else if (container) {
          this.$container = (0, import_util44.isString)(container) ? document.getElementById(container) : container;
          if (this.$container) {
            var $canvas = document.createElement("canvas");
            this.$container.appendChild($canvas);
            if (!this.$container.style.position) {
              this.$container.style.position = "relative";
            }
            this.$canvas = $canvas;
          }
        }
        this.context = this.$canvas.getContext("2d");
        this.resize(this.canvasConfig.width, this.canvasConfig.height);
      }
    }, {
      key: "getContext",
      value: function getContext() {
        return this.context;
      }
    }, {
      key: "getDomElement",
      value: function getDomElement() {
        return this.$canvas;
      }
    }, {
      key: "getDPR",
      value: function getDPR() {
        return this.dpr;
      }
    }, {
      key: "getBoundingClientRect",
      value: function getBoundingClientRect() {
        if (this.$canvas.getBoundingClientRect) {
          return this.$canvas.getBoundingClientRect();
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        if (this.$container && this.$canvas && this.$canvas.parentNode) {
          this.$container.removeChild(this.$canvas);
        }
      }
    }, {
      key: "resize",
      value: function resize(width2, height) {
        var dpr = this.canvasConfig.devicePixelRatio;
        this.dpr = dpr;
        if (this.$canvas) {
          this.$canvas.width = this.dpr * width2;
          this.$canvas.height = this.dpr * height;
          setDOMSize(this.$canvas, width2, height);
        }
        this.renderingContext.renderReasons.add(RenderReason.CAMERA_CHANGED);
      }
    }, {
      key: "applyCursorStyle",
      value: function applyCursorStyle(cursor) {
        if (this.$container && this.$container.style) {
          this.$container.style.cursor = cursor;
        }
      }
    }, {
      key: "toDataURL",
      value: (function() {
        var _toDataURL = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee() {
          var options, type, encoderOptions, _args = arguments;
          return _regeneratorRuntime().wrap(function(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                options = _args.length > 0 && _args[0] !== void 0 ? _args[0] : {};
                type = options.type, encoderOptions = options.encoderOptions;
                return _context.abrupt("return", this.context.canvas.toDataURL(type, encoderOptions));
              case 1:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
        function toDataURL() {
          return _toDataURL.apply(this, arguments);
        }
        return toDataURL;
      })()
    }]);
  })();
  var ContextRegisterPlugin = /* @__PURE__ */ (function(_AbstractRendererPlug) {
    function ContextRegisterPlugin2() {
      var _this2;
      _classCallCheck(this, ContextRegisterPlugin2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this2 = _callSuper(this, ContextRegisterPlugin2, [].concat(args));
      _this2.name = "canvas-context-register";
      return _this2;
    }
    _inherits(ContextRegisterPlugin2, _AbstractRendererPlug);
    return _createClass(ContextRegisterPlugin2, [{
      key: "init",
      value: function init() {
        this.context.ContextService = Canvas2DContextService;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        delete this.context.ContextService;
      }
    }]);
  })(AbstractRendererPlugin);
  var Renderer = /* @__PURE__ */ (function(_AbstractRenderer) {
    function Renderer2(config) {
      var _this2;
      _classCallCheck(this, Renderer2);
      _this2 = _callSuper(this, Renderer2, [config]);
      _this2.registerPlugin(new ContextRegisterPlugin());
      _this2.registerPlugin(new Plugin3());
      _this2.registerPlugin(new Plugin());
      _this2.registerPlugin(new Plugin4());
      _this2.registerPlugin(new Plugin5());
      _this2.registerPlugin(new Plugin2());
      _this2.registerPlugin(new Plugin6());
      return _this2;
    }
    _inherits(Renderer2, _AbstractRenderer);
    return _createClass(Renderer2);
  })(AbstractRenderer);

  // node_modules/@antv/g6/esm/elements/nodes/html.js
  var import_util45 = __toESM(require_lib());
  var __rest8 = function(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  var HTML2 = class _HTML extends BaseNode {
    constructor(options) {
      super(Object.assign(Object.assign({}, options), { style: Object.assign({}, _HTML.defaultStyleProps, options.style) }));
      this.rootPointerEvent = new FederatedPointerEvent(null);
      this.forwardEvents = (nativeEvent) => {
        const canvas2 = this.context.canvas;
        const iCanvas = canvas2.context.renderingContext.root.ownerDocument.defaultView;
        const normalizedEvents = this.normalizeToPointerEvent(nativeEvent, iCanvas);
        normalizedEvents.forEach((normalizedEvent) => {
          const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvent, iCanvas, nativeEvent);
          (0, import_util45.set)(canvas2.context.eventService, "mappingTable.pointerupoutside", []);
          canvas2.context.eventService.mapEvent(event);
        });
      };
    }
    get eventService() {
      return this.context.canvas.context.eventService;
    }
    get events() {
      return [
        CommonEvent.CLICK,
        CommonEvent.POINTER_DOWN,
        CommonEvent.POINTER_MOVE,
        CommonEvent.POINTER_UP,
        CommonEvent.POINTER_OVER,
        CommonEvent.POINTER_LEAVE
      ];
    }
    getDomElement() {
      return this.getShape("key").getDomElement();
    }
    /**
     * @override
     */
    render(attributes = this.parsedAttributes, container = this) {
      this.drawKeyShape(attributes, container);
      this.drawPortShapes(attributes, container);
    }
    getKeyStyle(attributes) {
      const _a2 = (0, import_util45.pick)(attributes, ["dx", "dy", "innerHTML", "pointerEvents", "cursor"]), { dx = 0, dy = 0 } = _a2, style = __rest8(_a2, ["dx", "dy"]);
      const [width2, height] = this.getSize(attributes);
      return Object.assign(Object.assign({ x: dx, y: dy }, style), { width: width2, height });
    }
    drawKeyShape(attributes, container) {
      const style = this.getKeyStyle(attributes);
      const { x: x3, y: y3, width: width2 = 0, height = 0 } = style;
      const bounds = this.upsert("key-container", Rect, { x: x3, y: y3, width: width2, height, opacity: 0 }, container);
      return this.upsert("key", HTML, style, bounds);
    }
    connectedCallback() {
      const renderer = this.context.canvas.getRenderer("main");
      const isCanvasRenderer = renderer instanceof Renderer;
      if (!isCanvasRenderer)
        return;
      const element = this.getDomElement();
      this.events.forEach((eventName) => {
        element.addEventListener(eventName, this.forwardEvents);
      });
    }
    attributeChangedCallback(name, oldValue, newValue) {
      if (name === "zIndex" && oldValue !== newValue) {
        this.getDomElement().style.zIndex = newValue;
      }
    }
    destroy() {
      const element = this.getDomElement();
      this.events.forEach((eventName) => {
        element.removeEventListener(eventName, this.forwardEvents);
      });
      super.destroy();
    }
    normalizeToPointerEvent(event, canvas2) {
      const normalizedEvents = [];
      if (canvas2.isTouchEvent(event)) {
        for (let i = 0; i < event.changedTouches.length; i++) {
          const touch = event.changedTouches[i];
          if ((0, import_util45.isUndefined)(touch.button))
            touch.button = 0;
          if ((0, import_util45.isUndefined)(touch.buttons))
            touch.buttons = 1;
          if ((0, import_util45.isUndefined)(touch.isPrimary)) {
            touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
          }
          if ((0, import_util45.isUndefined)(touch.width))
            touch.width = touch.radiusX || 1;
          if ((0, import_util45.isUndefined)(touch.height))
            touch.height = touch.radiusY || 1;
          if ((0, import_util45.isUndefined)(touch.tiltX))
            touch.tiltX = 0;
          if ((0, import_util45.isUndefined)(touch.tiltY))
            touch.tiltY = 0;
          if ((0, import_util45.isUndefined)(touch.pointerType))
            touch.pointerType = "touch";
          if ((0, import_util45.isUndefined)(touch.pointerId))
            touch.pointerId = touch.identifier || 0;
          if ((0, import_util45.isUndefined)(touch.pressure))
            touch.pressure = touch.force || 0.5;
          if ((0, import_util45.isUndefined)(touch.twist))
            touch.twist = 0;
          if ((0, import_util45.isUndefined)(touch.tangentialPressure))
            touch.tangentialPressure = 0;
          touch.isNormalized = true;
          touch.type = event.type;
          normalizedEvents.push(touch);
        }
      } else if (canvas2.isMouseEvent(event)) {
        const tempEvent = event;
        if ((0, import_util45.isUndefined)(tempEvent.isPrimary))
          tempEvent.isPrimary = true;
        if ((0, import_util45.isUndefined)(tempEvent.width))
          tempEvent.width = 1;
        if ((0, import_util45.isUndefined)(tempEvent.height))
          tempEvent.height = 1;
        if ((0, import_util45.isUndefined)(tempEvent.tiltX))
          tempEvent.tiltX = 0;
        if ((0, import_util45.isUndefined)(tempEvent.tiltY))
          tempEvent.tiltY = 0;
        if ((0, import_util45.isUndefined)(tempEvent.pointerType))
          tempEvent.pointerType = "mouse";
        if ((0, import_util45.isUndefined)(tempEvent.pointerId))
          tempEvent.pointerId = 1;
        if ((0, import_util45.isUndefined)(tempEvent.pressure))
          tempEvent.pressure = 0.5;
        if ((0, import_util45.isUndefined)(tempEvent.twist))
          tempEvent.twist = 0;
        if ((0, import_util45.isUndefined)(tempEvent.tangentialPressure))
          tempEvent.tangentialPressure = 0;
        tempEvent.isNormalized = true;
        normalizedEvents.push(tempEvent);
      } else {
        normalizedEvents.push(event);
      }
      return normalizedEvents;
    }
    transferMouseData(event, nativeEvent) {
      event.isTrusted = nativeEvent.isTrusted;
      event.srcElement = nativeEvent.srcElement;
      event.timeStamp = performance.now();
      event.type = nativeEvent.type;
      event.altKey = nativeEvent.altKey;
      event.metaKey = nativeEvent.metaKey;
      event.shiftKey = nativeEvent.shiftKey;
      event.ctrlKey = nativeEvent.ctrlKey;
      event.button = nativeEvent.button;
      event.buttons = nativeEvent.buttons;
      event.client.x = nativeEvent.clientX;
      event.client.y = nativeEvent.clientY;
      event.movement.x = nativeEvent.movementX;
      event.movement.y = nativeEvent.movementY;
      event.page.x = nativeEvent.pageX;
      event.page.y = nativeEvent.pageY;
      event.screen.x = nativeEvent.screenX;
      event.screen.y = nativeEvent.screenY;
      event.relatedTarget = null;
    }
    bootstrapEvent(event, normalizedEvent, view, nativeEvent) {
      event.view = view;
      event.originalEvent = null;
      event.nativeEvent = nativeEvent;
      event.pointerId = normalizedEvent.pointerId;
      event.width = normalizedEvent.width;
      event.height = normalizedEvent.height;
      event.isPrimary = normalizedEvent.isPrimary;
      event.pointerType = normalizedEvent.pointerType;
      event.pressure = normalizedEvent.pressure;
      event.tangentialPressure = normalizedEvent.tangentialPressure;
      event.tiltX = normalizedEvent.tiltX;
      event.tiltY = normalizedEvent.tiltY;
      event.twist = normalizedEvent.twist;
      this.transferMouseData(event, normalizedEvent);
      const { x: x3, y: y3 } = this.getViewportXY(normalizedEvent);
      event.viewport.x = x3;
      event.viewport.y = y3;
      const [canvasX, canvasY] = this.context.canvas.getCanvasByViewport([x3, y3]);
      event.canvas.x = canvasX;
      event.canvas.y = canvasY;
      event.global.copyFrom(event.canvas);
      event.offset.copyFrom(event.canvas);
      event.isTrusted = nativeEvent.isTrusted;
      if (event.type === "pointerleave") {
        event.type = "pointerout";
      }
      return event;
    }
    getViewportXY(nativeEvent) {
      let x3;
      let y3;
      const { offsetX, offsetY, clientX, clientY } = nativeEvent;
      if (!(0, import_util45.isNil)(offsetX) && !(0, import_util45.isNil)(offsetY)) {
        x3 = offsetX;
        y3 = offsetY;
      } else {
        const point4 = this.eventService.client2Viewport({ x: clientX, y: clientY });
        x3 = point4.x;
        y3 = point4.y;
      }
      return { x: x3, y: y3 };
    }
    onframe() {
      super.onframe();
      const { opacity } = this.attributes;
      this.getDomElement().style.opacity = `${opacity}`;
    }
  };
  HTML2.defaultStyleProps = {
    size: [160, 80],
    halo: false,
    icon: false,
    label: false,
    pointerEvents: "auto"
  };

  // node_modules/@antv/g6/esm/elements/nodes/image.js
  var __rest9 = function(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  var Image4 = class _Image extends BaseNode {
    constructor(options) {
      super(mergeOptions({ style: _Image.defaultStyleProps }, options));
    }
    getKeyStyle(attributes) {
      const [width2, height] = this.getSize(attributes);
      const _a2 = super.getKeyStyle(attributes), { fillOpacity, opacity = fillOpacity } = _a2, keyStyle = __rest9(_a2, ["fillOpacity", "opacity"]);
      return Object.assign(Object.assign({ opacity }, keyStyle), {
        width: width2,
        height,
        x: -width2 / 2,
        y: -height / 2
      });
    }
    getBounds() {
      return this.getShape("key").getBounds();
    }
    getHaloStyle(attributes) {
      if (attributes.halo === false)
        return false;
      const _a2 = this.getShape("key").attributes, { fill: keyStyleFill, stroke: keyStyleStroke } = _a2, keyStyle = __rest9(_a2, ["fill", "stroke"]);
      const haloStyle = subStyleProps(this.getGraphicStyle(attributes), "halo");
      const haloLineWidth = Number(haloStyle.lineWidth);
      const [width2, height] = add(this.getSize(attributes), [haloLineWidth, haloLineWidth]);
      const { lineWidth } = haloStyle;
      const recalculate = {
        fill: "transparent",
        lineWidth: lineWidth / 2,
        width: width2 - lineWidth / 2,
        height: height - lineWidth / 2,
        x: -(width2 - lineWidth / 2) / 2,
        y: -(height - lineWidth / 2) / 2
      };
      return Object.assign(Object.assign({}, haloStyle), recalculate);
    }
    getIconStyle(attributes) {
      const style = super.getIconStyle(attributes);
      const [width2, height] = this.getSize(attributes);
      return style ? Object.assign({ width: width2 * ICON_SIZE_RATIO, height: height * ICON_SIZE_RATIO }, style) : false;
    }
    drawKeyShape(attributes, container) {
      const image = this.upsert("key", Image3, this.getKeyStyle(attributes), container);
      connectImage(this);
      return image;
    }
    drawHaloShape(attributes, container) {
      this.upsert("halo", Rect, this.getHaloStyle(attributes), container);
    }
    update(attr2) {
      super.update(attr2);
      if (attr2 && ("x" in attr2 || "y" in attr2 || "z" in attr2)) {
        dispatchPositionChange(this);
      }
    }
  };
  Image4.defaultStyleProps = {
    size: 32
  };

  // node_modules/@antv/g6/esm/elements/nodes/rect.js
  var Rect2 = class extends BaseNode {
    constructor(options) {
      super(options);
    }
    getKeyStyle(attributes) {
      const [width2, height] = this.getSize(attributes);
      return Object.assign(Object.assign({}, super.getKeyStyle(attributes)), {
        width: width2,
        height,
        x: -width2 / 2,
        y: -height / 2
      });
    }
    getIconStyle(attributes) {
      const style = super.getIconStyle(attributes);
      const { width: width2, height } = this.getShape("key").attributes;
      return style ? Object.assign({ width: width2 * ICON_SIZE_RATIO, height: height * ICON_SIZE_RATIO }, style) : false;
    }
    drawKeyShape(attributes, container) {
      return this.upsert("key", Rect, this.getKeyStyle(attributes), container);
    }
  };

  // node_modules/@antv/g6/esm/elements/nodes/star.js
  var Star = class extends Polygon2 {
    constructor(options) {
      super(options);
    }
    getInnerR(attributes) {
      return attributes.innerR || this.getOuterR(attributes) * 3 / 8;
    }
    getOuterR(attributes) {
      return Math.min(...this.getSize(attributes)) / 2;
    }
    getPoints(attributes) {
      return getStarPoints(this.getOuterR(attributes), this.getInnerR(attributes));
    }
    getIconStyle(attributes) {
      const style = super.getIconStyle(attributes);
      const size2 = this.getInnerR(attributes) * 2 * ICON_SIZE_RATIO;
      return style ? Object.assign({ width: size2, height: size2 }, style) : false;
    }
    getPortXY(attributes, style) {
      const { placement = "top" } = style;
      const bbox = this.getShape("key").getLocalBounds();
      const ports = getStarPorts(this.getOuterR(attributes), this.getInnerR(attributes));
      return getPortXYByPlacement(bbox, placement, ports, false);
    }
  };

  // node_modules/@antv/g6/esm/elements/nodes/triangle.js
  var import_util46 = __toESM(require_lib());
  var Triangle = class _Triangle extends Polygon2 {
    constructor(options) {
      super(mergeOptions({ style: _Triangle.defaultStyleProps }, options));
    }
    getPoints(attributes) {
      const { direction: direction2 } = attributes;
      const [width2, height] = this.getSize(attributes);
      return getTrianglePoints(width2, height, direction2);
    }
    getPortXY(attributes, style) {
      const { direction: direction2 } = attributes;
      const { placement = "top" } = style;
      const bbox = this.getShape("key").getLocalBounds();
      const [width2, height] = this.getSize(attributes);
      const ports = getTrianglePorts(width2, height, direction2);
      return getPortXYByPlacement(bbox, placement, ports, false);
    }
    // icon 处于内切三角形的重心
    // icon is at the centroid of the triangle
    getIconStyle(attributes) {
      const { icon, iconText, iconSrc, direction: direction2 } = attributes;
      if (icon === false || (0, import_util46.isEmpty)(iconText || iconSrc))
        return false;
      const iconStyle = subStyleProps(this.getGraphicStyle(attributes), "icon");
      const bbox = this.getShape("key").getLocalBounds();
      const [x3, y3] = getTriangleCenter(bbox, direction2);
      const size2 = getIncircleRadius(bbox, direction2) * 2 * ICON_SIZE_RATIO;
      return Object.assign({
        x: x3,
        y: y3,
        width: size2,
        height: size2
      }, iconStyle);
    }
  };
  Triangle.defaultStyleProps = {
    size: 40,
    direction: "up"
  };

  // node_modules/@antv/g6/esm/elements/combos/base-combo.js
  var __rest10 = function(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  var BaseCombo = class _BaseCombo extends BaseNode {
    constructor(options) {
      super(mergeOptions({ style: _BaseCombo.defaultStyleProps }, options));
      this.type = "combo";
      this.updateComboPosition(this.parsedAttributes);
    }
    getKeySize(attributes) {
      const { collapsed, childrenNode = [] } = attributes;
      if (childrenNode.length === 0)
        return this.getEmptyKeySize(attributes);
      return collapsed ? this.getCollapsedKeySize(attributes) : this.getExpandedKeySize(attributes);
    }
    getEmptyKeySize(attributes) {
      const { padding, collapsedSize } = attributes;
      const [top, right, bottom, left] = parsePadding(padding);
      return add(parseSize(collapsedSize), [left + right, top + bottom, 0]);
    }
    getCollapsedKeySize(attributes) {
      return parseSize(attributes.collapsedSize);
    }
    getExpandedKeySize(attributes) {
      const contentBBox = this.getContentBBox(attributes);
      return [getBBoxWidth(contentBBox), getBBoxHeight(contentBBox), 0];
    }
    getContentBBox(attributes) {
      const { childrenNode = [], padding } = attributes;
      const children = childrenNode.map((id3) => this.context.element.getElement(id3)).filter(Boolean);
      if (children.length === 0) {
        const bbox = new AABB();
        const { x: x3 = 0, y: y3 = 0, size: size2 } = attributes;
        const [width2, height] = parseSize(size2);
        bbox.setMinMax([x3 - width2 / 2, y3 - height / 2, 0], [x3 + width2 / 2, y3 + height / 2, 0]);
        return bbox;
      }
      const childrenBBox = getCombinedBBox(children.map((child) => child.getBounds()));
      if (!padding)
        return childrenBBox;
      return getExpandedBBox(childrenBBox, padding);
    }
    drawCollapsedMarkerShape(attributes, container) {
      const style = this.getCollapsedMarkerStyle(attributes);
      this.upsert("collapsed-marker", Icon, style, container);
      connectImage(this);
    }
    getCollapsedMarkerStyle(attributes) {
      if (!attributes.collapsed || !attributes.collapsedMarker)
        return false;
      const _a2 = subStyleProps(this.getGraphicStyle(attributes), "collapsedMarker"), { type } = _a2, collapsedMarkerStyle = __rest10(_a2, ["type"]);
      const keyShape = this.getShape("key");
      const [x3, y3] = getXYByPlacement(keyShape.getLocalBounds(), "center");
      const style = Object.assign(Object.assign({}, collapsedMarkerStyle), { x: x3, y: y3 });
      if (type) {
        const text = this.getCollapsedMarkerText(type, attributes);
        Object.assign(style, { text });
      }
      return style;
    }
    getCollapsedMarkerText(type, attributes) {
      const { childrenData = [] } = attributes;
      const { model } = this.context;
      if (type === "descendant-count")
        return model.getDescendantsData(this.id).length.toString();
      if (type === "child-count")
        return childrenData.length.toString();
      if (type === "node-count")
        return model.getDescendantsData(this.id).filter((datum) => model.getElementType(idOf(datum)) === "node").length.toString();
      if ((0, import_util47.isFunction)(type))
        return type(childrenData);
      return "";
    }
    getComboPosition(attributes) {
      const { x: x3 = 0, y: y3 = 0, collapsed, childrenData = [] } = attributes;
      if (childrenData.length === 0)
        return [+x3, +y3, 0];
      if (collapsed) {
        const { model } = this.context;
        const descendants = model.getDescendantsData(this.id).filter((datum) => !model.isCombo(idOf(datum)));
        if (descendants.length > 0 && descendants.some(hasPosition)) {
          const totalPosition = descendants.reduce((acc, datum) => add(acc, positionOf(datum)), [0, 0, 0]);
          return divide(totalPosition, descendants.length);
        }
        return [+x3, +y3, 0];
      }
      return this.getContentBBox(attributes).center;
    }
    getComboStyle(attributes) {
      const [x3, y3] = this.getComboPosition(attributes);
      return { x: x3, y: y3, transform: [["translate", x3, y3]] };
    }
    updateComboPosition(attributes) {
      const comboStyle = this.getComboStyle(attributes);
      Object.assign(this.style, comboStyle);
      const { x: x3, y: y3 } = comboStyle;
      this.context.model.syncNodeLikeDatum({ id: this.id, style: { x: x3, y: y3 } });
      dispatchPositionChange(this);
    }
    render(attributes, container = this) {
      super.render(attributes, container);
      this.drawCollapsedMarkerShape(attributes, container);
    }
    update(attr2 = {}) {
      super.update(attr2);
      this.updateComboPosition(this.parsedAttributes);
    }
    onframe() {
      super.onframe();
      if (!this.attributes.collapsed)
        this.updateComboPosition(this.parsedAttributes);
      this.drawKeyShape(this.parsedAttributes, this);
    }
    animate(keyframes, options) {
      const animation = super.animate(this.attributes.collapsed ? keyframes : (
        // 如果当前 combo 是展开状态，则动画不受 x, y, z, transform 影响，仅由子元素决定位置
        // If the current combo is in the expanded state, the animation is not affected by x, y, z, transform, and the position is determined only by the child elements
        keyframes.map((_a2) => {
          var { x: x3, y: y3, z, transform } = _a2, keyframe = __rest10(_a2, ["x", "y", "z", "transform"]);
          return keyframe;
        })
      ), options);
      if (!animation)
        return animation;
      return new Proxy(animation, {
        set: (target, propKey, value) => {
          if (propKey === "currentTime")
            Promise.resolve().then(() => this.onframe());
          return Reflect.set(target, propKey, value);
        }
      });
    }
  };
  BaseCombo.defaultStyleProps = {
    childrenNode: [],
    droppable: true,
    draggable: true,
    collapsed: false,
    collapsedSize: 32,
    collapsedMarker: true,
    collapsedMarkerZIndex: 1,
    collapsedMarkerFontSize: 12,
    collapsedMarkerTextAlign: "center",
    collapsedMarkerTextBaseline: "middle",
    collapsedMarkerType: "child-count"
  };

  // node_modules/@antv/g6/esm/elements/combos/circle.js
  var CircleCombo = class extends BaseCombo {
    constructor(options) {
      super(options);
    }
    drawKeyShape(attributes, container) {
      return this.upsert("key", Circle, this.getKeyStyle(attributes), container);
    }
    getKeyStyle(attributes) {
      const { collapsed } = attributes;
      const keyStyle = super.getKeyStyle(attributes);
      const [width2] = this.getKeySize(attributes);
      return Object.assign(Object.assign(Object.assign({}, keyStyle), collapsed && subStyleProps(keyStyle, "collapsed")), { r: width2 / 2 });
    }
    getCollapsedKeySize(attributes) {
      const [collapsedWidth, collapsedHeight] = parseSize(attributes.collapsedSize);
      const collapsedR = Math.max(collapsedWidth, collapsedHeight) / 2;
      return [collapsedR * 2, collapsedR * 2, 0];
    }
    getExpandedKeySize(attributes) {
      const contentBBox = this.getContentBBox(attributes);
      const [width2, height] = getBBoxSize(contentBBox);
      const expandedR = Math.sqrt(Math.pow(width2, 2) + Math.pow(height, 2)) / 2;
      return [expandedR * 2, expandedR * 2, 0];
    }
    getIntersectPoint(point4, useExtendedLine = false) {
      const keyShapeBounds = this.getShape("key").getBounds();
      return getEllipseIntersectPoint(point4, keyShapeBounds, useExtendedLine);
    }
  };

  // node_modules/@antv/g6/esm/elements/combos/rect.js
  var RectCombo = class extends BaseCombo {
    constructor(options) {
      super(options);
    }
    drawKeyShape(attributes, container) {
      return this.upsert("key", Rect, this.getKeyStyle(attributes), container);
    }
    getKeyStyle(attributes) {
      const keyStyle = super.getKeyStyle(attributes);
      const [width2, height] = this.getKeySize(attributes);
      return Object.assign(Object.assign(Object.assign({}, keyStyle), attributes.collapsed && subStyleProps(keyStyle, "collapsed")), {
        width: width2,
        height,
        x: -width2 / 2,
        y: -height / 2
      });
    }
  };

  // node_modules/@antv/g6/esm/elements/edges/base-edge.js
  var import_util50 = __toESM(require_lib());

  // node_modules/@antv/g6/esm/utils/edge.js
  var import_util49 = __toESM(require_lib());

  // node_modules/@antv/g6/esm/utils/router/orth.js
  var import_util48 = __toESM(require_lib());
  var defaultOptions = {
    padding: 10
  };
  function orth(sourcePoint, targetPoint, sourceNode, targetNode, controlPoints, options) {
    const { padding } = Object.assign(defaultOptions, options);
    const sourceBBox = getNodeBBox(sourceNode, padding);
    const targetBBox = getNodeBBox(targetNode, padding);
    const points = [sourcePoint, ...controlPoints, targetPoint];
    let direction2 = null;
    const result = [];
    for (let fromIdx = 0, len = points.length; fromIdx < len - 1; fromIdx++) {
      const toIdx = fromIdx + 1;
      const from = points[fromIdx];
      const to = points[toIdx];
      const isOrth = isOrthogonal(from, to);
      let route = null;
      if (fromIdx === 0) {
        if (toIdx === len - 1) {
          if (sourceBBox.intersects(targetBBox)) {
            route = insideNode(from, to, sourceBBox, targetBBox);
          } else if (!isPointBBoxCenter(from, sourceBBox) && !isPointBBoxCenter(to, targetBBox)) {
            const fromWithPadding = getNearestBoundaryPoint(from, sourceBBox);
            const toWithPadding = getNearestBoundaryPoint(to, targetBBox);
            route = pointToPoint(fromWithPadding, toWithPadding, getDirection(fromWithPadding, toWithPadding));
            route.points.unshift(fromWithPadding);
            route.points.push(toWithPadding);
          } else if (!isOrth) {
            route = nodeToNode(from, to, sourceBBox, targetBBox);
          }
        } else {
          if (isPointInBBox(to, sourceBBox)) {
            route = insideNode(from, to, sourceBBox, getNodeBBox(to, padding), direction2);
          } else if (!isOrth) {
            route = nodeToPoint(from, to, sourceBBox);
          }
        }
      } else if (toIdx === len - 1) {
        if (isPointInBBox(from, targetBBox)) {
          route = insideNode(from, to, getNodeBBox(from, padding), targetBBox, direction2);
        } else if (!isOrth) {
          route = pointToNode(from, to, targetBBox, direction2);
        }
      } else if (!isOrth) {
        route = pointToPoint(from, to, direction2);
      }
      if (route) {
        result.push(...route.points);
        direction2 = route.direction;
      } else {
        direction2 = getDirection(from, to);
      }
      if (toIdx < len - 1)
        result.push(to);
    }
    return result.map(toVector2);
  }
  var opposites = {
    N: "S",
    S: "N",
    W: "E",
    E: "W"
  };
  var radians = {
    N: -Math.PI / 2,
    S: Math.PI / 2,
    E: 0,
    W: Math.PI
  };
  function getDirection(from, to) {
    const [fx, fy] = from;
    const [tx, ty] = to;
    if (fx === tx) {
      return fy > ty ? "N" : "S";
    }
    if (fy === ty) {
      return fx > tx ? "W" : "E";
    }
    return null;
  }
  function getBBoxSize2(bbox, direction2) {
    return direction2 === "N" || direction2 === "S" ? getBBoxHeight(bbox) : getBBoxWidth(bbox);
  }
  function pointToPoint(from, to, direction2) {
    const p1 = [from[0], to[1]];
    const p2 = [to[0], from[1]];
    const d1 = getDirection(from, p1);
    const d2 = getDirection(from, p2);
    const opposite = direction2 ? opposites[direction2] : null;
    const p = d1 === direction2 || d1 !== opposite && d2 !== direction2 ? p1 : p2;
    return { points: [p], direction: getDirection(p, to) };
  }
  function nodeToPoint(from, to, fromBBox) {
    if (isPointBBoxCenter(from, fromBBox)) {
      const p = freeJoin(from, to, fromBBox);
      return { points: [p], direction: getDirection(p, to) };
    } else {
      const fromWithPadding = getNearestBoundaryPoint(from, fromBBox);
      const isHorizontal3 = ["left", "right"].includes(getNearestBoundarySide(from, fromBBox));
      const p = isHorizontal3 ? [to[0], fromWithPadding[1]] : [fromWithPadding[0], to[1]];
      return { points: [p], direction: getDirection(p, to) };
    }
  }
  function pointToNode(from, to, toBBox, direction2) {
    const toWithPadding = isPointBBoxCenter(to, toBBox) ? to : getNearestBoundaryPoint(to, toBBox);
    const points = [
      [toWithPadding[0], from[1]],
      [from[0], toWithPadding[1]]
    ];
    const freePoints = points.filter((p) => isPointOutsideBBox(p, toBBox) && !isPointOnBBoxBoundary(p, toBBox, true));
    const freeDirectionPoints = freePoints.filter((p) => getDirection(p, from) !== direction2);
    if (freeDirectionPoints.length > 0) {
      const p = freeDirectionPoints.find((p2) => getDirection(from, p2) === direction2) || freeDirectionPoints[0];
      return {
        points: [p],
        direction: getDirection(p, to)
      };
    } else {
      const p = (0, import_util48.difference)(points, freePoints)[0];
      const p2 = moveTo(to, p, getBBoxSize2(toBBox, direction2) / 2);
      const p1 = freeJoin(p2, from, toBBox);
      return {
        points: [p1, p2],
        direction: getDirection(p2, to)
      };
    }
  }
  function nodeToNode(from, to, fromBBox, toBBox) {
    let route = nodeToPoint(from, to, fromBBox);
    const p1 = toVector3(route.points[0]);
    if (isPointInBBox(p1, toBBox)) {
      route = nodeToPoint(to, from, toBBox);
      const p2 = toVector3(route.points[0]);
      if (isPointInBBox(p2, fromBBox)) {
        const fromBorder = moveTo(from, p1, getBBoxSize2(fromBBox, getDirection(from, p1)) / 2);
        const toBorder = moveTo(to, p2, getBBoxSize2(toBBox, getDirection(to, p2)) / 2);
        const midPoint = [(fromBorder[0] + toBorder[0]) / 2, (fromBorder[1] + toBorder[1]) / 2];
        const startRoute = nodeToPoint(from, midPoint, fromBBox);
        const endRoute = pointToNode(midPoint, to, toBBox, startRoute.direction);
        route.points = [startRoute.points[0], endRoute.points[0]];
        route.direction = endRoute.direction;
      }
    }
    return route;
  }
  function insideNode(from, to, fromBBox, toBBox, direction2) {
    const DEFAULT_OFFSET = 0.01;
    const boundary = getCombinedBBox([fromBBox, toBBox]);
    const reversed = distance2(to, boundary.center) > distance2(from, boundary.center);
    const [start, end] = reversed ? [to, from] : [from, to];
    const halfPerimeter = getBBoxHeight(boundary) + getBBoxWidth(boundary);
    let p1;
    if (direction2) {
      const ref = [
        start[0] + halfPerimeter * Math.cos(radians[direction2]),
        start[1] + halfPerimeter * Math.sin(radians[direction2])
      ];
      p1 = moveTo(getNearestBoundaryPoint(ref, boundary), ref, DEFAULT_OFFSET);
    } else {
      p1 = moveTo(getNearestBoundaryPoint(start, boundary), start, -DEFAULT_OFFSET);
    }
    let p2 = freeJoin(p1, end, boundary);
    let points = [round(p1, 2), round(p2, 2)];
    if ((0, import_util48.isEqual)(round(p1), round(p2))) {
      const rad2 = angle(subtract(p1, start), [1, 0, 0]) + Math.PI / 2;
      p2 = [end[0] + halfPerimeter * Math.cos(rad2), end[1] + halfPerimeter * Math.sin(rad2), 0];
      p2 = round(moveTo(getNearestBoundaryPoint(p2, boundary), end, -DEFAULT_OFFSET), 2);
      const p3 = freeJoin(p1, p2, boundary);
      points = [p1, p3, p2];
    }
    return {
      points: reversed ? points.reverse() : points,
      direction: reversed ? getDirection(p1, to) : getDirection(p2, to)
    };
  }
  function freeJoin(p1, p2, bbox) {
    let p = [p1[0], p2[1]];
    if (isPointInBBox(p, bbox)) {
      p = [p2[0], p1[1]];
    }
    return p;
  }

  // node_modules/@antv/g6/esm/utils/edge.js
  function getLabelPositionStyle(key, placement, autoRotate, offsetX, offsetY) {
    const START_RATIO = 0;
    const MIDDLE_RATIO = 0.5;
    const END_RATIO = 0.99;
    let ratio = typeof placement === "number" ? placement : MIDDLE_RATIO;
    if (placement === "start")
      ratio = START_RATIO;
    if (placement === "end")
      ratio = END_RATIO;
    const point4 = parsePoint(key.getPoint(ratio));
    const pointOffset = parsePoint(key.getPoint(ratio + 0.01));
    let textAlign = placement === "start" ? "left" : placement === "end" ? "right" : "center";
    if (isHorizontal(point4, pointOffset) || !autoRotate) {
      const [x4, y4] = getXYByPlacement2(key, ratio, offsetX, offsetY);
      return { transform: [["translate", x4, y4]], textAlign };
    }
    let angle2 = Math.atan2(pointOffset[1] - point4[1], pointOffset[0] - point4[0]);
    const isRevert = pointOffset[0] < point4[0];
    if (isRevert) {
      textAlign = textAlign === "center" ? textAlign : textAlign === "left" ? "right" : "left";
      offsetX *= -1;
      angle2 += Math.PI;
    }
    const [x3, y3] = getXYByPlacement2(key, ratio, offsetX, offsetY, angle2);
    const transform = [
      ["translate", x3, y3],
      ["rotate", angle2 / Math.PI * 180]
    ];
    return {
      textAlign,
      transform
    };
  }
  function getBadgePositionStyle(shapeMap, placement, labelPlacement, offsetX, offsetY) {
    var _a2, _b;
    const badgeWidth = ((_a2 = shapeMap.badge) === null || _a2 === void 0 ? void 0 : _a2.getGeometryBounds().halfExtents[0]) * 2 || 0;
    const labelWidth = ((_b = shapeMap.label) === null || _b === void 0 ? void 0 : _b.getGeometryBounds().halfExtents[0]) * 2 || 0;
    return getLabelPositionStyle(shapeMap.key, labelPlacement, true, (labelWidth ? (labelWidth / 2 + badgeWidth / 2) * (placement === "suffix" ? 1 : -1) : 0) + offsetX, offsetY);
  }
  function getXYByPlacement2(key, ratio, offsetX, offsetY, angle2) {
    const [pointX, pointY] = parsePoint(key.getPoint(ratio));
    let actualOffsetX = offsetX;
    let actualOffsetY = offsetY;
    if (angle2) {
      actualOffsetX = offsetX * Math.cos(angle2) - offsetY * Math.sin(angle2);
      actualOffsetY = offsetX * Math.sin(angle2) + offsetY * Math.cos(angle2);
    }
    return [pointX + actualOffsetX, pointY + actualOffsetY];
  }
  function getCurveControlPoint(sourcePoint, targetPoint, curvePosition, curveOffset) {
    if ((0, import_util49.isEqual)(sourcePoint, targetPoint))
      return sourcePoint;
    const lineVector = subtract(targetPoint, sourcePoint);
    const controlPoint = [
      sourcePoint[0] + curvePosition * lineVector[0],
      sourcePoint[1] + curvePosition * lineVector[1]
    ];
    const perpVector = normalize2(perpendicular(lineVector, false));
    controlPoint[0] += curveOffset * perpVector[0];
    controlPoint[1] += curveOffset * perpVector[1];
    return controlPoint;
  }
  function parseCurveOffset(curveOffset) {
    if ((0, import_util49.isNumber)(curveOffset))
      return [curveOffset, -curveOffset];
    return curveOffset;
  }
  function parseCurvePosition(curvePosition) {
    if ((0, import_util49.isNumber)(curvePosition))
      return [curvePosition, 1 - curvePosition];
    return curvePosition;
  }
  function getQuadraticPath(sourcePoint, targetPoint, controlPoint) {
    return [
      ["M", sourcePoint[0], sourcePoint[1]],
      ["Q", controlPoint[0], controlPoint[1], targetPoint[0], targetPoint[1]]
    ];
  }
  function getCubicPath(sourcePoint, targetPoint, controlPoints) {
    return [
      ["M", sourcePoint[0], sourcePoint[1]],
      [
        "C",
        controlPoints[0][0],
        controlPoints[0][1],
        controlPoints[1][0],
        controlPoints[1][1],
        targetPoint[0],
        targetPoint[1]
      ]
    ];
  }
  function getPolylinePath(points, radius = 0, z = false) {
    const targetIndex = points.length - 1;
    const sourcePoint = points[0];
    const targetPoint = points[targetIndex];
    const controlPoints = points.slice(1, targetIndex);
    const pathArray = [["M", sourcePoint[0], sourcePoint[1]]];
    controlPoints.forEach((midPoint, i) => {
      const prevPoint = controlPoints[i - 1] || sourcePoint;
      const nextPoint = controlPoints[i + 1] || targetPoint;
      if (!isCollinear(prevPoint, midPoint, nextPoint) && radius) {
        const [ps, pt] = getBorderRadiusPoints(prevPoint, midPoint, nextPoint, radius);
        pathArray.push(["L", ps[0], ps[1]], ["Q", midPoint[0], midPoint[1], pt[0], pt[1]], ["L", pt[0], pt[1]]);
      } else {
        pathArray.push(["L", midPoint[0], midPoint[1]]);
      }
    });
    pathArray.push(["L", targetPoint[0], targetPoint[1]]);
    if (z)
      pathArray.push(["Z"]);
    return pathArray;
  }
  function getBorderRadiusPoints(prevPoint, midPoint, nextPoint, radius) {
    const d0 = manhattanDistance(prevPoint, midPoint);
    const d1 = manhattanDistance(nextPoint, midPoint);
    const r = Math.min(radius, Math.min(d0, d1) / 2);
    const ps = [
      midPoint[0] - r / d0 * (midPoint[0] - prevPoint[0]),
      midPoint[1] - r / d0 * (midPoint[1] - prevPoint[1])
    ];
    const pt = [
      midPoint[0] - r / d1 * (midPoint[0] - nextPoint[0]),
      midPoint[1] - r / d1 * (midPoint[1] - nextPoint[1])
    ];
    return [ps, pt];
  }
  var getRadians = (bbox) => {
    const halfPI = Math.PI / 2;
    const halfHeight = getBBoxHeight(bbox) / 2;
    const halfWidth = getBBoxWidth(bbox) / 2;
    const angleWithX = Math.atan2(halfHeight, halfWidth) / 2;
    const angleWithY = Math.atan2(halfWidth, halfHeight) / 2;
    return {
      top: [-halfPI - angleWithY, -halfPI + angleWithY],
      "top-right": [-halfPI + angleWithY, -angleWithX],
      "right-top": [-halfPI + angleWithY, -angleWithX],
      right: [-angleWithX, angleWithX],
      "bottom-right": [angleWithX, halfPI - angleWithY],
      "right-bottom": [angleWithX, halfPI - angleWithY],
      bottom: [halfPI - angleWithY, halfPI + angleWithY],
      "bottom-left": [halfPI + angleWithY, Math.PI - angleWithX],
      "left-bottom": [halfPI + angleWithY, Math.PI - angleWithX],
      left: [Math.PI - angleWithX, Math.PI + angleWithX],
      "top-left": [Math.PI + angleWithX, -halfPI - angleWithY],
      "left-top": [Math.PI + angleWithX, -halfPI - angleWithY]
    };
  };
  function getLoopEndpoints(node, placement, clockwise, sourcePort, targetPort) {
    const bbox = getNodeBBox(node);
    const center = node.getCenter();
    let sourcePoint = sourcePort && getPortPosition(sourcePort);
    let targetPoint = targetPort && getPortPosition(targetPort);
    if (!sourcePoint || !targetPoint) {
      const radians2 = getRadians(bbox);
      const angle1 = radians2[placement][0];
      const angle2 = radians2[placement][1];
      const [width2, height] = getBBoxSize(bbox);
      const r = Math.max(width2, height);
      const point1 = add(center, [r * Math.cos(angle1), r * Math.sin(angle1), 0]);
      const point22 = add(center, [r * Math.cos(angle2), r * Math.sin(angle2), 0]);
      sourcePoint = getNodeConnectionPoint(node, point1);
      targetPoint = getNodeConnectionPoint(node, point22);
      if (!clockwise) {
        [sourcePoint, targetPoint] = [targetPoint, sourcePoint];
      }
    }
    return [sourcePoint, targetPoint];
  }
  function getCubicLoopPath(node, placement, clockwise, dist, sourcePortKey, targetPortKey) {
    const sourcePort = node.getPorts()[sourcePortKey || targetPortKey];
    const targetPort = node.getPorts()[targetPortKey || sourcePortKey];
    let [sourcePoint, targetPoint] = getLoopEndpoints(node, placement, clockwise, sourcePort, targetPort);
    const controlPoints = getCubicLoopControlPoints(node, sourcePoint, targetPoint, dist);
    if (sourcePort)
      sourcePoint = getPortConnectionPoint(sourcePort, controlPoints[0]);
    if (targetPort)
      targetPoint = getPortConnectionPoint(targetPort, controlPoints.at(-1));
    return getCubicPath(sourcePoint, targetPoint, controlPoints);
  }
  function getCubicLoopControlPoints(node, sourcePoint, targetPoint, dist) {
    const center = node.getCenter();
    if ((0, import_util49.isEqual)(sourcePoint, targetPoint)) {
      const direction2 = subtract(sourcePoint, center);
      const adjustment = [
        dist * Math.sign(direction2[0]) || dist / 2,
        dist * Math.sign(direction2[1]) || -dist / 2,
        0
      ];
      return [add(sourcePoint, adjustment), add(targetPoint, multiply(adjustment, [1, -1, 1]))];
    }
    return [
      moveTo(center, sourcePoint, distance2(center, sourcePoint) + dist),
      moveTo(center, targetPoint, distance2(center, targetPoint) + dist)
    ];
  }
  function getPolylineLoopPath(node, radius, placement, clockwise, dist, sourcePortKey, targetPortKey) {
    const allPortsMap = getAllPorts(node);
    const sourcePort = allPortsMap[sourcePortKey || targetPortKey];
    const targetPort = allPortsMap[targetPortKey || sourcePortKey];
    let [sourcePoint, targetPoint] = getLoopEndpoints(node, placement, clockwise, sourcePort, targetPort);
    const controlPoints = getPolylineLoopControlPoints(node, sourcePoint, targetPoint, dist);
    if (sourcePort)
      sourcePoint = getPortConnectionPoint(sourcePort, controlPoints[0]);
    if (targetPort)
      targetPoint = getPortConnectionPoint(targetPort, controlPoints.at(-1));
    return getPolylinePath([sourcePoint, ...controlPoints, targetPoint], radius);
  }
  function getPolylineLoopControlPoints(node, sourcePoint, targetPoint, dist) {
    const controlPoints = [];
    const bbox = getNodeBBox(node);
    if ((0, import_util49.isEqual)(sourcePoint, targetPoint)) {
      const side = getNearestBoundarySide(sourcePoint, bbox);
      switch (side) {
        case "left":
          controlPoints.push([sourcePoint[0] - dist, sourcePoint[1]]);
          controlPoints.push([sourcePoint[0] - dist, sourcePoint[1] + dist]);
          controlPoints.push([sourcePoint[0], sourcePoint[1] + dist]);
          break;
        case "right":
          controlPoints.push([sourcePoint[0] + dist, sourcePoint[1]]);
          controlPoints.push([sourcePoint[0] + dist, sourcePoint[1] + dist]);
          controlPoints.push([sourcePoint[0], sourcePoint[1] + dist]);
          break;
        case "top":
          controlPoints.push([sourcePoint[0], sourcePoint[1] - dist]);
          controlPoints.push([sourcePoint[0] + dist, sourcePoint[1] - dist]);
          controlPoints.push([sourcePoint[0] + dist, sourcePoint[1]]);
          break;
        case "bottom":
          controlPoints.push([sourcePoint[0], sourcePoint[1] + dist]);
          controlPoints.push([sourcePoint[0] + dist, sourcePoint[1] + dist]);
          controlPoints.push([sourcePoint[0] + dist, sourcePoint[1]]);
          break;
      }
    } else {
      const sourceSide = getNearestBoundarySide(sourcePoint, bbox);
      const targetSide = getNearestBoundarySide(targetPoint, bbox);
      if (sourceSide === targetSide) {
        const side = sourceSide;
        let x3, y3;
        switch (side) {
          case "left":
            x3 = Math.min(sourcePoint[0], targetPoint[0]) - dist;
            controlPoints.push([x3, sourcePoint[1]]);
            controlPoints.push([x3, targetPoint[1]]);
            break;
          case "right":
            x3 = Math.max(sourcePoint[0], targetPoint[0]) + dist;
            controlPoints.push([x3, sourcePoint[1]]);
            controlPoints.push([x3, targetPoint[1]]);
            break;
          case "top":
            y3 = Math.min(sourcePoint[1], targetPoint[1]) - dist;
            controlPoints.push([sourcePoint[0], y3]);
            controlPoints.push([targetPoint[0], y3]);
            break;
          case "bottom":
            y3 = Math.max(sourcePoint[1], targetPoint[1]) + dist;
            controlPoints.push([sourcePoint[0], y3]);
            controlPoints.push([targetPoint[0], y3]);
            break;
        }
      } else {
        const getPointOffSide = (side, point4) => {
          return {
            left: [point4[0] - dist, point4[1]],
            right: [point4[0] + dist, point4[1]],
            top: [point4[0], point4[1] - dist],
            bottom: [point4[0], point4[1] + dist]
          }[side];
        };
        const p1 = getPointOffSide(sourceSide, sourcePoint);
        const p2 = getPointOffSide(targetSide, targetPoint);
        const p3 = freeJoin(p1, p2, bbox);
        controlPoints.push(p1, p3, p2);
      }
    }
    return controlPoints;
  }
  function getSubgraphRelatedEdges(ids, getRelatedEdges) {
    const edges = /* @__PURE__ */ new Set();
    const internal = /* @__PURE__ */ new Set();
    const external = /* @__PURE__ */ new Set();
    ids.forEach((id3) => {
      const relatedEdges = getRelatedEdges(id3);
      relatedEdges.forEach((edge) => {
        edges.add(edge);
        if (ids.includes(edge.source) && ids.includes(edge.target))
          internal.add(edge);
        else
          external.add(edge);
      });
    });
    return { edges: Array.from(edges), internal: Array.from(internal), external: Array.from(external) };
  }
  function findActualConnectNodeData(node, getParentData) {
    const path = [];
    let current2 = node;
    while (current2) {
      path.push(current2);
      const parent = getParentData(idOf(current2));
      if (parent)
        current2 = parent;
      else
        break;
    }
    if (path.some((n) => {
      var _a2;
      return (_a2 = n.style) === null || _a2 === void 0 ? void 0 : _a2.collapsed;
    })) {
      const index2 = path.reverse().findIndex(isCollapsed);
      return path[index2] || path.at(-1);
    }
    return node;
  }
  function getArrowSize(lineWidth, size2) {
    if (size2)
      return size2;
    if (lineWidth < 4)
      return 10;
    if (lineWidth === 4)
      return 12;
    return lineWidth * 2.5;
  }

  // node_modules/@antv/g6/esm/utils/symbol.js
  var symbol_exports = {};
  __export(symbol_exports, {
    circle: () => circle,
    diamond: () => diamond,
    rect: () => rect,
    simple: () => simple,
    triangle: () => triangle,
    triangleRect: () => triangleRect,
    vee: () => vee
  });
  var circle = (width2, height) => {
    const r = Math.max(width2, height) / 2;
    return [["M", -width2 / 2, 0], ["A", r, r, 0, 1, 0, 2 * r - width2 / 2, 0], ["A", r, r, 0, 1, 0, -width2 / 2, 0], ["Z"]];
  };
  var triangle = (width2, height) => {
    return [["M", -width2 / 2, 0], ["L", width2 / 2, -height / 2], ["L", width2 / 2, height / 2], ["Z"]];
  };
  var diamond = (width2, height) => {
    return [["M", -width2 / 2, 0], ["L", 0, -height / 2], ["L", width2 / 2, 0], ["L", 0, height / 2], ["Z"]];
  };
  var vee = (width2, height) => {
    return [
      ["M", -width2 / 2, 0],
      ["L", width2 / 2, -height / 2],
      ["L", 4 * width2 / 5 - width2 / 2, 0],
      ["L", width2 / 2, height / 2],
      ["Z"]
    ];
  };
  var rect = (width2, height) => {
    return [
      ["M", -width2 / 2, -height / 2],
      ["L", width2 / 2, -height / 2],
      ["L", width2 / 2, height / 2],
      ["L", -width2 / 2, height / 2],
      ["Z"]
    ];
  };
  var triangleRect = (width2, height) => {
    const tWidth = width2 / 2;
    const rWidth = width2 / 7;
    const rBeginX = width2 - rWidth;
    return [
      ["M", -tWidth, 0],
      ["L", 0, -height / 2],
      ["L", 0, height / 2],
      ["Z"],
      ["M", rBeginX - tWidth, -height / 2],
      ["L", rBeginX + rWidth - tWidth, -height / 2],
      ["L", rBeginX + rWidth - tWidth, height / 2],
      ["L", rBeginX - tWidth, height / 2],
      ["Z"]
    ];
  };
  var simple = (width2, height) => {
    return [
      ["M", width2 / 2, -height / 2],
      ["L", -width2 / 2, 0],
      ["L", width2 / 2, 0],
      ["L", -width2 / 2, 0],
      ["L", width2 / 2, height / 2]
    ];
  };

  // node_modules/@antv/g6/esm/elements/edges/base-edge.js
  var __rest11 = function(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  var BaseEdge = class _BaseEdge extends BaseElement {
    constructor(options) {
      super(mergeOptions({ style: _BaseEdge.defaultStyleProps }, options));
      this.type = "edge";
    }
    get sourceNode() {
      const { sourceNode: source } = this.parsedAttributes;
      return this.context.element.getElement(source);
    }
    get targetNode() {
      const { targetNode: target } = this.parsedAttributes;
      return this.context.element.getElement(target);
    }
    getKeyStyle(attributes) {
      const _a2 = this.getGraphicStyle(attributes), { loop } = _a2, style = __rest11(_a2, ["loop"]);
      const { sourceNode, targetNode } = this;
      const d2 = loop && isSameNode(sourceNode, targetNode) ? this.getLoopPath(attributes) : this.getKeyPath(attributes);
      const keyStyle = { d: d2 };
      Path.PARSED_STYLE_LIST.forEach((key) => {
        if (key in style)
          keyStyle[key] = style[key];
      });
      return keyStyle;
    }
    getLoopPath(attributes) {
      const { sourcePort, targetPort } = attributes;
      const node = this.sourceNode;
      const bbox = getNodeBBox(node);
      const defaultDist = Math.max(getBBoxWidth(bbox), getBBoxHeight(bbox));
      const { placement, clockwise, dist = defaultDist } = subStyleProps(this.getGraphicStyle(attributes), "loop");
      return getCubicLoopPath(node, placement, clockwise, dist, sourcePort, targetPort);
    }
    getEndpoints(attributes, optimize = true, controlPoints = []) {
      const { sourcePort: sourcePortKey, targetPort: targetPortKey } = attributes;
      const { sourceNode, targetNode } = this;
      const [sourcePort, targetPort] = findPorts(sourceNode, targetNode, sourcePortKey, targetPortKey);
      if (!optimize) {
        const sourcePoint2 = sourcePort ? getPortPosition(sourcePort) : sourceNode.getCenter();
        const targetPoint2 = targetPort ? getPortPosition(targetPort) : targetNode.getCenter();
        return [sourcePoint2, targetPoint2];
      }
      const _controlPoints = typeof controlPoints === "function" ? controlPoints() : controlPoints;
      const sourcePoint = getConnectionPoint(sourcePort || sourceNode, _controlPoints[0] || targetPort || targetNode);
      const targetPoint = getConnectionPoint(targetPort || targetNode, _controlPoints[_controlPoints.length - 1] || sourcePort || sourceNode);
      return [sourcePoint, targetPoint];
    }
    getHaloStyle(attributes) {
      if (attributes.halo === false)
        return false;
      const keyStyle = this.getKeyStyle(attributes);
      const haloStyle = subStyleProps(this.getGraphicStyle(attributes), "halo");
      return Object.assign(Object.assign({}, keyStyle), haloStyle);
    }
    getLabelStyle(attributes) {
      if (attributes.label === false || !attributes.labelText)
        return false;
      const labelStyle = subStyleProps(this.getGraphicStyle(attributes), "label");
      const { placement, offsetX, offsetY, autoRotate, maxWidth } = labelStyle, restStyle = __rest11(labelStyle, ["placement", "offsetX", "offsetY", "autoRotate", "maxWidth"]);
      const labelPositionStyle = getLabelPositionStyle(this.shapeMap.key, placement, autoRotate, offsetX, offsetY);
      const bbox = this.shapeMap.key.getLocalBounds();
      const wordWrapWidth = getWordWrapWidthByEnds([bbox.min, bbox.max], maxWidth);
      return Object.assign({ wordWrapWidth }, labelPositionStyle, restStyle);
    }
    getBadgeStyle(attributes) {
      if (attributes.badge === false || !attributes.badgeText)
        return false;
      const _a2 = subStyleProps(attributes, "badge"), { offsetX, offsetY, placement } = _a2, badgeStyle = __rest11(_a2, ["offsetX", "offsetY", "placement"]);
      return Object.assign(badgeStyle, getBadgePositionStyle(this.shapeMap, placement, attributes.labelPlacement, offsetX, offsetY));
    }
    drawArrow(attributes, type) {
      var _a2;
      const isStart = type === "start";
      const arrowType = type === "start" ? "startArrow" : "endArrow";
      const enable = attributes[arrowType];
      const keyShape = this.shapeMap.key;
      if (enable) {
        const arrowStyle = this.getArrowStyle(attributes, isStart);
        const [marker, markerOffset, arrowOffset] = isStart ? ["markerStart", "markerStartOffset", "startArrowOffset"] : ["markerEnd", "markerEndOffset", "endArrowOffset"];
        const arrow2 = keyShape.parsedStyle[marker];
        if (arrow2)
          arrow2.attr(arrowStyle);
        else {
          const Ctor = arrowStyle.src ? Image2 : Path;
          const arrowShape = new Ctor({ style: arrowStyle });
          keyShape.style[marker] = arrowShape;
        }
        keyShape.style[markerOffset] = attributes[arrowOffset] || arrowStyle.width / 2 + +arrowStyle.lineWidth;
      } else {
        const marker = isStart ? "markerStart" : "markerEnd";
        (_a2 = keyShape.style[marker]) === null || _a2 === void 0 ? void 0 : _a2.destroy();
        keyShape.style[marker] = null;
      }
    }
    getArrowStyle(attributes, isStart) {
      const keyStyle = this.getShape("key").attributes;
      const arrowType = isStart ? "startArrow" : "endArrow";
      const _a2 = subStyleProps(this.getGraphicStyle(attributes), arrowType), { size: size2, type } = _a2, arrowStyle = __rest11(_a2, ["size", "type"]);
      const [width2, height] = parseSize(getArrowSize(keyStyle.lineWidth, size2));
      const arrowFn = (0, import_util50.isFunction)(type) ? type : symbol_exports[type] || triangle;
      const d2 = arrowFn(width2, height);
      return Object.assign((0, import_util50.pick)(keyStyle, ["stroke", "strokeOpacity", "fillOpacity"]), { width: width2, height }, Object.assign({}, d2 && { d: d2, fill: type === "simple" ? "" : keyStyle.stroke }), arrowStyle);
    }
    drawLabelShape(attributes, container) {
      const style = this.getLabelStyle(attributes);
      this.upsert("label", Label, style, container);
    }
    drawHaloShape(attributes, container) {
      const style = this.getHaloStyle(attributes);
      this.upsert("halo", Path, style, container);
    }
    drawBadgeShape(attributes, container) {
      const style = this.getBadgeStyle(attributes);
      this.upsert("badge", Badge, style, container);
    }
    drawSourceArrow(attributes) {
      this.drawArrow(attributes, "start");
    }
    drawTargetArrow(attributes) {
      this.drawArrow(attributes, "end");
    }
    drawKeyShape(attributes, container) {
      const style = this.getKeyStyle(attributes);
      return this.upsert("key", Path, style, container);
    }
    render(attributes = this.parsedAttributes, container = this) {
      this.drawKeyShape(attributes, container);
      if (!this.getShape("key"))
        return;
      this.drawSourceArrow(attributes);
      this.drawTargetArrow(attributes);
      this.drawLabelShape(attributes, container);
      this.drawHaloShape(attributes, container);
      this.drawBadgeShape(attributes, container);
    }
    onframe() {
      this.drawKeyShape(this.parsedAttributes, this);
      this.drawSourceArrow(this.parsedAttributes);
      this.drawTargetArrow(this.parsedAttributes);
      this.drawHaloShape(this.parsedAttributes, this);
      this.drawLabelShape(this.parsedAttributes, this);
      this.drawBadgeShape(this.parsedAttributes, this);
    }
    animate(keyframes, options) {
      const animation = super.animate(keyframes, options);
      if (!animation)
        return animation;
      return new Proxy(animation, {
        set: (target, propKey, value) => {
          if (propKey === "currentTime")
            Promise.resolve().then(() => this.onframe());
          return Reflect.set(target, propKey, value);
        }
      });
    }
  };
  BaseEdge.defaultStyleProps = {
    badge: true,
    badgeOffsetX: 0,
    badgeOffsetY: 0,
    badgePlacement: "suffix",
    isBillboard: true,
    label: true,
    labelAutoRotate: true,
    labelIsBillboard: true,
    labelMaxWidth: "80%",
    labelOffsetX: 4,
    labelOffsetY: 0,
    labelPlacement: "center",
    labelTextBaseline: "middle",
    labelWordWrap: false,
    halo: false,
    haloDroppable: false,
    haloLineDash: 0,
    haloLineWidth: 12,
    haloPointerEvents: "none",
    haloStrokeOpacity: 0.25,
    haloZIndex: -1,
    loop: true,
    startArrow: false,
    startArrowLineDash: 0,
    startArrowLineJoin: "round",
    startArrowLineWidth: 1,
    startArrowTransformOrigin: "center",
    startArrowType: "vee",
    endArrow: false,
    endArrowLineDash: 0,
    endArrowLineJoin: "round",
    endArrowLineWidth: 1,
    endArrowTransformOrigin: "center",
    endArrowType: "vee",
    loopPlacement: "top",
    loopClockwise: true
  };

  // node_modules/@antv/g6/esm/elements/edges/cubic.js
  var Cubic3 = class _Cubic extends BaseEdge {
    constructor(options) {
      super(mergeOptions({ style: _Cubic.defaultStyleProps }, options));
    }
    /**
     * @inheritdoc
     */
    getKeyPath(attributes) {
      const [sourcePoint, targetPoint] = this.getEndpoints(attributes);
      const { controlPoints, curvePosition, curveOffset } = attributes;
      const actualControlPoints = this.getControlPoints(sourcePoint, targetPoint, parseCurvePosition(curvePosition), parseCurveOffset(curveOffset), controlPoints);
      return getCubicPath(sourcePoint, targetPoint, actualControlPoints);
    }
    getControlPoints(sourcePoint, targetPoint, curvePosition, curveOffset, controlPoints) {
      return (controlPoints === null || controlPoints === void 0 ? void 0 : controlPoints.length) === 2 ? controlPoints : [
        getCurveControlPoint(sourcePoint, targetPoint, curvePosition[0], curveOffset[0]),
        getCurveControlPoint(sourcePoint, targetPoint, curvePosition[1], curveOffset[1])
      ];
    }
  };
  Cubic3.defaultStyleProps = {
    curvePosition: 0.5,
    curveOffset: 20
  };

  // node_modules/@antv/g6/esm/elements/edges/cubic-horizontal.js
  var CubicHorizontal = class _CubicHorizontal extends Cubic3 {
    constructor(options) {
      super(mergeOptions({ style: _CubicHorizontal.defaultStyleProps }, options));
    }
    getControlPoints(sourcePoint, targetPoint, curvePosition, curveOffset) {
      const xDist = targetPoint[0] - sourcePoint[0];
      return [
        [sourcePoint[0] + xDist * curvePosition[0] + curveOffset[0], sourcePoint[1]],
        [targetPoint[0] - xDist * curvePosition[1] + curveOffset[1], targetPoint[1]]
      ];
    }
  };
  CubicHorizontal.defaultStyleProps = {
    curvePosition: [0.5, 0.5],
    curveOffset: [0, 0]
  };

  // node_modules/@antv/g6/esm/elements/edges/cubic-radial.js
  var CubicRadial = class _CubicRadial extends Cubic3 {
    constructor(options) {
      super(mergeOptions({ style: _CubicRadial.defaultStyleProps }, options));
    }
    get ref() {
      return this.context.model.getRootsData()[0];
    }
    getEndpoints(attributes) {
      if (this.sourceNode.id === this.ref.id) {
        return super.getEndpoints(attributes);
      }
      const refPoint = positionOf(this.ref);
      const sourcePoint = this.sourceNode.getIntersectPoint(refPoint, true);
      const targetPoint = this.targetNode.getIntersectPoint(refPoint);
      return [sourcePoint, targetPoint];
    }
    toRadialCoordinate(p) {
      const refPoint = positionOf(this.ref);
      const r = distance2(p, refPoint);
      const radian = rad(subtract(p, refPoint));
      return [r, radian];
    }
    getControlPoints(sourcePoint, targetPoint, curvePosition, curveOffset) {
      const [r1, rad1] = this.toRadialCoordinate(sourcePoint);
      const [r2] = this.toRadialCoordinate(targetPoint);
      const rDist = r2 - r1;
      return [
        [
          sourcePoint[0] + (rDist * curvePosition[0] + curveOffset[0]) * Math.cos(rad1),
          sourcePoint[1] + (rDist * curvePosition[0] + curveOffset[0]) * Math.sin(rad1)
        ],
        [
          targetPoint[0] - (rDist * curvePosition[1] - curveOffset[0]) * Math.cos(rad1),
          targetPoint[1] - (rDist * curvePosition[1] - curveOffset[0]) * Math.sin(rad1)
        ]
      ];
    }
  };
  CubicRadial.defaultStyleProps = {
    curvePosition: 0.5,
    curveOffset: 20
  };

  // node_modules/@antv/g6/esm/elements/edges/cubic-vertical.js
  var CubicVertical = class _CubicVertical extends Cubic3 {
    constructor(options) {
      super(mergeOptions({ style: _CubicVertical.defaultStyleProps }, options));
    }
    getControlPoints(sourcePoint, targetPoint, curvePosition, curveOffset) {
      const yDist = targetPoint[1] - sourcePoint[1];
      return [
        [sourcePoint[0], sourcePoint[1] + yDist * curvePosition[0] + curveOffset[0]],
        [targetPoint[0], targetPoint[1] - yDist * curvePosition[1] + curveOffset[1]]
      ];
    }
  };
  CubicVertical.defaultStyleProps = {
    curvePosition: [0.5, 0.5],
    curveOffset: [0, 0]
  };

  // node_modules/@antv/g6/esm/elements/edges/line.js
  var Line2 = class _Line extends BaseEdge {
    constructor(options) {
      super(mergeOptions({ style: _Line.defaultStyleProps }, options));
    }
    getKeyPath(attributes) {
      const [sourcePoint, targetPoint] = this.getEndpoints(attributes);
      return [
        ["M", sourcePoint[0], sourcePoint[1]],
        ["L", targetPoint[0], targetPoint[1]]
      ];
    }
  };
  Line2.defaultStyleProps = {};

  // node_modules/@antv/g6/esm/utils/router/shortest-path.js
  var import_util51 = __toESM(require_lib());
  var defaultCfg = {
    enableObstacleAvoidance: false,
    offset: 10,
    maxAllowedDirectionChange: Math.PI / 2,
    maximumLoops: 3e3,
    gridSize: 5,
    startDirections: ["top", "right", "bottom", "left"],
    endDirections: ["top", "right", "bottom", "left"],
    directionMap: {
      right: { stepX: 1, stepY: 0 },
      left: { stepX: -1, stepY: 0 },
      bottom: { stepX: 0, stepY: 1 },
      top: { stepX: 0, stepY: -1 }
    },
    penalties: { 0: 0, 90: 0 },
    distFunc: manhattanDistance
  };
  var keyOf = (point4) => `${Math.round(point4[0])}|||${Math.round(point4[1])}`;
  function alignToGrid(p, gridSize) {
    const align = (value) => Math.round(value / gridSize);
    if ((0, import_util51.isNumber)(p))
      return align(p);
    return p.map(align);
  }
  function getAngleDiff(angle1, angle2) {
    const directionChange = Math.abs(angle1 - angle2);
    return directionChange > Math.PI ? 2 * Math.PI - directionChange : directionChange;
  }
  function getDirectionAngle(p1, p2) {
    const deltaX = p2[0] - p1[0];
    const deltaY = p2[1] - p1[1];
    if (!deltaX && !deltaY)
      return 0;
    return Math.atan2(deltaY, deltaX);
  }
  function getDirectionChange(current2, neighbor, cameFrom, scaleStartPoint) {
    const directionAngle = getDirectionAngle(current2, neighbor);
    const currentCameFrom = cameFrom[keyOf(current2)];
    const prev = !currentCameFrom ? scaleStartPoint : currentCameFrom;
    const prevDirectionAngle = getDirectionAngle(prev, current2);
    return getAngleDiff(prevDirectionAngle, directionAngle);
  }
  var getObstacleMap = (nodes, options) => {
    const { offset, gridSize } = options;
    const obstacleMap = {};
    nodes.forEach((item) => {
      if (!item || item.destroyed || !item.isVisible())
        return;
      const bbox = getExpandedBBox(item.getRenderBounds(), offset);
      for (let x3 = alignToGrid(bbox.min[0], gridSize); x3 <= alignToGrid(bbox.max[0], gridSize); x3 += 1) {
        for (let y3 = alignToGrid(bbox.min[1], gridSize); y3 <= alignToGrid(bbox.max[1], gridSize); y3 += 1) {
          obstacleMap[`${x3}|||${y3}`] = true;
        }
      }
    });
    return obstacleMap;
  };
  function estimateCost(from, anchors, distFunc) {
    return Math.min(...anchors.map((anchor) => distFunc(from, anchor)));
  }
  function getNearestPoint(points, refPoint, distFunc) {
    let nearestPoint2 = points[0];
    let minDistance = distFunc(points[0], refPoint);
    for (let i = 0; i < points.length; i++) {
      const point4 = points[i];
      const dis = distFunc(point4, refPoint);
      if (dis < minDistance) {
        nearestPoint2 = point4;
        minDistance = dis;
      }
    }
    return nearestPoint2;
  }
  var getBoxPoints = (point4, node, directions2, options) => {
    if (!node)
      return [point4];
    const { directionMap, offset } = options;
    const expandedBBox = getExpandedBBox(node.getRenderBounds(), offset);
    const points = Object.keys(directionMap).reduce((res, directionKey) => {
      if (directions2.includes(directionKey)) {
        const direction2 = directionMap[directionKey];
        const [width2, height] = getBBoxSize(expandedBBox);
        const otherPoint = [point4[0] + direction2.stepX * width2, point4[1] + direction2.stepY * height];
        const segments = getBBoxSegments(expandedBBox);
        for (let i = 0; i < segments.length; i++) {
          const intersectP = getLinesIntersection([point4, otherPoint], segments[i]);
          if (intersectP && isPointOnBBoxBoundary(intersectP, expandedBBox)) {
            res.push(intersectP);
          }
        }
      }
      return res;
    }, []);
    if (!isPointInBBox(point4, expandedBBox)) {
      points.push(point4);
    }
    return points.map((point5) => alignToGrid(point5, options.gridSize));
  };
  var getControlPoints = (current2, cameFrom, scaleStartPoint, endPoint, startPoints, scaleEndPoint, gridSize) => {
    const controlPoints = [];
    let pointZero = [
      scaleEndPoint[0] === endPoint[0] ? endPoint[0] : current2[0] * gridSize,
      scaleEndPoint[1] === endPoint[1] ? endPoint[1] : current2[1] * gridSize
    ];
    controlPoints.unshift(pointZero);
    let _current = current2;
    let _currentCameFrom = cameFrom[keyOf(_current)];
    while (_currentCameFrom) {
      const prePoint = _currentCameFrom;
      const point4 = _current;
      const directionChange = getDirectionChange(prePoint, point4, cameFrom, scaleStartPoint);
      if (directionChange) {
        pointZero = [
          prePoint[0] === point4[0] ? pointZero[0] : prePoint[0] * gridSize,
          prePoint[1] === point4[1] ? pointZero[1] : prePoint[1] * gridSize
        ];
        controlPoints.unshift(pointZero);
      }
      _currentCameFrom = cameFrom[keyOf(prePoint)];
      _current = prePoint;
    }
    const realStartPoints = startPoints.map((point4) => [point4[0] * gridSize, point4[1] * gridSize]);
    const startPoint = getNearestPoint(realStartPoints, pointZero, manhattanDistance);
    controlPoints.unshift(startPoint);
    return controlPoints;
  };
  function aStarSearch(sourceNode, targetNode, nodes, config) {
    const startPoint = toVector2(sourceNode.getCenter());
    const endPoint = toVector2(targetNode.getCenter());
    const options = Object.assign(defaultCfg, config);
    const { gridSize } = options;
    const obstacles = options.enableObstacleAvoidance ? nodes : [sourceNode, targetNode];
    const obstacleMap = getObstacleMap(obstacles, options);
    const scaleStartPoint = alignToGrid(startPoint, gridSize);
    const scaleEndPoint = alignToGrid(endPoint, gridSize);
    const startPoints = getBoxPoints(startPoint, sourceNode, options.startDirections, options);
    const endPoints = getBoxPoints(endPoint, targetNode, options.endDirections, options);
    startPoints.forEach((point4) => delete obstacleMap[keyOf(point4)]);
    endPoints.forEach((point4) => delete obstacleMap[keyOf(point4)]);
    const openList = {};
    const closedList = {};
    const cameFrom = {};
    const gScore = {};
    const fScore = {};
    const sortedOpenSet = new SortedArray();
    for (let i = 0; i < startPoints.length; i++) {
      const firstStep = startPoints[i];
      const key = keyOf(firstStep);
      openList[key] = firstStep;
      gScore[key] = 0;
      fScore[key] = estimateCost(firstStep, endPoints, options.distFunc);
      sortedOpenSet.add({
        id: key,
        value: fScore[key]
      });
    }
    const endPointsKeys = endPoints.map((point4) => keyOf(point4));
    let remainLoops = options.maximumLoops;
    let current2;
    let curCost = Infinity;
    for (const [id3, value] of Object.entries(openList)) {
      if (fScore[id3] <= curCost) {
        curCost = fScore[id3];
        current2 = value;
      }
    }
    while (Object.keys(openList).length > 0 && remainLoops > 0) {
      const minId = sortedOpenSet.minId(false);
      if (minId) {
        current2 = openList[minId];
      } else {
        break;
      }
      const key = keyOf(current2);
      if (endPointsKeys.includes(key)) {
        return getControlPoints(current2, cameFrom, scaleStartPoint, endPoint, startPoints, scaleEndPoint, gridSize);
      }
      delete openList[key];
      sortedOpenSet.remove(key);
      closedList[key] = true;
      for (const dir of Object.values(options.directionMap)) {
        const neighbor = add(current2, [dir.stepX, dir.stepY]);
        const neighborId = keyOf(neighbor);
        if (closedList[neighborId])
          continue;
        const directionChange = getDirectionChange(current2, neighbor, cameFrom, scaleStartPoint);
        if (directionChange > options.maxAllowedDirectionChange)
          continue;
        if (obstacleMap[neighborId])
          continue;
        if (!openList[neighborId]) {
          openList[neighborId] = neighbor;
        }
        const directionPenalties = options.penalties[directionChange];
        const neighborCost = options.distFunc(current2, neighbor) + (isNaN(directionPenalties) ? gridSize : directionPenalties);
        const costFromStart = gScore[key] + neighborCost;
        const neighborGScore = gScore[neighborId];
        if (neighborGScore && costFromStart >= neighborGScore)
          continue;
        cameFrom[neighborId] = current2;
        gScore[neighborId] = costFromStart;
        fScore[neighborId] = costFromStart + estimateCost(neighbor, endPoints, options.distFunc);
        sortedOpenSet.add({
          id: neighborId,
          value: fScore[neighborId]
        });
      }
      remainLoops -= 1;
    }
    return [];
  }
  var SortedArray = class {
    constructor() {
      this.arr = [];
      this.map = {};
      this.arr = [];
      this.map = {};
    }
    _innerAdd(item, length) {
      let low = 0, high = length - 1;
      while (high - low > 1) {
        const mid = Math.floor((low + high) / 2);
        if (this.arr[mid].value > item.value) {
          high = mid;
        } else if (this.arr[mid].value < item.value) {
          low = mid;
        } else {
          this.arr.splice(mid, 0, item);
          this.map[item.id] = true;
          return;
        }
      }
      this.arr.splice(high, 0, item);
      this.map[item.id] = true;
    }
    /**
     * <zh/> 将新项添加到适当的索引位置
     *
     * <en/> Add the new item to the appropriate index
     * @param item - <zh/> 新项 | <en/> new item
     */
    add(item) {
      delete this.map[item.id];
      const length = this.arr.length;
      if (!length || this.arr[length - 1].value < item.value) {
        this.arr.push(item);
        this.map[item.id] = true;
        return;
      }
      this._innerAdd(item, length);
    }
    remove(id3) {
      if (!this.map[id3])
        return;
      delete this.map[id3];
    }
    _clearAndGetMinId() {
      let res;
      for (let i = this.arr.length - 1; i >= 0; i--) {
        if (this.map[this.arr[i].id])
          res = this.arr[i].id;
        else
          this.arr.splice(i, 1);
      }
      return res;
    }
    _findFirstId() {
      while (this.arr.length) {
        const first = this.arr.shift();
        if (this.map[first.id])
          return first.id;
      }
    }
    minId(clear) {
      if (clear) {
        return this._clearAndGetMinId();
      } else {
        return this._findFirstId();
      }
    }
  };

  // node_modules/@antv/g6/esm/elements/edges/polyline.js
  var Polyline2 = class _Polyline extends BaseEdge {
    constructor(options) {
      super(mergeOptions({ style: _Polyline.defaultStyleProps }, options));
    }
    getControlPoints(attributes) {
      const { router } = attributes;
      const { sourceNode, targetNode } = this;
      const [sourcePoint, targetPoint] = this.getEndpoints(attributes, false);
      let controlPoints = [];
      if (!router) {
        controlPoints = attributes.controlPoints;
      } else {
        if (router.type === "shortest-path") {
          const nodes = this.context.element.getNodes();
          controlPoints = aStarSearch(sourceNode, targetNode, nodes, router);
          if (!controlPoints.length) {
            controlPoints = orth(sourcePoint, targetPoint, sourceNode, targetNode, attributes.controlPoints, {
              padding: router.offset
            });
          }
        } else if (router.type === "orth") {
          controlPoints = orth(sourcePoint, targetPoint, sourceNode, targetNode, attributes.controlPoints, router);
        }
      }
      return controlPoints;
    }
    getPoints(attributes) {
      const controlPoints = this.getControlPoints(attributes);
      const [newSourcePoint, newTargetPoint] = this.getEndpoints(attributes, true, controlPoints);
      return [newSourcePoint, ...controlPoints, newTargetPoint];
    }
    getKeyPath(attributes) {
      const points = this.getPoints(attributes);
      return getPolylinePath(points, attributes.radius);
    }
    getLoopPath(attributes) {
      const { sourcePort: sourcePortKey, targetPort: targetPortKey, radius } = attributes;
      const node = this.sourceNode;
      const bbox = getNodeBBox(node);
      const defaultDist = Math.max(getBBoxWidth(bbox), getBBoxHeight(bbox)) / 4;
      const { placement, clockwise, dist = defaultDist } = subStyleProps(this.getGraphicStyle(attributes), "loop");
      return getPolylineLoopPath(node, radius, placement, clockwise, dist, sourcePortKey, targetPortKey);
    }
  };
  Polyline2.defaultStyleProps = {
    radius: 0,
    controlPoints: [],
    router: false
  };

  // node_modules/@antv/g6/esm/elements/edges/quadratic.js
  var Quadratic = class _Quadratic extends BaseEdge {
    constructor(options) {
      super(mergeOptions({ style: _Quadratic.defaultStyleProps }, options));
    }
    getKeyPath(attributes) {
      const { curvePosition, curveOffset } = attributes;
      const [sourcePoint, targetPoint] = this.getEndpoints(attributes);
      const controlPoint = attributes.controlPoint || getCurveControlPoint(sourcePoint, targetPoint, curvePosition, curveOffset);
      return getQuadraticPath(sourcePoint, targetPoint, controlPoint);
    }
  };
  Quadratic.defaultStyleProps = {
    curvePosition: 0.5,
    curveOffset: 30
  };

  // node_modules/@antv/g6/esm/utils/element.js
  var __rest12 = function(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  function isNode(shape) {
    return shape instanceof BaseNode && shape.type === "node";
  }
  function isEdge(shape) {
    return shape instanceof BaseEdge;
  }
  function isCombo(shape) {
    return shape instanceof BaseCombo;
  }
  function isElement2(shape) {
    return isNode(shape) || isEdge(shape) || isCombo(shape);
  }
  function isSameNode(node1, node2) {
    if (!node1 || !node2)
      return false;
    return node1 === node2;
  }
  var PORT_MAP = {
    top: [0.5, 0],
    right: [1, 0.5],
    bottom: [0.5, 1],
    left: [0, 0.5],
    "left-top": [0, 0],
    "top-left": [0, 0],
    "left-bottom": [0, 1],
    "bottom-left": [0, 1],
    "right-top": [1, 0],
    "top-right": [1, 0],
    "right-bottom": [1, 1],
    "bottom-right": [1, 1],
    default: [0.5, 0.5]
  };
  function getPortXYByPlacement(bbox, placement, portMap = PORT_MAP, isRelative = true) {
    const DEFAULT = [0.5, 0.5];
    const p = (0, import_util52.isString)(placement) ? (0, import_util52.get)(portMap, placement.toLocaleLowerCase(), DEFAULT) : placement;
    if (!isRelative && (0, import_util52.isString)(placement))
      return p;
    const [x3, y3] = p || DEFAULT;
    return [bbox.min[0] + getBBoxWidth(bbox) * x3, bbox.min[1] + getBBoxHeight(bbox) * y3];
  }
  function getAllPorts(node) {
    if (!node)
      return {};
    const ports = node.getPorts();
    const portsStyle = node.attributes.ports || [];
    portsStyle.forEach((portStyle, i) => {
      var _a2;
      const { key, placement } = portStyle;
      if (isSimplePort(portStyle)) {
        ports[_a2 = key || i] || (ports[_a2] = getXYByPlacement(node.getShape("key").getBounds(), placement));
      }
    });
    return ports;
  }
  function isSimplePort(portStyle) {
    const { r } = portStyle;
    return !r || Number(r) === 0;
  }
  function getPortPosition(port) {
    return isPoint(port) ? port : port.getPosition();
  }
  function findPorts(sourceNode, targetNode, sourcePortKey, targetPortKey) {
    const sourcePort = findPort(sourceNode, targetNode, sourcePortKey, targetPortKey);
    const targetPort = findPort(targetNode, sourceNode, targetPortKey, sourcePortKey);
    return [sourcePort, targetPort];
  }
  function findPort(node, oppositeNode, portKey, oppositePortKey) {
    const portsMap = getAllPorts(node);
    if (portKey)
      return portsMap[portKey];
    const ports = Object.values(portsMap);
    if (ports.length === 0)
      return void 0;
    const positions = ports.map((port) => getPortPosition(port));
    const oppositePositions = findConnectionPoints(oppositeNode, oppositePortKey);
    const [nearestPosition] = findNearestPoints(positions, oppositePositions);
    return ports.find((port) => getPortPosition(port) === nearestPosition);
  }
  function findConnectionPoints(node, portKey) {
    const allPortsMap = getAllPorts(node);
    if (portKey)
      return [getPortPosition(allPortsMap[portKey])];
    const oppositePorts = Object.values(allPortsMap);
    return oppositePorts.length > 0 ? oppositePorts.map((port) => getPortPosition(port)) : [node.getCenter()];
  }
  function getConnectionPoint(node, opposite) {
    return isCombo(node) || isNode(node) ? getNodeConnectionPoint(node, opposite) : getPortConnectionPoint(node, opposite);
  }
  function getPortConnectionPoint(port, opposite) {
    if (!port || !opposite)
      return [0, 0, 0];
    if (isPoint(port))
      return port;
    if (port.attributes.linkToCenter)
      return port.getPosition();
    const oppositePosition = isPoint(opposite) ? opposite : isNode(opposite) ? opposite.getCenter() : opposite.getPosition();
    return getEllipseIntersectPoint(oppositePosition, port.getBounds());
  }
  function getNodeConnectionPoint(nodeLike, opposite) {
    if (!nodeLike || !opposite)
      return [0, 0, 0];
    const oppositePosition = isPoint(opposite) ? opposite : isNode(opposite) ? opposite.getCenter() : opposite.getPosition();
    return nodeLike.getIntersectPoint(oppositePosition) || nodeLike.getCenter();
  }
  function getTextStyleByPlacement(bbox, placement = "bottom", offsetX = 0, offsetY = 0, isReverseBaseline = false) {
    const direction2 = placement.split("-");
    const [x3, y3] = getXYByPlacement(bbox, placement);
    const [top, bottom] = isReverseBaseline ? ["bottom", "top"] : ["top", "bottom"];
    const textBaseline = direction2.includes("top") ? bottom : direction2.includes("bottom") ? top : "middle";
    const textAlign = direction2.includes("left") ? "right" : direction2.includes("right") ? "left" : "center";
    return {
      transform: [["translate", x3 + offsetX, y3 + offsetY]],
      textBaseline,
      textAlign
    };
  }
  function getStarPoints(outerR, innerR) {
    return [
      [0, -outerR],
      [innerR * Math.cos(3 * Math.PI / 10), -innerR * Math.sin(3 * Math.PI / 10)],
      [outerR * Math.cos(Math.PI / 10), -outerR * Math.sin(Math.PI / 10)],
      [innerR * Math.cos(Math.PI / 10), innerR * Math.sin(Math.PI / 10)],
      [outerR * Math.cos(3 * Math.PI / 10), outerR * Math.sin(3 * Math.PI / 10)],
      [0, innerR],
      [-outerR * Math.cos(3 * Math.PI / 10), outerR * Math.sin(3 * Math.PI / 10)],
      [-innerR * Math.cos(Math.PI / 10), innerR * Math.sin(Math.PI / 10)],
      [-outerR * Math.cos(Math.PI / 10), -outerR * Math.sin(Math.PI / 10)],
      [-innerR * Math.cos(3 * Math.PI / 10), -innerR * Math.sin(3 * Math.PI / 10)]
    ];
  }
  function getStarPorts(outerR, innerR) {
    const r = {};
    r["top"] = [0, -outerR];
    r["left"] = [-outerR * Math.cos(Math.PI / 10), -outerR * Math.sin(Math.PI / 10)];
    r["left-bottom"] = [-outerR * Math.cos(3 * Math.PI / 10), outerR * Math.sin(3 * Math.PI / 10)];
    r["bottom"] = [0, innerR];
    r["right-bottom"] = [outerR * Math.cos(3 * Math.PI / 10), outerR * Math.sin(3 * Math.PI / 10)];
    r["right"] = r["default"] = [outerR * Math.cos(Math.PI / 10), -outerR * Math.sin(Math.PI / 10)];
    return r;
  }
  function getTrianglePoints(width2, height, direction2) {
    const halfHeight = height / 2;
    const halfWidth = width2 / 2;
    const MAP = {
      up: [
        [-halfWidth, halfHeight],
        [halfWidth, halfHeight],
        [0, -halfHeight]
      ],
      left: [
        [-halfWidth, 0],
        [halfWidth, halfHeight],
        [halfWidth, -halfHeight]
      ],
      right: [
        [-halfWidth, halfHeight],
        [-halfWidth, -halfHeight],
        [halfWidth, 0]
      ],
      down: [
        [-halfWidth, -halfHeight],
        [halfWidth, -halfHeight],
        [0, halfHeight]
      ]
    };
    return MAP[direction2] || MAP["up"];
  }
  function getTrianglePorts(width2, height, direction2) {
    const halfHeight = height / 2;
    const halfWidth = width2 / 2;
    const ports = {};
    if (direction2 === "down") {
      ports["bottom"] = ports["default"] = [0, halfHeight];
      ports["right"] = [halfWidth, -halfHeight];
      ports["left"] = [-halfWidth, -halfHeight];
    } else if (direction2 === "left") {
      ports["top"] = [halfWidth, -halfHeight];
      ports["bottom"] = [halfWidth, halfHeight];
      ports["left"] = ports["default"] = [-halfWidth, 0];
    } else if (direction2 === "right") {
      ports["top"] = [-halfWidth, -halfHeight];
      ports["bottom"] = [-halfWidth, halfHeight];
      ports["right"] = ports["default"] = [halfWidth, 0];
    } else {
      ports["left"] = [-halfWidth, halfHeight];
      ports["top"] = ports["default"] = [0, -halfHeight];
      ports["right"] = [halfWidth, halfHeight];
    }
    return ports;
  }
  function getDiamondPoints(width2, height) {
    return [
      [0, -height / 2],
      [width2 / 2, 0],
      [0, height / 2],
      [-width2 / 2, 0]
    ];
  }
  function isVisible(element) {
    return (0, import_util52.get)(element, ["style", "visibility"]) !== "hidden";
  }
  function setAttributes(element, style) {
    const { zIndex, transform, transformOrigin, visibility: visibility2, cursor, clipPath, component } = style, rest = __rest12(style, ["zIndex", "transform", "transformOrigin", "visibility", "cursor", "clipPath", "component"]);
    Object.assign(element.attributes, rest);
    if (transform)
      element.setAttribute("transform", transform);
    if ((0, import_util52.isNumber)(zIndex))
      element.setAttribute("zIndex", zIndex);
    if (transformOrigin)
      element.setAttribute("transformOrigin", transformOrigin);
    if (visibility2)
      element.setAttribute("visibility", visibility2);
    if (cursor)
      element.setAttribute("cursor", cursor);
    if (clipPath)
      element.setAttribute("clipPath", clipPath);
    if (component)
      element.setAttribute("component", component);
  }
  function updateStyle(shape, style) {
    if ("update" in shape)
      shape.update(style);
    else
      shape.attr(style);
  }
  function getHexagonPoints(outerR) {
    return [
      [0, outerR],
      [outerR * Math.sqrt(3) / 2, outerR / 2],
      [outerR * Math.sqrt(3) / 2, -outerR / 2],
      [0, -outerR],
      [-outerR * Math.sqrt(3) / 2, -outerR / 2],
      [-outerR * Math.sqrt(3) / 2, outerR / 2]
    ];
  }
  function markToBeDestroyed(element) {
    (0, import_util52.set)(element, "__to_be_destroyed__", true);
  }
  function isToBeDestroyed(element) {
    return (0, import_util52.get)(element, "__to_be_destroyed__", false);
  }

  // node_modules/@antv/g6/esm/behaviors/collapse-expand.js
  var __awaiter3 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var CollapseExpand = class _CollapseExpand extends BaseBehavior {
    constructor(context, options) {
      super(context, Object.assign({}, _CollapseExpand.defaultOptions, options));
      this.onCollapseExpand = (event) => __awaiter3(this, void 0, void 0, function* () {
        if (!this.validate(event))
          return;
        const { target } = event;
        if (!isElement2(target))
          return;
        const id3 = target.id;
        const { model, graph } = this.context;
        const data2 = model.getElementDataById(id3);
        if (!data2)
          return false;
        const { onCollapse, onExpand, animation, align } = this.options;
        if (isCollapsed(data2)) {
          yield graph.expandElement(id3, { animation, align });
          onExpand === null || onExpand === void 0 ? void 0 : onExpand(id3);
        } else {
          yield graph.collapseElement(id3, { animation, align });
          onCollapse === null || onCollapse === void 0 ? void 0 : onCollapse(id3);
        }
      });
      this.bindEvents();
    }
    update(options) {
      this.unbindEvents();
      super.update(options);
      this.bindEvents();
    }
    bindEvents() {
      const { graph } = this.context;
      const { trigger } = this.options;
      graph.on(`node:${trigger}`, this.onCollapseExpand);
      graph.on(`combo:${trigger}`, this.onCollapseExpand);
    }
    unbindEvents() {
      const { graph } = this.context;
      const { trigger } = this.options;
      graph.off(`node:${trigger}`, this.onCollapseExpand);
      graph.off(`combo:${trigger}`, this.onCollapseExpand);
    }
    validate(event) {
      if (this.destroyed)
        return false;
      const { enable } = this.options;
      if ((0, import_util53.isFunction)(enable))
        return enable(event);
      return !!enable;
    }
    destroy() {
      this.unbindEvents();
      super.destroy();
    }
  };
  CollapseExpand.defaultOptions = {
    enable: true,
    animation: true,
    trigger: CommonEvent.DBLCLICK,
    align: true
  };

  // node_modules/@antv/g6/esm/behaviors/create-edge.js
  var import_util54 = __toESM(require_lib());
  var __awaiter4 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var ASSIST_EDGE_ID = "g6-create-edge-assist-edge-id";
  var ASSIST_NODE_ID = "g6-create-edge-assist-node-id";
  var CreateEdge = class _CreateEdge extends BaseBehavior {
    constructor(context, options) {
      super(context, Object.assign({}, _CreateEdge.defaultOptions, options));
      this.drop = (event) => __awaiter4(this, void 0, void 0, function* () {
        const { targetType } = event;
        if (["combo", "node"].includes(targetType) && this.source) {
          yield this.handleCreateEdge(event);
        } else {
          yield this.cancelEdge();
        }
      });
      this.handleCreateEdge = (event) => __awaiter4(this, void 0, void 0, function* () {
        var _a2, _b, _c;
        if (!this.validate(event))
          return;
        const { graph, canvas: canvas2, batch, element } = this.context;
        const { style } = this.options;
        if (this.source) {
          this.createEdge(event);
          yield this.cancelEdge();
          return;
        }
        batch.startBatch();
        canvas2.setCursor("crosshair");
        this.source = this.getSelectedNodeIDs([event.target.id])[0];
        const sourceNode = graph.getElementData(this.source);
        graph.addNodeData([
          {
            id: ASSIST_NODE_ID,
            style: {
              visibility: "hidden",
              ports: [{ key: "port-1", placement: [0.5, 0.5] }],
              x: (_a2 = sourceNode.style) === null || _a2 === void 0 ? void 0 : _a2.x,
              y: (_b = sourceNode.style) === null || _b === void 0 ? void 0 : _b.y
            }
          }
        ]);
        graph.addEdgeData([
          {
            id: ASSIST_EDGE_ID,
            source: this.source,
            target: ASSIST_NODE_ID,
            style: Object.assign({ pointerEvents: "none" }, style)
          }
        ]);
        yield (_c = element.draw({ animation: false })) === null || _c === void 0 ? void 0 : _c.finished;
      });
      this.updateAssistEdge = (event) => __awaiter4(this, void 0, void 0, function* () {
        var _a2;
        if (!this.source)
          return;
        const { model, element } = this.context;
        model.translateNodeTo(ASSIST_NODE_ID, [event.canvas.x, event.canvas.y]);
        yield (_a2 = element.draw({ animation: false, silence: true })) === null || _a2 === void 0 ? void 0 : _a2.finished;
      });
      this.createEdge = (event) => {
        var _a2, _b;
        const { graph } = this.context;
        const { style, onFinish, onCreate } = this.options;
        const targetId = (_a2 = event.target) === null || _a2 === void 0 ? void 0 : _a2.id;
        if (targetId === void 0 || this.source === void 0)
          return;
        const target = (_b = this.getSelectedNodeIDs([event.target.id])) === null || _b === void 0 ? void 0 : _b[0];
        const id3 = `${this.source}-${target}-${(0, import_util54.uniqueId)()}`;
        const edgeData = onCreate({ id: id3, source: this.source, target, style });
        if (edgeData) {
          graph.addEdgeData([edgeData]);
          onFinish(edgeData);
        }
      };
      this.cancelEdge = () => __awaiter4(this, void 0, void 0, function* () {
        var _a2;
        if (!this.source)
          return;
        const { graph, element, batch } = this.context;
        graph.removeNodeData([ASSIST_NODE_ID]);
        this.source = void 0;
        yield (_a2 = element.draw({ animation: false })) === null || _a2 === void 0 ? void 0 : _a2.finished;
        batch.endBatch();
      });
      this.bindEvents();
    }
    /**
     * Update options
     * @param options - The options to update
     * @internal
     */
    update(options) {
      super.update(options);
      this.bindEvents();
    }
    bindEvents() {
      const { graph } = this.context;
      const { trigger } = this.options;
      this.unbindEvents();
      if (trigger === "click") {
        graph.on(NodeEvent.CLICK, this.handleCreateEdge);
        graph.on(ComboEvent.CLICK, this.handleCreateEdge);
        graph.on(CanvasEvent2.CLICK, this.cancelEdge);
        graph.on(EdgeEvent.CLICK, this.cancelEdge);
      } else {
        graph.on(NodeEvent.DRAG_START, this.handleCreateEdge);
        graph.on(ComboEvent.DRAG_START, this.handleCreateEdge);
        graph.on(CommonEvent.POINTER_UP, this.drop);
      }
      graph.on(CommonEvent.POINTER_MOVE, this.updateAssistEdge);
    }
    getSelectedNodeIDs(currTarget) {
      return Array.from(new Set(this.context.graph.getElementDataByState("node", this.options.state).map((node) => node.id).concat(currTarget)));
    }
    validate(event) {
      if (this.destroyed)
        return false;
      const { enable } = this.options;
      if ((0, import_util54.isFunction)(enable))
        return enable(event);
      return !!enable;
    }
    unbindEvents() {
      const { graph } = this.context;
      graph.off(NodeEvent.CLICK, this.handleCreateEdge);
      graph.off(ComboEvent.CLICK, this.handleCreateEdge);
      graph.off(CanvasEvent2.CLICK, this.cancelEdge);
      graph.off(EdgeEvent.CLICK, this.cancelEdge);
      graph.off(NodeEvent.DRAG_START, this.handleCreateEdge);
      graph.off(ComboEvent.DRAG_START, this.handleCreateEdge);
      graph.off(CommonEvent.POINTER_UP, this.drop);
      graph.off(CommonEvent.POINTER_MOVE, this.updateAssistEdge);
    }
    destroy() {
      this.unbindEvents();
      super.destroy();
    }
  };
  CreateEdge.defaultOptions = {
    animation: true,
    enable: true,
    style: {},
    trigger: "drag",
    onCreate: (data2) => data2,
    onFinish: () => {
    }
  };

  // node_modules/@antv/g6/esm/behaviors/drag-canvas.js
  var import_util55 = __toESM(require_lib());
  var __awaiter5 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var DragCanvas = class _DragCanvas extends BaseBehavior {
    constructor(context, options) {
      super(context, Object.assign({}, _DragCanvas.defaultOptions, options));
      this.isDragging = false;
      this.onDragStart = (event) => {
        if (!this.validate(event))
          return;
        this.isDragging = true;
        this.context.canvas.setCursor("grabbing");
      };
      this.onDrag = (event) => {
        var _a2, _b, _c, _d;
        if (!this.isDragging || PinchHandler.isPinching)
          return;
        const x3 = (_b = (_a2 = event.movement) === null || _a2 === void 0 ? void 0 : _a2.x) !== null && _b !== void 0 ? _b : event.dx;
        const y3 = (_d = (_c = event.movement) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : event.dy;
        if ((x3 | y3) !== 0) {
          this.translate([x3, y3], false);
        }
      };
      this.onDragEnd = () => {
        var _a2, _b;
        this.isDragging = false;
        this.context.canvas.setCursor(this.defaultCursor);
        (_b = (_a2 = this.options).onFinish) === null || _b === void 0 ? void 0 : _b.call(_a2);
      };
      this.invokeOnFinish = (0, import_util55.debounce)(() => {
        var _a2, _b;
        (_b = (_a2 = this.options).onFinish) === null || _b === void 0 ? void 0 : _b.call(_a2);
      }, 300);
      this.shortcut = new Shortcut(context.graph);
      this.bindEvents();
      this.defaultCursor = this.context.canvas.getConfig().cursor || "default";
    }
    /**
     * <zh/> 更新配置
     *
     * <en/> Update options
     * @param options - <zh/> 配置项 | <en/> Options
     * @internal
     */
    update(options) {
      this.unbindEvents();
      super.update(options);
      this.bindEvents();
    }
    bindEvents() {
      const { trigger } = this.options;
      if ((0, import_util55.isObject)(trigger)) {
        const { up = [], down = [], left = [], right = [] } = trigger;
        this.shortcut.bind(up, (event) => this.onTranslate([0, 1], event));
        this.shortcut.bind(down, (event) => this.onTranslate([0, -1], event));
        this.shortcut.bind(left, (event) => this.onTranslate([1, 0], event));
        this.shortcut.bind(right, (event) => this.onTranslate([-1, 0], event));
      } else {
        const { graph } = this.context;
        graph.on(CommonEvent.DRAG_START, this.onDragStart);
        graph.on(CommonEvent.DRAG, this.onDrag);
        graph.on(CommonEvent.DRAG_END, this.onDragEnd);
      }
    }
    onTranslate(value, event) {
      return __awaiter5(this, void 0, void 0, function* () {
        if (!this.validate(event))
          return;
        const { sensitivity } = this.options;
        const delta = sensitivity * -1;
        yield this.translate(multiply(value, delta), this.options.animation);
        this.invokeOnFinish();
      });
    }
    /**
     * <zh/> 平移画布
     *
     * <en/> Translate canvas
     * @param offset - <zh/> 平移距离 | <en/> Translation distance
     * @param animation - <zh/> 动画配置 | <en/> Animation configuration
     * @internal
     */
    translate(offset, animation) {
      return __awaiter5(this, void 0, void 0, function* () {
        offset = this.clampByDirection(offset);
        offset = this.clampByRange(offset);
        offset = this.clampByRotation(offset);
        yield this.context.graph.translateBy(offset, animation);
      });
    }
    clampByRotation([dx, dy]) {
      const rotation = this.context.graph.getRotation();
      return rotate2([dx, dy], rotation);
    }
    clampByDirection([dx, dy]) {
      const { direction: direction2 } = this.options;
      if (direction2 === "x") {
        dy = 0;
      } else if (direction2 === "y") {
        dx = 0;
      }
      return [dx, dy];
    }
    clampByRange([dx, dy]) {
      const { viewport, canvas: canvas2 } = this.context;
      const [canvasWidth, canvasHeight] = canvas2.getSize();
      const [top, right, bottom, left] = parsePadding(this.options.range);
      const range = [canvasHeight * top, canvasWidth * right, canvasHeight * bottom, canvasWidth * left];
      const draggableArea = getExpandedBBox(getPointBBox(viewport.getCanvasCenter()), range);
      const nextViewportCenter = subtract(viewport.getViewportCenter(), [dx, dy, 0]);
      if (!isPointInBBox(nextViewportCenter, draggableArea)) {
        const { min: [minX, minY], max: [maxX, maxY] } = draggableArea;
        if (nextViewportCenter[0] < minX && dx > 0 || nextViewportCenter[0] > maxX && dx < 0) {
          dx = 0;
        }
        if (nextViewportCenter[1] < minY && dy > 0 || nextViewportCenter[1] > maxY && dy < 0) {
          dy = 0;
        }
      }
      return [dx, dy];
    }
    validate(event) {
      if (this.destroyed)
        return false;
      const { enable } = this.options;
      if (typeof enable === "function")
        return enable(event);
      return !!enable;
    }
    unbindEvents() {
      this.shortcut.unbindAll();
      const { graph } = this.context;
      graph.off(CommonEvent.DRAG_START, this.onDragStart);
      graph.off(CommonEvent.DRAG, this.onDrag);
      graph.off(CommonEvent.DRAG_END, this.onDragEnd);
    }
    destroy() {
      this.shortcut.destroy();
      this.unbindEvents();
      this.context.canvas.setCursor(this.defaultCursor);
      super.destroy();
    }
  };
  DragCanvas.defaultOptions = {
    enable: (event) => {
      if ("targetType" in event)
        return event.targetType === "canvas";
      return true;
    },
    sensitivity: 10,
    direction: "both",
    range: Infinity
  };

  // node_modules/@antv/g6/esm/behaviors/drag-element.js
  var import_util56 = __toESM(require_lib());
  var __awaiter6 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var DragElement = class _DragElement extends BaseBehavior {
    constructor(context, options) {
      super(context, Object.assign({}, _DragElement.defaultOptions, options));
      this.enable = false;
      this.enableElements = ["node", "combo"];
      this.target = [];
      this.shadowOrigin = [0, 0];
      this.hiddenEdges = [];
      this.isDragging = false;
      this.onDrop = (event) => __awaiter6(this, void 0, void 0, function* () {
        var _a2;
        if (this.options.dropEffect !== "link")
          return;
        const { model, element } = this.context;
        const modifiedParentId = event.target.id;
        this.target.forEach((id3) => {
          const originalParent = model.getParentData(id3, COMBO_KEY);
          if (originalParent && idOf(originalParent) === modifiedParentId) {
            model.refreshComboData(modifiedParentId);
          }
          model.setParent(id3, modifiedParentId, COMBO_KEY);
        });
        yield (_a2 = element === null || element === void 0 ? void 0 : element.draw({ animation: true })) === null || _a2 === void 0 ? void 0 : _a2.finished;
      });
      this.setCursor = (event) => {
        if (this.isDragging)
          return;
        const { type } = event;
        const { canvas: canvas2 } = this.context;
        const { cursor } = this.options;
        if (type === CommonEvent.POINTER_ENTER)
          canvas2.setCursor((cursor === null || cursor === void 0 ? void 0 : cursor.grab) || "grab");
        else
          canvas2.setCursor((cursor === null || cursor === void 0 ? void 0 : cursor.default) || "default");
      };
      this.onDragStart = this.onDragStart.bind(this);
      this.onDrag = this.onDrag.bind(this);
      this.onDragEnd = this.onDragEnd.bind(this);
      this.onDrop = this.onDrop.bind(this);
      this.bindEvents();
    }
    /**
     * <zh/> 更新元素拖拽配置
     *
     * <en/> Update the element dragging configuration
     * @param options - <zh/> 配置项 | <en/> options
     * @internal
     */
    update(options) {
      this.unbindEvents();
      super.update(options);
      this.bindEvents();
    }
    bindEvents() {
      const { graph, canvas: canvas2 } = this.context;
      const $canvas = canvas2.getLayer().getContextService().$canvas;
      if ($canvas) {
        $canvas.addEventListener("blur", this.onDragEnd);
        $canvas.addEventListener("contextmenu", this.onDragEnd);
      }
      this.enableElements.forEach((type) => {
        graph.on(`${type}:${CommonEvent.DRAG_START}`, this.onDragStart);
        graph.on(`${type}:${CommonEvent.DRAG}`, this.onDrag);
        graph.on(`${type}:${CommonEvent.DRAG_END}`, this.onDragEnd);
        graph.on(`${type}:${CommonEvent.POINTER_ENTER}`, this.setCursor);
        graph.on(`${type}:${CommonEvent.POINTER_LEAVE}`, this.setCursor);
      });
      if (["link"].includes(this.options.dropEffect)) {
        graph.on(ComboEvent.DROP, this.onDrop);
        graph.on(CanvasEvent2.DROP, this.onDrop);
      }
    }
    /**
     * <zh/> 获取当前选中的节点 id 集合
     *
     * <en/> Get the id collection of the currently selected node
     * @param currTarget - <zh/> 当前拖拽目标元素 id 集合 | <en/> The id collection of the current drag target element
     * @returns <zh/> 当前选中的节点 id 集合 | <en/> The id collection of the currently selected node
     * @internal
     */
    getSelectedNodeIDs(currTarget) {
      return Array.from(new Set(this.context.graph.getElementDataByState("node", this.options.state).map((node) => node.id).concat(currTarget)));
    }
    /**
     * Get the delta of the drag
     * @param event - drag event object
     * @returns delta
     * @internal
     */
    getDelta(event) {
      const zoom = this.context.graph.getZoom();
      return divide([event.dx, event.dy], zoom);
    }
    /**
     * <zh/> 拖拽开始时的回调
     *
     * <en/> Callback when dragging starts
     * @param event - <zh/> 拖拽事件对象 | <en/> drag event object
     * @internal
     */
    onDragStart(event) {
      var _a2;
      this.enable = this.validate(event);
      if (!this.enable)
        return;
      const { batch, canvas: canvas2, graph } = this.context;
      canvas2.setCursor(((_a2 = this.options.cursor) === null || _a2 === void 0 ? void 0 : _a2.grabbing) || "grabbing");
      this.isDragging = true;
      batch.startBatch();
      const id3 = event.target.id;
      const states = graph.getElementState(id3);
      if (states.includes(this.options.state))
        this.target = this.getSelectedNodeIDs([id3]);
      else
        this.target = [id3];
      this.hideEdge();
      this.context.graph.frontElement(this.target);
      if (this.options.shadow)
        this.createShadow(this.target);
    }
    /**
     * <zh/> 拖拽过程中的回调
     *
     * <en/> Callback when dragging
     * @param event - <zh/> 拖拽事件对象 | <en/> drag event object
     * @internal
     */
    onDrag(event) {
      if (!this.enable)
        return;
      const delta = this.getDelta(event);
      if (this.options.shadow)
        this.moveShadow(delta);
      else
        this.moveElement(this.target, delta);
    }
    /**
     * <zh/> 元素拖拽结束的回调
     *
     * <en/> Callback when dragging ends
     * @internal
     */
    onDragEnd() {
      var _a2, _b, _c;
      if (!this.enable)
        return;
      this.enable = false;
      if (this.options.shadow) {
        if (!this.shadow)
          return;
        this.shadow.style.visibility = "hidden";
        const { x: x3 = 0, y: y3 = 0 } = this.shadow.attributes;
        const [dx, dy] = subtract([+x3, +y3], this.shadowOrigin);
        this.moveElement(this.target, [dx, dy]);
      }
      this.showEdges();
      (_b = (_a2 = this.options).onFinish) === null || _b === void 0 ? void 0 : _b.call(_a2, this.target);
      const { batch, canvas: canvas2 } = this.context;
      batch.endBatch();
      canvas2.setCursor(((_c = this.options.cursor) === null || _c === void 0 ? void 0 : _c.grab) || "grab");
      this.isDragging = false;
      this.target = [];
    }
    /**
     * <zh/> 验证元素是否允许拖拽
     *
     * <en/> Verify if the element is allowed to be dragged
     * @param event - <zh/> 拖拽事件对象 | <en/> drag event object
     * @returns <zh/> 是否允许拖拽 | <en/> Whether to allow dragging
     * @internal
     */
    validate(event) {
      if (this.destroyed || isToBeDestroyed(event.target) || // @ts-expect-error private property
      // 避免动画冲突，在combo/node折叠展开过程中不触发
      this.context.graph.isCollapsingExpanding)
        return false;
      const { enable } = this.options;
      if ((0, import_util56.isFunction)(enable))
        return enable(event);
      return !!enable;
    }
    clampByRotation([dx, dy]) {
      const rotation = this.context.graph.getRotation();
      return rotate2([dx, dy], rotation);
    }
    /**
     * <zh/> 移动元素
     *
     * <en/> Move the element
     * @param ids - <zh/> 元素 id 集合 | <en/> element id collection
     * @param offset <zh/> 偏移量 | <en/> offset
     * @internal
     */
    moveElement(ids, offset) {
      return __awaiter6(this, void 0, void 0, function* () {
        const { graph, model } = this.context;
        const { dropEffect } = this.options;
        if (dropEffect === "move")
          ids.forEach((id3) => model.refreshComboData(id3));
        graph.translateElementBy(Object.fromEntries(ids.map((id3) => [id3, this.clampByRotation(offset)])), false);
      });
    }
    moveShadow(offset) {
      if (!this.shadow)
        return;
      const { x: x3 = 0, y: y3 = 0 } = this.shadow.attributes;
      const [dx, dy] = offset;
      this.shadow.attr({ x: +x3 + dx, y: +y3 + dy });
    }
    createShadow(target) {
      const shadowStyle = subStyleProps(this.options, "shadow");
      const bbox = getCombinedBBox(target.map((id3) => this.context.element.getElement(id3).getBounds()));
      const [x3, y3] = bbox.min;
      this.shadowOrigin = [x3, y3];
      const [width2, height] = getBBoxSize(bbox);
      const positionStyle = { width: width2, height, x: x3, y: y3 };
      if (this.shadow) {
        this.shadow.attr(Object.assign(Object.assign(Object.assign({}, shadowStyle), positionStyle), { visibility: "visible" }));
      } else {
        this.shadow = new Rect({
          style: Object.assign(Object.assign(Object.assign({
            // @ts-ignore $layer is not in the type definition
            $layer: "transient"
          }, shadowStyle), positionStyle), { pointerEvents: "none" })
        });
        this.context.canvas.appendChild(this.shadow);
      }
    }
    showEdges() {
      if (this.options.shadow || this.hiddenEdges.length === 0)
        return;
      this.context.graph.showElement(this.hiddenEdges);
      this.hiddenEdges = [];
    }
    /**
     * Hide the edge
     * @internal
     */
    hideEdge() {
      const { hideEdge, shadow } = this.options;
      if (hideEdge === "none" || shadow)
        return;
      const { graph } = this.context;
      if (hideEdge === "all")
        this.hiddenEdges = graph.getEdgeData().map(idOf);
      else {
        this.hiddenEdges = Array.from(new Set(this.target.map((id3) => graph.getRelatedEdgesData(id3, hideEdge).map(idOf)).flat()));
      }
      graph.hideElement(this.hiddenEdges);
    }
    unbindEvents() {
      const { graph, canvas: canvas2 } = this.context;
      const $canvas = canvas2.getLayer().getContextService().$canvas;
      if ($canvas) {
        $canvas.removeEventListener("blur", this.onDragEnd);
        $canvas.removeEventListener("contextmenu", this.onDragEnd);
      }
      this.enableElements.forEach((type) => {
        graph.off(`${type}:${CommonEvent.DRAG_START}`, this.onDragStart);
        graph.off(`${type}:${CommonEvent.DRAG}`, this.onDrag);
        graph.off(`${type}:${CommonEvent.DRAG_END}`, this.onDragEnd);
        graph.off(`${type}:${CommonEvent.POINTER_ENTER}`, this.setCursor);
        graph.off(`${type}:${CommonEvent.POINTER_LEAVE}`, this.setCursor);
      });
      graph.off(`combo:${CommonEvent.DROP}`, this.onDrop);
      graph.off(`canvas:${CommonEvent.DROP}`, this.onDrop);
    }
    destroy() {
      var _a2;
      this.unbindEvents();
      (_a2 = this.shadow) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      super.destroy();
    }
  };
  DragElement.defaultOptions = {
    animation: true,
    enable: (event) => ["node", "combo"].includes(event.targetType),
    dropEffect: "move",
    state: "selected",
    hideEdge: "none",
    shadow: false,
    shadowZIndex: 100,
    shadowFill: "#F3F9FF",
    shadowFillOpacity: 0.5,
    shadowStroke: "#1890FF",
    shadowStrokeOpacity: 0.9,
    shadowLineDash: [5, 5],
    cursor: {
      default: "default",
      grab: "grab",
      grabbing: "grabbing"
    }
  };

  // node_modules/@antv/event-emitter/esm/index.js
  var WILDCARD = "*";
  var EventEmitter2 = (
    /** @class */
    (function() {
      function EventEmitter3() {
        this._events = {};
      }
      EventEmitter3.prototype.on = function(evt, callback, once) {
        if (!this._events[evt]) {
          this._events[evt] = [];
        }
        this._events[evt].push({
          callback,
          once: !!once
        });
        return this;
      };
      EventEmitter3.prototype.once = function(evt, callback) {
        return this.on(evt, callback, true);
      };
      EventEmitter3.prototype.emit = function(evt) {
        var _this2 = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var events = this._events[evt] || [];
        var wildcardEvents = this._events[WILDCARD] || [];
        var doEmit = function(es) {
          var length = es.length;
          for (var i = 0; i < length; i++) {
            if (!es[i]) {
              continue;
            }
            var _a2 = es[i], callback = _a2.callback, once = _a2.once;
            if (once) {
              es.splice(i, 1);
              if (es.length === 0) {
                delete _this2._events[evt];
              }
              length--;
              i--;
            }
            callback.apply(_this2, args);
          }
        };
        doEmit(events);
        doEmit(wildcardEvents);
      };
      EventEmitter3.prototype.off = function(evt, callback) {
        if (!evt) {
          this._events = {};
        } else {
          if (!callback) {
            delete this._events[evt];
          } else {
            var events = this._events[evt] || [];
            var length_1 = events.length;
            for (var i = 0; i < length_1; i++) {
              if (events[i].callback === callback) {
                events.splice(i, 1);
                length_1--;
                i--;
              }
            }
            if (events.length === 0) {
              delete this._events[evt];
            }
          }
        }
        return this;
      };
      EventEmitter3.prototype.getEvents = function() {
        return this._events;
      };
      return EventEmitter3;
    })()
  );
  var esm_default = EventEmitter2;

  // node_modules/@antv/graphlib/esm/utils/traverse.js
  function doBFS(queue, visited, fn, navigator) {
    while (queue.length) {
      const node = queue.shift();
      const abort = fn(node);
      if (abort) {
        return true;
      }
      visited.add(node.id);
      navigator(node.id).forEach((n) => {
        if (!visited.has(n.id)) {
          visited.add(n.id);
          queue.push(n);
        }
      });
    }
    return false;
  }
  function doDFS(node, visited, fn, navigator) {
    const abort = fn(node);
    if (abort) {
      return true;
    }
    visited.add(node.id);
    for (const n of navigator(node.id)) {
      if (!visited.has(n.id)) {
        if (doDFS(n, visited, fn, navigator)) {
          return true;
        }
      }
    }
    return false;
  }

  // node_modules/@antv/graphlib/esm/graphView.js
  var defaultFilter = () => true;
  var GraphView = class {
    graph;
    nodeFilter;
    edgeFilter;
    // caches
    cacheEnabled;
    inEdgesMap = /* @__PURE__ */ new Map();
    outEdgesMap = /* @__PURE__ */ new Map();
    bothEdgesMap = /* @__PURE__ */ new Map();
    allNodesMap = /* @__PURE__ */ new Map();
    allEdgesMap = /* @__PURE__ */ new Map();
    constructor(options) {
      this.graph = options.graph;
      const nodeFilter = options.nodeFilter || defaultFilter;
      const edgeFilter = options.edgeFilter || defaultFilter;
      this.nodeFilter = nodeFilter;
      this.edgeFilter = (edge) => {
        const { source, target } = this.graph.getEdgeDetail(edge.id);
        if (!nodeFilter(source) || !nodeFilter(target)) {
          return false;
        }
        return edgeFilter(edge, source, target);
      };
      if (options.cache === "auto") {
        this.cacheEnabled = true;
        this.startAutoCache();
      } else if (options.cache === "manual") {
        this.cacheEnabled = true;
      } else {
        this.cacheEnabled = false;
      }
    }
    /**
     * Clear all cache data. Therefore `getAllNodes()` will return `[]`.
     * If you want to disable caching, use `graphView.cacheEnabled = false` instead.
     */
    clearCache = () => {
      this.inEdgesMap.clear();
      this.outEdgesMap.clear();
      this.bothEdgesMap.clear();
      this.allNodesMap.clear();
      this.allEdgesMap.clear();
    };
    /**
     * Fully refresh all cache data to the current graph state.
     */
    refreshCache = () => {
      this.clearCache();
      this.updateCache(this.graph.getAllNodes().map((node) => node.id));
    };
    /**
     * Instead of a fully refreshment, this method partially update the cache data by specifying
     * involved(added, removed, updated) nodes. It's more efficient when handling small changes
     * on a large graph.
     */
    updateCache = (involvedNodeIds) => {
      const involvedEdgeIds = /* @__PURE__ */ new Set();
      involvedNodeIds.forEach((id3) => {
        const oldEdgesSet = this.bothEdgesMap.get(id3);
        if (oldEdgesSet) {
          oldEdgesSet.forEach((edge) => involvedEdgeIds.add(edge.id));
        }
        if (!this.hasNode(id3)) {
          this.inEdgesMap.delete(id3);
          this.outEdgesMap.delete(id3);
          this.bothEdgesMap.delete(id3);
          this.allNodesMap.delete(id3);
        } else {
          const inEdges = this.graph.getRelatedEdges(id3, "in").filter(this.edgeFilter);
          const outEdges = this.graph.getRelatedEdges(id3, "out").filter(this.edgeFilter);
          const bothEdges = Array.from(/* @__PURE__ */ new Set([...inEdges, ...outEdges]));
          bothEdges.forEach((edge) => involvedEdgeIds.add(edge.id));
          this.inEdgesMap.set(id3, inEdges);
          this.outEdgesMap.set(id3, outEdges);
          this.bothEdgesMap.set(id3, bothEdges);
          this.allNodesMap.set(id3, this.graph.getNode(id3));
        }
      });
      involvedEdgeIds.forEach((id3) => {
        if (this.hasEdge(id3)) {
          this.allEdgesMap.set(id3, this.graph.getEdge(id3));
        } else {
          this.allEdgesMap.delete(id3);
        }
      });
    };
    startAutoCache() {
      this.refreshCache();
      this.graph.on("changed", this.handleGraphChanged);
    }
    stopAutoCache() {
      this.graph.off("changed", this.handleGraphChanged);
    }
    handleGraphChanged = (event) => {
      const involvedNodeIds = /* @__PURE__ */ new Set();
      event.changes.forEach((change) => {
        switch (change.type) {
          case "NodeAdded":
            involvedNodeIds.add(change.value.id);
            break;
          case "NodeDataUpdated":
            involvedNodeIds.add(change.id);
            break;
          case "EdgeAdded":
            involvedNodeIds.add(change.value.source);
            involvedNodeIds.add(change.value.target);
            break;
          case "EdgeUpdated":
            if (change.propertyName === "source" || change.propertyName === "target") {
              involvedNodeIds.add(change.oldValue);
              involvedNodeIds.add(change.newValue);
            }
            break;
          case "EdgeDataUpdated":
            if (event.graph.hasEdge(change.id)) {
              const edge = event.graph.getEdge(change.id);
              involvedNodeIds.add(edge.source);
              involvedNodeIds.add(edge.target);
            }
            break;
          case "EdgeRemoved":
            involvedNodeIds.add(change.value.source);
            involvedNodeIds.add(change.value.target);
            break;
          case "NodeRemoved":
            involvedNodeIds.add(change.value.id);
            break;
          default:
            break;
        }
      });
      this.updateCache(involvedNodeIds);
    };
    // ================= Node =================
    checkNodeExistence(id3) {
      this.getNode(id3);
    }
    hasNode(id3) {
      if (!this.graph.hasNode(id3))
        return false;
      const node = this.graph.getNode(id3);
      return this.nodeFilter(node);
    }
    areNeighbors(firstNodeId, secondNodeId) {
      this.checkNodeExistence(firstNodeId);
      return this.getNeighbors(secondNodeId).some((neighbor) => neighbor.id === firstNodeId);
    }
    getNode(id3) {
      const node = this.graph.getNode(id3);
      if (!this.nodeFilter(node)) {
        throw new Error("Node not found for id: " + id3);
      }
      return node;
    }
    getRelatedEdges(id3, direction2) {
      this.checkNodeExistence(id3);
      if (this.cacheEnabled) {
        if (direction2 === "in") {
          return this.inEdgesMap.get(id3);
        } else if (direction2 === "out") {
          return this.outEdgesMap.get(id3);
        } else {
          return this.bothEdgesMap.get(id3);
        }
      }
      const edges = this.graph.getRelatedEdges(id3, direction2);
      return edges.filter(this.edgeFilter);
    }
    getDegree(id3, direction2) {
      return this.getRelatedEdges(id3, direction2).length;
    }
    getSuccessors(id3) {
      const outEdges = this.getRelatedEdges(id3, "out");
      const targets = outEdges.map((edge) => this.getNode(edge.target));
      return Array.from(new Set(targets));
    }
    getPredecessors(id3) {
      const inEdges = this.getRelatedEdges(id3, "in");
      const sources = inEdges.map((edge) => this.getNode(edge.source));
      return Array.from(new Set(sources));
    }
    getNeighbors(id3) {
      const predecessors = this.getPredecessors(id3);
      const successors = this.getSuccessors(id3);
      return Array.from(/* @__PURE__ */ new Set([...predecessors, ...successors]));
    }
    // ================= Edge =================
    hasEdge(id3) {
      if (!this.graph.hasEdge(id3))
        return false;
      const edge = this.graph.getEdge(id3);
      return this.edgeFilter(edge);
    }
    getEdge(id3) {
      const edge = this.graph.getEdge(id3);
      if (!this.edgeFilter(edge)) {
        throw new Error("Edge not found for id: " + id3);
      }
      return edge;
    }
    getEdgeDetail(id3) {
      const edge = this.getEdge(id3);
      return {
        edge,
        source: this.getNode(edge.source),
        target: this.getNode(edge.target)
      };
    }
    // ================= Tree =================
    hasTreeStructure(treeKey) {
      return this.graph.hasTreeStructure(treeKey);
    }
    getRoots(treeKey) {
      return this.graph.getRoots(treeKey).filter(this.nodeFilter);
    }
    getChildren(id3, treeKey) {
      this.checkNodeExistence(id3);
      return this.graph.getChildren(id3, treeKey).filter(this.nodeFilter);
    }
    getParent(id3, treeKey) {
      this.checkNodeExistence(id3);
      const parent = this.graph.getParent(id3, treeKey);
      if (!parent || !this.nodeFilter(parent))
        return null;
      return parent;
    }
    // ================= Graph =================
    getAllNodes() {
      if (this.cacheEnabled) {
        return Array.from(this.allNodesMap.values());
      }
      return this.graph.getAllNodes().filter(this.nodeFilter);
    }
    getAllEdges() {
      if (this.cacheEnabled) {
        return Array.from(this.allEdgesMap.values());
      }
      return this.graph.getAllEdges().filter(this.edgeFilter);
    }
    bfs(id3, fn, direction2 = "out") {
      const navigator = {
        in: this.getPredecessors.bind(this),
        out: this.getSuccessors.bind(this),
        both: this.getNeighbors.bind(this)
      }[direction2];
      doBFS([this.getNode(id3)], /* @__PURE__ */ new Set(), fn, navigator);
    }
    dfs(id3, fn, direction2 = "out") {
      const navigator = {
        in: this.getPredecessors.bind(this),
        out: this.getSuccessors.bind(this),
        both: this.getNeighbors.bind(this)
      }[direction2];
      doDFS(this.getNode(id3), /* @__PURE__ */ new Set(), fn, navigator);
    }
  };

  // node_modules/@antv/graphlib/esm/graph.js
  var Graph2 = class _Graph extends esm_default {
    nodeMap = /* @__PURE__ */ new Map();
    edgeMap = /* @__PURE__ */ new Map();
    inEdgesMap = /* @__PURE__ */ new Map();
    outEdgesMap = /* @__PURE__ */ new Map();
    bothEdgesMap = /* @__PURE__ */ new Map();
    treeIndices = /* @__PURE__ */ new Map();
    changes = [];
    batchCount = 0;
    /**
     * This function is called with a {@link GraphChangedEvent} each time a graph change happened.
     *
     * `event.changes` contains all the graph changes in order since last `onChanged`.
     */
    onChanged = () => {
    };
    /**
     * Create a new Graph instance.
     * @param options - The options to initialize a graph. See {@link GraphOptions}.
     *
     * ```ts
     * const graph = new Graph({
     *   // Optional, initial nodes.
     *   nodes: [
     *     // Each node has a unique ID.
     *     { id: 'A', foo: 1 },
     *     { id: 'B', foo: 1 },
     *   ],
     *   // Optional, initial edges.
     *   edges: [
     *     { id: 'C', source: 'B', target: 'B', weight: 1 },
     *   ],
     *   // Optional, called with a GraphChangedEvent.
     *   onChanged: (event) => {
     *     console.log(event);
     *   }
     * });
     * ```
     */
    constructor(options) {
      super();
      if (!options)
        return;
      if (options.nodes)
        this.addNodes(options.nodes);
      if (options.edges)
        this.addEdges(options.edges);
      if (options.tree)
        this.addTree(options.tree);
      if (options.onChanged)
        this.onChanged = options.onChanged;
    }
    /**
     * Batch several graph changes into one.
     *
     * Make several changes, but dispatch only one ChangedEvent at the end of batch:
     * ```ts
     * graph.batch(() => {
     *   graph.addNodes([]);
     *   graph.addEdges([]);
     * });
     * ```
     *
     * Batches can be nested. Only the outermost batch will dispatch a ChangedEvent:
     * ```ts
     * graph.batch(() => {
     *   graph.addNodes([]);
     *   graph.batch(() => {
     *     graph.addEdges([]);
     *   });
     * });
     * ```
     */
    batch = (fn) => {
      this.batchCount += 1;
      fn();
      this.batchCount -= 1;
      if (!this.batchCount) {
        this.commit();
      }
    };
    /**
     * Reset changes and dispatch a ChangedEvent.
     */
    commit() {
      const changes = this.changes;
      this.changes = [];
      const event = {
        graph: this,
        changes
      };
      this.emit("changed", event);
      this.onChanged(event);
    }
    /**
     * Reduce the number of ordered graph changes by dropping or merging unnecessary changes.
     *
     * For example, if we update a node and remove it in a batch:
     *
     * ```ts
     * graph.batch(() => {
     *   graph.updateNodeData('A', 'foo', 2);
     *   graph.removeNode('A');
     * });
     * ```
     *
     * We get 2 atomic graph changes like
     *
     * ```ts
     * [
     *   { type: 'NodeDataUpdated', id: 'A', propertyName: 'foo', oldValue: 1, newValue: 2 },
     *   { type: 'NodeRemoved', value: { id: 'A', data: { foo: 2 } },
     * ]
     * ```
     *
     * Since node 'A' has been removed, we actually have no need to handle with NodeDataUpdated change.
     *
     * `reduceChanges()` here helps us remove such changes.
     */
    reduceChanges(changes) {
      let mergedChanges = [];
      changes.forEach((change) => {
        switch (change.type) {
          case "NodeRemoved": {
            let isNewlyAdded = false;
            mergedChanges = mergedChanges.filter((pastChange) => {
              if (pastChange.type === "NodeAdded") {
                const sameId = pastChange.value.id === change.value.id;
                if (sameId) {
                  isNewlyAdded = true;
                }
                return !sameId;
              } else if (pastChange.type === "NodeDataUpdated") {
                return pastChange.id !== change.value.id;
              } else if (pastChange.type === "TreeStructureChanged") {
                return pastChange.nodeId !== change.value.id;
              }
              return true;
            });
            if (!isNewlyAdded) {
              mergedChanges.push(change);
            }
            break;
          }
          case "EdgeRemoved": {
            let isNewlyAdded = false;
            mergedChanges = mergedChanges.filter((pastChange) => {
              if (pastChange.type === "EdgeAdded") {
                const sameId = pastChange.value.id === change.value.id;
                if (sameId) {
                  isNewlyAdded = true;
                }
                return !sameId;
              } else if (pastChange.type === "EdgeDataUpdated" || pastChange.type === "EdgeUpdated") {
                return pastChange.id !== change.value.id;
              }
              return true;
            });
            if (!isNewlyAdded) {
              mergedChanges.push(change);
            }
            break;
          }
          case "NodeDataUpdated":
          case "EdgeDataUpdated":
          case "EdgeUpdated": {
            const index2 = mergedChanges.findIndex((pastChange) => {
              return pastChange.type === change.type && pastChange.id === change.id && (change.propertyName === void 0 || pastChange.propertyName === change.propertyName);
            });
            const existingChange = mergedChanges[index2];
            if (existingChange) {
              if (change.propertyName !== void 0) {
                existingChange.newValue = change.newValue;
              } else {
                mergedChanges.splice(index2, 1);
                mergedChanges.push(change);
              }
            } else {
              mergedChanges.push(change);
            }
            break;
          }
          case "TreeStructureDetached": {
            mergedChanges = mergedChanges.filter((pastChange) => {
              if (pastChange.type === "TreeStructureAttached") {
                return pastChange.treeKey !== change.treeKey;
              } else if (pastChange.type === "TreeStructureChanged") {
                return pastChange.treeKey !== change.treeKey;
              }
              return true;
            });
            mergedChanges.push(change);
            break;
          }
          case "TreeStructureChanged": {
            const existingChange = mergedChanges.find((pastChange) => {
              return pastChange.type === "TreeStructureChanged" && pastChange.treeKey === change.treeKey && pastChange.nodeId === change.nodeId;
            });
            if (existingChange) {
              existingChange.newParentId = change.newParentId;
            } else {
              mergedChanges.push(change);
            }
            break;
          }
          default:
            mergedChanges.push(change);
            break;
        }
      });
      return mergedChanges;
    }
    // ================= Node =================
    checkNodeExistence(id3) {
      this.getNode(id3);
    }
    /**
     * Check if a node exists in the graph.
     * @group NodeMethods
     */
    hasNode(id3) {
      return this.nodeMap.has(id3);
    }
    /**
     * Tell if two nodes are neighbors.
     * @group NodeMethods
     */
    areNeighbors(firstNodeId, secondNodeId) {
      return this.getNeighbors(secondNodeId).some((neighbor) => neighbor.id === firstNodeId);
    }
    /**
     * Get the node data with given ID.
     * @group NodeMethods
     */
    getNode(id3) {
      const node = this.nodeMap.get(id3);
      if (!node) {
        throw new Error("Node not found for id: " + id3);
      }
      return node;
    }
    /**
     * Given a node ID, find all edges of the node.
     * @param id - ID of the node
     * @param direction - Edge direction, defaults to 'both'.
     * @group NodeMethods
     */
    getRelatedEdges(id3, direction2) {
      this.checkNodeExistence(id3);
      if (direction2 === "in") {
        const inEdges = this.inEdgesMap.get(id3);
        return Array.from(inEdges);
      } else if (direction2 === "out") {
        const outEdges = this.outEdgesMap.get(id3);
        return Array.from(outEdges);
      } else {
        const bothEdges = this.bothEdgesMap.get(id3);
        return Array.from(bothEdges);
      }
    }
    /**
     * Get the degree of the given node.
     * @group NodeMethods
     */
    getDegree(id3, direction2) {
      return this.getRelatedEdges(id3, direction2).length;
    }
    /**
     * Get all successors of the given node.
     */
    getSuccessors(id3) {
      const outEdges = this.getRelatedEdges(id3, "out");
      const targets = outEdges.map((edge) => this.getNode(edge.target));
      return Array.from(new Set(targets));
    }
    /**
     * Get all predecessors of the given node.
     */
    getPredecessors(id3) {
      const inEdges = this.getRelatedEdges(id3, "in");
      const sources = inEdges.map((edge) => this.getNode(edge.source));
      return Array.from(new Set(sources));
    }
    /**
     * Given a node ID, find its neighbors.
     * @param id - ID of the node
     * @group NodeMethods
     */
    getNeighbors(id3) {
      const predecessors = this.getPredecessors(id3);
      const successors = this.getSuccessors(id3);
      return Array.from(/* @__PURE__ */ new Set([...predecessors, ...successors]));
    }
    doAddNode(node) {
      if (this.hasNode(node.id)) {
        throw new Error("Node already exists: " + node.id);
      }
      this.nodeMap.set(node.id, node);
      this.inEdgesMap.set(node.id, /* @__PURE__ */ new Set());
      this.outEdgesMap.set(node.id, /* @__PURE__ */ new Set());
      this.bothEdgesMap.set(node.id, /* @__PURE__ */ new Set());
      this.treeIndices.forEach((tree) => {
        tree.childrenMap.set(node.id, /* @__PURE__ */ new Set());
      });
      this.changes.push({ type: "NodeAdded", value: node });
    }
    /**
     * Add all nodes of the given array, or iterable, into the graph.
     * @group NodeMethods
     */
    addNodes(nodes) {
      this.batch(() => {
        for (const node of nodes) {
          this.doAddNode(node);
        }
      });
    }
    /**
     * Add a single node into the graph.
     * @group NodeMethods
     */
    addNode(node) {
      this.addNodes([node]);
    }
    doRemoveNode(id3) {
      const node = this.getNode(id3);
      const bothEdges = this.bothEdgesMap.get(id3);
      bothEdges?.forEach((edge) => this.doRemoveEdge(edge.id));
      this.nodeMap.delete(id3);
      this.treeIndices.forEach((tree) => {
        tree.childrenMap.get(id3)?.forEach((child) => {
          tree.parentMap.delete(child.id);
        });
        const parent = tree.parentMap.get(id3);
        if (parent)
          tree.childrenMap.get(parent.id)?.delete(node);
        tree.parentMap.delete(id3);
        tree.childrenMap.delete(id3);
      });
      this.bothEdgesMap.delete(id3);
      this.inEdgesMap.delete(id3);
      this.outEdgesMap.delete(id3);
      this.changes.push({ type: "NodeRemoved", value: node });
    }
    /**
     * Remove nodes and their attached edges from the graph.
     * @group NodeMethods
     */
    removeNodes(idList) {
      this.batch(() => {
        idList.forEach((id3) => this.doRemoveNode(id3));
      });
    }
    /**
     * Remove a single node and its attached edges from the graph.
     * @group NodeMethods
     */
    removeNode(id3) {
      this.removeNodes([id3]);
    }
    updateNodeDataProperty(id3, propertyName, value) {
      const node = this.getNode(id3);
      this.batch(() => {
        const oldValue = node.data[propertyName];
        const newValue = value;
        node.data[propertyName] = newValue;
        this.changes.push({
          type: "NodeDataUpdated",
          id: id3,
          propertyName,
          oldValue,
          newValue
        });
      });
    }
    /**
     * Like Object.assign, merge all properties of `path` to the node data.
     * @param id Node ID.
     * @param patch A data object to merge.
     */
    mergeNodeData(id3, patch) {
      this.batch(() => {
        Object.entries(patch).forEach(([propertyName, value]) => {
          this.updateNodeDataProperty(id3, propertyName, value);
        });
      });
    }
    updateNodeData(...args) {
      const id3 = args[0];
      const node = this.getNode(id3);
      if (typeof args[1] === "string") {
        this.updateNodeDataProperty(id3, args[1], args[2]);
        return;
      }
      let data2;
      if (typeof args[1] === "function") {
        const update = args[1];
        data2 = update(node.data);
      } else if (typeof args[1] === "object") {
        data2 = args[1];
      }
      this.batch(() => {
        const oldValue = node.data;
        const newValue = data2;
        node.data = data2;
        this.changes.push({
          type: "NodeDataUpdated",
          id: id3,
          oldValue,
          newValue
        });
      });
    }
    // ================= Edge =================
    checkEdgeExistence(id3) {
      if (!this.hasEdge(id3)) {
        throw new Error("Edge not found for id: " + id3);
      }
    }
    /**
     * Check if an edge exists in the graph.
     * @group NodeMethods
     */
    hasEdge(id3) {
      return this.edgeMap.has(id3);
    }
    /**
     * Get the edge data with given ID.
     * @group EdgeMethods
     */
    getEdge(id3) {
      this.checkEdgeExistence(id3);
      return this.edgeMap.get(id3);
    }
    /**
     * Get the edge, the source node, and the target node by an edge ID.
     * @group EdgeMethods
     */
    getEdgeDetail(id3) {
      const edge = this.getEdge(id3);
      return {
        edge,
        source: this.getNode(edge.source),
        target: this.getNode(edge.target)
      };
    }
    doAddEdge(edge) {
      if (this.hasEdge(edge.id)) {
        throw new Error("Edge already exists: " + edge.id);
      }
      this.checkNodeExistence(edge.source);
      this.checkNodeExistence(edge.target);
      this.edgeMap.set(edge.id, edge);
      const inEdges = this.inEdgesMap.get(edge.target);
      const outEdges = this.outEdgesMap.get(edge.source);
      const bothEdgesOfSource = this.bothEdgesMap.get(edge.source);
      const bothEdgesOfTarget = this.bothEdgesMap.get(edge.target);
      inEdges.add(edge);
      outEdges.add(edge);
      bothEdgesOfSource.add(edge);
      bothEdgesOfTarget.add(edge);
      this.changes.push({ type: "EdgeAdded", value: edge });
    }
    /**
     * Add all edges of the given iterable(an array, a set, etc.) into the graph.
     * @group EdgeMethods
     */
    addEdges(edges) {
      this.batch(() => {
        for (const edge of edges) {
          this.doAddEdge(edge);
        }
      });
    }
    /**
     * Add a single edge pointing from `source` to `target` into the graph.
     *
     * ```ts
     * graph.addNode({ id: 'NodeA' });
     * graph.addNode({ id: 'NodeB' });
     * graph.addEdge({ id: 'EdgeA', source: 'NodeA', target: 'NodeB' });
     * ```
     *
     * If `source` or `target` were not found in the current graph, it throws an Error.
     * @group EdgeMethods
     */
    addEdge(edge) {
      this.addEdges([edge]);
    }
    doRemoveEdge(id3) {
      const edge = this.getEdge(id3);
      const outEdges = this.outEdgesMap.get(edge.source);
      const inEdges = this.inEdgesMap.get(edge.target);
      const bothEdgesOfSource = this.bothEdgesMap.get(edge.source);
      const bothEdgesOfTarget = this.bothEdgesMap.get(edge.target);
      outEdges.delete(edge);
      inEdges.delete(edge);
      bothEdgesOfSource.delete(edge);
      bothEdgesOfTarget.delete(edge);
      this.edgeMap.delete(id3);
      this.changes.push({ type: "EdgeRemoved", value: edge });
    }
    /**
     * Remove edges whose id was included in the given id list.
     * @group EdgeMethods
     */
    removeEdges(idList) {
      this.batch(() => {
        idList.forEach((id3) => this.doRemoveEdge(id3));
      });
    }
    /**
     * Remove a single edge of the given id.
     * @group EdgeMethods
     */
    removeEdge(id3) {
      this.removeEdges([id3]);
    }
    /**
     * Change the source of an edge. The source must be found in current graph.
     * @group EdgeMethods
     */
    updateEdgeSource(id3, source) {
      const edge = this.getEdge(id3);
      this.checkNodeExistence(source);
      const oldSource = edge.source;
      const newSource = source;
      this.outEdgesMap.get(oldSource).delete(edge);
      this.bothEdgesMap.get(oldSource).delete(edge);
      this.outEdgesMap.get(newSource).add(edge);
      this.bothEdgesMap.get(newSource).add(edge);
      edge.source = source;
      this.batch(() => {
        this.changes.push({
          type: "EdgeUpdated",
          id: id3,
          propertyName: "source",
          oldValue: oldSource,
          newValue: newSource
        });
      });
    }
    /**
     * Change the target of an edge. The target must be found in current graph.
     * @group EdgeMethods
     */
    updateEdgeTarget(id3, target) {
      const edge = this.getEdge(id3);
      this.checkNodeExistence(target);
      const oldTarget = edge.target;
      const newTarget = target;
      this.inEdgesMap.get(oldTarget).delete(edge);
      this.bothEdgesMap.get(oldTarget).delete(edge);
      this.inEdgesMap.get(newTarget).add(edge);
      this.bothEdgesMap.get(newTarget).add(edge);
      edge.target = target;
      this.batch(() => {
        this.changes.push({
          type: "EdgeUpdated",
          id: id3,
          propertyName: "target",
          oldValue: oldTarget,
          newValue: newTarget
        });
      });
    }
    updateEdgeDataProperty(id3, propertyName, value) {
      const edge = this.getEdge(id3);
      this.batch(() => {
        const oldValue = edge.data[propertyName];
        const newValue = value;
        edge.data[propertyName] = newValue;
        this.changes.push({
          type: "EdgeDataUpdated",
          id: id3,
          propertyName,
          oldValue,
          newValue
        });
      });
    }
    updateEdgeData(...args) {
      const id3 = args[0];
      const edge = this.getEdge(id3);
      if (typeof args[1] === "string") {
        this.updateEdgeDataProperty(id3, args[1], args[2]);
        return;
      }
      let data2;
      if (typeof args[1] === "function") {
        const update = args[1];
        data2 = update(edge.data);
      } else if (typeof args[1] === "object") {
        data2 = args[1];
      }
      this.batch(() => {
        const oldValue = edge.data;
        const newValue = data2;
        edge.data = data2;
        this.changes.push({
          type: "EdgeDataUpdated",
          id: id3,
          oldValue,
          newValue
        });
      });
    }
    /**
     * @group EdgeMethods
     */
    mergeEdgeData(id3, patch) {
      this.batch(() => {
        Object.entries(patch).forEach(([propertyName, value]) => {
          this.updateEdgeDataProperty(id3, propertyName, value);
        });
      });
    }
    // ================= Tree =================
    checkTreeExistence(treeKey) {
      if (!this.hasTreeStructure(treeKey)) {
        throw new Error("Tree structure not found for treeKey: " + treeKey);
      }
    }
    hasTreeStructure(treeKey) {
      return this.treeIndices.has(treeKey);
    }
    /**
     * Attach a new tree structure representing the hierarchy of all nodes in the graph.
     * @param treeKey A unique key of the tree structure. You can attach multiple tree structures with different keys.
     *
     * ```ts
     * const graph = new Graph({
     *   nodes: [{ id: 1 }, { id: 2 }, { id: 3 }],
     * });
     * graph.attachTreeStructure('Inheritance');
     * graph.setParent(2, 1, 'Inheritance');
     * graph.setParent(3, 1, 'Inheritance');
     * graph.getRoots('Inheritance'); // [1]
     * graph.getChildren(1, 'Inheritance'); // [2,3]
     * ```
     * @group TreeMethods
     */
    attachTreeStructure(treeKey) {
      if (this.treeIndices.has(treeKey)) {
        return;
      }
      this.treeIndices.set(treeKey, {
        parentMap: /* @__PURE__ */ new Map(),
        childrenMap: /* @__PURE__ */ new Map()
      });
      this.batch(() => {
        this.changes.push({
          type: "TreeStructureAttached",
          treeKey
        });
      });
    }
    /**
     * Detach the tree structure of the given tree key from the graph.
     *
     * ```ts
     * graph.detachTreeStructure('Inheritance');
     * graph.getRoots('Inheritance'); // Error!
     * ```
     * @group TreeMethods
     */
    detachTreeStructure(treeKey) {
      this.checkTreeExistence(treeKey);
      this.treeIndices.delete(treeKey);
      this.batch(() => {
        this.changes.push({
          type: "TreeStructureDetached",
          treeKey
        });
      });
    }
    /**
     * Traverse the given tree data, add each node into the graph, then attach the tree structure.
     *
     * ```ts
     * graph.addTree({
     *   id: 1,
     *   children: [
     *     { id: 2 },
     *     { id: 3 },
     *   ],
     * }, 'Inheritance');
     * graph.getRoots('Inheritance'); // [1]
     * graph.getChildren(1, 'Inheritance'); // [2, 3]
     * graph.getAllNodes(); // [1, 2, 3]
     * graph.getAllEdges(); // []
     * ```
     * @group TreeMethods
     */
    addTree(tree, treeKey) {
      this.batch(() => {
        this.attachTreeStructure(treeKey);
        const nodes = [];
        const stack = Array.isArray(tree) ? tree : [tree];
        while (stack.length) {
          const node = stack.shift();
          nodes.push(node);
          if (node.children) {
            stack.push(...node.children);
          }
        }
        this.addNodes(nodes);
        nodes.forEach((parent) => {
          parent.children?.forEach((child) => {
            this.setParent(child.id, parent.id, treeKey);
          });
        });
      });
    }
    /**
     * Get the root nodes of an attached tree structure.
     *
     * Consider a graph with the following tree structure attached:
     * ```
     * Tree structure:
     *    O     3
     *   / \    |
     *  1   2   4
     * ```
     * `graph.getRoots()` takes all nodes without a parent, therefore [0, 3] was returned.
     *
     * Newly added nodes are also unparented. So they are counted as roots.
     * ```ts
     * graph.addNode({ id: 5 });
     * graph.getRoots(); // [0, 3, 5]
     * ```
     *
     * Here is how the tree structure looks like:
     * ```
     * Tree structure:
     *    O     3  5
     *   / \    |
     *  1   2   4
     * ```
     *
     * By setting a parent, a root node no more be a root.
     * ```ts
     * graph.setParent(5, 2);
     * graph.getRoots(); // [0, 3]
     * ```
     *
     * The tree structure now becomes:
     * ```
     * Tree structure:
     *    O     3
     *   / \    |
     *  1   2   4
     *      |
     *      5
     * ```
     *
     * Removing a node forces its children to be unparented, or roots.
     * ```ts
     * graph.removeNode(0);
     * graph.getRoots(); // [1, 2, 3]
     * ```
     *
     * You might draw the the structure as follow:
     * ```
     * Tree structure:
     *  1   2  3
     *      |  |
     *      5  4
     * ```
     * @group TreeMethods
     */
    getRoots(treeKey) {
      this.checkTreeExistence(treeKey);
      return this.getAllNodes().filter((node) => !this.getParent(node.id, treeKey));
    }
    /**
     * Given a node ID and an optional tree key, get the children of the node in the specified tree structure.
     * @group TreeMethods
     */
    getChildren(id3, treeKey) {
      this.checkNodeExistence(id3);
      this.checkTreeExistence(treeKey);
      const tree = this.treeIndices.get(treeKey);
      const children = tree.childrenMap.get(id3);
      return Array.from(children || []);
    }
    /**
     * Given a node ID and an optional tree key, get the parent of the node in the specified tree structure.
     * If the given node is one of the tree roots, this returns null.
     * @group TreeMethods
     */
    getParent(id3, treeKey) {
      this.checkNodeExistence(id3);
      this.checkTreeExistence(treeKey);
      const tree = this.treeIndices.get(treeKey);
      return tree.parentMap.get(id3) || null;
    }
    /**
     * Returns an array of all the ancestor nodes, staring from the parent to the root.
     */
    getAncestors(id3, treeKey) {
      const ancestors = [];
      let current2 = this.getNode(id3);
      let parent;
      while (parent = this.getParent(current2.id, treeKey)) {
        ancestors.push(parent);
        current2 = parent;
      }
      return ancestors;
    }
    /**
     * Set node parent. If this operation causes a circle, it fails with an error.
     * @param id - ID of the child node.
     * @param parent - ID of the parent node. If it is undefined or null, means unset parent for node with id.
     * @param treeKey - Which tree structure the relation is applied to.
     * @group TreeMethods
     */
    setParent(id3, parent, treeKey) {
      this.checkTreeExistence(treeKey);
      const tree = this.treeIndices.get(treeKey);
      if (!tree)
        return;
      const node = this.getNode(id3);
      const oldParent = tree.parentMap.get(id3);
      if (oldParent?.id === parent)
        return;
      if (parent === void 0 || parent === null) {
        if (oldParent) {
          tree.childrenMap.get(oldParent.id)?.delete(node);
        }
        tree.parentMap.delete(id3);
        return;
      }
      const newParent = this.getNode(parent);
      tree.parentMap.set(id3, newParent);
      if (oldParent) {
        tree.childrenMap.get(oldParent.id)?.delete(node);
      }
      let children = tree.childrenMap.get(newParent.id);
      if (!children) {
        children = /* @__PURE__ */ new Set();
        tree.childrenMap.set(newParent.id, children);
      }
      children.add(node);
      this.batch(() => {
        this.changes.push({
          type: "TreeStructureChanged",
          treeKey,
          nodeId: id3,
          oldParentId: oldParent?.id,
          newParentId: newParent.id
        });
      });
    }
    dfsTree(id3, fn, treeKey) {
      const navigator = (nodeId) => this.getChildren(nodeId, treeKey);
      return doDFS(this.getNode(id3), /* @__PURE__ */ new Set(), fn, navigator);
    }
    bfsTree(id3, fn, treeKey) {
      const navigator = (nodeId) => this.getChildren(nodeId, treeKey);
      return doBFS([this.getNode(id3)], /* @__PURE__ */ new Set(), fn, navigator);
    }
    // ================= Graph =================
    /**
     * Get all nodes in the graph as an array.
     */
    getAllNodes() {
      return Array.from(this.nodeMap.values());
    }
    /**
     * Get all edges in the graph as an array.
     */
    getAllEdges() {
      return Array.from(this.edgeMap.values());
    }
    bfs(id3, fn, direction2 = "out") {
      const navigator = {
        in: this.getPredecessors.bind(this),
        out: this.getSuccessors.bind(this),
        both: this.getNeighbors.bind(this)
      }[direction2];
      return doBFS([this.getNode(id3)], /* @__PURE__ */ new Set(), fn, navigator);
    }
    dfs(id3, fn, direction2 = "out") {
      const navigator = {
        in: this.getPredecessors.bind(this),
        out: this.getSuccessors.bind(this),
        both: this.getNeighbors.bind(this)
      }[direction2];
      return doDFS(this.getNode(id3), /* @__PURE__ */ new Set(), fn, navigator);
    }
    clone() {
      const newNodes = this.getAllNodes().map((oldNode) => {
        return { ...oldNode, data: { ...oldNode.data } };
      });
      const newEdges = this.getAllEdges().map((oldEdge) => {
        return { ...oldEdge, data: { ...oldEdge.data } };
      });
      const newGraph = new _Graph({
        nodes: newNodes,
        edges: newEdges
      });
      this.treeIndices.forEach(({ parentMap: oldParentMap, childrenMap: oldChildrenMap }, treeKey) => {
        const parentMap = /* @__PURE__ */ new Map();
        oldParentMap.forEach((parent, key) => {
          parentMap.set(key, newGraph.getNode(parent.id));
        });
        const childrenMap = /* @__PURE__ */ new Map();
        oldChildrenMap.forEach((children, key) => {
          childrenMap.set(key, new Set(Array.from(children).map((n) => newGraph.getNode(n.id))));
        });
        newGraph.treeIndices.set(treeKey, {
          parentMap,
          childrenMap
        });
      });
      return newGraph;
    }
    toJSON() {
      return JSON.stringify({
        nodes: this.getAllNodes(),
        edges: this.getAllEdges()
        // FIXME: And tree structures?
      });
    }
    createView(options) {
      return new GraphView({
        graph: this,
        ...options
      });
    }
  };

  // node_modules/@antv/g6/esm/utils/layout.js
  var import_util57 = __toESM(require_lib());

  // node_modules/@antv/g6/esm/layouts/base-layout.js
  var BaseLayout = class {
    constructor(context, options) {
      this.context = context;
      this.options = options || {};
    }
  };

  // node_modules/@antv/g6/esm/utils/layout.js
  var __awaiter7 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest13 = function(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  function isTreeLayout(options) {
    const { type } = options;
    return ["compact-box", "mindmap", "dendrogram", "indented"].includes(type);
  }
  function isPreLayout(options) {
    return !Array.isArray(options) && (options === null || options === void 0 ? void 0 : options.preLayout);
  }
  function layoutMapping2GraphData(layoutMapping) {
    const { nodes, edges } = layoutMapping;
    const data2 = { nodes: [], edges: [], combos: [] };
    nodes.forEach((nodeLike) => {
      const target = nodeLike.data._isCombo ? data2.combos : data2.nodes;
      const { x: x3, y: y3, z = 0 } = nodeLike.data;
      target === null || target === void 0 ? void 0 : target.push({
        id: nodeLike.id,
        style: { x: x3, y: y3, z }
      });
    });
    edges.forEach((edge) => {
      const { id: id3, source, target, data: { points = [], controlPoints = points.slice(1, points.length - 1) } } = edge;
      data2.edges.push({
        id: id3,
        source,
        target,
        style: Object.assign({}, (controlPoints === null || controlPoints === void 0 ? void 0 : controlPoints.length) ? { controlPoints: controlPoints.map(parsePoint) } : {})
      });
    });
    return data2;
  }
  function layoutAdapter(Ctor, context) {
    class AdaptLayout extends BaseLayout {
      constructor(context2, options) {
        super(context2, options);
        this.instance = new Ctor({});
        this.id = this.instance.id;
        if ("stop" in this.instance && "tick" in this.instance) {
          const instance = this.instance;
          this.stop = instance.stop.bind(instance);
          this.tick = (iterations) => {
            const tickResult = instance.tick(iterations);
            return layoutMapping2GraphData(tickResult);
          };
        }
      }
      execute(model, options) {
        return __awaiter7(this, void 0, void 0, function* () {
          return layoutMapping2GraphData(yield this.instance.execute(this.graphData2LayoutModel(model), this.transformOptions((0, import_util57.deepMix)({}, this.options, options))));
        });
      }
      transformOptions(options) {
        if (!("onTick" in options))
          return options;
        const onTick = options.onTick;
        options.onTick = (data2) => onTick(layoutMapping2GraphData(data2));
        return options;
      }
      graphData2LayoutModel(data2) {
        const { nodes = [], edges = [], combos = [] } = data2;
        const nodesToLayout = nodes.map((datum) => {
          const id3 = idOf(datum);
          const { data: data3, style, combo } = datum, rest = __rest13(datum, ["data", "style", "combo"]);
          const result = {
            id: id3,
            data: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, data3), { data: data3 }), combo ? { parentId: combo } : {}), { style }), rest)
          };
          if (style === null || style === void 0 ? void 0 : style.x)
            Object.assign(result.data, { x: style.x });
          if (style === null || style === void 0 ? void 0 : style.y)
            Object.assign(result.data, { y: style.y });
          if (style === null || style === void 0 ? void 0 : style.z)
            Object.assign(result.data, { z: style.z });
          return result;
        });
        const nodesIdMap = new Map(nodesToLayout.map((node) => [node.id, node]));
        const edgesToLayout = edges.filter((edge) => {
          const { source, target } = edge;
          return nodesIdMap.has(source) && nodesIdMap.has(target);
        }).map((edge) => {
          const { source, target, data: data3, style } = edge;
          return { id: idOf(edge), source, target, data: Object.assign({}, data3), style: Object.assign({}, style) };
        });
        const combosToLayout = combos.map((combo) => {
          return { id: idOf(combo), data: Object.assign({ _isCombo: true }, combo.data), style: Object.assign({}, combo.style) };
        });
        const layoutModel = new Graph2({
          nodes: [...nodesToLayout, ...combosToLayout],
          edges: edgesToLayout
        });
        if (context.model.model.hasTreeStructure(COMBO_KEY)) {
          layoutModel.attachTreeStructure(COMBO_KEY);
          nodesToLayout.forEach((node) => {
            const parent = context.model.model.getParent(node.id, COMBO_KEY);
            if (parent && layoutModel.hasNode(parent.id)) {
              layoutModel.setParent(node.id, parent.id, COMBO_KEY);
            }
          });
        }
        return layoutModel;
      }
    }
    return AdaptLayout;
  }
  function invokeLayoutMethod(layout2, method, ...args) {
    if (method in layout2) {
      return layout2[method](...args);
    }
    if ("instance" in layout2) {
      const instance = layout2.instance;
      if (method in instance)
        return instance[method](...args);
    }
    return null;
  }
  function getLayoutProperty(layout2, name) {
    if (name in layout2)
      return layout2[name];
    if ("instance" in layout2) {
      const instance = layout2.instance;
      if (name in instance)
        return instance[name];
    }
    return null;
  }

  // node_modules/@antv/g6/esm/behaviors/drag-element-force.js
  var __awaiter8 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var DragElementForce = class extends DragElement {
    get forceLayoutInstance() {
      return this.context.layout.getLayoutInstance().find((layout2) => ["d3-force", "d3-force-3d"].includes(layout2 === null || layout2 === void 0 ? void 0 : layout2.id));
    }
    /**
     * Whether the behavior is enabled
     * @param event - The event object
     * @returns Is the behavior enabled
     * @internal
     */
    validate(event) {
      if (!this.context.layout)
        return false;
      if (!this.forceLayoutInstance) {
        print.warn("DragElementForce only works with d3-force or d3-force-3d layout");
        return false;
      }
      return super.validate(event);
    }
    /**
     * Move selected elements by offset
     * @param ids - The selected element IDs
     * @param offset - The offset to move
     * @internal
     */
    moveElement(ids, offset) {
      return __awaiter8(this, void 0, void 0, function* () {
        const layout2 = this.forceLayoutInstance;
        this.context.graph.getNodeData(ids).forEach((element, index2) => {
          const { x: x3 = 0, y: y3 = 0 } = element.style || {};
          if (layout2)
            invokeLayoutMethod(layout2, "setFixedPosition", ids[index2], [...add([+x3, +y3], this.clampByRotation(offset))]);
        });
      });
    }
    /**
     * Triggered when the drag starts
     * @param event - The event object
     * @internal
     */
    onDragStart(event) {
      this.enable = this.validate(event);
      if (!this.enable)
        return;
      this.target = this.getSelectedNodeIDs([event.target.id]);
      this.hideEdge();
      this.context.graph.frontElement(this.target);
      const layout2 = this.forceLayoutInstance;
      if (layout2)
        getLayoutProperty(layout2, "simulation").alphaTarget(0.3).restart();
      this.context.graph.getNodeData(this.target).forEach((element) => {
        const { x: x3 = 0, y: y3 = 0 } = element.style || {};
        if (layout2)
          invokeLayoutMethod(layout2, "setFixedPosition", idOf(element), [+x3, +y3]);
      });
    }
    /**
     * Triggered when dragging
     * @param event - The event object
     * @internal
     */
    onDrag(event) {
      if (!this.enable)
        return;
      const delta = this.getDelta(event);
      this.moveElement(this.target, delta);
    }
    /**
     * Triggered when the drag ends
     * @internal
     */
    onDragEnd() {
      const layout2 = this.forceLayoutInstance;
      if (layout2)
        getLayoutProperty(layout2, "simulation").alphaTarget(0);
      if (this.options.fixed)
        return;
      this.context.graph.getNodeData(this.target).forEach((element) => {
        if (layout2)
          invokeLayoutMethod(layout2, "setFixedPosition", idOf(element), [null, null, null]);
      });
    }
  };

  // node_modules/@antv/g6/esm/behaviors/fix-element-size.js
  var import_util58 = __toESM(require_lib());
  var __awaiter9 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var FixElementSize = class _FixElementSize extends BaseBehavior {
    constructor(context, options) {
      super(context, Object.assign({}, _FixElementSize.defaultOptions, options));
      this.isZoomEvent = (event) => Boolean(event.data && "scale" in event.data);
      this.relatedEdgeToUpdate = /* @__PURE__ */ new Set();
      this.zoom = this.context.graph.getZoom();
      this.fixElementSize = (event) => __awaiter9(this, void 0, void 0, function* () {
        if (!this.validate(event))
          return;
        const { graph } = this.context;
        const { state, nodeFilter, edgeFilter, comboFilter } = this.options;
        const nodeData = (state ? graph.getElementDataByState("node", state) : graph.getNodeData()).filter(nodeFilter);
        const edgeData = (state ? graph.getElementDataByState("edge", state) : graph.getEdgeData()).filter(edgeFilter);
        const comboData = (state ? graph.getElementDataByState("combo", state) : graph.getComboData()).filter(comboFilter);
        const currentScale = this.isZoomEvent(event) ? this.zoom = Math.max(0.01, Math.min(event.data.scale, 10)) : this.zoom;
        const nodeLikeData = [...nodeData, ...comboData];
        if (nodeLikeData.length > 0) {
          nodeLikeData.forEach((datum) => this.fixNodeLike(datum, currentScale));
        }
        this.updateRelatedEdges();
        if (edgeData.length > 0) {
          edgeData.forEach((datum) => this.fixEdge(datum, currentScale));
        }
      });
      this.cachedStyles = /* @__PURE__ */ new Map();
      this.getOriginalFieldValue = (id3, shape, field) => {
        var _a2;
        const shapesStyle = this.cachedStyles.get(id3) || [];
        const shapeStyle = ((_a2 = shapesStyle.find((style) => style.shape === shape)) === null || _a2 === void 0 ? void 0 : _a2.style) || {};
        if (!(field in shapeStyle)) {
          shapeStyle[field] = shape.attributes[field];
          this.cachedStyles.set(id3, [
            ...shapesStyle.filter((style) => style.shape !== shape),
            { shape, style: shapeStyle }
          ]);
        }
        return shapeStyle[field];
      };
      this.scaleEntireElement = (id3, el, currentScale) => {
        el.setLocalScale(1 / currentScale);
        const shapesStyle = this.cachedStyles.get(id3) || [];
        shapesStyle.push({ shape: el });
        this.cachedStyles.set(id3, shapesStyle);
      };
      this.scaleSpecificShapes = (el, currentScale, config) => {
        const descendantShapes = getDescendantShapes(el);
        const configs = Array.isArray(config) ? config : [config];
        configs.forEach((config2) => {
          const { shape: shapeFilter, fields } = config2;
          const shape = typeof shapeFilter === "function" ? shapeFilter(descendantShapes) : el.getShape(shapeFilter);
          if (!shape)
            return;
          if (!fields) {
            this.scaleEntireElement(el.id, shape, currentScale);
            return;
          }
          fields.forEach((field) => {
            const oriFieldValue = this.getOriginalFieldValue(el.id, shape, field);
            if (!(0, import_util58.isNumber)(oriFieldValue))
              return;
            shape.style[field] = oriFieldValue / currentScale;
          });
        });
      };
      this.skipIfExceedViewport = (el) => {
        const { viewport } = this.context;
        return !(viewport === null || viewport === void 0 ? void 0 : viewport.isInViewport(el.getRenderBounds(), false, 30));
      };
      this.fixNodeLike = (datum, currentScale) => {
        const id3 = idOf(datum);
        const { element, model } = this.context;
        const el = element.getElement(id3);
        if (!el || this.skipIfExceedViewport(el))
          return;
        const edges = model.getRelatedEdgesData(id3);
        edges.forEach((edge) => this.relatedEdgeToUpdate.add(idOf(edge)));
        const config = this.options[el.type];
        if (!config) {
          this.scaleEntireElement(id3, el, currentScale);
          return;
        }
        this.scaleSpecificShapes(el, currentScale, config);
      };
      this.fixEdge = (datum, currentScale) => {
        const id3 = idOf(datum);
        const el = this.context.element.getElement(id3);
        if (!el || this.skipIfExceedViewport(el))
          return;
        const config = this.options.edge;
        if (!config) {
          el.style.transformOrigin = "center";
          this.scaleEntireElement(id3, el, currentScale);
          return;
        }
        this.scaleSpecificShapes(el, currentScale, config);
      };
      this.updateRelatedEdges = () => {
        const { element } = this.context;
        if (this.relatedEdgeToUpdate.size > 0) {
          this.relatedEdgeToUpdate.forEach((id3) => {
            const edge = element.getElement(id3);
            edge === null || edge === void 0 ? void 0 : edge.update({});
          });
        }
        this.relatedEdgeToUpdate.clear();
      };
      this.resetTransform = (event) => __awaiter9(this, void 0, void 0, function* () {
        var _a2;
        if ((_a2 = event.data) === null || _a2 === void 0 ? void 0 : _a2.firstRender)
          return;
        if (this.options.reset) {
          this.restoreCachedStyles();
        } else {
          this.fixElementSize({ data: { scale: this.zoom } });
        }
      });
      this.bindEvents();
    }
    restoreCachedStyles() {
      if (this.cachedStyles.size > 0) {
        this.cachedStyles.forEach((shapesStyle) => {
          shapesStyle.forEach(({ shape, style }) => {
            if ((0, import_util58.isEmpty)(style)) {
              shape.setLocalScale(1);
            } else {
              if (this.options.state)
                return;
              Object.entries(style).forEach(([field, value]) => shape.style[field] = value);
            }
          });
        });
        const { graph, element } = this.context;
        const nodeIds = Object.keys(Object.fromEntries(this.cachedStyles)).filter((id3) => id3 && graph.getElementType(id3) === "node");
        if (nodeIds.length > 0) {
          const edgeIds = /* @__PURE__ */ new Set();
          nodeIds.forEach((id3) => {
            graph.getRelatedEdgesData(id3).forEach((edge) => edgeIds.add(idOf(edge)));
          });
          edgeIds.forEach((id3) => {
            const edge = element === null || element === void 0 ? void 0 : element.getElement(id3);
            edge === null || edge === void 0 ? void 0 : edge.update({});
          });
        }
      }
    }
    bindEvents() {
      const { graph } = this.context;
      graph.on(GraphEvent.AFTER_DRAW, this.resetTransform);
      graph.on(GraphEvent.AFTER_TRANSFORM, this.fixElementSize);
    }
    unbindEvents() {
      const { graph } = this.context;
      graph.off(GraphEvent.AFTER_DRAW, this.resetTransform);
      graph.off(GraphEvent.AFTER_TRANSFORM, this.fixElementSize);
    }
    validate(event) {
      if (this.destroyed)
        return false;
      const { enable } = this.options;
      if ((0, import_util58.isFunction)(enable))
        return enable(event);
      return !!enable;
    }
    destroy() {
      this.unbindEvents();
      super.destroy();
    }
  };
  FixElementSize.defaultOptions = {
    enable: (event) => event.data.scale < 1,
    nodeFilter: () => true,
    edgeFilter: () => true,
    comboFilter: () => true,
    edge: [{ shape: "key", fields: ["lineWidth"] }, { shape: "halo", fields: ["lineWidth"] }, { shape: "label" }],
    reset: false
  };

  // node_modules/@antv/g6/esm/behaviors/focus-element.js
  var import_util59 = __toESM(require_lib());
  var __awaiter10 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var FocusElement = class _FocusElement extends BaseBehavior {
    constructor(context, options) {
      super(context, Object.assign({}, _FocusElement.defaultOptions, options));
      this.focus = (event) => __awaiter10(this, void 0, void 0, function* () {
        if (!this.validate(event))
          return;
        const { graph } = this.context;
        yield graph.focusElement(event.target.id, this.options.animation);
      });
      this.bindEvents();
    }
    bindEvents() {
      const { graph } = this.context;
      this.unbindEvents();
      ELEMENT_TYPES.forEach((type) => {
        graph.on(`${type}:${CommonEvent.CLICK}`, this.focus);
      });
    }
    validate(event) {
      if (this.destroyed)
        return false;
      const { enable } = this.options;
      if ((0, import_util59.isFunction)(enable))
        return enable(event);
      return !!enable;
    }
    unbindEvents() {
      const { graph } = this.context;
      ELEMENT_TYPES.forEach((type) => {
        graph.off(`${type}:${CommonEvent.CLICK}`, this.focus);
      });
    }
    destroy() {
      this.unbindEvents();
      super.destroy();
    }
  };
  FocusElement.defaultOptions = {
    animation: {
      easing: "ease-in",
      duration: 500
    },
    enable: true
  };

  // node_modules/@antv/g6/esm/behaviors/hover-activate.js
  var import_util60 = __toESM(require_lib());
  var HoverActivate = class _HoverActivate extends BaseBehavior {
    constructor(context, options) {
      super(context, Object.assign({}, _HoverActivate.defaultOptions, options));
      this.isFrozen = false;
      this.toggleFrozen = (e) => {
        this.isFrozen = e.type === "dragstart";
      };
      this.hoverElement = (event) => {
        if (!this.validate(event))
          return;
        const isEnter = event.type === CommonEvent.POINTER_ENTER;
        this.updateElementsState(event, isEnter);
        const { onHover, onHoverEnd } = this.options;
        if (isEnter)
          onHover === null || onHover === void 0 ? void 0 : onHover(event);
        else
          onHoverEnd === null || onHoverEnd === void 0 ? void 0 : onHoverEnd(event);
      };
      this.updateElementsState = (event, add5) => {
        if (!this.options.state && !this.options.inactiveState)
          return;
        const { graph } = this.context;
        const { state, animation, inactiveState } = this.options;
        const activeIds = this.getActiveIds(event);
        const states = {};
        if (state) {
          Object.assign(states, this.getElementsState(activeIds, state, add5));
        }
        if (inactiveState) {
          const inactiveIds = idsOf(graph.getData(), true).filter((id3) => !activeIds.includes(id3));
          Object.assign(states, this.getElementsState(inactiveIds, inactiveState, add5));
        }
        graph.setElementState(states, animation);
      };
      this.getElementsState = (ids, state, add5) => {
        const { graph } = this.context;
        const states = {};
        ids.forEach((id3) => {
          const currentState = graph.getElementState(id3);
          if (add5) {
            states[id3] = currentState.includes(state) ? currentState : [...currentState, state];
          } else {
            states[id3] = currentState.filter((s) => s !== state);
          }
        });
        return states;
      };
      this.bindEvents();
    }
    bindEvents() {
      const { graph } = this.context;
      this.unbindEvents();
      ELEMENT_TYPES.forEach((type) => {
        graph.on(`${type}:${CommonEvent.POINTER_ENTER}`, this.hoverElement);
        graph.on(`${type}:${CommonEvent.POINTER_LEAVE}`, this.hoverElement);
      });
      const canvas2 = this.context.canvas.document;
      canvas2.addEventListener(`${CommonEvent.DRAG_START}`, this.toggleFrozen);
      canvas2.addEventListener(`${CommonEvent.DRAG_END}`, this.toggleFrozen);
    }
    getActiveIds(event) {
      const { graph } = this.context;
      const { degree: degree3, direction: direction2 } = this.options;
      const elementId = event.target.id;
      return degree3 ? getElementNthDegreeIds(graph, event.targetType, elementId, typeof degree3 === "function" ? degree3(event) : degree3, direction2) : [elementId];
    }
    validate(event) {
      if (this.destroyed || this.isFrozen || isToBeDestroyed(event.target) || // @ts-expect-error private property
      // 避免动画冲突，在combo/node折叠展开过程中不触发
      this.context.graph.isCollapsingExpanding)
        return false;
      const { enable } = this.options;
      if ((0, import_util60.isFunction)(enable))
        return enable(event);
      return !!enable;
    }
    unbindEvents() {
      const { graph } = this.context;
      ELEMENT_TYPES.forEach((type) => {
        graph.off(`${type}:${CommonEvent.POINTER_ENTER}`, this.hoverElement);
        graph.off(`${type}:${CommonEvent.POINTER_LEAVE}`, this.hoverElement);
      });
      const canvas2 = this.context.canvas.document;
      canvas2.removeEventListener(`${CommonEvent.DRAG_START}`, this.toggleFrozen);
      canvas2.removeEventListener(`${CommonEvent.DRAG_END}`, this.toggleFrozen);
    }
    destroy() {
      this.unbindEvents();
      super.destroy();
    }
  };
  HoverActivate.defaultOptions = {
    animation: false,
    enable: true,
    degree: 0,
    direction: "both",
    state: "active",
    inactiveState: void 0
  };

  // node_modules/@antv/g6/esm/behaviors/lasso-select.js
  var LassoSelect = class extends BrushSelect {
    /**
     * Triggered when the mouse is pressed
     * @param event - mouse event
     * @internal
     */
    onPointerDown(event) {
      if (!super.validate(event) || !super.isKeydown() || this.points)
        return;
      const { canvas: canvas2, graph } = this.context;
      this.pathShape = new Path({
        id: "g6-lasso-select",
        style: this.options.style
      });
      canvas2.appendChild(this.pathShape);
      this.points = [getCursorPoint(event, graph)];
    }
    /**
     * Triggered when the mouse is moved
     * @param event - mouse event
     * @internal
     */
    onPointerMove(event) {
      var _a2;
      if (!this.points)
        return;
      const { immediately, mode } = this.options;
      this.points.push(getCursorPoint(event, this.context.graph));
      (_a2 = this.pathShape) === null || _a2 === void 0 ? void 0 : _a2.setAttribute("d", pointsToPath(this.points));
      if (immediately && mode === "default" && this.points.length > 2)
        super.updateElementsStates(this.points);
    }
    /**
     * Triggered when the mouse is released
     * @internal
     */
    onPointerUp() {
      if (!this.points)
        return;
      if (this.points.length < 2) {
        this.clearLasso();
        return;
      }
      super.updateElementsStates(this.points);
      this.clearLasso();
    }
    clearLasso() {
      var _a2;
      (_a2 = this.pathShape) === null || _a2 === void 0 ? void 0 : _a2.remove();
      this.pathShape = void 0;
      this.points = void 0;
    }
  };

  // node_modules/@antv/g6/esm/behaviors/optimize-viewport-transform.js
  var import_util61 = __toESM(require_lib());
  var OptimizeViewportTransform = class _OptimizeViewportTransform extends BaseBehavior {
    constructor(context, options) {
      super(context, Object.assign({}, _OptimizeViewportTransform.defaultOptions, options));
      this.hiddenShapes = [];
      this.isVisible = true;
      this.setElementsVisibility = (elements, visibility2, filter) => {
        elements.filter(Boolean).forEach((element) => {
          if (visibility2 === "hidden" && !element.isVisible()) {
            this.hiddenShapes.push(element);
          } else if (visibility2 === "visible" && this.hiddenShapes.includes(element)) {
            this.hiddenShapes.splice(this.hiddenShapes.indexOf(element), 1);
          } else {
            setVisibility(element, visibility2, filter);
          }
        });
      };
      this.filterShapes = (type, filter) => {
        if ((0, import_util61.isFunction)(filter))
          return (shape) => !filter(type, shape);
        const includesClassnames = filter === null || filter === void 0 ? void 0 : filter[type];
        return (shape) => {
          if (!shape.className)
            return true;
          return !(includesClassnames === null || includesClassnames === void 0 ? void 0 : includesClassnames.includes(shape.className));
        };
      };
      this.hideShapes = (event) => {
        if (!this.validate(event) || !this.isVisible)
          return;
        const { element } = this.context;
        const { shapes = {} } = this.options;
        this.setElementsVisibility(element.getNodes(), "hidden", this.filterShapes("node", shapes));
        this.setElementsVisibility(element.getEdges(), "hidden", this.filterShapes("edge", shapes));
        this.setElementsVisibility(element.getCombos(), "hidden", this.filterShapes("combo", shapes));
        this.isVisible = false;
      };
      this.showShapes = (0, import_util61.debounce)((event) => {
        if (!this.validate(event) || this.isVisible)
          return;
        const { element } = this.context;
        this.setElementsVisibility(element.getNodes(), "visible");
        this.setElementsVisibility(element.getEdges(), "visible");
        this.setElementsVisibility(element.getCombos(), "visible");
        this.isVisible = true;
      }, this.options.debounce);
      this.bindEvents();
    }
    bindEvents() {
      const { graph } = this.context;
      graph.on(GraphEvent.BEFORE_TRANSFORM, this.hideShapes);
      graph.on(GraphEvent.AFTER_TRANSFORM, this.showShapes);
    }
    unbindEvents() {
      const { graph } = this.context;
      graph.off(GraphEvent.BEFORE_TRANSFORM, this.hideShapes);
      graph.off(GraphEvent.AFTER_TRANSFORM, this.showShapes);
    }
    validate(event) {
      if (this.destroyed)
        return false;
      const { enable } = this.options;
      if ((0, import_util61.isFunction)(enable))
        return enable(event);
      return !!enable;
    }
    update(options) {
      this.unbindEvents();
      super.update(options);
      this.bindEvents();
    }
    destroy() {
      this.unbindEvents();
      super.destroy();
    }
  };
  OptimizeViewportTransform.defaultOptions = {
    enable: true,
    debounce: 200,
    shapes: (type) => type === "node"
  };

  // node_modules/@antv/g6/esm/behaviors/scroll-canvas.js
  var import_util62 = __toESM(require_lib());
  var __awaiter11 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var ScrollCanvas = class _ScrollCanvas extends BaseBehavior {
    constructor(context, options) {
      super(context, Object.assign({}, _ScrollCanvas.defaultOptions, options));
      this.onWheel = (event) => __awaiter11(this, void 0, void 0, function* () {
        if (this.options.preventDefault)
          event.preventDefault();
        const diffX = event.deltaX;
        const diffY = event.deltaY;
        yield this.scroll([-diffX, -diffY], event);
      });
      this.shortcut = new Shortcut(context.graph);
      this.bindEvents();
    }
    /**
     * <zh/> 更新配置
     *
     * <en/> Update options
     * @param options - <zh/> 配置项 | <en/> Options
     * @internal
     */
    update(options) {
      super.update(options);
      this.bindEvents();
    }
    bindEvents() {
      var _a2, _b;
      const { trigger } = this.options;
      this.shortcut.unbindAll();
      if ((0, import_util62.isObject)(trigger)) {
        (_a2 = this.graphDom) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener(CommonEvent.WHEEL, this.onWheel);
        const { up = [], down = [], left = [], right = [] } = trigger;
        this.shortcut.bind(up, (event) => this.scroll([0, -10], event));
        this.shortcut.bind(down, (event) => this.scroll([0, 10], event));
        this.shortcut.bind(left, (event) => this.scroll([-10, 0], event));
        this.shortcut.bind(right, (event) => this.scroll([10, 0], event));
      } else {
        (_b = this.graphDom) === null || _b === void 0 ? void 0 : _b.addEventListener(CommonEvent.WHEEL, this.onWheel, { passive: false });
      }
    }
    get graphDom() {
      return this.context.graph.getCanvas().getContextService().getDomElement();
    }
    formatDisplacement(d2) {
      const { sensitivity } = this.options;
      d2 = multiply(d2, sensitivity);
      d2 = this.clampByDirection(d2);
      d2 = this.clampByRange(d2);
      return d2;
    }
    clampByDirection([dx, dy]) {
      const { direction: direction2 } = this.options;
      if (direction2 === "x") {
        dy = 0;
      } else if (direction2 === "y") {
        dx = 0;
      }
      return [dx, dy];
    }
    clampByRange([dx, dy]) {
      const { viewport, canvas: canvas2 } = this.context;
      const [canvasWidth, canvasHeight] = canvas2.getSize();
      const [top, right, bottom, left] = parsePadding(this.options.range);
      const range = [canvasHeight * top, canvasWidth * right, canvasHeight * bottom, canvasWidth * left];
      const scrollableArea = getExpandedBBox(getPointBBox(viewport.getCanvasCenter()), range);
      const nextViewportCenter = subtract(viewport.getViewportCenter(), [dx, dy, 0]);
      if (!isPointInBBox(nextViewportCenter, scrollableArea)) {
        const { min: [minX, minY], max: [maxX, maxY] } = scrollableArea;
        if (nextViewportCenter[0] < minX && dx > 0 || nextViewportCenter[0] > maxX && dx < 0) {
          dx = 0;
        }
        if (nextViewportCenter[1] < minY && dy > 0 || nextViewportCenter[1] > maxY && dy < 0) {
          dy = 0;
        }
      }
      return [dx, dy];
    }
    scroll(value, event) {
      return __awaiter11(this, void 0, void 0, function* () {
        if (!this.validate(event))
          return;
        const { onFinish } = this.options;
        const graph = this.context.graph;
        const formattedValue = this.formatDisplacement(value);
        yield graph.translateBy(formattedValue, false);
        onFinish === null || onFinish === void 0 ? void 0 : onFinish();
      });
    }
    validate(event) {
      if (this.destroyed)
        return false;
      const { enable } = this.options;
      if ((0, import_util62.isFunction)(enable))
        return enable(event);
      return !!enable;
    }
    /**
     * <zh/> 销毁画布滚动
     *
     * <en/> Destroy the canvas scrolling
     */
    destroy() {
      var _a2;
      this.shortcut.destroy();
      (_a2 = this.graphDom) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener(CommonEvent.WHEEL, this.onWheel);
      super.destroy();
    }
  };
  ScrollCanvas.defaultOptions = {
    enable: true,
    sensitivity: 1,
    preventDefault: true,
    range: Infinity
  };

  // node_modules/@antv/g6/esm/behaviors/zoom-canvas.js
  var import_util63 = __toESM(require_lib());
  var __awaiter12 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var ZoomCanvas = class _ZoomCanvas extends BaseBehavior {
    constructor(context, options) {
      super(context, Object.assign({}, _ZoomCanvas.defaultOptions, options));
      this.zoom = (value, event, animation) => __awaiter12(this, void 0, void 0, function* () {
        if (!this.validate(event))
          return;
        const { graph } = this.context;
        let origin = this.options.origin;
        if (!origin && "viewport" in event) {
          origin = parsePoint(event.viewport);
        }
        const { sensitivity, onFinish } = this.options;
        const ratio = 1 + (0, import_util63.clamp)(value, -50, 50) * sensitivity / 100;
        const zoom = graph.getZoom();
        yield graph.zoomTo(zoom * ratio, animation, origin);
        onFinish === null || onFinish === void 0 ? void 0 : onFinish();
      });
      this.onReset = () => __awaiter12(this, void 0, void 0, function* () {
        yield this.context.graph.zoomTo(1, this.options.animation);
      });
      this.preventDefault = (event) => {
        if (this.options.preventDefault)
          event.preventDefault();
      };
      this.shortcut = new Shortcut(context.graph);
      this.bindEvents();
    }
    /**
     * <zh/> 更新配置
     *
     * <en/> Update options
     * @param options - <zh/> 配置项 | <en/> Options
     * @internal
     */
    update(options) {
      super.update(options);
      this.bindEvents();
    }
    bindEvents() {
      const { trigger } = this.options;
      this.shortcut.unbindAll();
      if (Array.isArray(trigger)) {
        if (trigger.includes(CommonEvent.PINCH)) {
          this.shortcut.bind([CommonEvent.PINCH], (event) => {
            this.zoom(event.scale, event, false);
          });
        } else {
          const container = this.context.canvas.getContainer();
          container === null || container === void 0 ? void 0 : container.addEventListener(CommonEvent.WHEEL, this.preventDefault);
          this.shortcut.bind([...trigger, CommonEvent.WHEEL], (event) => {
            const { deltaX, deltaY } = event;
            this.zoom(-(deltaY !== null && deltaY !== void 0 ? deltaY : deltaX), event, false);
          });
        }
      }
      if (typeof trigger === "object") {
        const { zoomIn = [], zoomOut = [], reset = [] } = trigger;
        this.shortcut.bind(zoomIn, (event) => this.zoom(10, event, this.options.animation));
        this.shortcut.bind(zoomOut, (event) => this.zoom(-10, event, this.options.animation));
        this.shortcut.bind(reset, this.onReset);
      }
    }
    /**
     * <zh/> 验证是否可以缩放
     *
     * <en/> Verify whether it can be zoomed
     * @param event - <zh/> 事件对象 | <en/> Event object
     * @returns <zh/> 是否可以缩放 | <en/> Whether it can be zoomed
     * @internal
     */
    validate(event) {
      if (this.destroyed)
        return false;
      const { enable } = this.options;
      if ((0, import_util63.isFunction)(enable))
        return enable(event);
      return !!enable;
    }
    /**
     * <zh/> 销毁缩放画布
     *
     * <en/> Destroy zoom canvas
     */
    destroy() {
      var _a2;
      this.shortcut.destroy();
      (_a2 = this.context.canvas.getContainer()) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener(CommonEvent.WHEEL, this.preventDefault);
      super.destroy();
    }
  };
  ZoomCanvas.defaultOptions = {
    animation: { duration: 200 },
    enable: true,
    sensitivity: 1,
    trigger: [],
    preventDefault: true
  };

  // node_modules/@antv/g6/esm/layouts/index.js
  var import_hierarchy = __toESM(require_hierarchy());

  // node_modules/@antv/layout/lib/antv-dagre.js
  init_tslib_es6();
  var import_util85 = __toESM(require_lib());

  // node_modules/@antv/layout/lib/antv-dagre/layout.js
  var import_util79 = __toESM(require_lib());

  // node_modules/@antv/layout/lib/antv-dagre/data/list.js
  var filterOutLinks = (k, v) => {
    if (k !== "next" && k !== "prev") {
      return v;
    }
  };
  var unlink = (entry) => {
    entry.prev.next = entry.next;
    entry.next.prev = entry.prev;
    delete entry.next;
    delete entry.prev;
  };
  var List = class {
    constructor() {
      const shortcut = {};
      shortcut.prev = shortcut;
      shortcut.next = shortcut.prev;
      this.shortcut = shortcut;
    }
    dequeue() {
      const shortcut = this.shortcut;
      const entry = shortcut.prev;
      if (entry && entry !== shortcut) {
        unlink(entry);
        return entry;
      }
    }
    enqueue(entry) {
      const shortcut = this.shortcut;
      if (entry.prev && entry.next) {
        unlink(entry);
      }
      entry.next = shortcut.next;
      shortcut.next.prev = entry;
      shortcut.next = entry;
      entry.prev = shortcut;
    }
    toString() {
      const strs = [];
      const sentinel = this.shortcut;
      let curr = sentinel.prev;
      while (curr !== sentinel) {
        strs.push(JSON.stringify(curr, filterOutLinks));
        curr = curr === null || curr === void 0 ? void 0 : curr.prev;
      }
      return `[${strs.join(", ")}]`;
    }
  };

  // node_modules/@antv/layout/lib/antv-dagre/greedy-fas.js
  var List2 = class extends List {
  };
  var DEFAULT_WEIGHT_FN = () => 1;
  var greedyFAS = (g, weightFn) => {
    var _a2;
    if (g.getAllNodes().length <= 1)
      return [];
    const state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
    const results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);
    return (_a2 = results.map((e) => g.getRelatedEdges(e.v, "out").filter(({ target }) => target === e.w))) === null || _a2 === void 0 ? void 0 : _a2.flat();
  };
  var doGreedyFAS = (g, buckets, zeroIdx) => {
    let results = [];
    const sources = buckets[buckets.length - 1];
    const sinks = buckets[0];
    let entry;
    while (g.getAllNodes().length) {
      while (entry = sinks.dequeue()) {
        removeNode(g, buckets, zeroIdx, entry);
      }
      while (entry = sources.dequeue()) {
        removeNode(g, buckets, zeroIdx, entry);
      }
      if (g.getAllNodes().length) {
        for (let i = buckets.length - 2; i > 0; --i) {
          entry = buckets[i].dequeue();
          if (entry) {
            results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));
            break;
          }
        }
      }
    }
    return results;
  };
  var removeNode = (g, buckets, zeroIdx, entry, collectPredecessors) => {
    var _a2, _b;
    const results = [];
    if (g.hasNode(entry.v)) {
      (_a2 = g.getRelatedEdges(entry.v, "in")) === null || _a2 === void 0 ? void 0 : _a2.forEach((edge) => {
        const weight = edge.data.weight;
        const uEntry = g.getNode(edge.source);
        if (collectPredecessors) {
          results.push({ v: edge.source, w: edge.target, in: 0, out: 0 });
        }
        if (uEntry.data.out === void 0)
          uEntry.data.out = 0;
        uEntry.data.out -= weight;
        assignBucket(buckets, zeroIdx, Object.assign({ v: uEntry.id }, uEntry.data));
      });
      (_b = g.getRelatedEdges(entry.v, "out")) === null || _b === void 0 ? void 0 : _b.forEach((edge) => {
        const weight = edge.data.weight;
        const w = edge.target;
        const wEntry = g.getNode(w);
        if (wEntry.data.in === void 0)
          wEntry.data.in = 0;
        wEntry.data.in -= weight;
        assignBucket(buckets, zeroIdx, Object.assign({ v: wEntry.id }, wEntry.data));
      });
      g.removeNode(entry.v);
    }
    return collectPredecessors ? results : void 0;
  };
  var buildState = (g, weightFn) => {
    const fasGraph = new Graph2();
    let maxIn = 0;
    let maxOut = 0;
    g.getAllNodes().forEach((v) => {
      fasGraph.addNode({
        id: v.id,
        data: { v: v.id, in: 0, out: 0 }
      });
    });
    g.getAllEdges().forEach((e) => {
      const edge = fasGraph.getRelatedEdges(e.source, "out").find((edge2) => edge2.target === e.target);
      const weight = (weightFn === null || weightFn === void 0 ? void 0 : weightFn(e)) || 1;
      if (!edge) {
        fasGraph.addEdge({
          id: e.id,
          source: e.source,
          target: e.target,
          data: {
            weight
          }
        });
      } else {
        fasGraph.updateEdgeData(edge === null || edge === void 0 ? void 0 : edge.id, Object.assign(Object.assign({}, edge.data), { weight: edge.data.weight + weight }));
      }
      maxOut = Math.max(maxOut, fasGraph.getNode(e.source).data.out += weight);
      maxIn = Math.max(maxIn, fasGraph.getNode(e.target).data.in += weight);
    });
    const buckets = [];
    const rangeMax = maxOut + maxIn + 3;
    for (let i = 0; i < rangeMax; i++) {
      buckets.push(new List2());
    }
    const zeroIdx = maxIn + 1;
    fasGraph.getAllNodes().forEach((v) => {
      assignBucket(buckets, zeroIdx, Object.assign({ v: v.id }, fasGraph.getNode(v.id).data));
    });
    return { buckets, zeroIdx, graph: fasGraph };
  };
  var assignBucket = (buckets, zeroIdx, entry) => {
    if (!entry.out) {
      buckets[0].enqueue(entry);
    } else if (!entry["in"]) {
      buckets[buckets.length - 1].enqueue(entry);
    } else {
      buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
    }
  };

  // node_modules/@antv/layout/lib/antv-dagre/acyclic.js
  var run = (g, acyclicer) => {
    const weightFn = (g2) => {
      return (e) => e.data.weight || 1;
    };
    const fas = acyclicer === "greedy" ? greedyFAS(g, weightFn(g)) : dfsFAS(g);
    fas === null || fas === void 0 ? void 0 : fas.forEach((e) => {
      const label = e.data;
      g.removeEdge(e.id);
      label.forwardName = e.data.name;
      label.reversed = true;
      g.addEdge({
        id: e.id,
        source: e.target,
        target: e.source,
        data: Object.assign({}, label)
      });
    });
  };
  var dfsFAS = (g) => {
    const fas = [];
    const stack = {};
    const visited = {};
    const dfs4 = (v) => {
      if (visited[v]) {
        return;
      }
      visited[v] = true;
      stack[v] = true;
      g.getRelatedEdges(v, "out").forEach((e) => {
        if (stack[e.target]) {
          fas.push(e);
        } else {
          dfs4(e.target);
        }
      });
      delete stack[v];
    };
    g.getAllNodes().forEach((n) => dfs4(n.id));
    return fas;
  };
  var undo = (g) => {
    g.getAllEdges().forEach((e) => {
      const label = e.data;
      if (label.reversed) {
        g.removeEdge(e.id);
        const forwardName = label.forwardName;
        delete label.reversed;
        delete label.forwardName;
        g.addEdge({
          id: e.id,
          source: e.target,
          target: e.source,
          data: Object.assign(Object.assign({}, label), { forwardName })
        });
      }
    });
  };

  // node_modules/@antv/layout/lib/antv-dagre/util.js
  var import_util64 = __toESM(require_lib());
  var safeSort = (valueA, valueB) => {
    return Number(valueA) - Number(valueB);
  };
  var addDummyNode = (g, type, data2, name) => {
    let v;
    do {
      v = `${name}${Math.random()}`;
    } while (g.hasNode(v));
    data2.dummy = type;
    g.addNode({
      id: v,
      data: data2
    });
    return v;
  };
  var simplify = (g) => {
    const simplified = new Graph2();
    g.getAllNodes().forEach((v) => {
      simplified.addNode(Object.assign({}, v));
    });
    g.getAllEdges().forEach((e) => {
      const edge = simplified.getRelatedEdges(e.source, "out").find((edge2) => edge2.target === e.target);
      if (!edge) {
        simplified.addEdge({
          id: e.id,
          source: e.source,
          target: e.target,
          data: {
            weight: e.data.weight || 0,
            minlen: e.data.minlen || 1
          }
        });
      } else {
        simplified.updateEdgeData(edge === null || edge === void 0 ? void 0 : edge.id, Object.assign(Object.assign({}, edge.data), { weight: edge.data.weight + e.data.weight || 0, minlen: Math.max(edge.data.minlen, e.data.minlen || 1) }));
      }
    });
    return simplified;
  };
  var asNonCompoundGraph = (g) => {
    const simplified = new Graph2();
    g.getAllNodes().forEach((node) => {
      if (!g.getChildren(node.id).length) {
        simplified.addNode(Object.assign({}, node));
      }
    });
    g.getAllEdges().forEach((edge) => {
      simplified.addEdge(edge);
    });
    return simplified;
  };
  var zipObject = (keys, values2) => {
    return keys === null || keys === void 0 ? void 0 : keys.reduce((obj, key, i) => {
      obj[key] = values2[i];
      return obj;
    }, {});
  };
  var intersectRect = (rect2, point4) => {
    const x3 = Number(rect2.x);
    const y3 = Number(rect2.y);
    const dx = Number(point4.x) - x3;
    const dy = Number(point4.y) - y3;
    let w = Number(rect2.width) / 2;
    let h = Number(rect2.height) / 2;
    if (!dx && !dy) {
      return { x: 0, y: 0 };
    }
    let sx;
    let sy;
    if (Math.abs(dy) * w > Math.abs(dx) * h) {
      if (dy < 0) {
        h = -h;
      }
      sx = h * dx / dy;
      sy = h;
    } else {
      if (dx < 0) {
        w = -w;
      }
      sx = w;
      sy = w * dy / dx;
    }
    return { x: x3 + sx, y: y3 + sy };
  };
  var buildLayerMatrix = (g) => {
    const layeringNodes = [];
    const rankMax = maxRank(g) + 1;
    for (let i = 0; i < rankMax; i++) {
      layeringNodes.push([]);
    }
    g.getAllNodes().forEach((node) => {
      const rank2 = node.data.rank;
      if (rank2 !== void 0 && layeringNodes[rank2]) {
        layeringNodes[rank2].push(node.id);
      }
    });
    for (let i = 0; i < rankMax; i++) {
      layeringNodes[i] = layeringNodes[i].sort((va, vb) => safeSort(g.getNode(va).data.order, g.getNode(vb).data.order));
    }
    return layeringNodes;
  };
  var normalizeRanks = (g) => {
    const nodeRanks = g.getAllNodes().filter((v) => v.data.rank !== void 0).map((v) => v.data.rank);
    const min4 = Math.min(...nodeRanks);
    g.getAllNodes().forEach((v) => {
      if (v.data.hasOwnProperty("rank") && min4 !== Infinity) {
        v.data.rank -= min4;
      }
    });
  };
  var removeEmptyRanks = (g, nodeRankFactor = 0) => {
    const nodes = g.getAllNodes();
    const nodeRanks = nodes.filter((v) => v.data.rank !== void 0).map((v) => v.data.rank);
    const offset = Math.min(...nodeRanks);
    const layers = [];
    nodes.forEach((v) => {
      const rank2 = (v.data.rank || 0) - offset;
      if (!layers[rank2]) {
        layers[rank2] = [];
      }
      layers[rank2].push(v.id);
    });
    let delta = 0;
    for (let i = 0; i < layers.length; i++) {
      const vs = layers[i];
      if (vs === void 0) {
        if (i % nodeRankFactor !== 0) {
          delta -= 1;
        }
      } else if (delta) {
        vs === null || vs === void 0 ? void 0 : vs.forEach((v) => {
          const node = g.getNode(v);
          if (node) {
            node.data.rank = node.data.rank || 0;
            node.data.rank += delta;
          }
        });
      }
    }
  };
  var addBorderNode = (g, prefix, rank2, order2) => {
    const node = {
      width: 0,
      height: 0
    };
    if ((0, import_util64.isNumber)(rank2) && (0, import_util64.isNumber)(order2)) {
      node.rank = rank2;
      node.order = order2;
    }
    return addDummyNode(g, "border", node, prefix);
  };
  var maxRank = (g) => {
    let maxRank2;
    g.getAllNodes().forEach((v) => {
      const rank2 = v.data.rank;
      if (rank2 !== void 0) {
        if (maxRank2 === void 0 || rank2 > maxRank2) {
          maxRank2 = rank2;
        }
      }
    });
    if (!maxRank2) {
      maxRank2 = 0;
    }
    return maxRank2;
  };
  var partition = (collection, fn) => {
    const result = { lhs: [], rhs: [] };
    collection === null || collection === void 0 ? void 0 : collection.forEach((value) => {
      if (fn(value)) {
        result.lhs.push(value);
      } else {
        result.rhs.push(value);
      }
    });
    return result;
  };
  var minBy = (array, func) => {
    return array.reduce((a2, b) => {
      const valA = func(a2);
      const valB = func(b);
      return valA > valB ? b : a2;
    });
  };
  var doDFS2 = (graph, node, postorder, visited, navigator, result) => {
    if (!visited.includes(node.id)) {
      visited.push(node.id);
      if (!postorder) {
        result.push(node.id);
      }
      navigator(node.id).forEach((n) => doDFS2(graph, n, postorder, visited, navigator, result));
      if (postorder) {
        result.push(node.id);
      }
    }
  };
  var dfs2 = (graph, node, order2, isDirected) => {
    const nodes = Array.isArray(node) ? node : [node];
    const navigator = (n) => isDirected ? graph.getSuccessors(n) : graph.getNeighbors(n);
    const results = [];
    const visited = [];
    nodes.forEach((node2) => {
      if (!graph.hasNode(node2.id)) {
        throw new Error(`Graph does not have node: ${node2}`);
      } else {
        doDFS2(graph, node2, order2 === "post", visited, navigator, results);
      }
    });
    return results;
  };

  // node_modules/@antv/layout/lib/antv-dagre/add-border-segments.js
  var addBorderSegments = (g) => {
    const dfs4 = (v) => {
      const children = g.getChildren(v);
      const node = g.getNode(v);
      if (children === null || children === void 0 ? void 0 : children.length) {
        children.forEach((child) => dfs4(child.id));
      }
      if (node.data.hasOwnProperty("minRank")) {
        node.data.borderLeft = [];
        node.data.borderRight = [];
        for (let rank2 = node.data.minRank, maxRank2 = node.data.maxRank + 1; rank2 < maxRank2; rank2 += 1) {
          addBorderNode2(g, "borderLeft", "_bl", v, node, rank2);
          addBorderNode2(g, "borderRight", "_br", v, node, rank2);
        }
      }
    };
    g.getRoots().forEach((child) => dfs4(child.id));
  };
  var addBorderNode2 = (g, prop, prefix, sg, sgNode, rank2) => {
    const label = { rank: rank2, borderType: prop, width: 0, height: 0 };
    const prev = sgNode.data[prop][rank2 - 1];
    const curr = addDummyNode(g, "border", label, prefix);
    sgNode.data[prop][rank2] = curr;
    g.setParent(curr, sg);
    if (prev) {
      g.addEdge({
        id: `e${Math.random()}`,
        source: prev,
        target: curr,
        data: { weight: 1 }
      });
    }
  };

  // node_modules/@antv/layout/lib/antv-dagre/coordinate-system.js
  var adjust = (g, rankdir) => {
    const rd = rankdir.toLowerCase();
    if (rd === "lr" || rd === "rl") {
      swapWidthHeight(g);
    }
  };
  var undo2 = (g, rankdir) => {
    const rd = rankdir.toLowerCase();
    if (rd === "bt" || rd === "rl") {
      reverseY(g);
    }
    if (rd === "lr" || rd === "rl") {
      swapXY(g);
      swapWidthHeight(g);
    }
  };
  var swapWidthHeight = (g) => {
    g.getAllNodes().forEach((v) => {
      swapWidthHeightOne(v);
    });
    g.getAllEdges().forEach((e) => {
      swapWidthHeightOne(e);
    });
  };
  var swapWidthHeightOne = (node) => {
    const w = node.data.width;
    node.data.width = node.data.height;
    node.data.height = w;
  };
  var reverseY = (g) => {
    g.getAllNodes().forEach((v) => {
      reverseYOne(v.data);
    });
    g.getAllEdges().forEach((edge) => {
      var _a2;
      (_a2 = edge.data.points) === null || _a2 === void 0 ? void 0 : _a2.forEach((point4) => reverseYOne(point4));
      if (edge.data.hasOwnProperty("y")) {
        reverseYOne(edge.data);
      }
    });
  };
  var reverseYOne = (node) => {
    if (node === null || node === void 0 ? void 0 : node.y) {
      node.y = -node.y;
    }
  };
  var swapXY = (g) => {
    g.getAllNodes().forEach((v) => {
      swapXYOne(v.data);
    });
    g.getAllEdges().forEach((edge) => {
      var _a2;
      (_a2 = edge.data.points) === null || _a2 === void 0 ? void 0 : _a2.forEach((point4) => swapXYOne(point4));
      if (edge.data.hasOwnProperty("x")) {
        swapXYOne(edge.data);
      }
    });
  };
  var swapXYOne = (node) => {
    const x3 = node.x;
    node.x = node.y;
    node.y = x3;
  };

  // node_modules/@antv/layout/lib/antv-dagre/nesting-graph.js
  var run2 = (g) => {
    const root2 = addDummyNode(g, "root", {}, "_root");
    const depths = treeDepths(g);
    let maxDepth = Math.max(...Object.values(depths));
    if (Math.abs(maxDepth) === Infinity) {
      maxDepth = 1;
    }
    const height = maxDepth - 1;
    const nodeSep = 2 * height + 1;
    g.getAllEdges().forEach((e) => {
      e.data.minlen *= nodeSep;
    });
    const weight = sumWeights(g) + 1;
    g.getRoots().forEach((child) => {
      dfs3(g, root2, nodeSep, weight, height, depths, child.id);
    });
    return {
      nestingRoot: root2,
      nodeRankFactor: nodeSep
    };
  };
  var dfs3 = (g, root2, nodeSep, weight, height, depths, v) => {
    const children = g.getChildren(v);
    if (!(children === null || children === void 0 ? void 0 : children.length)) {
      if (v !== root2) {
        g.addEdge({
          id: `e${Math.random()}`,
          source: root2,
          target: v,
          data: { weight: 0, minlen: nodeSep }
        });
      }
      return;
    }
    const top = addBorderNode(g, "_bt");
    const bottom = addBorderNode(g, "_bb");
    const label = g.getNode(v);
    g.setParent(top, v);
    label.data.borderTop = top;
    g.setParent(bottom, v);
    label.data.borderBottom = bottom;
    children === null || children === void 0 ? void 0 : children.forEach((childNode) => {
      dfs3(g, root2, nodeSep, weight, height, depths, childNode.id);
      const childTop = childNode.data.borderTop ? childNode.data.borderTop : childNode.id;
      const childBottom = childNode.data.borderBottom ? childNode.data.borderBottom : childNode.id;
      const thisWeight = childNode.data.borderTop ? weight : 2 * weight;
      const minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;
      g.addEdge({
        id: `e${Math.random()}`,
        source: top,
        target: childTop,
        data: {
          minlen,
          weight: thisWeight,
          nestingEdge: true
        }
      });
      g.addEdge({
        id: `e${Math.random()}`,
        source: childBottom,
        target: bottom,
        data: {
          minlen,
          weight: thisWeight,
          nestingEdge: true
        }
      });
    });
    if (!g.getParent(v)) {
      g.addEdge({
        id: `e${Math.random()}`,
        source: root2,
        target: top,
        data: {
          weight: 0,
          minlen: height + depths[v]
        }
      });
    }
  };
  var treeDepths = (g) => {
    const depths = {};
    const dfs4 = (v, depth) => {
      const children = g.getChildren(v);
      children === null || children === void 0 ? void 0 : children.forEach((child) => dfs4(child.id, depth + 1));
      depths[v] = depth;
    };
    g.getRoots().forEach((v) => dfs4(v.id, 1));
    return depths;
  };
  var sumWeights = (g) => {
    let result = 0;
    g.getAllEdges().forEach((e) => {
      result += e.data.weight;
    });
    return result;
  };
  var cleanup = (g, nestingRoot) => {
    if (nestingRoot) {
      g.removeNode(nestingRoot);
    }
    g.getAllEdges().forEach((e) => {
      if (e.data.nestingEdge) {
        g.removeEdge(e.id);
      }
    });
  };

  // node_modules/@antv/layout/lib/antv-dagre/normalize.js
  var DUMMY_NODE_EDGE = "edge";
  var DUMMY_NODE_EDGE_LABEL = "edge-label";
  var run3 = (g, dummyChains) => {
    g.getAllEdges().forEach((edge) => normalizeEdge(g, edge, dummyChains));
  };
  var normalizeEdge = (g, e, dummyChains) => {
    let v = e.source;
    let vRank = g.getNode(v).data.rank;
    const w = e.target;
    const wRank = g.getNode(w).data.rank;
    const labelRank = e.data.labelRank;
    if (wRank === vRank + 1)
      return;
    g.removeEdge(e.id);
    let dummy;
    let nodeData;
    let i;
    for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {
      e.data.points = [];
      nodeData = {
        originalEdge: e,
        width: 0,
        height: 0,
        rank: vRank
      };
      dummy = addDummyNode(g, DUMMY_NODE_EDGE, nodeData, "_d");
      if (vRank === labelRank) {
        nodeData.width = e.data.width;
        nodeData.height = e.data.height;
        nodeData.dummy = DUMMY_NODE_EDGE_LABEL;
        nodeData.labelpos = e.data.labelpos;
      }
      g.addEdge({
        id: `e${Math.random()}`,
        source: v,
        target: dummy,
        data: { weight: e.data.weight }
      });
      if (i === 0) {
        dummyChains.push(dummy);
      }
      v = dummy;
    }
    g.addEdge({
      id: `e${Math.random()}`,
      source: v,
      target: w,
      data: { weight: e.data.weight }
    });
  };
  var undo3 = (g, dummyChains) => {
    dummyChains.forEach((v) => {
      let node = g.getNode(v);
      const { data: data2 } = node;
      const originalEdge = data2.originalEdge;
      let w;
      if (originalEdge) {
        g.addEdge(originalEdge);
      }
      let currentV = v;
      while (node.data.dummy) {
        w = g.getSuccessors(currentV)[0];
        g.removeNode(currentV);
        originalEdge.data.points.push({
          x: node.data.x,
          y: node.data.y
        });
        if (node.data.dummy === DUMMY_NODE_EDGE_LABEL) {
          originalEdge.data.x = node.data.x;
          originalEdge.data.y = node.data.y;
          originalEdge.data.width = node.data.width;
          originalEdge.data.height = node.data.height;
        }
        currentV = w.id;
        node = g.getNode(currentV);
      }
    });
  };

  // node_modules/@antv/layout/lib/antv-dagre/order/index.js
  var import_util70 = __toESM(require_lib());

  // node_modules/@antv/layout/lib/antv-dagre/order/add-subgraph-constraints.js
  var addSubgraphConstraints = (g, cg, vs) => {
    const prev = {};
    let rootPrev;
    vs === null || vs === void 0 ? void 0 : vs.forEach((v) => {
      let child = g.getParent(v);
      let parent;
      let prevChild;
      while (child) {
        parent = g.getParent(child.id);
        if (parent) {
          prevChild = prev[parent.id];
          prev[parent.id] = child.id;
        } else {
          prevChild = rootPrev;
          rootPrev = child.id;
        }
        if (prevChild && prevChild !== child.id) {
          if (!cg.hasNode(prevChild)) {
            cg.addNode({
              id: prevChild,
              data: {}
            });
          }
          if (!cg.hasNode(child.id)) {
            cg.addNode({
              id: child.id,
              data: {}
            });
          }
          if (!cg.hasEdge(`e${prevChild}-${child.id}`)) {
            cg.addEdge({
              id: `e${prevChild}-${child.id}`,
              source: prevChild,
              target: child.id,
              data: {}
            });
          }
          return;
        }
        child = parent;
      }
    });
  };

  // node_modules/@antv/layout/lib/antv-dagre/order/build-layer-graph.js
  var buildLayerGraph = (g, rank2, direction2) => {
    const root2 = createRootNode(g);
    const result = new Graph2({
      tree: [
        {
          id: root2,
          children: [],
          data: {}
        }
      ]
    });
    g.getAllNodes().forEach((v) => {
      const parent = g.getParent(v.id);
      if (v.data.rank === rank2 || v.data.minRank <= rank2 && rank2 <= v.data.maxRank) {
        if (!result.hasNode(v.id)) {
          result.addNode(Object.assign({}, v));
        }
        if ((parent === null || parent === void 0 ? void 0 : parent.id) && !result.hasNode(parent === null || parent === void 0 ? void 0 : parent.id)) {
          result.addNode(Object.assign({}, parent));
        }
        result.setParent(v.id, (parent === null || parent === void 0 ? void 0 : parent.id) || root2);
        g.getRelatedEdges(v.id, direction2).forEach((e) => {
          const u = e.source === v.id ? e.target : e.source;
          if (!result.hasNode(u)) {
            result.addNode(Object.assign({}, g.getNode(u)));
          }
          const edge = result.getRelatedEdges(u, "out").find(({ target }) => target === v.id);
          const weight = edge !== void 0 ? edge.data.weight : 0;
          if (!edge) {
            result.addEdge({
              id: e.id,
              source: u,
              target: v.id,
              data: {
                weight: e.data.weight + weight
              }
            });
          } else {
            result.updateEdgeData(edge.id, Object.assign(Object.assign({}, edge.data), { weight: e.data.weight + weight }));
          }
        });
        if (v.data.hasOwnProperty("minRank")) {
          result.updateNodeData(v.id, Object.assign(Object.assign({}, v.data), { borderLeft: v.data.borderLeft[rank2], borderRight: v.data.borderRight[rank2] }));
        }
      }
    });
    return result;
  };
  var createRootNode = (g) => {
    let v;
    while (g.hasNode(v = `_root${Math.random()}`))
      ;
    return v;
  };

  // node_modules/@antv/layout/lib/antv-dagre/order/cross-count.js
  var twoLayerCrossCount = (g, northLayer, southLayer) => {
    const southPos = zipObject(southLayer, southLayer.map((v, i) => i));
    const unflat = northLayer.map((v) => {
      const unsort = g.getRelatedEdges(v, "out").map((e) => {
        return { pos: southPos[e.target] || 0, weight: e.data.weight };
      });
      return unsort === null || unsort === void 0 ? void 0 : unsort.sort((a2, b) => a2.pos - b.pos);
    });
    const southEntries = unflat.flat().filter((entry) => entry !== void 0);
    let firstIndex = 1;
    while (firstIndex < southLayer.length)
      firstIndex <<= 1;
    const treeSize = 2 * firstIndex - 1;
    firstIndex -= 1;
    const tree = Array(treeSize).fill(0, 0, treeSize);
    let cc = 0;
    southEntries === null || southEntries === void 0 ? void 0 : southEntries.forEach((entry) => {
      if (entry) {
        let index2 = entry.pos + firstIndex;
        tree[index2] += entry.weight;
        let weightSum = 0;
        while (index2 > 0) {
          if (index2 % 2) {
            weightSum += tree[index2 + 1];
          }
          index2 = index2 - 1 >> 1;
          tree[index2] += entry.weight;
        }
        cc += entry.weight * weightSum;
      }
    });
    return cc;
  };
  var crossCount = (g, layering) => {
    let cc = 0;
    for (let i = 1; i < (layering === null || layering === void 0 ? void 0 : layering.length); i += 1) {
      cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);
    }
    return cc;
  };

  // node_modules/@antv/layout/lib/antv-dagre/order/init-order.js
  var initOrder = (g) => {
    const visited = {};
    const simpleNodes = g.getAllNodes();
    const nodeRanks = simpleNodes.map((v) => {
      var _a2;
      return (_a2 = v.data.rank) !== null && _a2 !== void 0 ? _a2 : -Infinity;
    });
    const maxRank2 = Math.max(...nodeRanks);
    const layers = [];
    for (let i = 0; i < maxRank2 + 1; i++) {
      layers.push([]);
    }
    const orderedVs = simpleNodes.sort((a2, b) => g.getNode(a2.id).data.rank - g.getNode(b.id).data.rank);
    const beforeSort = orderedVs.filter((n) => {
      return g.getNode(n.id).data.fixorder !== void 0;
    });
    const fixOrderNodes = beforeSort.sort((a2, b) => g.getNode(a2.id).data.fixorder - g.getNode(b.id).data.fixorder);
    fixOrderNodes === null || fixOrderNodes === void 0 ? void 0 : fixOrderNodes.forEach((n) => {
      if (!isNaN(g.getNode(n.id).data.rank)) {
        layers[g.getNode(n.id).data.rank].push(n.id);
      }
      visited[n.id] = true;
    });
    orderedVs === null || orderedVs === void 0 ? void 0 : orderedVs.forEach((n) => g.dfsTree(n.id, (node) => {
      if (visited.hasOwnProperty(node.id))
        return true;
      visited[node.id] = true;
      if (!isNaN(node.data.rank)) {
        layers[node.data.rank].push(node.id);
      }
    }));
    return layers;
  };

  // node_modules/@antv/layout/lib/antv-dagre/order/barycenter.js
  var barycenter = (g, movable) => {
    return movable.map((v) => {
      const inV = g.getRelatedEdges(v, "in");
      if (!(inV === null || inV === void 0 ? void 0 : inV.length)) {
        return { v };
      }
      const result = { sum: 0, weight: 0 };
      inV === null || inV === void 0 ? void 0 : inV.forEach((e) => {
        const nodeU = g.getNode(e.source);
        result.sum += e.data.weight * nodeU.data.order;
        result.weight += e.data.weight;
      });
      return {
        v,
        barycenter: result.sum / result.weight,
        weight: result.weight
      };
    });
  };

  // node_modules/@antv/layout/lib/antv-dagre/order/resolve-conflicts.js
  var resolveConflicts = (entries, cg) => {
    var _a2, _b, _c;
    const mappedEntries = {};
    entries === null || entries === void 0 ? void 0 : entries.forEach((entry, i) => {
      mappedEntries[entry.v] = {
        i,
        indegree: 0,
        in: [],
        out: [],
        vs: [entry.v]
      };
      const tmp2 = mappedEntries[entry.v];
      if (entry.barycenter !== void 0) {
        tmp2.barycenter = entry.barycenter;
        tmp2.weight = entry.weight;
      }
    });
    (_a2 = cg.getAllEdges()) === null || _a2 === void 0 ? void 0 : _a2.forEach((e) => {
      const entryV = mappedEntries[e.source];
      const entryW = mappedEntries[e.target];
      if (entryV !== void 0 && entryW !== void 0) {
        entryW.indegree++;
        entryV.out.push(mappedEntries[e.target]);
      }
    });
    const sourceSet = (_c = (_b = Object.values(mappedEntries)).filter) === null || _c === void 0 ? void 0 : _c.call(_b, (entry) => !entry.indegree);
    return doResolveConflicts(sourceSet);
  };
  var doResolveConflicts = (sourceSet) => {
    var _a2, _b;
    const entries = [];
    const handleIn = (vEntry) => {
      return (uEntry) => {
        if (uEntry.merged)
          return;
        if (uEntry.barycenter === void 0 || vEntry.barycenter === void 0 || uEntry.barycenter >= vEntry.barycenter) {
          mergeEntries(vEntry, uEntry);
        }
      };
    };
    const handleOut = (vEntry) => {
      return (wEntry) => {
        wEntry["in"].push(vEntry);
        if (--wEntry.indegree === 0) {
          sourceSet.push(wEntry);
        }
      };
    };
    while (sourceSet === null || sourceSet === void 0 ? void 0 : sourceSet.length) {
      const entry = sourceSet.pop();
      entries.push(entry);
      (_a2 = entry["in"].reverse()) === null || _a2 === void 0 ? void 0 : _a2.forEach((e) => handleIn(entry)(e));
      (_b = entry.out) === null || _b === void 0 ? void 0 : _b.forEach((e) => handleOut(entry)(e));
    }
    const filtered = entries.filter((entry) => !entry.merged);
    const keys = [
      "vs",
      "i",
      "barycenter",
      "weight"
    ];
    return filtered.map((entry) => {
      const picked = {};
      keys === null || keys === void 0 ? void 0 : keys.forEach((key) => {
        if (entry[key] === void 0)
          return;
        picked[key] = entry[key];
      });
      return picked;
    });
  };
  var mergeEntries = (target, source) => {
    var _a2;
    let sum = 0;
    let weight = 0;
    if (target.weight) {
      sum += target.barycenter * target.weight;
      weight += target.weight;
    }
    if (source.weight) {
      sum += source.barycenter * source.weight;
      weight += source.weight;
    }
    target.vs = (_a2 = source.vs) === null || _a2 === void 0 ? void 0 : _a2.concat(target.vs);
    target.barycenter = sum / weight;
    target.weight = weight;
    target.i = Math.min(source.i, target.i);
    source.merged = true;
  };
  var resolve_conflicts_default = resolveConflicts;

  // node_modules/@antv/layout/lib/antv-dagre/order/sort.js
  var sort = (entries, biasRight, usePrev, keepNodeOrder) => {
    const parts = partition(entries, (entry) => {
      const hasFixOrder = entry.hasOwnProperty("fixorder") && !isNaN(entry.fixorder);
      if (keepNodeOrder) {
        return !hasFixOrder && entry.hasOwnProperty("barycenter");
      }
      return hasFixOrder || entry.hasOwnProperty("barycenter");
    });
    const sortable = parts.lhs;
    const unsortable = parts.rhs.sort((a2, b) => -a2.i - -b.i);
    const vs = [];
    let sum = 0;
    let weight = 0;
    let vsIndex = 0;
    sortable === null || sortable === void 0 ? void 0 : sortable.sort(compareWithBias(!!biasRight, !!usePrev));
    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
    sortable === null || sortable === void 0 ? void 0 : sortable.forEach((entry) => {
      var _a2;
      vsIndex += (_a2 = entry.vs) === null || _a2 === void 0 ? void 0 : _a2.length;
      vs.push(entry.vs);
      sum += entry.barycenter * entry.weight;
      weight += entry.weight;
      vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
    });
    const result = {
      vs: vs.flat()
    };
    if (weight) {
      result.barycenter = sum / weight;
      result.weight = weight;
    }
    return result;
  };
  var consumeUnsortable = (vs, unsortable, index2) => {
    let iindex = index2;
    let last2;
    while (unsortable.length && (last2 = unsortable[unsortable.length - 1]).i <= iindex) {
      unsortable.pop();
      vs === null || vs === void 0 ? void 0 : vs.push(last2.vs);
      iindex++;
    }
    return iindex;
  };
  var compareWithBias = (bias, usePrev) => {
    return (entryV, entryW) => {
      if (entryV.fixorder !== void 0 && entryW.fixorder !== void 0) {
        return entryV.fixorder - entryW.fixorder;
      }
      if (entryV.barycenter < entryW.barycenter) {
        return -1;
      }
      if (entryV.barycenter > entryW.barycenter) {
        return 1;
      }
      if (usePrev && entryV.order !== void 0 && entryW.order !== void 0) {
        if (entryV.order < entryW.order) {
          return -1;
        }
        if (entryV.order > entryW.order) {
          return 1;
        }
      }
      return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
    };
  };

  // node_modules/@antv/layout/lib/antv-dagre/order/sort-subgraph.js
  var sortSubgraph = (g, v, cg, biasRight, usePrev, keepNodeOrder) => {
    var _a2, _b, _c, _d;
    let movable = g.getChildren(v).map((n) => n.id);
    const node = g.getNode(v);
    const bl = node ? node.data.borderLeft : void 0;
    const br = node ? node.data.borderRight : void 0;
    const subgraphs = {};
    if (bl) {
      movable = movable === null || movable === void 0 ? void 0 : movable.filter((w) => {
        return w !== bl && w !== br;
      });
    }
    const barycenters = barycenter(g, movable || []);
    barycenters === null || barycenters === void 0 ? void 0 : barycenters.forEach((entry) => {
      var _a3;
      if ((_a3 = g.getChildren(entry.v)) === null || _a3 === void 0 ? void 0 : _a3.length) {
        const subgraphResult = sortSubgraph(g, entry.v, cg, biasRight, keepNodeOrder);
        subgraphs[entry.v] = subgraphResult;
        if (subgraphResult.hasOwnProperty("barycenter")) {
          mergeBarycenters(entry, subgraphResult);
        }
      }
    });
    const entries = resolve_conflicts_default(barycenters, cg);
    expandSubgraphs(entries, subgraphs);
    (_a2 = entries.filter((e) => e.vs.length > 0)) === null || _a2 === void 0 ? void 0 : _a2.forEach((e) => {
      const node2 = g.getNode(e.vs[0]);
      if (node2) {
        e.fixorder = node2.data.fixorder;
        e.order = node2.data.order;
      }
    });
    const result = sort(entries, biasRight, usePrev, keepNodeOrder);
    if (bl) {
      result.vs = [bl, result.vs, br].flat();
      if ((_b = g.getPredecessors(bl)) === null || _b === void 0 ? void 0 : _b.length) {
        const blPred = g.getNode(((_c = g.getPredecessors(bl)) === null || _c === void 0 ? void 0 : _c[0].id) || "");
        const brPred = g.getNode(((_d = g.getPredecessors(br)) === null || _d === void 0 ? void 0 : _d[0].id) || "");
        if (!result.hasOwnProperty("barycenter")) {
          result.barycenter = 0;
          result.weight = 0;
        }
        result.barycenter = (result.barycenter * result.weight + blPred.data.order + brPred.data.order) / (result.weight + 2);
        result.weight += 2;
      }
    }
    return result;
  };
  var expandSubgraphs = (entries, subgraphs) => {
    entries === null || entries === void 0 ? void 0 : entries.forEach((entry) => {
      var _a2;
      const vss = (_a2 = entry.vs) === null || _a2 === void 0 ? void 0 : _a2.map((v) => {
        if (subgraphs[v]) {
          return subgraphs[v].vs;
        }
        return v;
      });
      entry.vs = vss.flat();
    });
  };
  var mergeBarycenters = (target, other) => {
    if (target.barycenter !== void 0) {
      target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
      target.weight += other.weight;
    } else {
      target.barycenter = other.barycenter;
      target.weight = other.weight;
    }
  };

  // node_modules/@antv/layout/lib/antv-dagre/order/index.js
  var order = (g, keepNodeOrder) => {
    const mxRank = maxRank(g);
    const range1 = [];
    const range2 = [];
    for (let i = 1; i < mxRank + 1; i++)
      range1.push(i);
    for (let i = mxRank - 1; i > -1; i--)
      range2.push(i);
    const downLayerGraphs = buildLayerGraphs(g, range1, "in");
    const upLayerGraphs = buildLayerGraphs(g, range2, "out");
    let layering = initOrder(g);
    assignOrder(g, layering);
    let bestCC = Number.POSITIVE_INFINITY;
    let best;
    for (let i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
      sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2, false, keepNodeOrder);
      layering = buildLayerMatrix(g);
      const cc = crossCount(g, layering);
      if (cc < bestCC) {
        lastBest = 0;
        best = (0, import_util70.clone)(layering);
        bestCC = cc;
      }
    }
    layering = initOrder(g);
    assignOrder(g, layering);
    for (let i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
      sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2, true, keepNodeOrder);
      layering = buildLayerMatrix(g);
      const cc = crossCount(g, layering);
      if (cc < bestCC) {
        lastBest = 0;
        best = (0, import_util70.clone)(layering);
        bestCC = cc;
      }
    }
    assignOrder(g, best);
  };
  var buildLayerGraphs = (g, ranks, direction2) => {
    return ranks.map((rank2) => {
      return buildLayerGraph(g, rank2, direction2);
    });
  };
  var sweepLayerGraphs = (layerGraphs, biasRight, usePrev, keepNodeOrder) => {
    const cg = new Graph2();
    layerGraphs === null || layerGraphs === void 0 ? void 0 : layerGraphs.forEach((lg) => {
      var _a2;
      const root2 = lg.getRoots()[0].id;
      const sorted = sortSubgraph(lg, root2, cg, biasRight, usePrev, keepNodeOrder);
      for (let i = 0; i < ((_a2 = sorted.vs) === null || _a2 === void 0 ? void 0 : _a2.length) || 0; i++) {
        const lnode = lg.getNode(sorted.vs[i]);
        if (lnode) {
          lnode.data.order = i;
        }
      }
      addSubgraphConstraints(lg, cg, sorted.vs);
    });
  };
  var assignOrder = (g, layering) => {
    layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
      layer === null || layer === void 0 ? void 0 : layer.forEach((v, i) => {
        g.getNode(v).data.order = i;
      });
    });
  };

  // node_modules/@antv/layout/lib/antv-dagre/order/init-data-order.js
  var initDataOrder = (g, nodeOrder) => {
    const simpleNodes = g.getAllNodes().filter((v) => {
      var _a2;
      return !((_a2 = g.getChildren(v.id)) === null || _a2 === void 0 ? void 0 : _a2.length);
    });
    const ranks = simpleNodes.map((v) => v.data.rank);
    const maxRank2 = Math.max(...ranks);
    const layers = [];
    for (let i = 0; i < maxRank2 + 1; i++) {
      layers[i] = [];
    }
    nodeOrder === null || nodeOrder === void 0 ? void 0 : nodeOrder.forEach((n) => {
      const node = g.getNode(n);
      if (!node || node.data.dummy) {
        return;
      }
      if (!isNaN(node.data.rank)) {
        node.data.fixorder = layers[node.data.rank].length;
        layers[node.data.rank].push(n);
      }
    });
  };

  // node_modules/@antv/layout/lib/antv-dagre/parent-dummy-chains.js
  var dfsBothOrder = (g) => {
    const result = {};
    let lim = 0;
    const dfs4 = (v) => {
      const low = lim;
      g.getChildren(v).forEach((n) => dfs4(n.id));
      result[v] = { low, lim: lim++ };
    };
    g.getRoots().forEach((n) => dfs4(n.id));
    return result;
  };
  var findPath = (g, postorderNums, v, w) => {
    var _a2, _b;
    const vPath = [];
    const wPath = [];
    const low = Math.min(postorderNums[v].low, postorderNums[w].low);
    const lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);
    let parent;
    let lca;
    parent = v;
    do {
      parent = (_a2 = g.getParent(parent)) === null || _a2 === void 0 ? void 0 : _a2.id;
      vPath.push(parent);
    } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
    lca = parent;
    parent = w;
    while (parent && parent !== lca) {
      wPath.push(parent);
      parent = (_b = g.getParent(parent)) === null || _b === void 0 ? void 0 : _b.id;
    }
    return { lca, path: vPath.concat(wPath.reverse()) };
  };
  var parentDummyChains = (g, dummyChains) => {
    const postorderNums = dfsBothOrder(g);
    dummyChains.forEach((startV) => {
      var _a2, _b;
      let v = startV;
      let node = g.getNode(v);
      const originalEdge = node.data.originalEdge;
      if (!originalEdge)
        return;
      const pathData = findPath(g, postorderNums, originalEdge.source, originalEdge.target);
      const path = pathData.path;
      const lca = pathData.lca;
      let pathIdx = 0;
      let pathV = path[pathIdx];
      let ascending = true;
      while (v !== originalEdge.target) {
        node = g.getNode(v);
        if (ascending) {
          while (pathV !== lca && ((_a2 = g.getNode(pathV)) === null || _a2 === void 0 ? void 0 : _a2.data.maxRank) < node.data.rank) {
            pathIdx++;
            pathV = path[pathIdx];
          }
          if (pathV === lca) {
            ascending = false;
          }
        }
        if (!ascending) {
          while (pathIdx < path.length - 1 && ((_b = g.getNode(path[pathIdx + 1])) === null || _b === void 0 ? void 0 : _b.data.minRank) <= node.data.rank) {
            pathIdx++;
          }
          pathV = path[pathIdx];
        }
        if (g.hasNode(pathV)) {
          g.setParent(v, pathV);
        }
        v = g.getSuccessors(v)[0].id;
      }
    });
  };

  // node_modules/@antv/layout/lib/antv-dagre/position/bk.js
  var findType1Conflicts = (g, layering) => {
    const conflicts = {};
    const visitLayer = (prevLayer, layer) => {
      let k0 = 0;
      let scanPos = 0;
      const prevLayerLength = prevLayer.length;
      const lastNode = layer === null || layer === void 0 ? void 0 : layer[(layer === null || layer === void 0 ? void 0 : layer.length) - 1];
      layer === null || layer === void 0 ? void 0 : layer.forEach((v, i) => {
        var _a2;
        const w = findOtherInnerSegmentNode(g, v);
        const k1 = w ? g.getNode(w.id).data.order : prevLayerLength;
        if (w || v === lastNode) {
          (_a2 = layer.slice(scanPos, i + 1)) === null || _a2 === void 0 ? void 0 : _a2.forEach((scanNode) => {
            var _a3;
            (_a3 = g.getPredecessors(scanNode)) === null || _a3 === void 0 ? void 0 : _a3.forEach((u) => {
              var _a4;
              const uLabel = g.getNode(u.id);
              const uPos = uLabel.data.order;
              if ((uPos < k0 || k1 < uPos) && !(uLabel.data.dummy && ((_a4 = g.getNode(scanNode)) === null || _a4 === void 0 ? void 0 : _a4.data.dummy))) {
                addConflict(conflicts, u.id, scanNode);
              }
            });
          });
          scanPos = i + 1;
          k0 = k1;
        }
      });
      return layer;
    };
    if (layering === null || layering === void 0 ? void 0 : layering.length) {
      layering.reduce(visitLayer);
    }
    return conflicts;
  };
  var findType2Conflicts = (g, layering) => {
    const conflicts = {};
    function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
      var _a2, _b;
      let v;
      for (let i = southPos; i < southEnd; i++) {
        v = south[i];
        if ((_a2 = g.getNode(v)) === null || _a2 === void 0 ? void 0 : _a2.data.dummy) {
          (_b = g.getPredecessors(v)) === null || _b === void 0 ? void 0 : _b.forEach((u) => {
            const uNode = g.getNode(u.id);
            if (uNode.data.dummy && (uNode.data.order < prevNorthBorder || uNode.data.order > nextNorthBorder)) {
              addConflict(conflicts, u.id, v);
            }
          });
        }
      }
    }
    function getScannedKey(params) {
      return JSON.stringify(params.slice(1));
    }
    function scanIfNeeded(params, scanCache) {
      const cacheKey = getScannedKey(params);
      if (scanCache.get(cacheKey))
        return;
      scan(...params);
      scanCache.set(cacheKey, true);
    }
    const visitLayer = (north, south) => {
      let prevNorthPos = -1;
      let nextNorthPos;
      let southPos = 0;
      const scanned = /* @__PURE__ */ new Map();
      south === null || south === void 0 ? void 0 : south.forEach((v, southLookahead) => {
        var _a2;
        if (((_a2 = g.getNode(v)) === null || _a2 === void 0 ? void 0 : _a2.data.dummy) === "border") {
          const predecessors = g.getPredecessors(v) || [];
          if (predecessors.length) {
            nextNorthPos = g.getNode(predecessors[0].id).data.order;
            scanIfNeeded([south, southPos, southLookahead, prevNorthPos, nextNorthPos], scanned);
            southPos = southLookahead;
            prevNorthPos = nextNorthPos;
          }
        }
        scanIfNeeded([south, southPos, south.length, nextNorthPos, north.length], scanned);
      });
      return south;
    };
    if (layering === null || layering === void 0 ? void 0 : layering.length) {
      layering.reduce(visitLayer);
    }
    return conflicts;
  };
  var findOtherInnerSegmentNode = (g, v) => {
    var _a2, _b;
    if ((_a2 = g.getNode(v)) === null || _a2 === void 0 ? void 0 : _a2.data.dummy) {
      return (_b = g.getPredecessors(v)) === null || _b === void 0 ? void 0 : _b.find((u) => g.getNode(u.id).data.dummy);
    }
  };
  var addConflict = (conflicts, v, w) => {
    let vv = v;
    let ww = w;
    if (vv > ww) {
      const tmp2 = vv;
      vv = ww;
      ww = tmp2;
    }
    let conflictsV = conflicts[vv];
    if (!conflictsV) {
      conflicts[vv] = conflictsV = {};
    }
    conflictsV[ww] = true;
  };
  var hasConflict = (conflicts, v, w) => {
    let vv = v;
    let ww = w;
    if (vv > ww) {
      const tmp2 = v;
      vv = ww;
      ww = tmp2;
    }
    return !!conflicts[vv];
  };
  var verticalAlignment = (g, layering, conflicts, neighborFn) => {
    const root2 = {};
    const align = {};
    const pos = {};
    layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
      layer === null || layer === void 0 ? void 0 : layer.forEach((v, order2) => {
        root2[v] = v;
        align[v] = v;
        pos[v] = order2;
      });
    });
    layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
      let prevIdx = -1;
      layer === null || layer === void 0 ? void 0 : layer.forEach((v) => {
        let ws = neighborFn(v).map((n) => n.id);
        if (ws.length) {
          ws = ws.sort((a2, b) => pos[a2] - pos[b]);
          const mp = (ws.length - 1) / 2;
          for (let i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {
            const w = ws[i];
            if (align[v] === v && prevIdx < pos[w] && !hasConflict(conflicts, v, w)) {
              align[w] = v;
              align[v] = root2[v] = root2[w];
              prevIdx = pos[w];
            }
          }
        }
      });
    });
    return { root: root2, align };
  };
  var horizontalCompaction = (g, layering, root2, align, nodesep, edgesep, reverseSep) => {
    var _a2;
    const xs = {};
    const blockG = buildBlockGraph(g, layering, root2, nodesep, edgesep, reverseSep);
    const borderType = reverseSep ? "borderLeft" : "borderRight";
    const iterate = (setXsFunc, nextNodesFunc) => {
      let stack = blockG.getAllNodes();
      let elem = stack.pop();
      const visited = {};
      while (elem) {
        if (visited[elem.id]) {
          setXsFunc(elem.id);
        } else {
          visited[elem.id] = true;
          stack.push(elem);
          stack = stack.concat(nextNodesFunc(elem.id));
        }
        elem = stack.pop();
      }
    };
    const pass1 = (elem) => {
      xs[elem] = (blockG.getRelatedEdges(elem, "in") || []).reduce((acc, e) => {
        return Math.max(acc, (xs[e.source] || 0) + e.data.weight);
      }, 0);
    };
    const pass2 = (elem) => {
      const min4 = (blockG.getRelatedEdges(elem, "out") || []).reduce((acc, e) => {
        return Math.min(acc, (xs[e.target] || 0) - e.data.weight);
      }, Number.POSITIVE_INFINITY);
      const node = g.getNode(elem);
      if (min4 !== Number.POSITIVE_INFINITY && node.data.borderType !== borderType) {
        xs[elem] = Math.max(xs[elem], min4);
      }
    };
    iterate(pass1, blockG.getPredecessors.bind(blockG));
    iterate(pass2, blockG.getSuccessors.bind(blockG));
    (_a2 = Object.values(align)) === null || _a2 === void 0 ? void 0 : _a2.forEach((v) => {
      xs[v] = xs[root2[v]];
    });
    return xs;
  };
  var buildBlockGraph = (g, layering, root2, nodesep, edgesep, reverseSep) => {
    const blockGraph = new Graph2();
    const sepFn = sep(nodesep, edgesep, reverseSep);
    layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
      let u;
      layer === null || layer === void 0 ? void 0 : layer.forEach((v) => {
        const vRoot = root2[v];
        if (!blockGraph.hasNode(vRoot)) {
          blockGraph.addNode({
            id: vRoot,
            data: {}
          });
        }
        if (u) {
          const uRoot = root2[u];
          const edge = blockGraph.getRelatedEdges(uRoot, "out").find((edge2) => edge2.target === vRoot);
          if (!edge) {
            blockGraph.addEdge({
              id: `e${Math.random()}`,
              source: uRoot,
              target: vRoot,
              data: {
                weight: Math.max(sepFn(g, v, u), 0)
              }
            });
          } else {
            blockGraph.updateEdgeData(edge.id, Object.assign(Object.assign({}, edge.data), { weight: Math.max(sepFn(g, v, u), edge.data.weight || 0) }));
          }
        }
        u = v;
      });
    });
    return blockGraph;
  };
  var findSmallestWidthAlignment = (g, xss) => {
    return minBy(Object.values(xss), (xs) => {
      var _a2;
      let max4 = Number.NEGATIVE_INFINITY;
      let min4 = Number.POSITIVE_INFINITY;
      (_a2 = Object.keys(xs)) === null || _a2 === void 0 ? void 0 : _a2.forEach((v) => {
        const x3 = xs[v];
        const halfWidth = width(g, v) / 2;
        max4 = Math.max(x3 + halfWidth, max4);
        min4 = Math.min(x3 - halfWidth, min4);
      });
      return max4 - min4;
    });
  };
  function alignCoordinates(xss, alignTo) {
    const alignToVals = Object.values(alignTo);
    const alignToMin = Math.min(...alignToVals);
    const alignToMax = Math.max(...alignToVals);
    ["u", "d"].forEach((vert) => {
      ["l", "r"].forEach((horiz) => {
        const alignment = vert + horiz;
        const xs = xss[alignment];
        let delta;
        if (xs === alignTo)
          return;
        const xsVals = Object.values(xs);
        delta = horiz === "l" ? alignToMin - Math.min(...xsVals) : alignToMax - Math.max(...xsVals);
        if (delta) {
          xss[alignment] = {};
          Object.keys(xs).forEach((key) => {
            xss[alignment][key] = xs[key] + delta;
          });
        }
      });
    });
  }
  var balance = (xss, align) => {
    const result = {};
    Object.keys(xss.ul).forEach((key) => {
      if (align) {
        result[key] = xss[align.toLowerCase()][key];
      } else {
        const values2 = Object.values(xss).map((x3) => x3[key]);
        result[key] = (values2[0] + values2[1]) / 2;
      }
    });
    return result;
  };
  var sep = (nodeSep, edgeSep, reverseSep) => {
    return (g, v, w) => {
      const vLabel = g.getNode(v);
      const wLabel = g.getNode(w);
      let sum = 0;
      let delta = 0;
      sum += vLabel.data.width / 2;
      if (vLabel.data.hasOwnProperty("labelpos")) {
        switch ((vLabel.data.labelpos || "").toLowerCase()) {
          case "l":
            delta = -vLabel.data.width / 2;
            break;
          case "r":
            delta = vLabel.data.width / 2;
            break;
        }
      }
      if (delta) {
        sum += reverseSep ? delta : -delta;
      }
      delta = 0;
      sum += (vLabel.data.dummy ? edgeSep : nodeSep) / 2;
      sum += (wLabel.data.dummy ? edgeSep : nodeSep) / 2;
      sum += wLabel.data.width / 2;
      if (wLabel.data.labelpos) {
        switch ((wLabel.data.labelpos || "").toLowerCase()) {
          case "l":
            delta = wLabel.data.width / 2;
            break;
          case "r":
            delta = -wLabel.data.width / 2;
            break;
        }
      }
      if (delta) {
        sum += reverseSep ? delta : -delta;
      }
      delta = 0;
      return sum;
    };
  };
  var width = (g, v) => g.getNode(v).data.width || 0;

  // node_modules/@antv/layout/lib/antv-dagre/position/index.js
  var positionY = (g, options) => {
    const { ranksep = 0 } = options || {};
    const layering = buildLayerMatrix(g);
    let prevY = 0;
    layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
      const heights = layer.map((v) => g.getNode(v).data.height);
      const maxHeight = Math.max(...heights, 0);
      layer === null || layer === void 0 ? void 0 : layer.forEach((v) => {
        g.getNode(v).data.y = prevY + maxHeight / 2;
      });
      prevY += maxHeight + ranksep;
    });
  };
  var positionX = (g, options) => {
    const { align: graphAlign, nodesep = 0, edgesep = 0 } = options || {};
    const layering = buildLayerMatrix(g);
    const conflicts = Object.assign(findType1Conflicts(g, layering), findType2Conflicts(g, layering));
    const xss = {};
    let adjustedLayering = [];
    ["u", "d"].forEach((vert) => {
      adjustedLayering = vert === "u" ? layering : Object.values(layering).reverse();
      ["l", "r"].forEach((horiz) => {
        if (horiz === "r") {
          adjustedLayering = adjustedLayering.map((inner) => Object.values(inner).reverse());
        }
        const neighborFn = (vert === "u" ? g.getPredecessors : g.getSuccessors).bind(g);
        const align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);
        const xs = horizontalCompaction(g, adjustedLayering, align.root, align.align, nodesep, edgesep, horiz === "r");
        if (horiz === "r") {
          Object.keys(xs).forEach((xsKey) => xs[xsKey] = -xs[xsKey]);
        }
        xss[vert + horiz] = xs;
      });
    });
    const smallestWidth = findSmallestWidthAlignment(g, xss);
    smallestWidth && alignCoordinates(xss, smallestWidth);
    return balance(xss, graphAlign);
  };
  var position = (g, options) => {
    var _a2;
    const ng = asNonCompoundGraph(g);
    positionY(ng, options);
    const xs = positionX(ng, options);
    (_a2 = Object.keys(xs)) === null || _a2 === void 0 ? void 0 : _a2.forEach((key) => {
      ng.getNode(key).data.x = xs[key];
    });
  };

  // node_modules/@antv/layout/lib/antv-dagre/rank/util.js
  var longestPath = (g) => {
    const visited = {};
    const dfs4 = (v) => {
      var _a2;
      const label = g.getNode(v);
      if (!label)
        return 0;
      if (visited[v]) {
        return label.data.rank;
      }
      visited[v] = true;
      let rank2;
      (_a2 = g.getRelatedEdges(v, "out")) === null || _a2 === void 0 ? void 0 : _a2.forEach((e) => {
        const wRank = dfs4(e.target);
        const minLen = e.data.minlen;
        const r = wRank - minLen;
        if (r) {
          if (rank2 === void 0 || r < rank2) {
            rank2 = r;
          }
        }
      });
      if (!rank2) {
        rank2 = 0;
      }
      label.data.rank = rank2;
      return rank2;
    };
    g.getAllNodes().filter((n) => g.getRelatedEdges(n.id, "in").length === 0).forEach((source) => dfs4(source.id));
  };
  var longestPathWithLayer = (g) => {
    const visited = {};
    let minRank;
    const dfs4 = (v) => {
      var _a2;
      const label = g.getNode(v);
      if (!label)
        return 0;
      if (visited[v]) {
        return label.data.rank;
      }
      visited[v] = true;
      let rank2;
      (_a2 = g.getRelatedEdges(v, "out")) === null || _a2 === void 0 ? void 0 : _a2.forEach((e) => {
        const wRank = dfs4(e.target);
        const minLen = e.data.minlen;
        const r = wRank - minLen;
        if (r) {
          if (rank2 === void 0 || r < rank2) {
            rank2 = r;
          }
        }
      });
      if (!rank2) {
        rank2 = 0;
      }
      if (minRank === void 0 || rank2 < minRank) {
        minRank = rank2;
      }
      label.data.rank = rank2;
      return rank2;
    };
    g.getAllNodes().filter((n) => g.getRelatedEdges(n.id, "in").length === 0).forEach((source) => {
      if (source)
        dfs4(source.id);
    });
    if (minRank === void 0) {
      minRank = 0;
    }
    const forwardVisited = {};
    const dfsForward = (v, nextRank) => {
      var _a2;
      const label = g.getNode(v);
      const currRank = !isNaN(label.data.layer) ? label.data.layer : nextRank;
      if (label.data.rank === void 0 || label.data.rank < currRank) {
        label.data.rank = currRank;
      }
      if (forwardVisited[v])
        return;
      forwardVisited[v] = true;
      (_a2 = g.getRelatedEdges(v, "out")) === null || _a2 === void 0 ? void 0 : _a2.forEach((e) => {
        dfsForward(e.target, currRank + e.data.minlen);
      });
    };
    g.getAllNodes().forEach((n) => {
      const label = n.data;
      if (!label)
        return;
      if (!isNaN(label.layer)) {
        dfsForward(n.id, label.layer);
      } else {
        label.rank -= minRank;
      }
    });
  };
  var slack = (g, e) => {
    return g.getNode(e.target).data.rank - g.getNode(e.source).data.rank - e.data.minlen;
  };

  // node_modules/@antv/layout/lib/antv-dagre/rank/feasible-tree.js
  var feasibleTree = (g) => {
    const t = new Graph2({
      tree: []
    });
    const start = g.getAllNodes()[0];
    const size2 = g.getAllNodes().length;
    t.addNode(start);
    let edge;
    let delta;
    while (tightTree(t, g) < size2) {
      edge = findMinSlackEdge(t, g);
      delta = t.hasNode(edge.source) ? slack(g, edge) : -slack(g, edge);
      shiftRanks(t, g, delta);
    }
    return t;
  };
  var tightTree = (t, g) => {
    const dfs4 = (v) => {
      g.getRelatedEdges(v, "both").forEach((e) => {
        const edgeV = e.source;
        const w = v === edgeV ? e.target : edgeV;
        if (!t.hasNode(w) && !slack(g, e)) {
          t.addNode({
            id: w,
            data: {}
          });
          t.addEdge({
            id: e.id,
            source: v,
            target: w,
            data: {}
          });
          dfs4(w);
        }
      });
    };
    t.getAllNodes().forEach((n) => dfs4(n.id));
    return t.getAllNodes().length;
  };
  var feasibleTreeWithLayer = (g) => {
    const t = new Graph2({ tree: [] });
    const start = g.getAllNodes()[0];
    const size2 = g.getAllNodes().length;
    t.addNode(start);
    let edge;
    let delta;
    while (tightTreeWithLayer(t, g) < size2) {
      edge = findMinSlackEdge(t, g);
      delta = t.hasNode(edge.source) ? slack(g, edge) : -slack(g, edge);
      shiftRanks(t, g, delta);
    }
    return t;
  };
  var tightTreeWithLayer = (t, g) => {
    const dfs4 = (v) => {
      var _a2;
      (_a2 = g.getRelatedEdges(v, "both")) === null || _a2 === void 0 ? void 0 : _a2.forEach((e) => {
        const edgeV = e.source;
        const w = v === edgeV ? e.target : edgeV;
        if (!t.hasNode(w) && (g.getNode(w).data.layer !== void 0 || !slack(g, e))) {
          t.addNode({
            id: w,
            data: {}
          });
          t.addEdge({
            id: e.id,
            source: v,
            target: w,
            data: {}
          });
          dfs4(w);
        }
      });
    };
    t.getAllNodes().forEach((n) => dfs4(n.id));
    return t.getAllNodes().length;
  };
  var findMinSlackEdge = (t, g) => {
    return minBy(g.getAllEdges(), (e) => {
      if (t.hasNode(e.source) !== t.hasNode(e.target)) {
        return slack(g, e);
      }
      return Infinity;
    });
  };
  var shiftRanks = (t, g, delta) => {
    t.getAllNodes().forEach((tn) => {
      const v = g.getNode(tn.id);
      if (!v.data.rank)
        v.data.rank = 0;
      v.data.rank += delta;
    });
  };

  // node_modules/@antv/layout/lib/antv-dagre/rank/network-simplex.js
  var networkSimplex = (og) => {
    const g = simplify(og);
    longestPath(g);
    const t = feasibleTree(g);
    initLowLimValues(t);
    initCutValues(t, g);
    let e;
    let f;
    while (e = leaveEdge(t)) {
      f = enterEdge(t, g, e);
      exchangeEdges(t, g, e, f);
    }
  };
  var initCutValues = (t, g) => {
    let vs = dfs2(t, t.getAllNodes(), "post", false);
    vs = vs.slice(0, (vs === null || vs === void 0 ? void 0 : vs.length) - 1);
    vs.forEach((v) => {
      assignCutValue(t, g, v);
    });
  };
  var assignCutValue = (t, g, child) => {
    const childLab = t.getNode(child);
    const parent = childLab.data.parent;
    const edge = t.getRelatedEdges(child, "both").find((e) => e.target === parent || e.source === parent);
    edge.data.cutvalue = calcCutValue(t, g, child);
  };
  var calcCutValue = (t, g, child) => {
    const childLab = t.getNode(child);
    const parent = childLab.data.parent;
    let childIsTail = true;
    let graphEdge = g.getRelatedEdges(child, "out").find((e) => e.target === parent);
    let cutValue = 0;
    if (!graphEdge) {
      childIsTail = false;
      graphEdge = g.getRelatedEdges(parent, "out").find((e) => e.target === child);
    }
    cutValue = graphEdge.data.weight;
    g.getRelatedEdges(child, "both").forEach((e) => {
      const isOutEdge = e.source === child;
      const other = isOutEdge ? e.target : e.source;
      if (other !== parent) {
        const pointsToHead = isOutEdge === childIsTail;
        const otherWeight = e.data.weight;
        cutValue += pointsToHead ? otherWeight : -otherWeight;
        if (isTreeEdge(t, child, other)) {
          const otherCutValue = t.getRelatedEdges(child, "both").find((e3) => e3.source === other || e3.target === other).data.cutvalue;
          cutValue += pointsToHead ? -otherCutValue : otherCutValue;
        }
      }
    });
    return cutValue;
  };
  var initLowLimValues = (tree, root2 = tree.getAllNodes()[0].id) => {
    dfsAssignLowLim(tree, {}, 1, root2);
  };
  var dfsAssignLowLim = (tree, visited, nextLim, v, parent) => {
    var _a2;
    const low = nextLim;
    let useNextLim = nextLim;
    const label = tree.getNode(v);
    visited[v] = true;
    (_a2 = tree.getNeighbors(v)) === null || _a2 === void 0 ? void 0 : _a2.forEach((w) => {
      if (!visited[w.id]) {
        useNextLim = dfsAssignLowLim(tree, visited, useNextLim, w.id, v);
      }
    });
    label.data.low = low;
    label.data.lim = useNextLim++;
    if (parent) {
      label.data.parent = parent;
    } else {
      delete label.data.parent;
    }
    return useNextLim;
  };
  var leaveEdge = (tree) => {
    return tree.getAllEdges().find((e) => {
      return e.data.cutvalue < 0;
    });
  };
  var enterEdge = (t, g, edge) => {
    let v = edge.source;
    let w = edge.target;
    if (!g.getRelatedEdges(v, "out").find((e) => e.target === w)) {
      v = edge.target;
      w = edge.source;
    }
    const vLabel = t.getNode(v);
    const wLabel = t.getNode(w);
    let tailLabel = vLabel;
    let flip = false;
    if (vLabel.data.lim > wLabel.data.lim) {
      tailLabel = wLabel;
      flip = true;
    }
    const candidates = g.getAllEdges().filter((edge2) => {
      return flip === isDescendant(t.getNode(edge2.source), tailLabel) && flip !== isDescendant(t.getNode(edge2.target), tailLabel);
    });
    return minBy(candidates, (edge2) => {
      return slack(g, edge2);
    });
  };
  var exchangeEdges = (t, g, e, f) => {
    const existed = t.getRelatedEdges(e.source, "both").find((edge) => edge.source === e.target || edge.target === e.target);
    if (existed) {
      t.removeEdge(existed.id);
    }
    t.addEdge({
      id: `e${Math.random()}`,
      source: f.source,
      target: f.target,
      data: {}
    });
    initLowLimValues(t);
    initCutValues(t, g);
    updateRanks(t, g);
  };
  var updateRanks = (t, g) => {
    const root2 = t.getAllNodes().find((v) => {
      return !v.data.parent;
    });
    let vs = dfs2(t, root2, "pre", false);
    vs = vs.slice(1);
    vs.forEach((v) => {
      const parent = t.getNode(v).data.parent;
      let edge = g.getRelatedEdges(v, "out").find((e) => e.target === parent);
      let flipped = false;
      if (!edge && g.hasNode(parent)) {
        edge = g.getRelatedEdges(parent, "out").find((e) => e.target === v);
        flipped = true;
      }
      g.getNode(v).data.rank = (g.hasNode(parent) && g.getNode(parent).data.rank || 0) + (flipped ? edge === null || edge === void 0 ? void 0 : edge.data.minlen : -(edge === null || edge === void 0 ? void 0 : edge.data.minlen));
    });
  };
  var isTreeEdge = (tree, u, v) => {
    return tree.getRelatedEdges(u, "both").find((e) => e.source === v || e.target === v);
  };
  var isDescendant = (vLabel, rootLabel) => {
    return rootLabel.data.low <= vLabel.data.lim && vLabel.data.lim <= rootLabel.data.lim;
  };

  // node_modules/@antv/layout/lib/antv-dagre/rank/index.js
  var rank = (g, ranker) => {
    switch (ranker) {
      case "network-simplex":
        networkSimplexRanker(g);
        break;
      case "tight-tree":
        tightTreeRanker(g);
        break;
      case "longest-path":
        longestPathRanker(g);
        break;
      // default: networkSimplexRanker(g);
      default:
        tightTreeRanker(g);
    }
  };
  var longestPathRanker = longestPath;
  var tightTreeRanker = (g) => {
    longestPathWithLayer(g);
    feasibleTreeWithLayer(g);
  };
  var networkSimplexRanker = (g) => {
    networkSimplex(g);
  };

  // node_modules/@antv/layout/lib/antv-dagre/layout.js
  var layout = (g, options) => {
    const { edgeLabelSpace, keepNodeOrder, prevGraph, rankdir, ranksep } = options;
    if (!keepNodeOrder && prevGraph) {
      inheritOrder(g, prevGraph);
    }
    const layoutGraph = buildLayoutGraph(g);
    if (!!edgeLabelSpace) {
      options.ranksep = makeSpaceForEdgeLabels(layoutGraph, {
        rankdir,
        ranksep
      });
    }
    let dimension;
    try {
      dimension = runLayout(layoutGraph, options);
    } catch (e) {
      if (e.message === "Not possible to find intersection inside of the rectangle") {
        console.error("The following error may be caused by improper layer setting, please make sure your manual layer setting does not violate the graph's structure:\n", e);
        return;
      }
      throw e;
    }
    updateInputGraph(g, layoutGraph);
    return dimension;
  };
  var runLayout = (g, options) => {
    const { acyclicer, ranker, rankdir = "tb", nodeOrder, keepNodeOrder, align, nodesep = 50, edgesep = 20, ranksep = 50 } = options;
    removeSelfEdges(g);
    run(g, acyclicer);
    const { nestingRoot, nodeRankFactor } = run2(g);
    rank(asNonCompoundGraph(g), ranker);
    injectEdgeLabelProxies(g);
    removeEmptyRanks(g, nodeRankFactor);
    cleanup(g, nestingRoot);
    normalizeRanks(g);
    assignRankMinMax(g);
    removeEdgeLabelProxies(g);
    const dummyChains = [];
    run3(g, dummyChains);
    parentDummyChains(g, dummyChains);
    addBorderSegments(g);
    if (keepNodeOrder) {
      initDataOrder(g, nodeOrder);
    }
    order(g, keepNodeOrder);
    insertSelfEdges(g);
    adjust(g, rankdir);
    position(g, {
      align,
      nodesep,
      edgesep,
      ranksep
    });
    positionSelfEdges(g);
    removeBorderNodes(g);
    undo3(g, dummyChains);
    fixupEdgeLabelCoords(g);
    undo2(g, rankdir);
    const { width: width2, height } = translateGraph(g);
    assignNodeIntersects(g);
    reversePointsForReversedEdges(g);
    undo(g);
    return { width: width2, height };
  };
  var inheritOrder = (currG, prevG) => {
    currG.getAllNodes().forEach((n) => {
      const node = currG.getNode(n.id);
      if (prevG.hasNode(n.id)) {
        const prevNode = prevG.getNode(n.id);
        node.data.fixorder = prevNode.data._order;
        delete prevNode.data._order;
      } else {
        delete node.data.fixorder;
      }
    });
  };
  var updateInputGraph = (inputGraph, layoutGraph) => {
    inputGraph.getAllNodes().forEach((v) => {
      var _a2;
      const inputLabel = inputGraph.getNode(v.id);
      if (inputLabel) {
        const layoutLabel = layoutGraph.getNode(v.id);
        inputLabel.data.x = layoutLabel.data.x;
        inputLabel.data.y = layoutLabel.data.y;
        inputLabel.data._order = layoutLabel.data.order;
        inputLabel.data._rank = layoutLabel.data.rank;
        if ((_a2 = layoutGraph.getChildren(v.id)) === null || _a2 === void 0 ? void 0 : _a2.length) {
          inputLabel.data.width = layoutLabel.data.width;
          inputLabel.data.height = layoutLabel.data.height;
        }
      }
    });
    inputGraph.getAllEdges().forEach((e) => {
      const inputLabel = inputGraph.getEdge(e.id);
      const layoutLabel = layoutGraph.getEdge(e.id);
      inputLabel.data.points = layoutLabel ? layoutLabel.data.points : [];
      if (layoutLabel && layoutLabel.data.hasOwnProperty("x")) {
        inputLabel.data.x = layoutLabel.data.x;
        inputLabel.data.y = layoutLabel.data.y;
      }
    });
  };
  var nodeNumAttrs = ["width", "height", "layer", "fixorder"];
  var nodeDefaults = { width: 0, height: 0 };
  var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
  var edgeDefaults = {
    minlen: 1,
    weight: 1,
    width: 0,
    height: 0,
    labeloffset: 10,
    labelpos: "r"
  };
  var edgeAttrs = ["labelpos"];
  var buildLayoutGraph = (inputGraph) => {
    const g = new Graph2({ tree: [] });
    inputGraph.getAllNodes().forEach((v) => {
      const node = canonicalize(inputGraph.getNode(v.id).data);
      const defaultNode = Object.assign(Object.assign({}, nodeDefaults), node);
      const defaultAttrs = selectNumberAttrs(defaultNode, nodeNumAttrs);
      if (!g.hasNode(v.id)) {
        g.addNode({
          id: v.id,
          data: Object.assign({}, defaultAttrs)
        });
      }
      const parent = inputGraph.hasTreeStructure("combo") ? inputGraph.getParent(v.id, "combo") : inputGraph.getParent(v.id);
      if (!(0, import_util79.isNil)(parent)) {
        if (!g.hasNode(parent.id)) {
          g.addNode(Object.assign({}, parent));
        }
        g.setParent(v.id, parent.id);
      }
    });
    inputGraph.getAllEdges().forEach((e) => {
      const edge = canonicalize(inputGraph.getEdge(e.id).data);
      const pickedProperties = {};
      edgeAttrs === null || edgeAttrs === void 0 ? void 0 : edgeAttrs.forEach((key) => {
        if (edge[key] !== void 0)
          pickedProperties[key] = edge[key];
      });
      g.addEdge({
        id: e.id,
        source: e.source,
        target: e.target,
        data: Object.assign({}, edgeDefaults, selectNumberAttrs(edge, edgeNumAttrs), pickedProperties)
      });
    });
    return g;
  };
  var makeSpaceForEdgeLabels = (g, options) => {
    const { ranksep = 0, rankdir } = options;
    g.getAllNodes().forEach((node) => {
      if (!isNaN(node.data.layer)) {
        if (!node.data.layer)
          node.data.layer = 0;
      }
    });
    g.getAllEdges().forEach((edge) => {
      var _a2;
      edge.data.minlen *= 2;
      if (((_a2 = edge.data.labelpos) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase()) !== "c") {
        if (rankdir === "TB" || rankdir === "BT") {
          edge.data.width += edge.data.labeloffset;
        } else {
          edge.data.height += edge.data.labeloffset;
        }
      }
    });
    return ranksep / 2;
  };
  var injectEdgeLabelProxies = (g) => {
    g.getAllEdges().forEach((e) => {
      if (e.data.width && e.data.height) {
        const v = g.getNode(e.source);
        const w = g.getNode(e.target);
        const label = {
          e,
          rank: (w.data.rank - v.data.rank) / 2 + v.data.rank
        };
        addDummyNode(g, "edge-proxy", label, "_ep");
      }
    });
  };
  var assignRankMinMax = (g) => {
    let maxRank2 = 0;
    g.getAllNodes().forEach((node) => {
      var _a2, _b;
      if (node.data.borderTop) {
        node.data.minRank = (_a2 = g.getNode(node.data.borderTop)) === null || _a2 === void 0 ? void 0 : _a2.data.rank;
        node.data.maxRank = (_b = g.getNode(node.data.borderBottom)) === null || _b === void 0 ? void 0 : _b.data.rank;
        maxRank2 = Math.max(maxRank2, node.data.maxRank || -Infinity);
      }
    });
    return maxRank2;
  };
  var removeEdgeLabelProxies = (g) => {
    g.getAllNodes().forEach((node) => {
      if (node.data.dummy === "edge-proxy") {
        g.getEdge(node.data.e.id).data.labelRank = node.data.rank;
        g.removeNode(node.id);
      }
    });
  };
  var translateGraph = (g, options) => {
    let minX;
    let maxX = 0;
    let minY;
    let maxY = 0;
    const { marginx: marginX = 0, marginy: marginY = 0 } = options || {};
    const getExtremes = (attrs) => {
      if (!attrs.data)
        return;
      const x3 = attrs.data.x;
      const y3 = attrs.data.y;
      const w = attrs.data.width;
      const h = attrs.data.height;
      if (!isNaN(x3) && !isNaN(w)) {
        if (minX === void 0) {
          minX = x3 - w / 2;
        }
        minX = Math.min(minX, x3 - w / 2);
        maxX = Math.max(maxX, x3 + w / 2);
      }
      if (!isNaN(y3) && !isNaN(h)) {
        if (minY === void 0) {
          minY = y3 - h / 2;
        }
        minY = Math.min(minY, y3 - h / 2);
        maxY = Math.max(maxY, y3 + h / 2);
      }
    };
    g.getAllNodes().forEach((v) => {
      getExtremes(v);
    });
    g.getAllEdges().forEach((e) => {
      if (e === null || e === void 0 ? void 0 : e.data.hasOwnProperty("x")) {
        getExtremes(e);
      }
    });
    minX -= marginX;
    minY -= marginY;
    g.getAllNodes().forEach((node) => {
      node.data.x -= minX;
      node.data.y -= minY;
    });
    g.getAllEdges().forEach((edge) => {
      var _a2;
      (_a2 = edge.data.points) === null || _a2 === void 0 ? void 0 : _a2.forEach((p) => {
        p.x -= minX;
        p.y -= minY;
      });
      if (edge.data.hasOwnProperty("x")) {
        edge.data.x -= minX;
      }
      if (edge.data.hasOwnProperty("y")) {
        edge.data.y -= minY;
      }
    });
    return {
      width: maxX - minX + marginX,
      height: maxY - minY + marginY
    };
  };
  var assignNodeIntersects = (g) => {
    g.getAllEdges().forEach((e) => {
      const nodeV = g.getNode(e.source);
      const nodeW = g.getNode(e.target);
      let p1;
      let p2;
      if (!e.data.points) {
        e.data.points = [];
        p1 = { x: nodeW.data.x, y: nodeW.data.y };
        p2 = { x: nodeV.data.x, y: nodeV.data.y };
      } else {
        p1 = e.data.points[0];
        p2 = e.data.points[e.data.points.length - 1];
      }
      e.data.points.unshift(intersectRect(nodeV.data, p1));
      e.data.points.push(intersectRect(nodeW.data, p2));
    });
  };
  var fixupEdgeLabelCoords = (g) => {
    g.getAllEdges().forEach((edge) => {
      if (edge.data.hasOwnProperty("x")) {
        if (edge.data.labelpos === "l" || edge.data.labelpos === "r") {
          edge.data.width -= edge.data.labeloffset;
        }
        switch (edge.data.labelpos) {
          case "l":
            edge.data.x -= edge.data.width / 2 + edge.data.labeloffset;
            break;
          case "r":
            edge.data.x += edge.data.width / 2 + edge.data.labeloffset;
            break;
        }
      }
    });
  };
  var reversePointsForReversedEdges = (g) => {
    g.getAllEdges().forEach((edge) => {
      var _a2;
      if (edge.data.reversed) {
        (_a2 = edge.data.points) === null || _a2 === void 0 ? void 0 : _a2.reverse();
      }
    });
  };
  var removeBorderNodes = (g) => {
    g.getAllNodes().forEach((v) => {
      var _a2, _b, _c;
      if ((_a2 = g.getChildren(v.id)) === null || _a2 === void 0 ? void 0 : _a2.length) {
        const node = g.getNode(v.id);
        const t = g.getNode(node.data.borderTop);
        const b = g.getNode(node.data.borderBottom);
        const l = g.getNode(node.data.borderLeft[((_b = node.data.borderLeft) === null || _b === void 0 ? void 0 : _b.length) - 1]);
        const r = g.getNode(node.data.borderRight[((_c = node.data.borderRight) === null || _c === void 0 ? void 0 : _c.length) - 1]);
        node.data.width = Math.abs((r === null || r === void 0 ? void 0 : r.data.x) - (l === null || l === void 0 ? void 0 : l.data.x)) || 10;
        node.data.height = Math.abs((b === null || b === void 0 ? void 0 : b.data.y) - (t === null || t === void 0 ? void 0 : t.data.y)) || 10;
        node.data.x = ((l === null || l === void 0 ? void 0 : l.data.x) || 0) + node.data.width / 2;
        node.data.y = ((t === null || t === void 0 ? void 0 : t.data.y) || 0) + node.data.height / 2;
      }
    });
    g.getAllNodes().forEach((n) => {
      if (n.data.dummy === "border") {
        g.removeNode(n.id);
      }
    });
  };
  var removeSelfEdges = (g) => {
    g.getAllEdges().forEach((e) => {
      if (e.source === e.target) {
        const node = g.getNode(e.source);
        if (!node.data.selfEdges) {
          node.data.selfEdges = [];
        }
        node.data.selfEdges.push(e);
        g.removeEdge(e.id);
      }
    });
  };
  var insertSelfEdges = (g) => {
    const layers = buildLayerMatrix(g);
    layers === null || layers === void 0 ? void 0 : layers.forEach((layer) => {
      let orderShift = 0;
      layer === null || layer === void 0 ? void 0 : layer.forEach((v, i) => {
        var _a2;
        const node = g.getNode(v);
        node.data.order = i + orderShift;
        (_a2 = node.data.selfEdges) === null || _a2 === void 0 ? void 0 : _a2.forEach((selfEdge) => {
          addDummyNode(g, "selfedge", {
            width: selfEdge.data.width,
            height: selfEdge.data.height,
            rank: node.data.rank,
            order: i + ++orderShift,
            e: selfEdge
          }, "_se");
        });
        delete node.data.selfEdges;
      });
    });
  };
  var positionSelfEdges = (g) => {
    g.getAllNodes().forEach((v) => {
      const node = g.getNode(v.id);
      if (node.data.dummy === "selfedge") {
        const selfNode = g.getNode(node.data.e.source);
        const x3 = selfNode.data.x + selfNode.data.width / 2;
        const y3 = selfNode.data.y;
        const dx = node.data.x - x3;
        const dy = selfNode.data.height / 2;
        if (g.hasEdge(node.data.e.id)) {
          g.updateEdgeData(node.data.e.id, node.data.e.data);
        } else {
          g.addEdge({
            id: node.data.e.id,
            source: node.data.e.source,
            target: node.data.e.target,
            data: node.data.e.data
          });
        }
        g.removeNode(v.id);
        node.data.e.data.points = [
          { x: x3 + 2 * dx / 3, y: y3 - dy },
          { x: x3 + 5 * dx / 6, y: y3 - dy },
          { y: y3, x: x3 + dx },
          { x: x3 + 5 * dx / 6, y: y3 + dy },
          { x: x3 + 2 * dx / 3, y: y3 + dy }
        ];
        node.data.e.data.x = node.data.x;
        node.data.e.data.y = node.data.y;
      }
    });
  };
  var selectNumberAttrs = (obj, attrs) => {
    const pickedProperties = {};
    attrs === null || attrs === void 0 ? void 0 : attrs.forEach((key) => {
      if (obj[key] === void 0)
        return;
      pickedProperties[key] = +obj[key];
    });
    return pickedProperties;
  };
  var canonicalize = (attrs = {}) => {
    const newAttrs = {};
    Object.keys(attrs).forEach((k) => {
      newAttrs[k.toLowerCase()] = attrs[k];
    });
    return newAttrs;
  };

  // node_modules/@antv/layout/lib/util/array.js
  var isArray2 = Array.isArray;

  // node_modules/@antv/layout/lib/util/math.js
  var import_util81 = __toESM(require_lib());
  var floydWarshall = (adjMatrix) => {
    const dist = [];
    const size2 = adjMatrix.length;
    for (let i = 0; i < size2; i += 1) {
      dist[i] = [];
      for (let j = 0; j < size2; j += 1) {
        if (i === j) {
          dist[i][j] = 0;
        } else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {
          dist[i][j] = Infinity;
        } else {
          dist[i][j] = adjMatrix[i][j];
        }
      }
    }
    for (let k = 0; k < size2; k += 1) {
      for (let i = 0; i < size2; i += 1) {
        for (let j = 0; j < size2; j += 1) {
          if (dist[i][j] > dist[i][k] + dist[k][j]) {
            dist[i][j] = dist[i][k] + dist[k][j];
          }
        }
      }
    }
    return dist;
  };
  var getAdjMatrix = (data2, directed) => {
    const { nodes, edges } = data2;
    const matrix3 = [];
    const nodeMap = {};
    if (!nodes) {
      throw new Error("invalid nodes data!");
    }
    if (nodes) {
      nodes.forEach((node, i) => {
        nodeMap[node.id] = i;
        const row2 = [];
        matrix3.push(row2);
      });
    }
    edges === null || edges === void 0 ? void 0 : edges.forEach((e) => {
      const { source, target } = e;
      const sIndex = nodeMap[source];
      const tIndex = nodeMap[target];
      if (sIndex === void 0 || tIndex === void 0)
        return;
      matrix3[sIndex][tIndex] = 1;
      if (!directed) {
        matrix3[tIndex][sIndex] = 1;
      }
    });
    return matrix3;
  };
  var scaleMatrix = (matrix3, ratio) => {
    const result = [];
    matrix3.forEach((row2) => {
      const newRow = [];
      row2.forEach((v) => {
        newRow.push(v * ratio);
      });
      result.push(newRow);
    });
    return result;
  };
  var getLayoutBBox = (nodes) => {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    nodes.forEach((node) => {
      let size2 = node.data.size;
      if (isArray2(size2)) {
        if (size2.length === 1)
          size2 = [size2[0], size2[0]];
      } else if ((0, import_util81.isNumber)(size2)) {
        size2 = [size2, size2];
      } else if (size2 === void 0 || isNaN(size2)) {
        size2 = [30, 30];
      }
      const halfSize = [size2[0] / 2, size2[1] / 2];
      const left = node.data.x - halfSize[0];
      const right = node.data.x + halfSize[0];
      const top = node.data.y - halfSize[1];
      const bottom = node.data.y + halfSize[1];
      if (minX > left)
        minX = left;
      if (minY > top)
        minY = top;
      if (maxX < right)
        maxX = right;
      if (maxY < bottom)
        maxY = bottom;
    });
    return { minX, minY, maxX, maxY };
  };
  var getEuclideanDistance = (p1, p2) => Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
  var graphTreeDfs = (graph, nodes, fn, mode = "TB", treeKey, stopFns = {}) => {
    if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
      return;
    const { stopBranchFn, stopAllFn } = stopFns;
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (!graph.hasNode(node.id))
        continue;
      if (stopBranchFn === null || stopBranchFn === void 0 ? void 0 : stopBranchFn(node))
        continue;
      if (stopAllFn === null || stopAllFn === void 0 ? void 0 : stopAllFn(node))
        return;
      if (mode === "TB")
        fn(node);
      graphTreeDfs(graph, graph.getChildren(node.id, treeKey), fn, mode, treeKey, stopFns);
      if (mode !== "TB")
        fn(node);
    }
  };

  // node_modules/@antv/layout/lib/util/object.js
  var import_util82 = __toESM(require_lib());
  var clone4 = (target) => {
    if (target === null) {
      return target;
    }
    if (target instanceof Date) {
      return new Date(target.getTime());
    }
    if (target instanceof Array) {
      const cp = [];
      target.forEach((v) => {
        cp.push(v);
      });
      return cp.map((n) => clone4(n));
    }
    if (typeof target === "object") {
      const cp = {};
      Object.keys(target).forEach((k) => {
        cp[k] = clone4(target[k]);
      });
      return cp;
    }
    return target;
  };
  var cloneFormatData = (target, initRange) => {
    const cloned = clone4(target);
    cloned.data = cloned.data || {};
    if (initRange) {
      if (!(0, import_util82.isNumber)(cloned.data.x))
        cloned.data.x = Math.random() * initRange[0];
      if (!(0, import_util82.isNumber)(cloned.data.y))
        cloned.data.y = Math.random() * initRange[1];
    }
    return cloned;
  };

  // node_modules/@antv/layout/lib/util/function.js
  var import_util84 = __toESM(require_lib());

  // node_modules/@antv/layout/lib/util/size.js
  var import_util83 = __toESM(require_lib());
  function parseSize2(size2) {
    if (!size2)
      return [0, 0, 0];
    if ((0, import_util83.isNumber)(size2))
      return [size2, size2, size2];
    else if (size2.length === 0)
      return [0, 0, 0];
    const [x3, y3 = x3, z = x3] = size2;
    return [x3, y3, z];
  }

  // node_modules/@antv/layout/lib/util/function.js
  function formatNumberFn(defaultValue, value) {
    let resultFunc;
    if ((0, import_util84.isFunction)(value)) {
      resultFunc = value;
    } else if ((0, import_util84.isNumber)(value)) {
      resultFunc = () => value;
    } else {
      resultFunc = () => defaultValue;
    }
    return resultFunc;
  }
  function formatSizeFn(defaultValue, value, resultIsNumber = true) {
    if (!value && value !== 0) {
      return (d2) => {
        const { size: size2 } = d2.data || {};
        if (size2) {
          if (Array.isArray(size2))
            return resultIsNumber ? Math.max(...size2) || defaultValue : size2;
          if ((0, import_util84.isObject)(size2) && size2.width && size2.height) {
            return resultIsNumber ? Math.max(size2.width, size2.height) || defaultValue : [size2.width, size2.height];
          }
          return size2;
        }
        return defaultValue;
      };
    }
    if ((0, import_util84.isFunction)(value))
      return value;
    if ((0, import_util84.isNumber)(value))
      return () => value;
    if (Array.isArray(value)) {
      return () => {
        if (resultIsNumber)
          return Math.max(...value) || defaultValue;
        return value;
      };
    }
    if ((0, import_util84.isObject)(value) && value.width && value.height) {
      return () => {
        if (resultIsNumber)
          return Math.max(value.width, value.height) || defaultValue;
        return [value.width, value.height];
      };
    }
    return () => defaultValue;
  }
  var formatNodeSizeToNumber = (nodeSize, nodeSpacing, defaultNodeSize = 10) => {
    let nodeSizeFunc;
    const nodeSpacingFunc = typeof nodeSpacing === "function" ? nodeSpacing : () => nodeSpacing || 0;
    if (!nodeSize) {
      nodeSizeFunc = (d2) => {
        var _a2, _b, _c;
        if ((_a2 = d2.data) === null || _a2 === void 0 ? void 0 : _a2.bboxSize)
          return (_b = d2.data) === null || _b === void 0 ? void 0 : _b.bboxSize;
        if ((_c = d2.data) === null || _c === void 0 ? void 0 : _c.size) {
          const dataSize = d2.data.size;
          if (Array.isArray(dataSize))
            return dataSize;
          if ((0, import_util84.isObject)(dataSize))
            return [dataSize.width, dataSize.height];
          return dataSize;
        }
        return defaultNodeSize;
      };
    } else if (Array.isArray(nodeSize)) {
      nodeSizeFunc = (d2) => nodeSize;
    } else if ((0, import_util84.isFunction)(nodeSize)) {
      nodeSizeFunc = nodeSize;
    } else {
      nodeSizeFunc = (d2) => nodeSize;
    }
    const func = (d2) => {
      const nodeSize2 = nodeSizeFunc(d2);
      const nodeSpacing2 = nodeSpacingFunc(d2);
      return Math.max(...parseSize2(nodeSize2)) + nodeSpacing2;
    };
    return func;
  };

  // node_modules/@antv/layout/lib/antv-dagre.js
  var DEFAULTS_LAYOUT_OPTIONS = {
    rankdir: "TB",
    nodesep: 50,
    ranksep: 50,
    edgeLabelSpace: true,
    ranker: "tight-tree",
    controlPoints: false,
    radial: false,
    focusNode: null
    // radial 为 true 时生效，关注的节点
  };
  var AntVDagreLayout = class {
    constructor(options = {}) {
      this.options = options;
      this.id = "antv-dagre";
      this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS), options);
    }
    /**
     * Return the positions of nodes and edges(if needed).
     */
    execute(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.genericDagreLayout(false, graph, options);
      });
    }
    /**
     * To directly assign the positions to the nodes.
     */
    assign(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.genericDagreLayout(true, graph, options);
      });
    }
    genericDagreLayout(assign2, graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const mergedOptions = Object.assign(Object.assign({}, this.options), options);
        const {
          nodeSize,
          align,
          rankdir = "TB",
          ranksep,
          nodesep,
          ranksepFunc,
          nodesepFunc,
          edgeLabelSpace,
          ranker,
          nodeOrder,
          begin,
          controlPoints,
          radial,
          sortByCombo,
          // focusNode,
          preset
        } = mergedOptions;
        const g = new Graph2({
          tree: []
        });
        const ranksepfunc = formatNumberFn(ranksep || 50, ranksepFunc);
        const nodesepfunc = formatNumberFn(nodesep || 50, nodesepFunc);
        let horisep = nodesepfunc;
        let vertisep = ranksepfunc;
        if (rankdir === "LR" || rankdir === "RL") {
          horisep = ranksepfunc;
          vertisep = nodesepfunc;
        }
        const nodeSizeFunc = formatSizeFn(10, nodeSize, false);
        const nodes = graph.getAllNodes();
        const edges = graph.getAllEdges();
        nodes.forEach((node) => {
          const size2 = parseSize2(nodeSizeFunc(node));
          const verti = vertisep(node);
          const hori = horisep(node);
          const width2 = size2[0] + 2 * hori;
          const height = size2[1] + 2 * verti;
          const layer = node.data.layer;
          if ((0, import_util85.isNumber)(layer)) {
            g.addNode({
              id: node.id,
              data: { width: width2, height, layer }
            });
          } else {
            g.addNode({
              id: node.id,
              data: { width: width2, height }
            });
          }
        });
        if (sortByCombo) {
          g.attachTreeStructure("combo");
          nodes.forEach((node) => {
            const { parentId } = node.data;
            if (parentId === void 0)
              return;
            if (g.hasNode(parentId)) {
              g.setParent(node.id, parentId, "combo");
            }
          });
        }
        edges.forEach((edge) => {
          g.addEdge({
            id: edge.id,
            source: edge.source,
            target: edge.target,
            data: {
              weight: edge.data.weight || 1
            }
          });
        });
        let prevGraph = void 0;
        if (preset === null || preset === void 0 ? void 0 : preset.length) {
          prevGraph = new Graph2({
            nodes: preset
          });
        }
        layout(g, {
          prevGraph,
          edgeLabelSpace,
          keepNodeOrder: !!nodeOrder,
          nodeOrder: nodeOrder || [],
          acyclicer: "greedy",
          ranker,
          rankdir,
          nodesep,
          align
        });
        const layoutTopLeft = [0, 0];
        if (begin) {
          let minX = Infinity;
          let minY = Infinity;
          g.getAllNodes().forEach((node) => {
            if (minX > node.data.x)
              minX = node.data.x;
            if (minY > node.data.y)
              minY = node.data.y;
          });
          g.getAllEdges().forEach((edge) => {
            var _a2;
            (_a2 = edge.data.points) === null || _a2 === void 0 ? void 0 : _a2.forEach((point4) => {
              if (minX > point4.x)
                minX = point4.x;
              if (minY > point4.y)
                minY = point4.y;
            });
          });
          layoutTopLeft[0] = begin[0] - minX;
          layoutTopLeft[1] = begin[1] - minY;
        }
        const isHorizontal3 = rankdir === "LR" || rankdir === "RL";
        if (radial) {
        } else {
          const layerCoords = /* @__PURE__ */ new Set();
          const isInvert = rankdir === "BT" || rankdir === "RL";
          const layerCoordSort = isInvert ? (a2, b) => b - a2 : (a2, b) => a2 - b;
          g.getAllNodes().forEach((node) => {
            node.data.x = node.data.x + layoutTopLeft[0];
            node.data.y = node.data.y + layoutTopLeft[1];
            layerCoords.add(isHorizontal3 ? node.data.x : node.data.y);
          });
          const layerCoordsArr = Array.from(layerCoords).sort(layerCoordSort);
          const isDifferentLayer = isHorizontal3 ? (point1, point22) => point1.x !== point22.x : (point1, point22) => point1.y !== point22.y;
          const filterControlPointsOutOfBoundary = isHorizontal3 ? (ps, point1, point22) => {
            const max4 = Math.max(point1.y, point22.y);
            const min4 = Math.min(point1.y, point22.y);
            return ps.filter((point4) => point4.y <= max4 && point4.y >= min4);
          } : (ps, point1, point22) => {
            const max4 = Math.max(point1.x, point22.x);
            const min4 = Math.min(point1.x, point22.x);
            return ps.filter((point4) => point4.x <= max4 && point4.x >= min4);
          };
          g.getAllEdges().forEach((edge, i) => {
            var _a2;
            if (edgeLabelSpace && controlPoints && edge.data.type !== "loop") {
              edge.data.controlPoints = getControlPoints2((_a2 = edge.data.points) === null || _a2 === void 0 ? void 0 : _a2.map(({ x: x3, y: y3 }) => ({
                x: x3 + layoutTopLeft[0],
                y: y3 + layoutTopLeft[1]
              })), g.getNode(edge.source), g.getNode(edge.target), layerCoordsArr, isHorizontal3, isDifferentLayer, filterControlPointsOutOfBoundary);
            }
          });
        }
        let layoutNodes = [];
        layoutNodes = g.getAllNodes().map((node) => cloneFormatData(node));
        const layoutEdges = g.getAllEdges();
        if (assign2) {
          layoutNodes.forEach((node) => {
            graph.mergeNodeData(node.id, {
              x: node.data.x,
              y: node.data.y
            });
          });
          layoutEdges.forEach((edge) => {
            graph.mergeEdgeData(edge.id, {
              controlPoints: edge.data.controlPoints
            });
          });
        }
        const result = {
          nodes: layoutNodes,
          edges: layoutEdges
        };
        return result;
      });
    }
  };
  var getControlPoints2 = (points, sourceNode, targetNode, layerCoordsArr, isHorizontal3, isDifferentLayer, filterControlPointsOutOfBoundary) => {
    let controlPoints = (points === null || points === void 0 ? void 0 : points.slice(1, points.length - 1)) || [];
    if (sourceNode && targetNode) {
      let { x: sourceX, y: sourceY } = sourceNode.data;
      let { x: targetX, y: targetY } = targetNode.data;
      if (isHorizontal3) {
        sourceX = sourceNode.data.y;
        sourceY = sourceNode.data.x;
        targetX = targetNode.data.y;
        targetY = targetNode.data.x;
      }
      if (targetY !== sourceY && sourceX !== targetX) {
        const sourceLayer = layerCoordsArr.indexOf(sourceY);
        const sourceNextLayerCoord = layerCoordsArr[sourceLayer + 1];
        if (sourceNextLayerCoord) {
          const firstControlPoint = controlPoints[0];
          const insertStartControlPoint = isHorizontal3 ? {
            x: (sourceY + sourceNextLayerCoord) / 2,
            y: (firstControlPoint === null || firstControlPoint === void 0 ? void 0 : firstControlPoint.y) || targetX
          } : {
            x: (firstControlPoint === null || firstControlPoint === void 0 ? void 0 : firstControlPoint.x) || targetX,
            y: (sourceY + sourceNextLayerCoord) / 2
          };
          if (!firstControlPoint || isDifferentLayer(firstControlPoint, insertStartControlPoint)) {
            controlPoints.unshift(insertStartControlPoint);
          }
        }
        const targetLayer = layerCoordsArr.indexOf(targetY);
        const layerDiff = Math.abs(targetLayer - sourceLayer);
        if (layerDiff === 1) {
          controlPoints = filterControlPointsOutOfBoundary(controlPoints, sourceNode.data, targetNode.data);
          if (!controlPoints.length) {
            controlPoints.push(isHorizontal3 ? {
              x: (sourceY + targetY) / 2,
              y: sourceX
            } : {
              x: sourceX,
              y: (sourceY + targetY) / 2
            });
          }
        } else if (layerDiff > 1) {
          const targetLastLayerCoord = layerCoordsArr[targetLayer - 1];
          if (targetLastLayerCoord) {
            const lastControlPoints = controlPoints[controlPoints.length - 1];
            const insertEndControlPoint = isHorizontal3 ? {
              x: (targetY + targetLastLayerCoord) / 2,
              y: (lastControlPoints === null || lastControlPoints === void 0 ? void 0 : lastControlPoints.y) || targetX
            } : {
              x: (lastControlPoints === null || lastControlPoints === void 0 ? void 0 : lastControlPoints.x) || sourceX,
              y: (targetY + targetLastLayerCoord) / 2
            };
            if (!lastControlPoints || isDifferentLayer(lastControlPoints, insertEndControlPoint)) {
              controlPoints.push(insertEndControlPoint);
            }
          }
        }
      }
    }
    return controlPoints;
  };

  // node_modules/@antv/layout/lib/circular.js
  init_tslib_es6();

  // node_modules/@antv/layout/lib/util/common.js
  var handleSingleNodeGraph = (graph, assign2, center) => {
    const nodes = graph.getAllNodes();
    const edges = graph.getAllEdges();
    if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length)) {
      const result = { nodes: [], edges };
      return result;
    }
    if (nodes.length === 1) {
      if (assign2) {
        graph.mergeNodeData(nodes[0].id, {
          x: center[0],
          y: center[1]
        });
      }
      const result = {
        nodes: [
          Object.assign(Object.assign({}, nodes[0]), { data: Object.assign(Object.assign({}, nodes[0].data), { x: center[0], y: center[1] }) })
        ],
        edges
      };
      return result;
    }
  };

  // node_modules/@antv/layout/lib/circular.js
  var DEFAULTS_LAYOUT_OPTIONS2 = {
    radius: null,
    startRadius: null,
    endRadius: null,
    startAngle: 0,
    endAngle: 2 * Math.PI,
    clockwise: true,
    divisions: 1,
    ordering: null,
    angleRatio: 1
  };
  var CircularLayout = class {
    constructor(options = {}) {
      this.options = options;
      this.id = "circular";
      this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS2), options);
    }
    /**
     * Return the positions of nodes and edges(if needed).
     */
    execute(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.genericCircularLayout(false, graph, options);
      });
    }
    /**
     * To directly assign the positions to the nodes.
     */
    assign(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.genericCircularLayout(true, graph, options);
      });
    }
    genericCircularLayout(assign2, graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const mergedOptions = Object.assign(Object.assign({}, this.options), options);
        const { width: width2, height, center, divisions, startAngle = 0, endAngle = 2 * Math.PI, angleRatio, ordering, clockwise, nodeSpacing: paramNodeSpacing, nodeSize: paramNodeSize } = mergedOptions;
        const nodes = graph.getAllNodes();
        const edges = graph.getAllEdges();
        const [calculatedWidth, calculatedHeight, calculatedCenter] = calculateCenter(width2, height, center);
        const n = nodes === null || nodes === void 0 ? void 0 : nodes.length;
        if (!n || n === 1) {
          return handleSingleNodeGraph(graph, assign2, calculatedCenter);
        }
        const angleStep = (endAngle - startAngle) / n;
        let { radius, startRadius, endRadius } = mergedOptions;
        if (paramNodeSpacing) {
          const nodeSpacing = formatNumberFn(10, paramNodeSpacing);
          const nodeSize = formatSizeFn(10, paramNodeSize);
          let maxNodeSize = -Infinity;
          nodes.forEach((node) => {
            const nSize = nodeSize(node);
            if (maxNodeSize < nSize)
              maxNodeSize = nSize;
          });
          let perimeter = 0;
          nodes.forEach((node, i) => {
            if (i === 0)
              perimeter += maxNodeSize || 10;
            else
              perimeter += (nodeSpacing(node) || 0) + (maxNodeSize || 10);
          });
          radius = perimeter / (2 * Math.PI);
        } else if (!radius && !startRadius && !endRadius) {
          radius = Math.min(calculatedHeight, calculatedWidth) / 2;
        } else if (!startRadius && endRadius) {
          startRadius = endRadius;
        } else if (startRadius && !endRadius) {
          endRadius = startRadius;
        }
        const astep = angleStep * angleRatio;
        let layoutNodes = [];
        if (ordering === "topology") {
          layoutNodes = topologyOrdering(graph, nodes);
        } else if (ordering === "topology-directed") {
          layoutNodes = topologyOrdering(graph, nodes, true);
        } else if (ordering === "degree") {
          layoutNodes = degreeOrdering(graph, nodes);
        } else {
          layoutNodes = nodes.map((node) => cloneFormatData(node));
        }
        const divN = Math.ceil(n / divisions);
        for (let i = 0; i < n; ++i) {
          let r = radius;
          if (!r && startRadius !== null && endRadius !== null) {
            r = startRadius + i * (endRadius - startRadius) / (n - 1);
          }
          if (!r) {
            r = 10 + i * 100 / (n - 1);
          }
          let angle2 = startAngle + i % divN * astep + 2 * Math.PI / divisions * Math.floor(i / divN);
          if (!clockwise) {
            angle2 = endAngle - i % divN * astep - 2 * Math.PI / divisions * Math.floor(i / divN);
          }
          layoutNodes[i].data.x = calculatedCenter[0] + Math.cos(angle2) * r;
          layoutNodes[i].data.y = calculatedCenter[1] + Math.sin(angle2) * r;
        }
        if (assign2) {
          layoutNodes.forEach((node) => {
            graph.mergeNodeData(node.id, {
              x: node.data.x,
              y: node.data.y
            });
          });
        }
        const result = {
          nodes: layoutNodes,
          edges
        };
        return result;
      });
    }
  };
  var topologyOrdering = (graph, nodes, directed = false) => {
    const orderedCNodes = [cloneFormatData(nodes[0])];
    const pickFlags = {};
    const n = nodes.length;
    pickFlags[nodes[0].id] = true;
    let k = 0;
    nodes.forEach((node, i) => {
      if (i !== 0) {
        if ((i === n - 1 || graph.getDegree(node.id, "both") !== graph.getDegree(nodes[i + 1].id, "both") || graph.areNeighbors(orderedCNodes[k].id, node.id)) && !pickFlags[node.id]) {
          orderedCNodes.push(cloneFormatData(node));
          pickFlags[node.id] = true;
          k++;
        } else {
          const children = directed ? graph.getSuccessors(orderedCNodes[k].id) : graph.getNeighbors(orderedCNodes[k].id);
          let foundChild = false;
          for (let j = 0; j < children.length; j++) {
            const child = children[j];
            if (graph.getDegree(child.id) === graph.getDegree(node.id) && !pickFlags[child.id]) {
              orderedCNodes.push(cloneFormatData(child));
              pickFlags[child.id] = true;
              foundChild = true;
              break;
            }
          }
          let ii = 0;
          while (!foundChild) {
            if (!pickFlags[nodes[ii].id]) {
              orderedCNodes.push(cloneFormatData(nodes[ii]));
              pickFlags[nodes[ii].id] = true;
              foundChild = true;
            }
            ii++;
            if (ii === n) {
              break;
            }
          }
        }
      }
    });
    return orderedCNodes;
  };
  function degreeOrdering(graph, nodes) {
    const orderedNodes = [];
    nodes.forEach((node, i) => {
      orderedNodes.push(cloneFormatData(node));
    });
    orderedNodes.sort((nodeA, nodeB) => graph.getDegree(nodeA.id, "both") - graph.getDegree(nodeB.id, "both"));
    return orderedNodes;
  }
  var calculateCenter = (width2, height, center) => {
    let calculatedWidth = width2;
    let calculatedHeight = height;
    let calculatedCenter = center;
    if (!calculatedWidth && typeof window !== "undefined") {
      calculatedWidth = window.innerWidth;
    }
    if (!calculatedHeight && typeof window !== "undefined") {
      calculatedHeight = window.innerHeight;
    }
    if (!calculatedCenter) {
      calculatedCenter = [calculatedWidth / 2, calculatedHeight / 2];
    }
    return [calculatedWidth, calculatedHeight, calculatedCenter];
  };

  // node_modules/@antv/layout/lib/combo-combined.js
  init_tslib_es6();
  var import_util93 = __toESM(require_lib());

  // node_modules/@antv/layout/lib/concentric.js
  init_tslib_es6();
  var import_util88 = __toESM(require_lib());
  var DEFAULTS_LAYOUT_OPTIONS3 = {
    nodeSize: 30,
    nodeSpacing: 10,
    preventOverlap: false,
    sweep: void 0,
    equidistant: false,
    startAngle: 3 / 2 * Math.PI,
    clockwise: true,
    maxLevelDiff: void 0,
    sortBy: "degree"
  };
  var ConcentricLayout = class {
    constructor(options = {}) {
      this.options = options;
      this.id = "concentric";
      this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS3), options);
    }
    /**
     * Return the positions of nodes and edges(if needed).
     */
    execute(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.genericConcentricLayout(false, graph, options);
      });
    }
    /**
     * To directly assign the positions to the nodes.
     */
    assign(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.genericConcentricLayout(true, graph, options);
      });
    }
    genericConcentricLayout(assign2, graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const mergedOptions = Object.assign(Object.assign({}, this.options), options);
        const { center: propsCenter, width: propsWidth, height: propsHeight, sortBy: propsSortBy, maxLevelDiff: propsMaxLevelDiff, sweep: propsSweep, clockwise, equidistant, preventOverlap, startAngle = 3 / 2 * Math.PI, nodeSize, nodeSpacing } = mergedOptions;
        const nodes = graph.getAllNodes();
        const edges = graph.getAllEdges();
        const width2 = !propsWidth && typeof window !== "undefined" ? window.innerWidth : propsWidth;
        const height = !propsHeight && typeof window !== "undefined" ? window.innerHeight : propsHeight;
        const center = !propsCenter ? [width2 / 2, height / 2] : propsCenter;
        if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length) || nodes.length === 1) {
          return handleSingleNodeGraph(graph, assign2, center);
        }
        const layoutNodes = [];
        let maxNodeSize;
        let maxNodeSpacing = 0;
        if (isArray2(nodeSize)) {
          maxNodeSize = Math.max(nodeSize[0], nodeSize[1]);
        } else if ((0, import_util88.isFunction)(nodeSize)) {
          maxNodeSize = -Infinity;
          nodes.forEach((node) => {
            const currentSize = Math.max(...parseSize2(nodeSize(node)));
            if (currentSize > maxNodeSize)
              maxNodeSize = currentSize;
          });
        } else {
          maxNodeSize = nodeSize;
        }
        if (isArray2(nodeSpacing)) {
          maxNodeSpacing = Math.max(nodeSpacing[0], nodeSpacing[1]);
        } else if ((0, import_util88.isNumber)(nodeSpacing)) {
          maxNodeSpacing = nodeSpacing;
        }
        nodes.forEach((node) => {
          const cnode = cloneFormatData(node);
          layoutNodes.push(cnode);
          let nodeSize2 = maxNodeSize;
          const { data: data2 } = cnode;
          if (isArray2(data2.size)) {
            nodeSize2 = Math.max(data2.size[0], data2.size[1]);
          } else if ((0, import_util88.isNumber)(data2.size)) {
            nodeSize2 = data2.size;
          } else if ((0, import_util88.isObject)(data2.size)) {
            nodeSize2 = Math.max(data2.size.width, data2.size.height);
          }
          maxNodeSize = Math.max(maxNodeSize, nodeSize2);
          if ((0, import_util88.isFunction)(nodeSpacing)) {
            maxNodeSpacing = Math.max(nodeSpacing(node), maxNodeSpacing);
          }
        });
        const nodeIdxMap = {};
        layoutNodes.forEach((node, i) => {
          nodeIdxMap[node.id] = i;
        });
        let sortBy = propsSortBy;
        if (!(0, import_util88.isString)(sortBy) || layoutNodes[0].data[sortBy] === void 0) {
          sortBy = "degree";
        }
        if (sortBy === "degree") {
          layoutNodes.sort((n1, n2) => graph.getDegree(n2.id, "both") - graph.getDegree(n1.id, "both"));
        } else {
          layoutNodes.sort((n1, n2) => n2.data[sortBy] - n1.data[sortBy]);
        }
        const maxValueNode = layoutNodes[0];
        const maxLevelDiff = (propsMaxLevelDiff || (sortBy === "degree" ? graph.getDegree(maxValueNode.id, "both") : maxValueNode.data[sortBy])) / 4;
        const levels = [{ nodes: [] }];
        let currentLevel = levels[0];
        layoutNodes.forEach((node) => {
          if (currentLevel.nodes.length > 0) {
            const diff = sortBy === "degree" ? Math.abs(graph.getDegree(currentLevel.nodes[0].id, "both") - graph.getDegree(node.id, "both")) : Math.abs(currentLevel.nodes[0].data[sortBy] - node.data[sortBy]);
            if (maxLevelDiff && diff >= maxLevelDiff) {
              currentLevel = { nodes: [] };
              levels.push(currentLevel);
            }
          }
          currentLevel.nodes.push(node);
        });
        let minDist = maxNodeSize + maxNodeSpacing;
        if (!preventOverlap) {
          const firstLvlHasMulti = levels.length > 0 && levels[0].nodes.length > 1;
          const maxR = Math.min(width2, height) / 2 - minDist;
          const rStep = maxR / (levels.length + (firstLvlHasMulti ? 1 : 0));
          minDist = Math.min(minDist, rStep);
        }
        let r = 0;
        levels.forEach((level) => {
          const sweep = propsSweep === void 0 ? 2 * Math.PI - 2 * Math.PI / level.nodes.length : propsSweep;
          level.dTheta = sweep / Math.max(1, level.nodes.length - 1);
          if (level.nodes.length > 1 && preventOverlap) {
            const dcos = Math.cos(level.dTheta) - Math.cos(0);
            const dsin = Math.sin(level.dTheta) - Math.sin(0);
            const rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin));
            r = Math.max(rMin, r);
          }
          level.r = r;
          r += minDist;
        });
        if (equidistant) {
          let rDeltaMax = 0;
          let rr = 0;
          for (let i = 0; i < levels.length; i++) {
            const level = levels[i];
            const rDelta = (level.r || 0) - rr;
            rDeltaMax = Math.max(rDeltaMax, rDelta);
          }
          rr = 0;
          levels.forEach((level, i) => {
            if (i === 0) {
              rr = level.r || 0;
            }
            level.r = rr;
            rr += rDeltaMax;
          });
        }
        levels.forEach((level) => {
          const dTheta = level.dTheta || 0;
          const rr = level.r || 0;
          level.nodes.forEach((node, j) => {
            const theta = startAngle + (clockwise ? 1 : -1) * dTheta * j;
            node.data.x = center[0] + rr * Math.cos(theta);
            node.data.y = center[1] + rr * Math.sin(theta);
          });
        });
        if (assign2) {
          layoutNodes.forEach((node) => graph.mergeNodeData(node.id, {
            x: node.data.x,
            y: node.data.y
          }));
        }
        const result = {
          nodes: layoutNodes,
          edges
        };
        return result;
      });
    }
  };

  // node_modules/@antv/layout/lib/force/index.js
  init_tslib_es6();
  var import_util90 = __toESM(require_lib());

  // node_modules/d3-quadtree/src/add.js
  function add_default(d2) {
    const x3 = +this._x.call(null, d2), y3 = +this._y.call(null, d2);
    return add2(this.cover(x3, y3), x3, y3, d2);
  }
  function add2(tree, x3, y3, d2) {
    if (isNaN(x3) || isNaN(y3)) return tree;
    var parent, node = tree._root, leaf = { data: d2 }, x0 = tree._x0, y0 = tree._y0, x1 = tree._x1, y1 = tree._y1, xm, ym, xp, yp, right, bottom, i, j;
    if (!node) return tree._root = leaf, tree;
    while (node.length) {
      if (right = x3 >= (xm = (x0 + x1) / 2)) x0 = xm;
      else x1 = xm;
      if (bottom = y3 >= (ym = (y0 + y1) / 2)) y0 = ym;
      else y1 = ym;
      if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
    }
    xp = +tree._x.call(null, node.data);
    yp = +tree._y.call(null, node.data);
    if (x3 === xp && y3 === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
    do {
      parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
      if (right = x3 >= (xm = (x0 + x1) / 2)) x0 = xm;
      else x1 = xm;
      if (bottom = y3 >= (ym = (y0 + y1) / 2)) y0 = ym;
      else y1 = ym;
    } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));
    return parent[j] = node, parent[i] = leaf, tree;
  }
  function addAll(data2) {
    var d2, i, n = data2.length, x3, y3, xz = new Array(n), yz = new Array(n), x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
    for (i = 0; i < n; ++i) {
      if (isNaN(x3 = +this._x.call(null, d2 = data2[i])) || isNaN(y3 = +this._y.call(null, d2))) continue;
      xz[i] = x3;
      yz[i] = y3;
      if (x3 < x0) x0 = x3;
      if (x3 > x1) x1 = x3;
      if (y3 < y0) y0 = y3;
      if (y3 > y1) y1 = y3;
    }
    if (x0 > x1 || y0 > y1) return this;
    this.cover(x0, y0).cover(x1, y1);
    for (i = 0; i < n; ++i) {
      add2(this, xz[i], yz[i], data2[i]);
    }
    return this;
  }

  // node_modules/d3-quadtree/src/cover.js
  function cover_default(x3, y3) {
    if (isNaN(x3 = +x3) || isNaN(y3 = +y3)) return this;
    var x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1;
    if (isNaN(x0)) {
      x1 = (x0 = Math.floor(x3)) + 1;
      y1 = (y0 = Math.floor(y3)) + 1;
    } else {
      var z = x1 - x0 || 1, node = this._root, parent, i;
      while (x0 > x3 || x3 >= x1 || y0 > y3 || y3 >= y1) {
        i = (y3 < y0) << 1 | x3 < x0;
        parent = new Array(4), parent[i] = node, node = parent, z *= 2;
        switch (i) {
          case 0:
            x1 = x0 + z, y1 = y0 + z;
            break;
          case 1:
            x0 = x1 - z, y1 = y0 + z;
            break;
          case 2:
            x1 = x0 + z, y0 = y1 - z;
            break;
          case 3:
            x0 = x1 - z, y0 = y1 - z;
            break;
        }
      }
      if (this._root && this._root.length) this._root = node;
    }
    this._x0 = x0;
    this._y0 = y0;
    this._x1 = x1;
    this._y1 = y1;
    return this;
  }

  // node_modules/d3-quadtree/src/data.js
  function data_default() {
    var data2 = [];
    this.visit(function(node) {
      if (!node.length) do
        data2.push(node.data);
      while (node = node.next);
    });
    return data2;
  }

  // node_modules/d3-quadtree/src/extent.js
  function extent_default(_2) {
    return arguments.length ? this.cover(+_2[0][0], +_2[0][1]).cover(+_2[1][0], +_2[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
  }

  // node_modules/d3-quadtree/src/quad.js
  function quad_default(node, x0, y0, x1, y1) {
    this.node = node;
    this.x0 = x0;
    this.y0 = y0;
    this.x1 = x1;
    this.y1 = y1;
  }

  // node_modules/d3-quadtree/src/find.js
  function find_default2(x3, y3, radius) {
    var data2, x0 = this._x0, y0 = this._y0, x1, y1, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q, i;
    if (node) quads.push(new quad_default(node, x0, y0, x32, y32));
    if (radius == null) radius = Infinity;
    else {
      x0 = x3 - radius, y0 = y3 - radius;
      x32 = x3 + radius, y32 = y3 + radius;
      radius *= radius;
    }
    while (q = quads.pop()) {
      if (!(node = q.node) || (x1 = q.x0) > x32 || (y1 = q.y0) > y32 || (x22 = q.x1) < x0 || (y22 = q.y1) < y0) continue;
      if (node.length) {
        var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2;
        quads.push(
          new quad_default(node[3], xm, ym, x22, y22),
          new quad_default(node[2], x1, ym, xm, y22),
          new quad_default(node[1], xm, y1, x22, ym),
          new quad_default(node[0], x1, y1, xm, ym)
        );
        if (i = (y3 >= ym) << 1 | x3 >= xm) {
          q = quads[quads.length - 1];
          quads[quads.length - 1] = quads[quads.length - 1 - i];
          quads[quads.length - 1 - i] = q;
        }
      } else {
        var dx = x3 - +this._x.call(null, node.data), dy = y3 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
        if (d2 < radius) {
          var d3 = Math.sqrt(radius = d2);
          x0 = x3 - d3, y0 = y3 - d3;
          x32 = x3 + d3, y32 = y3 + d3;
          data2 = node.data;
        }
      }
    }
    return data2;
  }

  // node_modules/d3-quadtree/src/remove.js
  function remove_default2(d2) {
    if (isNaN(x3 = +this._x.call(null, d2)) || isNaN(y3 = +this._y.call(null, d2))) return this;
    var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x3, y3, xm, ym, right, bottom, i, j;
    if (!node) return this;
    if (node.length) while (true) {
      if (right = x3 >= (xm = (x0 + x1) / 2)) x0 = xm;
      else x1 = xm;
      if (bottom = y3 >= (ym = (y0 + y1) / 2)) y0 = ym;
      else y1 = ym;
      if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
      if (!node.length) break;
      if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3]) retainer = parent, j = i;
    }
    while (node.data !== d2) if (!(previous = node, node = node.next)) return this;
    if (next = node.next) delete node.next;
    if (previous) return next ? previous.next = next : delete previous.next, this;
    if (!parent) return this._root = next, this;
    next ? parent[i] = next : delete parent[i];
    if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
      if (retainer) retainer[j] = node;
      else this._root = node;
    }
    return this;
  }
  function removeAll(data2) {
    for (var i = 0, n = data2.length; i < n; ++i) this.remove(data2[i]);
    return this;
  }

  // node_modules/d3-quadtree/src/root.js
  function root_default() {
    return this._root;
  }

  // node_modules/d3-quadtree/src/size.js
  function size_default() {
    var size2 = 0;
    this.visit(function(node) {
      if (!node.length) do
        ++size2;
      while (node = node.next);
    });
    return size2;
  }

  // node_modules/d3-quadtree/src/visit.js
  function visit_default(callback) {
    var quads = [], q, node = this._root, child, x0, y0, x1, y1;
    if (node) quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
    while (q = quads.pop()) {
      if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
        var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
        if (child = node[3]) quads.push(new quad_default(child, xm, ym, x1, y1));
        if (child = node[2]) quads.push(new quad_default(child, x0, ym, xm, y1));
        if (child = node[1]) quads.push(new quad_default(child, xm, y0, x1, ym));
        if (child = node[0]) quads.push(new quad_default(child, x0, y0, xm, ym));
      }
    }
    return this;
  }

  // node_modules/d3-quadtree/src/visitAfter.js
  function visitAfter_default(callback) {
    var quads = [], next = [], q;
    if (this._root) quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
    while (q = quads.pop()) {
      var node = q.node;
      if (node.length) {
        var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
        if (child = node[0]) quads.push(new quad_default(child, x0, y0, xm, ym));
        if (child = node[1]) quads.push(new quad_default(child, xm, y0, x1, ym));
        if (child = node[2]) quads.push(new quad_default(child, x0, ym, xm, y1));
        if (child = node[3]) quads.push(new quad_default(child, xm, ym, x1, y1));
      }
      next.push(q);
    }
    while (q = next.pop()) {
      callback(q.node, q.x0, q.y0, q.x1, q.y1);
    }
    return this;
  }

  // node_modules/d3-quadtree/src/x.js
  function defaultX(d2) {
    return d2[0];
  }
  function x_default(_2) {
    return arguments.length ? (this._x = _2, this) : this._x;
  }

  // node_modules/d3-quadtree/src/y.js
  function defaultY(d2) {
    return d2[1];
  }
  function y_default(_2) {
    return arguments.length ? (this._y = _2, this) : this._y;
  }

  // node_modules/d3-quadtree/src/quadtree.js
  function quadtree(nodes, x3, y3) {
    var tree = new Quadtree(x3 == null ? defaultX : x3, y3 == null ? defaultY : y3, NaN, NaN, NaN, NaN);
    return nodes == null ? tree : tree.addAll(nodes);
  }
  function Quadtree(x3, y3, x0, y0, x1, y1) {
    this._x = x3;
    this._y = y3;
    this._x0 = x0;
    this._y0 = y0;
    this._x1 = x1;
    this._y1 = y1;
    this._root = void 0;
  }
  function leaf_copy(leaf) {
    var copy = { data: leaf.data }, next = copy;
    while (leaf = leaf.next) next = next.next = { data: leaf.data };
    return copy;
  }
  var treeProto = quadtree.prototype = Quadtree.prototype;
  treeProto.copy = function() {
    var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
    if (!node) return copy;
    if (!node.length) return copy._root = leaf_copy(node), copy;
    nodes = [{ source: node, target: copy._root = new Array(4) }];
    while (node = nodes.pop()) {
      for (var i = 0; i < 4; ++i) {
        if (child = node.source[i]) {
          if (child.length) nodes.push({ source: child, target: node.target[i] = new Array(4) });
          else node.target[i] = leaf_copy(child);
        }
      }
    }
    return copy;
  };
  treeProto.add = add_default;
  treeProto.addAll = addAll;
  treeProto.cover = cover_default;
  treeProto.data = data_default;
  treeProto.extent = extent_default;
  treeProto.find = find_default2;
  treeProto.remove = remove_default2;
  treeProto.removeAll = removeAll;
  treeProto.root = root_default;
  treeProto.size = size_default;
  treeProto.visit = visit_default;
  treeProto.visitAfter = visitAfter_default;
  treeProto.x = x_default;
  treeProto.y = y_default;

  // node_modules/d3-octree/src/add.js
  function add_default2(d2) {
    const x3 = +this._x.call(null, d2), y3 = +this._y.call(null, d2), z = +this._z.call(null, d2);
    return add3(this.cover(x3, y3, z), x3, y3, z, d2);
  }
  function add3(tree, x3, y3, z, d2) {
    if (isNaN(x3) || isNaN(y3) || isNaN(z)) return tree;
    var parent, node = tree._root, leaf = { data: d2 }, x0 = tree._x0, y0 = tree._y0, z0 = tree._z0, x1 = tree._x1, y1 = tree._y1, z1 = tree._z1, xm, ym, zm, xp, yp, zp, right, bottom, deep2, i, j;
    if (!node) return tree._root = leaf, tree;
    while (node.length) {
      if (right = x3 >= (xm = (x0 + x1) / 2)) x0 = xm;
      else x1 = xm;
      if (bottom = y3 >= (ym = (y0 + y1) / 2)) y0 = ym;
      else y1 = ym;
      if (deep2 = z >= (zm = (z0 + z1) / 2)) z0 = zm;
      else z1 = zm;
      if (parent = node, !(node = node[i = deep2 << 2 | bottom << 1 | right])) return parent[i] = leaf, tree;
    }
    xp = +tree._x.call(null, node.data);
    yp = +tree._y.call(null, node.data);
    zp = +tree._z.call(null, node.data);
    if (x3 === xp && y3 === yp && z === zp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
    do {
      parent = parent ? parent[i] = new Array(8) : tree._root = new Array(8);
      if (right = x3 >= (xm = (x0 + x1) / 2)) x0 = xm;
      else x1 = xm;
      if (bottom = y3 >= (ym = (y0 + y1) / 2)) y0 = ym;
      else y1 = ym;
      if (deep2 = z >= (zm = (z0 + z1) / 2)) z0 = zm;
      else z1 = zm;
    } while ((i = deep2 << 2 | bottom << 1 | right) === (j = (zp >= zm) << 2 | (yp >= ym) << 1 | xp >= xm));
    return parent[j] = node, parent[i] = leaf, tree;
  }
  function addAll2(data2) {
    if (!Array.isArray(data2)) data2 = Array.from(data2);
    const n = data2.length;
    const xz = new Float64Array(n);
    const yz = new Float64Array(n);
    const zz = new Float64Array(n);
    let x0 = Infinity, y0 = Infinity, z0 = Infinity, x1 = -Infinity, y1 = -Infinity, z1 = -Infinity;
    for (let i = 0, d2, x3, y3, z; i < n; ++i) {
      if (isNaN(x3 = +this._x.call(null, d2 = data2[i])) || isNaN(y3 = +this._y.call(null, d2)) || isNaN(z = +this._z.call(null, d2))) continue;
      xz[i] = x3;
      yz[i] = y3;
      zz[i] = z;
      if (x3 < x0) x0 = x3;
      if (x3 > x1) x1 = x3;
      if (y3 < y0) y0 = y3;
      if (y3 > y1) y1 = y3;
      if (z < z0) z0 = z;
      if (z > z1) z1 = z;
    }
    if (x0 > x1 || y0 > y1 || z0 > z1) return this;
    this.cover(x0, y0, z0).cover(x1, y1, z1);
    for (let i = 0; i < n; ++i) {
      add3(this, xz[i], yz[i], zz[i], data2[i]);
    }
    return this;
  }

  // node_modules/d3-octree/src/cover.js
  function cover_default2(x3, y3, z) {
    if (isNaN(x3 = +x3) || isNaN(y3 = +y3) || isNaN(z = +z)) return this;
    var x0 = this._x0, y0 = this._y0, z0 = this._z0, x1 = this._x1, y1 = this._y1, z1 = this._z1;
    if (isNaN(x0)) {
      x1 = (x0 = Math.floor(x3)) + 1;
      y1 = (y0 = Math.floor(y3)) + 1;
      z1 = (z0 = Math.floor(z)) + 1;
    } else {
      var t = x1 - x0 || 1, node = this._root, parent, i;
      while (x0 > x3 || x3 >= x1 || y0 > y3 || y3 >= y1 || z0 > z || z >= z1) {
        i = (z < z0) << 2 | (y3 < y0) << 1 | x3 < x0;
        parent = new Array(8), parent[i] = node, node = parent, t *= 2;
        switch (i) {
          case 0:
            x1 = x0 + t, y1 = y0 + t, z1 = z0 + t;
            break;
          case 1:
            x0 = x1 - t, y1 = y0 + t, z1 = z0 + t;
            break;
          case 2:
            x1 = x0 + t, y0 = y1 - t, z1 = z0 + t;
            break;
          case 3:
            x0 = x1 - t, y0 = y1 - t, z1 = z0 + t;
            break;
          case 4:
            x1 = x0 + t, y1 = y0 + t, z0 = z1 - t;
            break;
          case 5:
            x0 = x1 - t, y1 = y0 + t, z0 = z1 - t;
            break;
          case 6:
            x1 = x0 + t, y0 = y1 - t, z0 = z1 - t;
            break;
          case 7:
            x0 = x1 - t, y0 = y1 - t, z0 = z1 - t;
            break;
        }
      }
      if (this._root && this._root.length) this._root = node;
    }
    this._x0 = x0;
    this._y0 = y0;
    this._z0 = z0;
    this._x1 = x1;
    this._y1 = y1;
    this._z1 = z1;
    return this;
  }

  // node_modules/d3-octree/src/data.js
  function data_default2() {
    var data2 = [];
    this.visit(function(node) {
      if (!node.length) do
        data2.push(node.data);
      while (node = node.next);
    });
    return data2;
  }

  // node_modules/d3-octree/src/extent.js
  function extent_default2(_2) {
    return arguments.length ? this.cover(+_2[0][0], +_2[0][1], +_2[0][2]).cover(+_2[1][0], +_2[1][1], +_2[1][2]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0, this._z0], [this._x1, this._y1, this._z1]];
  }

  // node_modules/d3-octree/src/octant.js
  function octant_default(node, x0, y0, z0, x1, y1, z1) {
    this.node = node;
    this.x0 = x0;
    this.y0 = y0;
    this.z0 = z0;
    this.x1 = x1;
    this.y1 = y1;
    this.z1 = z1;
  }

  // node_modules/d3-octree/src/find.js
  function find_default3(x3, y3, z, radius) {
    var data2, x0 = this._x0, y0 = this._y0, z0 = this._z0, x1, y1, z1, x22, y22, z2, x32 = this._x1, y32 = this._y1, z3 = this._z1, octs = [], node = this._root, q, i;
    if (node) octs.push(new octant_default(node, x0, y0, z0, x32, y32, z3));
    if (radius == null) radius = Infinity;
    else {
      x0 = x3 - radius, y0 = y3 - radius, z0 = z - radius;
      x32 = x3 + radius, y32 = y3 + radius, z3 = z + radius;
      radius *= radius;
    }
    while (q = octs.pop()) {
      if (!(node = q.node) || (x1 = q.x0) > x32 || (y1 = q.y0) > y32 || (z1 = q.z0) > z3 || (x22 = q.x1) < x0 || (y22 = q.y1) < y0 || (z2 = q.z1) < z0) continue;
      if (node.length) {
        var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2, zm = (z1 + z2) / 2;
        octs.push(
          new octant_default(node[7], xm, ym, zm, x22, y22, z2),
          new octant_default(node[6], x1, ym, zm, xm, y22, z2),
          new octant_default(node[5], xm, y1, zm, x22, ym, z2),
          new octant_default(node[4], x1, y1, zm, xm, ym, z2),
          new octant_default(node[3], xm, ym, z1, x22, y22, zm),
          new octant_default(node[2], x1, ym, z1, xm, y22, zm),
          new octant_default(node[1], xm, y1, z1, x22, ym, zm),
          new octant_default(node[0], x1, y1, z1, xm, ym, zm)
        );
        if (i = (z >= zm) << 2 | (y3 >= ym) << 1 | x3 >= xm) {
          q = octs[octs.length - 1];
          octs[octs.length - 1] = octs[octs.length - 1 - i];
          octs[octs.length - 1 - i] = q;
        }
      } else {
        var dx = x3 - +this._x.call(null, node.data), dy = y3 - +this._y.call(null, node.data), dz = z - +this._z.call(null, node.data), d2 = dx * dx + dy * dy + dz * dz;
        if (d2 < radius) {
          var d3 = Math.sqrt(radius = d2);
          x0 = x3 - d3, y0 = y3 - d3, z0 = z - d3;
          x32 = x3 + d3, y32 = y3 + d3, z3 = z + d3;
          data2 = node.data;
        }
      }
    }
    return data2;
  }

  // node_modules/d3-octree/src/findAll.js
  var distance3 = (x1, y1, z1, x22, y22, z2) => Math.sqrt((x1 - x22) ** 2 + (y1 - y22) ** 2 + (z1 - z2) ** 2);
  function findAllWithinRadius(x3, y3, z, radius) {
    const result = [];
    const xMin = x3 - radius;
    const yMin = y3 - radius;
    const zMin = z - radius;
    const xMax = x3 + radius;
    const yMax = y3 + radius;
    const zMax = z + radius;
    this.visit((node, x1, y1, z1, x22, y22, z2) => {
      if (!node.length) {
        do {
          const d2 = node.data;
          if (distance3(x3, y3, z, this._x(d2), this._y(d2), this._z(d2)) <= radius) {
            result.push(d2);
          }
        } while (node = node.next);
      }
      return x1 > xMax || y1 > yMax || z1 > zMax || x22 < xMin || y22 < yMin || z2 < zMin;
    });
    return result;
  }

  // node_modules/d3-octree/src/remove.js
  function remove_default3(d2) {
    if (isNaN(x3 = +this._x.call(null, d2)) || isNaN(y3 = +this._y.call(null, d2)) || isNaN(z = +this._z.call(null, d2))) return this;
    var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, z0 = this._z0, x1 = this._x1, y1 = this._y1, z1 = this._z1, x3, y3, z, xm, ym, zm, right, bottom, deep2, i, j;
    if (!node) return this;
    if (node.length) while (true) {
      if (right = x3 >= (xm = (x0 + x1) / 2)) x0 = xm;
      else x1 = xm;
      if (bottom = y3 >= (ym = (y0 + y1) / 2)) y0 = ym;
      else y1 = ym;
      if (deep2 = z >= (zm = (z0 + z1) / 2)) z0 = zm;
      else z1 = zm;
      if (!(parent = node, node = node[i = deep2 << 2 | bottom << 1 | right])) return this;
      if (!node.length) break;
      if (parent[i + 1 & 7] || parent[i + 2 & 7] || parent[i + 3 & 7] || parent[i + 4 & 7] || parent[i + 5 & 7] || parent[i + 6 & 7] || parent[i + 7 & 7]) retainer = parent, j = i;
    }
    while (node.data !== d2) if (!(previous = node, node = node.next)) return this;
    if (next = node.next) delete node.next;
    if (previous) return next ? previous.next = next : delete previous.next, this;
    if (!parent) return this._root = next, this;
    next ? parent[i] = next : delete parent[i];
    if ((node = parent[0] || parent[1] || parent[2] || parent[3] || parent[4] || parent[5] || parent[6] || parent[7]) && node === (parent[7] || parent[6] || parent[5] || parent[4] || parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
      if (retainer) retainer[j] = node;
      else this._root = node;
    }
    return this;
  }
  function removeAll2(data2) {
    for (var i = 0, n = data2.length; i < n; ++i) this.remove(data2[i]);
    return this;
  }

  // node_modules/d3-octree/src/root.js
  function root_default2() {
    return this._root;
  }

  // node_modules/d3-octree/src/size.js
  function size_default2() {
    var size2 = 0;
    this.visit(function(node) {
      if (!node.length) do
        ++size2;
      while (node = node.next);
    });
    return size2;
  }

  // node_modules/d3-octree/src/visit.js
  function visit_default2(callback) {
    var octs = [], q, node = this._root, child, x0, y0, z0, x1, y1, z1;
    if (node) octs.push(new octant_default(node, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1));
    while (q = octs.pop()) {
      if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, z0 = q.z0, x1 = q.x1, y1 = q.y1, z1 = q.z1) && node.length) {
        var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2, zm = (z0 + z1) / 2;
        if (child = node[7]) octs.push(new octant_default(child, xm, ym, zm, x1, y1, z1));
        if (child = node[6]) octs.push(new octant_default(child, x0, ym, zm, xm, y1, z1));
        if (child = node[5]) octs.push(new octant_default(child, xm, y0, zm, x1, ym, z1));
        if (child = node[4]) octs.push(new octant_default(child, x0, y0, zm, xm, ym, z1));
        if (child = node[3]) octs.push(new octant_default(child, xm, ym, z0, x1, y1, zm));
        if (child = node[2]) octs.push(new octant_default(child, x0, ym, z0, xm, y1, zm));
        if (child = node[1]) octs.push(new octant_default(child, xm, y0, z0, x1, ym, zm));
        if (child = node[0]) octs.push(new octant_default(child, x0, y0, z0, xm, ym, zm));
      }
    }
    return this;
  }

  // node_modules/d3-octree/src/visitAfter.js
  function visitAfter_default2(callback) {
    var octs = [], next = [], q;
    if (this._root) octs.push(new octant_default(this._root, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1));
    while (q = octs.pop()) {
      var node = q.node;
      if (node.length) {
        var child, x0 = q.x0, y0 = q.y0, z0 = q.z0, x1 = q.x1, y1 = q.y1, z1 = q.z1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2, zm = (z0 + z1) / 2;
        if (child = node[0]) octs.push(new octant_default(child, x0, y0, z0, xm, ym, zm));
        if (child = node[1]) octs.push(new octant_default(child, xm, y0, z0, x1, ym, zm));
        if (child = node[2]) octs.push(new octant_default(child, x0, ym, z0, xm, y1, zm));
        if (child = node[3]) octs.push(new octant_default(child, xm, ym, z0, x1, y1, zm));
        if (child = node[4]) octs.push(new octant_default(child, x0, y0, zm, xm, ym, z1));
        if (child = node[5]) octs.push(new octant_default(child, xm, y0, zm, x1, ym, z1));
        if (child = node[6]) octs.push(new octant_default(child, x0, ym, zm, xm, y1, z1));
        if (child = node[7]) octs.push(new octant_default(child, xm, ym, zm, x1, y1, z1));
      }
      next.push(q);
    }
    while (q = next.pop()) {
      callback(q.node, q.x0, q.y0, q.z0, q.x1, q.y1, q.z1);
    }
    return this;
  }

  // node_modules/d3-octree/src/x.js
  function defaultX2(d2) {
    return d2[0];
  }
  function x_default2(_2) {
    return arguments.length ? (this._x = _2, this) : this._x;
  }

  // node_modules/d3-octree/src/y.js
  function defaultY2(d2) {
    return d2[1];
  }
  function y_default2(_2) {
    return arguments.length ? (this._y = _2, this) : this._y;
  }

  // node_modules/d3-octree/src/z.js
  function defaultZ(d2) {
    return d2[2];
  }
  function z_default(_2) {
    return arguments.length ? (this._z = _2, this) : this._z;
  }

  // node_modules/d3-octree/src/octree.js
  function octree(nodes, x3, y3, z) {
    var tree = new Octree(x3 == null ? defaultX2 : x3, y3 == null ? defaultY2 : y3, z == null ? defaultZ : z, NaN, NaN, NaN, NaN, NaN, NaN);
    return nodes == null ? tree : tree.addAll(nodes);
  }
  function Octree(x3, y3, z, x0, y0, z0, x1, y1, z1) {
    this._x = x3;
    this._y = y3;
    this._z = z;
    this._x0 = x0;
    this._y0 = y0;
    this._z0 = z0;
    this._x1 = x1;
    this._y1 = y1;
    this._z1 = z1;
    this._root = void 0;
  }
  function leaf_copy2(leaf) {
    var copy = { data: leaf.data }, next = copy;
    while (leaf = leaf.next) next = next.next = { data: leaf.data };
    return copy;
  }
  var treeProto2 = octree.prototype = Octree.prototype;
  treeProto2.copy = function() {
    var copy = new Octree(this._x, this._y, this._z, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1), node = this._root, nodes, child;
    if (!node) return copy;
    if (!node.length) return copy._root = leaf_copy2(node), copy;
    nodes = [{ source: node, target: copy._root = new Array(8) }];
    while (node = nodes.pop()) {
      for (var i = 0; i < 8; ++i) {
        if (child = node.source[i]) {
          if (child.length) nodes.push({ source: child, target: node.target[i] = new Array(8) });
          else node.target[i] = leaf_copy2(child);
        }
      }
    }
    return copy;
  };
  treeProto2.add = add_default2;
  treeProto2.addAll = addAll2;
  treeProto2.cover = cover_default2;
  treeProto2.data = data_default2;
  treeProto2.extent = extent_default2;
  treeProto2.find = find_default3;
  treeProto2.findAllWithinRadius = findAllWithinRadius;
  treeProto2.remove = remove_default3;
  treeProto2.removeAll = removeAll2;
  treeProto2.root = root_default2;
  treeProto2.size = size_default2;
  treeProto2.visit = visit_default2;
  treeProto2.visitAfter = visitAfter_default2;
  treeProto2.x = x_default2;
  treeProto2.y = y_default2;
  treeProto2.z = z_default;

  // node_modules/@antv/layout/lib/force/force-n-body.js
  var theta2 = 0.81;
  var epsilon = 0.1;
  function forceNBody(calcGraph, factor, coulombDisScale2, accMap, dimensions = 2) {
    const weightParam = factor / coulombDisScale2;
    const calcNodes = calcGraph.getAllNodes();
    const data2 = calcNodes.map((calcNode, i) => {
      const { nodeStrength, x: x3, y: y3, z, size: size2 } = calcNode.data;
      return {
        x: x3,
        y: y3,
        z,
        size: size2,
        index: i,
        id: calcNode.id,
        vx: 0,
        vy: 0,
        vz: 0,
        weight: weightParam * nodeStrength
      };
    });
    const tree = (dimensions === 2 ? quadtree(data2, (d2) => d2.x, (d2) => d2.y) : octree(data2, (d2) => d2.x, (d2) => d2.y, (d2) => d2.z)).visitAfter(accumulate);
    const nodeMap = /* @__PURE__ */ new Map();
    data2.forEach((n) => {
      nodeMap.set(n.id, n);
      computeForce(n, tree, dimensions);
    });
    data2.map((n, i) => {
      const { id: id3, data: data3 } = calcNodes[i];
      const { mass = 1 } = data3;
      accMap[id3] = {
        x: n.vx / mass,
        y: n.vy / mass,
        z: n.vz / mass
      };
    });
    return accMap;
  }
  function accumulate(treeNode) {
    let accWeight = 0;
    let accX = 0;
    let accY = 0;
    let accZ = 0;
    let accSize = 0;
    const numChildren = treeNode.length;
    if (numChildren) {
      for (let i = 0; i < numChildren; i++) {
        const q = treeNode[i];
        if (q && q.weight) {
          accWeight += q.weight;
          accX += q.x * q.weight;
          accY += q.y * q.weight;
          accZ += q.z * q.weight;
          accSize += q.size * q.weight;
        }
      }
      treeNode.x = accX / accWeight;
      treeNode.y = accY / accWeight;
      treeNode.z = accZ / accWeight;
      treeNode.size = accSize / accWeight;
      treeNode.weight = accWeight;
    } else {
      const q = treeNode;
      treeNode.x = q.data.x;
      treeNode.y = q.data.y;
      treeNode.z = q.data.z;
      treeNode.size = q.data.size;
      treeNode.weight = q.data.weight;
    }
  }
  var apply = (treeNode, x1, arg1, arg2, arg3, node, dimensions) => {
    var _a2;
    if (((_a2 = treeNode.data) === null || _a2 === void 0 ? void 0 : _a2.id) === node.id)
      return;
    const x22 = [arg1, arg2, arg3][dimensions - 1];
    const dx = node.x - treeNode.x || epsilon;
    const dy = node.y - treeNode.y || epsilon;
    const dz = node.z - treeNode.z || epsilon;
    const pos = [dx, dy, dz];
    const width2 = x22 - x1;
    let len2 = 0;
    for (let i = 0; i < dimensions; i++) {
      len2 += pos[i] * pos[i];
    }
    const len1 = Math.sqrt(len2);
    const len3 = len1 * len2;
    if (width2 * width2 * theta2 < len2) {
      const param = treeNode.weight / len3;
      node.vx += dx * param;
      node.vy += dy * param;
      node.vz += dz * param;
      return true;
    }
    if (treeNode.length)
      return false;
    if (treeNode.data !== node) {
      const param = treeNode.data.weight / len3;
      node.vx += dx * param;
      node.vy += dy * param;
      node.vz += dz * param;
    }
  };
  function computeForce(node, tree, dimensions) {
    tree.visit((treeNode, x1, y1, x22, y22) => apply(treeNode, x1, y1, x22, y22, node, dimensions));
  }

  // node_modules/@antv/layout/lib/force/index.js
  var DEFAULTS_LAYOUT_OPTIONS4 = {
    dimensions: 2,
    maxIteration: 500,
    gravity: 10,
    factor: 1,
    edgeStrength: 50,
    nodeStrength: 1e3,
    coulombDisScale: 5e-3,
    damping: 0.9,
    maxSpeed: 200,
    minMovement: 0.4,
    interval: 0.02,
    linkDistance: 200,
    clusterNodeStrength: 20,
    preventOverlap: true,
    distanceThresholdMode: "mean"
  };
  var ForceLayout = class {
    constructor(options = {}) {
      this.options = options;
      this.id = "force";
      this.timeInterval = 0;
      this.judgingDistance = 0;
      this.running = false;
      this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS4), options);
    }
    /**
     * Return the positions of nodes and edges(if needed).
     */
    execute(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.genericForceLayout(false, graph, options);
      });
    }
    /**
     * To directly assign the positions to the nodes.
     */
    assign(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.genericForceLayout(true, graph, options);
      });
    }
    /**
     * Stop simulation immediately.
     */
    stop() {
      if (this.timeInterval && typeof window !== "undefined") {
        window.clearInterval(this.timeInterval);
      }
      this.running = false;
    }
    /**
     * Manually steps the simulation by the specified number of iterations.
     * @see https://github.com/d3/d3-force#simulation_tick
     */
    tick(iterations = this.options.maxIteration || 1) {
      if (this.lastResult) {
        return this.lastResult;
      }
      for (let i = 0; (this.judgingDistance > this.lastOptions.minMovement || i < 1) && i < iterations; i++) {
        this.runOneStep(this.lastCalcGraph, this.lastGraph, i, this.lastVelMap, this.lastOptions);
        this.updatePosition(this.lastGraph, this.lastCalcGraph, this.lastVelMap, this.lastOptions);
      }
      const result = {
        nodes: this.lastLayoutNodes,
        edges: this.lastLayoutEdges
      };
      if (this.lastAssign) {
        result.nodes.forEach((node) => this.lastGraph.mergeNodeData(node.id, {
          x: node.data.x,
          y: node.data.y,
          z: this.options.dimensions === 3 ? node.data.z : void 0
        }));
      }
      return result;
    }
    genericForceLayout(assign2, graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const mergedOptions = Object.assign(Object.assign({}, this.options), options);
        const nodes = graph.getAllNodes();
        const edges = graph.getAllEdges();
        const formattedOptions = this.formatOptions(mergedOptions, graph);
        const { dimensions, width: width2, height, nodeSize, getMass, nodeStrength, edgeStrength, linkDistance } = formattedOptions;
        const layoutNodes = nodes.map((node, i) => {
          return Object.assign(Object.assign({}, node), { data: Object.assign(Object.assign({}, node.data), {
            // ...randomDistribution(node, dimensions, 30, i),
            x: (0, import_util90.isNumber)(node.data.x) ? node.data.x : Math.random() * width2,
            y: (0, import_util90.isNumber)(node.data.y) ? node.data.y : Math.random() * height,
            z: (0, import_util90.isNumber)(node.data.z) ? node.data.z : Math.random() * Math.sqrt(width2 * height),
            size: nodeSize(node) || 30,
            mass: getMass(node),
            nodeStrength: nodeStrength(node)
          }) });
        });
        const layoutEdges = edges.map((edge) => Object.assign(Object.assign({}, edge), { data: Object.assign(Object.assign({}, edge.data), { edgeStrength: edgeStrength(edge), linkDistance: linkDistance(edge, graph.getNode(edge.source), graph.getNode(edge.target)) }) }));
        if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length)) {
          this.lastResult = { nodes: [], edges };
          return { nodes: [], edges };
        }
        const velMap = {};
        nodes.forEach((node, i) => {
          velMap[node.id] = {
            x: 0,
            y: 0,
            z: 0
          };
        });
        const calcGraph = new Graph2({
          nodes: layoutNodes,
          edges: layoutEdges
        });
        this.formatCentripetal(formattedOptions, calcGraph);
        const { maxIteration, minMovement, onTick } = formattedOptions;
        this.lastLayoutNodes = layoutNodes;
        this.lastLayoutEdges = layoutEdges;
        this.lastAssign = assign2;
        this.lastGraph = graph;
        this.lastCalcGraph = calcGraph;
        this.lastOptions = formattedOptions;
        this.lastVelMap = velMap;
        if (typeof window === "undefined")
          return;
        let iter = 0;
        return new Promise((resolve) => {
          this.timeInterval = window.setInterval(() => {
            if (!nodes || !this.running) {
              resolve({
                nodes: formatOutNodes(graph, layoutNodes),
                edges
              });
            }
            this.runOneStep(calcGraph, graph, iter, velMap, formattedOptions);
            this.updatePosition(graph, calcGraph, velMap, formattedOptions);
            if (assign2) {
              layoutNodes.forEach((node) => graph.mergeNodeData(node.id, {
                x: node.data.x,
                y: node.data.y,
                z: dimensions === 3 ? node.data.z : void 0
              }));
            }
            onTick === null || onTick === void 0 ? void 0 : onTick({
              nodes: formatOutNodes(graph, layoutNodes),
              edges
            });
            iter++;
            if (iter >= maxIteration || this.judgingDistance < minMovement) {
              window.clearInterval(this.timeInterval);
              resolve({
                nodes: formatOutNodes(graph, layoutNodes),
                edges
              });
            }
          }, 0);
          this.running = true;
        });
      });
    }
    /**
     * Format merged layout options.
     * @param options merged layout options
     * @param graph original graph
     * @returns
     */
    formatOptions(options, graph) {
      const formattedOptions = Object.assign({}, options);
      const { width: propsWidth, height: propsHeight, getMass } = options;
      formattedOptions.width = !propsWidth && typeof window !== "undefined" ? window.innerWidth : propsWidth;
      formattedOptions.height = !propsHeight && typeof window !== "undefined" ? window.innerHeight : propsHeight;
      if (!options.center) {
        formattedOptions.center = [
          formattedOptions.width / 2,
          formattedOptions.height / 2
        ];
      }
      if (!getMass) {
        formattedOptions.getMass = (d2) => {
          let massWeight = 1;
          if ((0, import_util90.isNumber)(d2 === null || d2 === void 0 ? void 0 : d2.data.mass))
            massWeight = d2 === null || d2 === void 0 ? void 0 : d2.data.mass;
          const degree3 = graph.getDegree(d2.id, "both");
          return !degree3 || degree3 < 5 ? massWeight : degree3 * 5 * massWeight;
        };
      }
      formattedOptions.nodeSize = formatNodeSizeToNumber(options.nodeSize, options.nodeSpacing);
      const linkDistanceFn = options.linkDistance ? formatNumberFn(1, options.linkDistance) : (edge) => {
        return 1 + formattedOptions.nodeSize(graph.getNode(edge.source)) + formattedOptions.nodeSize(graph.getNode(edge.target));
      };
      formattedOptions.linkDistance = linkDistanceFn;
      formattedOptions.nodeStrength = formatNumberFn(1, options.nodeStrength);
      formattedOptions.edgeStrength = formatNumberFn(1, options.edgeStrength);
      return formattedOptions;
    }
    /**
     * Format centripetalOption in the option.
     * @param options merged layout options
     * @param calcGraph calculation graph
     */
    formatCentripetal(options, calcGraph) {
      const { dimensions, centripetalOptions, center, clusterNodeStrength, leafCluster, clustering, nodeClusterBy } = options;
      const calcNodes = calcGraph.getAllNodes();
      const basicCentripetal = centripetalOptions || {
        leaf: 2,
        single: 2,
        others: 1,
        // eslint-disable-next-line
        center: (n) => {
          return {
            x: center[0],
            y: center[1],
            z: dimensions === 3 ? center[2] : void 0
          };
        }
      };
      if (typeof clusterNodeStrength !== "function") {
        options.clusterNodeStrength = (node) => clusterNodeStrength;
      }
      let sameTypeLeafMap;
      let clusters;
      if (leafCluster && nodeClusterBy) {
        sameTypeLeafMap = getSameTypeLeafMap(calcGraph, nodeClusterBy);
        clusters = Array.from(new Set(calcNodes === null || calcNodes === void 0 ? void 0 : calcNodes.map((node) => node.data[nodeClusterBy]))) || [];
        options.centripetalOptions = Object.assign(basicCentripetal, {
          single: 100,
          leaf: (node) => {
            const { siblingLeaves, sameTypeLeaves } = sameTypeLeafMap[node.id] || {};
            if ((sameTypeLeaves === null || sameTypeLeaves === void 0 ? void 0 : sameTypeLeaves.length) === (siblingLeaves === null || siblingLeaves === void 0 ? void 0 : siblingLeaves.length) || (clusters === null || clusters === void 0 ? void 0 : clusters.length) === 1) {
              return 1;
            }
            return options.clusterNodeStrength(node);
          },
          others: 1,
          center: (node) => {
            const degree3 = calcGraph.getDegree(node.id, "both");
            if (!degree3) {
              return {
                x: 100,
                y: 100,
                z: 0
              };
            }
            let centerPos;
            if (degree3 === 1) {
              const { sameTypeLeaves = [] } = sameTypeLeafMap[node.id] || {};
              if (sameTypeLeaves.length === 1) {
                centerPos = void 0;
              } else if (sameTypeLeaves.length > 1) {
                centerPos = getAvgNodePosition(sameTypeLeaves);
              }
            } else {
              centerPos = void 0;
            }
            return {
              x: centerPos === null || centerPos === void 0 ? void 0 : centerPos.x,
              y: centerPos === null || centerPos === void 0 ? void 0 : centerPos.y,
              z: centerPos === null || centerPos === void 0 ? void 0 : centerPos.z
            };
          }
        });
      }
      if (clustering && nodeClusterBy) {
        if (!sameTypeLeafMap) {
          sameTypeLeafMap = getSameTypeLeafMap(calcGraph, nodeClusterBy);
        }
        if (!clusters) {
          clusters = Array.from(new Set(calcNodes.map((node) => node.data[nodeClusterBy])));
        }
        clusters = clusters.filter((item) => item !== void 0);
        const centerInfo = {};
        clusters.forEach((cluster) => {
          const sameTypeNodes = calcNodes.filter((node) => node.data[nodeClusterBy] === cluster).map((node) => calcGraph.getNode(node.id));
          centerInfo[cluster] = getAvgNodePosition(sameTypeNodes);
        });
        options.centripetalOptions = Object.assign(basicCentripetal, {
          single: (node) => options.clusterNodeStrength(node),
          leaf: (node) => options.clusterNodeStrength(node),
          others: (node) => options.clusterNodeStrength(node),
          center: (node) => {
            const centerPos = centerInfo[node.data[nodeClusterBy]];
            return {
              x: centerPos === null || centerPos === void 0 ? void 0 : centerPos.x,
              y: centerPos === null || centerPos === void 0 ? void 0 : centerPos.y,
              z: centerPos === null || centerPos === void 0 ? void 0 : centerPos.z
            };
          }
        });
      }
      const { leaf, single, others } = options.centripetalOptions || {};
      if (leaf && typeof leaf !== "function") {
        options.centripetalOptions.leaf = () => leaf;
      }
      if (single && typeof single !== "function") {
        options.centripetalOptions.single = () => single;
      }
      if (others && typeof others !== "function") {
        options.centripetalOptions.others = () => others;
      }
    }
    /**
     * One iteration.
     * @param calcGraph calculation graph
     * @param graph origin graph
     * @param iter current iteration index
     * @param velMap nodes' velocity map
     * @param options formatted layout options
     * @returns
     */
    runOneStep(calcGraph, graph, iter, velMap, options) {
      const accMap = {};
      const calcNodes = calcGraph.getAllNodes();
      const calcEdges = calcGraph.getAllEdges();
      if (!(calcNodes === null || calcNodes === void 0 ? void 0 : calcNodes.length))
        return;
      const { monitor } = options;
      this.calRepulsive(calcGraph, accMap, options);
      if (calcEdges)
        this.calAttractive(calcGraph, accMap, options);
      this.calGravity(calcGraph, graph, accMap, options);
      this.updateVelocity(calcGraph, accMap, velMap, options);
      if (monitor) {
        const energy = this.calTotalEnergy(accMap, calcNodes);
        monitor({
          energy,
          nodes: graph.getAllNodes(),
          edges: graph.getAllEdges(),
          iterations: iter
        });
      }
    }
    /**
     * Calculate graph energy for monitoring convergence.
     * @param accMap acceleration map
     * @param nodes calculation nodes
     * @returns energy
     */
    calTotalEnergy(accMap, nodes) {
      if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
        return 0;
      let energy = 0;
      nodes.forEach((node, i) => {
        const vx = accMap[node.id].x;
        const vy = accMap[node.id].y;
        const vz = this.options.dimensions === 3 ? accMap[node.id].z : 0;
        const speed2 = vx * vx + vy * vy + vz * vz;
        const { mass = 1 } = node.data;
        energy += mass * speed2 * 0.5;
      });
      return energy;
    }
    /**
     * Calculate the repulsive forces according to coulombs law.
     * @param calcGraph calculation graph
     * @param accMap acceleration map
     * @param options formatted layout options
     */
    calRepulsive(calcGraph, accMap, options) {
      const { dimensions, factor, coulombDisScale } = options;
      forceNBody(calcGraph, factor, coulombDisScale * coulombDisScale, accMap, dimensions);
    }
    /**
     * Calculate the attractive forces according to hooks law.
     * @param calcGraph calculation graph
     * @param accMap acceleration map
     */
    calAttractive(calcGraph, accMap, options) {
      const { dimensions, nodeSize } = options;
      calcGraph.getAllEdges().forEach((edge, i) => {
        const { source, target } = edge;
        const sourceNode = calcGraph.getNode(source);
        const targetNode = calcGraph.getNode(target);
        if (!sourceNode || !targetNode)
          return;
        let vecX = targetNode.data.x - sourceNode.data.x;
        let vecY = targetNode.data.y - sourceNode.data.y;
        let vecZ = dimensions === 3 ? targetNode.data.z - sourceNode.data.z : 0;
        if (!vecX && !vecY) {
          vecX = Math.random() * 0.01;
          vecY = Math.random() * 0.01;
          if (dimensions === 3 && !vecZ) {
            vecZ = Math.random() * 0.01;
          }
        }
        const vecLength = Math.sqrt(vecX * vecX + vecY * vecY + vecZ * vecZ);
        if (vecLength < nodeSize(sourceNode) + nodeSize(targetNode))
          return;
        const direX = vecX / vecLength;
        const direY = vecY / vecLength;
        const direZ = vecZ / vecLength;
        const { linkDistance = 200, edgeStrength = 200 } = edge.data || {};
        const diff = linkDistance - vecLength;
        const param = diff * edgeStrength;
        const massSource = sourceNode.data.mass || 1;
        const massTarget = targetNode.data.mass || 1;
        const sourceMassRatio = 1 / massSource;
        const targetMassRatio = 1 / massTarget;
        const disX = direX * param;
        const disY = direY * param;
        const disZ = direZ * param;
        accMap[source].x -= disX * sourceMassRatio;
        accMap[source].y -= disY * sourceMassRatio;
        accMap[source].z -= disZ * sourceMassRatio;
        accMap[target].x += disX * targetMassRatio;
        accMap[target].y += disY * targetMassRatio;
        accMap[target].z += disZ * targetMassRatio;
      });
    }
    /**
     * Calculate the gravity forces toward center.
     * @param calcGraph calculation graph
     * @param graph origin graph
     * @param accMap acceleration map
     * @param options formatted layout options
     */
    calGravity(calcGraph, graph, accMap, options) {
      const { getCenter } = options;
      const calcNodes = calcGraph.getAllNodes();
      const nodes = graph.getAllNodes();
      const edges = graph.getAllEdges();
      const { width: width2, height, center, gravity: defaultGravity, centripetalOptions } = options;
      if (!calcNodes)
        return;
      calcNodes.forEach((calcNode) => {
        const { id: id3, data: data2 } = calcNode;
        const { mass, x: x3, y: y3, z } = data2;
        const node = graph.getNode(id3);
        let vecX = 0;
        let vecY = 0;
        let vecZ = 0;
        let gravity = defaultGravity;
        const inDegree = calcGraph.getDegree(id3, "in");
        const outDegree = calcGraph.getDegree(id3, "out");
        const degree3 = calcGraph.getDegree(id3, "both");
        const forceCenter = getCenter === null || getCenter === void 0 ? void 0 : getCenter(node, degree3);
        if (forceCenter) {
          const [centerX, centerY, strength] = forceCenter;
          vecX = x3 - centerX;
          vecY = y3 - centerY;
          gravity = strength;
        } else {
          vecX = x3 - center[0];
          vecY = y3 - center[1];
          vecZ = z - center[2];
        }
        if (gravity) {
          accMap[id3].x -= gravity * vecX / mass;
          accMap[id3].y -= gravity * vecY / mass;
          accMap[id3].z -= gravity * vecZ / mass;
        }
        if (centripetalOptions) {
          const { leaf, single, others, center: centriCenter } = centripetalOptions;
          const { x: centriX, y: centriY, z: centriZ, centerStrength } = (centriCenter === null || centriCenter === void 0 ? void 0 : centriCenter(node, nodes, edges, width2, height)) || {
            x: 0,
            y: 0,
            z: 0,
            centerStrength: 0
          };
          if (!(0, import_util90.isNumber)(centriX) || !(0, import_util90.isNumber)(centriY))
            return;
          const vx = (x3 - centriX) / mass;
          const vy = (y3 - centriY) / mass;
          const vz = (z - centriZ) / mass;
          if (centerStrength) {
            accMap[id3].x -= centerStrength * vx;
            accMap[id3].y -= centerStrength * vy;
            accMap[id3].z -= centerStrength * vz;
          }
          if (degree3 === 0) {
            const singleStrength = single(node);
            if (!singleStrength)
              return;
            accMap[id3].x -= singleStrength * vx;
            accMap[id3].y -= singleStrength * vy;
            accMap[id3].z -= singleStrength * vz;
            return;
          }
          if (inDegree === 0 || outDegree === 0) {
            const leafStrength = leaf(node, nodes, edges);
            if (!leafStrength)
              return;
            accMap[id3].x -= leafStrength * vx;
            accMap[id3].y -= leafStrength * vy;
            accMap[id3].z -= leafStrength * vz;
            return;
          }
          const othersStrength = others(node);
          if (!othersStrength)
            return;
          accMap[id3].x -= othersStrength * vx;
          accMap[id3].y -= othersStrength * vy;
          accMap[id3].z -= othersStrength * vz;
        }
      });
    }
    /**
     * Update the velocities for nodes.
     * @param calcGraph calculation graph
     * @param accMap acceleration map
     * @param velMap velocity map
     * @param options formatted layout options
     * @returns
     */
    updateVelocity(calcGraph, accMap, velMap, options) {
      const { damping, maxSpeed, interval: interval2, dimensions } = options;
      const calcNodes = calcGraph.getAllNodes();
      if (!(calcNodes === null || calcNodes === void 0 ? void 0 : calcNodes.length))
        return;
      calcNodes.forEach((calcNode) => {
        const { id: id3 } = calcNode;
        let vx = (velMap[id3].x + accMap[id3].x * interval2) * damping || 0.01;
        let vy = (velMap[id3].y + accMap[id3].y * interval2) * damping || 0.01;
        let vz = dimensions === 3 ? (velMap[id3].z + accMap[id3].z * interval2) * damping || 0.01 : 0;
        const vLength = Math.sqrt(vx * vx + vy * vy + vz * vz);
        if (vLength > maxSpeed) {
          const param2 = maxSpeed / vLength;
          vx = param2 * vx;
          vy = param2 * vy;
          vz = param2 * vz;
        }
        velMap[id3] = {
          x: vx,
          y: vy,
          z: vz
        };
      });
    }
    /**
     * Update nodes' positions.
     * @param graph origin graph
     * @param calcGraph calculatition graph
     * @param velMap velocity map
     * @param options formatted layou options
     * @returns
     */
    updatePosition(graph, calcGraph, velMap, options) {
      const { distanceThresholdMode, interval: interval2, dimensions } = options;
      const calcNodes = calcGraph.getAllNodes();
      if (!(calcNodes === null || calcNodes === void 0 ? void 0 : calcNodes.length)) {
        this.judgingDistance = 0;
        return;
      }
      let sum = 0;
      if (distanceThresholdMode === "max")
        this.judgingDistance = -Infinity;
      else if (distanceThresholdMode === "min")
        this.judgingDistance = Infinity;
      calcNodes.forEach((calcNode) => {
        const { id: id3 } = calcNode;
        const node = graph.getNode(id3);
        if ((0, import_util90.isNumber)(node.data.fx) && (0, import_util90.isNumber)(node.data.fy)) {
          calcGraph.mergeNodeData(id3, {
            x: node.data.fx,
            y: node.data.fy,
            z: dimensions === 3 ? node.data.fz : void 0
          });
          return;
        }
        const distX = velMap[id3].x * interval2;
        const distY = velMap[id3].y * interval2;
        const distZ = dimensions === 3 ? velMap[id3].z * interval2 : 0;
        calcGraph.mergeNodeData(id3, {
          x: calcNode.data.x + distX,
          y: calcNode.data.y + distY,
          z: calcNode.data.z + distZ
        });
        const distanceMagnitude = Math.sqrt(distX * distX + distY * distY + distZ * distZ);
        switch (distanceThresholdMode) {
          case "max":
            if (this.judgingDistance < distanceMagnitude) {
              this.judgingDistance = distanceMagnitude;
            }
            break;
          case "min":
            if (this.judgingDistance > distanceMagnitude) {
              this.judgingDistance = distanceMagnitude;
            }
            break;
          default:
            sum = sum + distanceMagnitude;
            break;
        }
      });
      if (!distanceThresholdMode || distanceThresholdMode === "mean") {
        this.judgingDistance = sum / calcNodes.length;
      }
    }
  };
  var getSameTypeLeafMap = (calcGraph, nodeClusterBy) => {
    const calcNodes = calcGraph.getAllNodes();
    if (!(calcNodes === null || calcNodes === void 0 ? void 0 : calcNodes.length))
      return {};
    const sameTypeLeafMap = {};
    calcNodes.forEach((node, i) => {
      const degree3 = calcGraph.getDegree(node.id, "both");
      if (degree3 === 1) {
        sameTypeLeafMap[node.id] = getCoreNodeAndSiblingLeaves(calcGraph, "leaf", node, nodeClusterBy);
      }
    });
    return sameTypeLeafMap;
  };
  var getCoreNodeAndSiblingLeaves = (calcGraph, type, node, nodeClusterBy) => {
    const inDegree = calcGraph.getDegree(node.id, "in");
    const outDegree = calcGraph.getDegree(node.id, "out");
    let coreNode = node;
    let siblingLeaves = [];
    if (inDegree === 0) {
      coreNode = calcGraph.getSuccessors(node.id)[0];
      siblingLeaves = calcGraph.getNeighbors(coreNode.id);
    } else if (outDegree === 0) {
      coreNode = calcGraph.getPredecessors(node.id)[0];
      siblingLeaves = calcGraph.getNeighbors(coreNode.id);
    }
    siblingLeaves = siblingLeaves.filter((node2) => calcGraph.getDegree(node2.id, "in") === 0 || calcGraph.getDegree(node2.id, "out") === 0);
    const sameTypeLeaves = getSameTypeNodes(calcGraph, type, nodeClusterBy, node, siblingLeaves);
    return { coreNode, siblingLeaves, sameTypeLeaves };
  };
  var getSameTypeNodes = (calcGraph, type, nodeClusterBy, node, relativeNodes) => {
    const typeName = node.data[nodeClusterBy] || "";
    let sameTypeNodes = (relativeNodes === null || relativeNodes === void 0 ? void 0 : relativeNodes.filter((item) => item.data[nodeClusterBy] === typeName)) || [];
    if (type === "leaf") {
      sameTypeNodes = sameTypeNodes.filter((item) => calcGraph.getDegree(item.id, "in") === 0 || calcGraph.getDegree(item.id, "out") === 0);
    }
    return sameTypeNodes;
  };
  var getAvgNodePosition = (nodes) => {
    const totalNodes = { x: 0, y: 0 };
    nodes.forEach((node) => {
      const { x: x3, y: y3 } = node.data;
      totalNodes.x += x3 || 0;
      totalNodes.y += y3 || 0;
    });
    const length = nodes.length || 1;
    return {
      x: totalNodes.x / length,
      y: totalNodes.y / length
    };
  };
  var formatOutNodes = (graph, layoutNodes) => layoutNodes.map((calcNode) => {
    const { id: id3, data: data2 } = calcNode;
    const node = graph.getNode(id3);
    return Object.assign(Object.assign({}, node), { data: Object.assign(Object.assign({}, node.data), { x: data2.x, y: data2.y, z: data2.z }) });
  });

  // node_modules/@antv/layout/lib/mds.js
  init_tslib_es6();

  // node_modules/ml-matrix/matrix.mjs
  var matrix2 = __toESM(require_matrix2(), 1);
  var Matrix2 = matrix2.Matrix;
  var SingularValueDecomposition2 = matrix2.SingularValueDecomposition;
  var matrix_default = matrix2.default.Matrix ? matrix2.default.Matrix : matrix2.Matrix;

  // node_modules/@antv/layout/lib/mds.js
  var DEFAULTS_LAYOUT_OPTIONS5 = {
    center: [0, 0],
    linkDistance: 50
  };
  var MDSLayout = class {
    constructor(options = {}) {
      this.options = options;
      this.id = "mds";
      this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS5), options);
    }
    /**
     * Return the positions of nodes and edges(if needed).
     */
    execute(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.genericMDSLayout(false, graph, options);
      });
    }
    /**
     * To directly assign the positions to the nodes.
     */
    assign(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.genericMDSLayout(true, graph, options);
      });
    }
    genericMDSLayout(assign2, graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const mergedOptions = Object.assign(Object.assign({}, this.options), options);
        const { center = [0, 0], linkDistance = 50 } = mergedOptions;
        const nodes = graph.getAllNodes();
        const edges = graph.getAllEdges();
        if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length) || nodes.length === 1) {
          return handleSingleNodeGraph(graph, assign2, center);
        }
        const adjMatrix = getAdjMatrix({ nodes, edges }, false);
        const distances = floydWarshall(adjMatrix);
        handleInfinity(distances);
        const scaledD = scaleMatrix(distances, linkDistance);
        const positions = runMDS(scaledD);
        const layoutNodes = [];
        positions.forEach((p, i) => {
          const cnode = cloneFormatData(nodes[i]);
          cnode.data.x = p[0] + center[0];
          cnode.data.y = p[1] + center[1];
          layoutNodes.push(cnode);
        });
        if (assign2) {
          layoutNodes.forEach((node) => graph.mergeNodeData(node.id, {
            x: node.data.x,
            y: node.data.y
          }));
        }
        const result = {
          nodes: layoutNodes,
          edges
        };
        return result;
      });
    }
  };
  var handleInfinity = (distances) => {
    let maxDistance = -999999;
    distances.forEach((row2) => {
      row2.forEach((value) => {
        if (value === Infinity) {
          return;
        }
        if (maxDistance < value) {
          maxDistance = value;
        }
      });
    });
    distances.forEach((row2, i) => {
      row2.forEach((value, j) => {
        if (value === Infinity) {
          distances[i][j] = maxDistance;
        }
      });
    });
  };
  var runMDS = (distances) => {
    const dimension = 2;
    const M = Matrix2.mul(Matrix2.pow(distances, 2), -0.5);
    const rowMeans = M.mean("row");
    const colMeans = M.mean("column");
    const totalMean = M.mean();
    M.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans);
    const ret = new SingularValueDecomposition2(M);
    const eigenValues = Matrix2.sqrt(ret.diagonalMatrix).diagonal();
    return ret.leftSingularVectors.toJSON().map((row2) => {
      return Matrix2.mul([row2], [eigenValues]).toJSON()[0].splice(0, dimension);
    });
  };

  // node_modules/@antv/layout/lib/types.js
  function isLayoutWithIterations(layout2) {
    return !!layout2.tick && !!layout2.stop;
  }

  // node_modules/@antv/layout/lib/combo-combined.js
  var FORCE_LAYOUT_TYPE_MAP = {
    gForce: true,
    force2: true,
    d3force: true,
    fruchterman: true,
    forceAtlas2: true,
    force: true,
    "graphin-force": true
  };
  var DEFAULTS_LAYOUT_OPTIONS6 = {
    center: [0, 0],
    comboPadding: 10,
    treeKey: "combo"
  };
  var ComboCombinedLayout = class {
    constructor(options = {}) {
      this.options = options;
      this.id = "comboCombined";
      this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS6), options);
    }
    /**
     * Return the positions of nodes and edges(if needed).
     */
    execute(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.genericComboCombinedLayout(false, graph, options);
      });
    }
    /**
     * To directly assign the positions to the nodes.
     */
    assign(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.genericComboCombinedLayout(true, graph, options);
      });
    }
    genericComboCombinedLayout(assign2, graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const mergedOptions = this.initVals(Object.assign(Object.assign({}, this.options), options));
        const { center, treeKey, outerLayout: propsOuterLayout } = mergedOptions;
        const nodes = graph.getAllNodes().filter((node) => !node.data._isCombo);
        const combos = graph.getAllNodes().filter((node) => node.data._isCombo);
        const edges = graph.getAllEdges();
        const n = nodes === null || nodes === void 0 ? void 0 : nodes.length;
        if (!n || n === 1) {
          return handleSingleNodeGraph(graph, assign2, center);
        }
        const layoutNodes = [];
        const nodeMap = /* @__PURE__ */ new Map();
        nodes.forEach((node) => {
          nodeMap.set(node.id, node);
        });
        const comboMap = /* @__PURE__ */ new Map();
        combos.forEach((combo) => {
          comboMap.set(combo.id, combo);
        });
        const comboNodes = /* @__PURE__ */ new Map();
        const innerGraphLayoutPromises = this.getInnerGraphs(graph, treeKey, nodeMap, comboMap, edges, mergedOptions, comboNodes);
        yield Promise.all(innerGraphLayoutPromises);
        const outerNodeIds = /* @__PURE__ */ new Map();
        const outerLayoutNodes = [];
        const nodeAncestorIdMap = /* @__PURE__ */ new Map();
        let allHaveNoPosition = true;
        graph.getRoots(treeKey).forEach((root2) => {
          const combo = comboNodes.get(root2.id);
          const cacheCombo = comboMap.get(root2.id) || nodeMap.get(root2.id);
          const comboLayoutNode = {
            id: root2.id,
            data: Object.assign(Object.assign({}, root2.data), { x: combo.data.x || cacheCombo.data.x, y: combo.data.y || cacheCombo.data.y, fx: combo.data.fx || cacheCombo.data.fx, fy: combo.data.fy || cacheCombo.data.fy, mass: combo.data.mass || cacheCombo.data.mass, size: combo.data.size })
          };
          outerLayoutNodes.push(comboLayoutNode);
          outerNodeIds.set(root2.id, true);
          if (!isNaN(comboLayoutNode.data.x) && comboLayoutNode.data.x !== 0 && !isNaN(comboLayoutNode.data.y) && comboLayoutNode.data.y !== 0) {
            allHaveNoPosition = false;
          } else {
            comboLayoutNode.data.x = Math.random() * 100;
            comboLayoutNode.data.y = Math.random() * 100;
          }
          graphTreeDfs(graph, [root2], (child) => {
            if (child.id !== root2.id)
              nodeAncestorIdMap.set(child.id, root2.id);
          }, "TB", treeKey);
        });
        const outerLayoutEdges = [];
        edges.forEach((edge) => {
          const sourceAncestorId = nodeAncestorIdMap.get(edge.source) || edge.source;
          const targetAncestorId = nodeAncestorIdMap.get(edge.target) || edge.target;
          if (sourceAncestorId !== targetAncestorId && outerNodeIds.has(sourceAncestorId) && outerNodeIds.has(targetAncestorId)) {
            outerLayoutEdges.push({
              id: edge.id,
              source: sourceAncestorId,
              target: targetAncestorId,
              data: {}
            });
          }
        });
        let outerPositions;
        if (outerLayoutNodes === null || outerLayoutNodes === void 0 ? void 0 : outerLayoutNodes.length) {
          if (outerLayoutNodes.length === 1) {
            outerLayoutNodes[0].data.x = center[0];
            outerLayoutNodes[0].data.y = center[1];
          } else {
            const outerLayoutGraph = new Graph2({
              nodes: outerLayoutNodes,
              edges: outerLayoutEdges
            });
            const outerLayout = propsOuterLayout || new ForceLayout();
            if (allHaveNoPosition && FORCE_LAYOUT_TYPE_MAP[outerLayout.id]) {
              const outerLayoutPreset = outerLayoutNodes.length < 100 ? new MDSLayout() : new ConcentricLayout();
              yield outerLayoutPreset.assign(outerLayoutGraph);
            }
            const options2 = Object.assign({ center, kg: 5, preventOverlap: true, animate: false }, outerLayout.id === "force" ? {
              gravity: 1,
              factor: 4,
              linkDistance: (edge, source, target) => {
                const sourceSize = Math.max(...source.data.size) || 32;
                const targetSize = Math.max(...target.data.size) || 32;
                return sourceSize / 2 + targetSize / 2 + 200;
              }
            } : {});
            outerPositions = yield executeLayout(outerLayout, outerLayoutGraph, options2);
          }
          comboNodes.forEach((comboNode) => {
            var _a2;
            const outerPosition = outerPositions.nodes.find((pos) => pos.id === comboNode.id);
            if (outerPosition) {
              const { x: x4, y: y4 } = outerPosition.data;
              comboNode.data.visited = true;
              comboNode.data.x = x4;
              comboNode.data.y = y4;
              layoutNodes.push({
                id: comboNode.id,
                data: { x: x4, y: y4 }
              });
            }
            const { x: x3, y: y3 } = comboNode.data;
            (_a2 = comboNode.data.nodes) === null || _a2 === void 0 ? void 0 : _a2.forEach((node) => {
              layoutNodes.push({
                id: node.id,
                data: { x: node.data.x + x3, y: node.data.y + y3 }
              });
            });
          });
          comboNodes.forEach(({ data: data2 }) => {
            const { x: x3, y: y3, visited, nodes: nodes2 } = data2;
            nodes2 === null || nodes2 === void 0 ? void 0 : nodes2.forEach((node) => {
              if (!visited) {
                const layoutNode = layoutNodes.find((n2) => n2.id === node.id);
                layoutNode.data.x += x3 || 0;
                layoutNode.data.y += y3 || 0;
              }
            });
          });
        }
        if (assign2) {
          layoutNodes.forEach((node) => {
            graph.mergeNodeData(node.id, {
              x: node.data.x,
              y: node.data.y
            });
          });
        }
        const result = {
          nodes: layoutNodes,
          edges
        };
        return result;
      });
    }
    initVals(options) {
      const formattedOptions = Object.assign({}, options);
      const { nodeSize, spacing, comboPadding } = options;
      let nodeSizeFunc;
      let spacingFunc;
      if ((0, import_util93.isNumber)(spacing)) {
        spacingFunc = () => spacing;
      } else if ((0, import_util93.isFunction)(spacing)) {
        spacingFunc = spacing;
      } else {
        spacingFunc = () => 0;
      }
      formattedOptions.spacing = spacingFunc;
      if (!nodeSize) {
        nodeSizeFunc = (d2) => {
          const spacing2 = spacingFunc(d2);
          if (d2.size) {
            if (isArray2(d2.size)) {
              const res = d2.size[0] > d2.size[1] ? d2.size[0] : d2.size[1];
              return (res + spacing2) / 2;
            }
            if ((0, import_util93.isObject)(d2.size)) {
              const res = d2.size.width > d2.size.height ? d2.size.width : d2.size.height;
              return (res + spacing2) / 2;
            }
            return (d2.size + spacing2) / 2;
          }
          return 32 + spacing2 / 2;
        };
      } else if ((0, import_util93.isFunction)(nodeSize)) {
        nodeSizeFunc = (d2) => {
          const size2 = nodeSize(d2);
          const spacing2 = spacingFunc(d2);
          if (isArray2(d2.size)) {
            const res = d2.size[0] > d2.size[1] ? d2.size[0] : d2.size[1];
            return (res + spacing2) / 2;
          }
          return ((size2 || 32) + spacing2) / 2;
        };
      } else if (isArray2(nodeSize)) {
        const larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];
        const radius = larger / 2;
        nodeSizeFunc = (d2) => radius + spacingFunc(d2) / 2;
      } else {
        const radius = nodeSize / 2;
        nodeSizeFunc = (d2) => radius + spacingFunc(d2) / 2;
      }
      formattedOptions.nodeSize = nodeSizeFunc;
      let comboPaddingFunc;
      if ((0, import_util93.isNumber)(comboPadding)) {
        comboPaddingFunc = () => comboPadding;
      } else if (isArray2(comboPadding)) {
        comboPaddingFunc = () => Math.max.apply(null, comboPadding);
      } else if ((0, import_util93.isFunction)(comboPadding)) {
        comboPaddingFunc = comboPadding;
      } else {
        comboPaddingFunc = () => 0;
      }
      formattedOptions.comboPadding = comboPaddingFunc;
      return formattedOptions;
    }
    getInnerGraphs(graph, treeKey, nodeMap, comboMap, edges, options, comboNodes) {
      const { nodeSize, comboPadding, spacing, innerLayout } = options;
      const innerGraphLayout = innerLayout || new ConcentricLayout({});
      const innerLayoutOptions = {
        center: [0, 0],
        preventOverlap: true,
        nodeSpacing: spacing
      };
      const innerLayoutPromises = [];
      const getSize = (node) => {
        let padding = (comboPadding === null || comboPadding === void 0 ? void 0 : comboPadding(node)) || 10;
        if (isArray2(padding))
          padding = Math.max(...padding);
        return {
          size: padding ? [padding * 2, padding * 2] : [30, 30],
          padding
        };
      };
      graph.getRoots(treeKey).forEach((root2) => {
        comboNodes.set(root2.id, {
          id: root2.id,
          data: {
            nodes: [],
            size: getSize(root2).size
          }
        });
        let start = Promise.resolve();
        graphTreeDfs(graph, [root2], (treeNode) => {
          var _a2;
          if (!treeNode.data._isCombo)
            return;
          const { size: nsize, padding } = getSize(treeNode);
          if (!((_a2 = graph.getChildren(treeNode.id, treeKey)) === null || _a2 === void 0 ? void 0 : _a2.length)) {
            comboNodes.set(treeNode.id, {
              id: treeNode.id,
              data: Object.assign(Object.assign({}, treeNode.data), { size: nsize })
            });
          } else {
            const comboNode = comboNodes.get(treeNode.id);
            comboNodes.set(treeNode.id, {
              id: treeNode.id,
              data: Object.assign({ nodes: [] }, comboNode === null || comboNode === void 0 ? void 0 : comboNode.data)
            });
            const innerLayoutNodeIds = /* @__PURE__ */ new Map();
            const innerLayoutNodes = graph.getChildren(treeNode.id, treeKey).map((child) => {
              if (child.data._isCombo) {
                if (!comboNodes.has(child.id)) {
                  comboNodes.set(child.id, {
                    id: child.id,
                    data: Object.assign({}, child.data)
                  });
                }
                innerLayoutNodeIds.set(child.id, true);
                return comboNodes.get(child.id);
              }
              const oriNode = nodeMap.get(child.id) || comboMap.get(child.id);
              innerLayoutNodeIds.set(child.id, true);
              return {
                id: child.id,
                data: Object.assign(Object.assign({}, oriNode.data), child.data)
              };
            });
            const innerGraphData = {
              nodes: innerLayoutNodes,
              edges: edges.filter((edge) => innerLayoutNodeIds.has(edge.source) && innerLayoutNodeIds.has(edge.target))
            };
            let minNodeSize = Infinity;
            innerLayoutNodes.forEach((node) => {
              var _a3;
              let { size: size2 } = node.data;
              if (!size2) {
                size2 = ((_a3 = comboNodes.get(node.id)) === null || _a3 === void 0 ? void 0 : _a3.data.size) || (nodeSize === null || nodeSize === void 0 ? void 0 : nodeSize(node)) || [30, 30];
              }
              if ((0, import_util93.isNumber)(size2))
                size2 = [size2, size2];
              const [size0, size1] = size2;
              if (minNodeSize > size0)
                minNodeSize = size0;
              if (minNodeSize > size1)
                minNodeSize = size1;
              node.data.size = size2;
            });
            start = start.then(() => __awaiter(this, void 0, void 0, function* () {
              const innerGraphCore = new Graph2(innerGraphData);
              yield executeLayout(innerGraphLayout, innerGraphCore, innerLayoutOptions, true);
              const { minX, minY, maxX, maxY } = getLayoutBBox(innerLayoutNodes);
              const center = { x: (maxX + minX) / 2, y: (maxY + minY) / 2 };
              innerGraphData.nodes.forEach((node) => {
                node.data.x -= center.x;
                node.data.y -= center.y;
              });
              const size2 = [
                Math.max(maxX - minX, minNodeSize) + padding * 2,
                Math.max(maxY - minY, minNodeSize) + padding * 2
              ];
              comboNodes.get(treeNode.id).data.size = size2;
              comboNodes.get(treeNode.id).data.nodes = innerLayoutNodes;
            }));
          }
          return true;
        }, "BT", treeKey);
        innerLayoutPromises.push(start);
      });
      return innerLayoutPromises;
    }
  };
  function executeLayout(layout2, graph, options, assign2) {
    var _a2;
    return __awaiter(this, void 0, void 0, function* () {
      if (isLayoutWithIterations(layout2)) {
        layout2.execute(graph, options);
        layout2.stop();
        return layout2.tick((_a2 = options.iterations) !== null && _a2 !== void 0 ? _a2 : 300);
      }
      if (assign2)
        return yield layout2.assign(graph, options);
      return yield layout2.execute(graph, options);
    });
  }

  // node_modules/@antv/layout/lib/d3-force/index.js
  init_tslib_es6();
  var import_util95 = __toESM(require_lib());

  // node_modules/d3-force/src/center.js
  function center_default(x3, y3) {
    var nodes, strength = 1;
    if (x3 == null) x3 = 0;
    if (y3 == null) y3 = 0;
    function force() {
      var i, n = nodes.length, node, sx = 0, sy = 0;
      for (i = 0; i < n; ++i) {
        node = nodes[i], sx += node.x, sy += node.y;
      }
      for (sx = (sx / n - x3) * strength, sy = (sy / n - y3) * strength, i = 0; i < n; ++i) {
        node = nodes[i], node.x -= sx, node.y -= sy;
      }
    }
    force.initialize = function(_2) {
      nodes = _2;
    };
    force.x = function(_2) {
      return arguments.length ? (x3 = +_2, force) : x3;
    };
    force.y = function(_2) {
      return arguments.length ? (y3 = +_2, force) : y3;
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = +_2, force) : strength;
    };
    return force;
  }

  // node_modules/d3-force/src/constant.js
  function constant_default(x3) {
    return function() {
      return x3;
    };
  }

  // node_modules/d3-force/src/jiggle.js
  function jiggle_default(random) {
    return (random() - 0.5) * 1e-6;
  }

  // node_modules/d3-force/src/collide.js
  function x(d2) {
    return d2.x + d2.vx;
  }
  function y(d2) {
    return d2.y + d2.vy;
  }
  function collide_default(radius) {
    var nodes, radii, random, strength = 1, iterations = 1;
    if (typeof radius !== "function") radius = constant_default(radius == null ? 1 : +radius);
    function force() {
      var i, n = nodes.length, tree, node, xi, yi, ri, ri2;
      for (var k = 0; k < iterations; ++k) {
        tree = quadtree(nodes, x, y).visitAfter(prepare);
        for (i = 0; i < n; ++i) {
          node = nodes[i];
          ri = radii[node.index], ri2 = ri * ri;
          xi = node.x + node.vx;
          yi = node.y + node.vy;
          tree.visit(apply3);
        }
      }
      function apply3(quad, x0, y0, x1, y1) {
        var data2 = quad.data, rj = quad.r, r = ri + rj;
        if (data2) {
          if (data2.index > node.index) {
            var x3 = xi - data2.x - data2.vx, y3 = yi - data2.y - data2.vy, l = x3 * x3 + y3 * y3;
            if (l < r * r) {
              if (x3 === 0) x3 = jiggle_default(random), l += x3 * x3;
              if (y3 === 0) y3 = jiggle_default(random), l += y3 * y3;
              l = (r - (l = Math.sqrt(l))) / l * strength;
              node.vx += (x3 *= l) * (r = (rj *= rj) / (ri2 + rj));
              node.vy += (y3 *= l) * r;
              data2.vx -= x3 * (r = 1 - r);
              data2.vy -= y3 * r;
            }
          }
          return;
        }
        return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
      }
    }
    function prepare(quad) {
      if (quad.data) return quad.r = radii[quad.data.index];
      for (var i = quad.r = 0; i < 4; ++i) {
        if (quad[i] && quad[i].r > quad.r) {
          quad.r = quad[i].r;
        }
      }
    }
    function initialize() {
      if (!nodes) return;
      var i, n = nodes.length, node;
      radii = new Array(n);
      for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
    }
    force.initialize = function(_nodes, _random) {
      nodes = _nodes;
      random = _random;
      initialize();
    };
    force.iterations = function(_2) {
      return arguments.length ? (iterations = +_2, force) : iterations;
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = +_2, force) : strength;
    };
    force.radius = function(_2) {
      return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : radius;
    };
    return force;
  }

  // node_modules/d3-force/src/link.js
  function index(d2) {
    return d2.index;
  }
  function find3(nodeById, nodeId) {
    var node = nodeById.get(nodeId);
    if (!node) throw new Error("node not found: " + nodeId);
    return node;
  }
  function link_default(links) {
    var id3 = index, strength = defaultStrength, strengths, distance6 = constant_default(30), distances, nodes, count, bias, random, iterations = 1;
    if (links == null) links = [];
    function defaultStrength(link) {
      return 1 / Math.min(count[link.source.index], count[link.target.index]);
    }
    function force(alpha) {
      for (var k = 0, n = links.length; k < iterations; ++k) {
        for (var i = 0, link, source, target, x3, y3, l, b; i < n; ++i) {
          link = links[i], source = link.source, target = link.target;
          x3 = target.x + target.vx - source.x - source.vx || jiggle_default(random);
          y3 = target.y + target.vy - source.y - source.vy || jiggle_default(random);
          l = Math.sqrt(x3 * x3 + y3 * y3);
          l = (l - distances[i]) / l * alpha * strengths[i];
          x3 *= l, y3 *= l;
          target.vx -= x3 * (b = bias[i]);
          target.vy -= y3 * b;
          source.vx += x3 * (b = 1 - b);
          source.vy += y3 * b;
        }
      }
    }
    function initialize() {
      if (!nodes) return;
      var i, n = nodes.length, m2 = links.length, nodeById = new Map(nodes.map((d2, i2) => [id3(d2, i2, nodes), d2])), link;
      for (i = 0, count = new Array(n); i < m2; ++i) {
        link = links[i], link.index = i;
        if (typeof link.source !== "object") link.source = find3(nodeById, link.source);
        if (typeof link.target !== "object") link.target = find3(nodeById, link.target);
        count[link.source.index] = (count[link.source.index] || 0) + 1;
        count[link.target.index] = (count[link.target.index] || 0) + 1;
      }
      for (i = 0, bias = new Array(m2); i < m2; ++i) {
        link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
      }
      strengths = new Array(m2), initializeStrength();
      distances = new Array(m2), initializeDistance();
    }
    function initializeStrength() {
      if (!nodes) return;
      for (var i = 0, n = links.length; i < n; ++i) {
        strengths[i] = +strength(links[i], i, links);
      }
    }
    function initializeDistance() {
      if (!nodes) return;
      for (var i = 0, n = links.length; i < n; ++i) {
        distances[i] = +distance6(links[i], i, links);
      }
    }
    force.initialize = function(_nodes, _random) {
      nodes = _nodes;
      random = _random;
      initialize();
    };
    force.links = function(_2) {
      return arguments.length ? (links = _2, initialize(), force) : links;
    };
    force.id = function(_2) {
      return arguments.length ? (id3 = _2, force) : id3;
    };
    force.iterations = function(_2) {
      return arguments.length ? (iterations = +_2, force) : iterations;
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default(+_2), initializeStrength(), force) : strength;
    };
    force.distance = function(_2) {
      return arguments.length ? (distance6 = typeof _2 === "function" ? _2 : constant_default(+_2), initializeDistance(), force) : distance6;
    };
    return force;
  }

  // node_modules/d3-dispatch/src/dispatch.js
  var noop = { value: () => {
  } };
  function dispatch() {
    for (var i = 0, n = arguments.length, _2 = {}, t; i < n; ++i) {
      if (!(t = arguments[i] + "") || t in _2 || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
      _2[t] = [];
    }
    return new Dispatch(_2);
  }
  function Dispatch(_2) {
    this._ = _2;
  }
  function parseTypenames(typenames, types) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
      if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
      return { type: t, name };
    });
  }
  Dispatch.prototype = dispatch.prototype = {
    constructor: Dispatch,
    on: function(typename, callback) {
      var _2 = this._, T = parseTypenames(typename + "", _2), t, i = -1, n = T.length;
      if (arguments.length < 2) {
        while (++i < n) if ((t = (typename = T[i]).type) && (t = get2(_2[t], typename.name))) return t;
        return;
      }
      if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
      while (++i < n) {
        if (t = (typename = T[i]).type) _2[t] = set3(_2[t], typename.name, callback);
        else if (callback == null) for (t in _2) _2[t] = set3(_2[t], typename.name, null);
      }
      return this;
    },
    copy: function() {
      var copy = {}, _2 = this._;
      for (var t in _2) copy[t] = _2[t].slice();
      return new Dispatch(copy);
    },
    call: function(type, that) {
      if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
      if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
      for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
    },
    apply: function(type, that, args) {
      if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
      for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
    }
  };
  function get2(type, name) {
    for (var i = 0, n = type.length, c2; i < n; ++i) {
      if ((c2 = type[i]).name === name) {
        return c2.value;
      }
    }
  }
  function set3(type, name, callback) {
    for (var i = 0, n = type.length; i < n; ++i) {
      if (type[i].name === name) {
        type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
        break;
      }
    }
    if (callback != null) type.push({ name, value: callback });
    return type;
  }
  var dispatch_default = dispatch;

  // node_modules/d3-timer/src/timer.js
  var frame = 0;
  var timeout = 0;
  var interval = 0;
  var pokeDelay = 1e3;
  var taskHead;
  var taskTail;
  var clockLast = 0;
  var clockNow = 0;
  var clockSkew = 0;
  var clock2 = typeof performance === "object" && performance.now ? performance : Date;
  var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
    setTimeout(f, 17);
  };
  function now() {
    return clockNow || (setFrame(clearNow), clockNow = clock2.now() + clockSkew);
  }
  function clearNow() {
    clockNow = 0;
  }
  function Timer() {
    this._call = this._time = this._next = null;
  }
  Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart: function(callback, delay, time) {
      if (typeof callback !== "function") throw new TypeError("callback is not a function");
      time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail !== this) {
        if (taskTail) taskTail._next = this;
        else taskHead = this;
        taskTail = this;
      }
      this._call = callback;
      this._time = time;
      sleep();
    },
    stop: function() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep();
      }
    }
  };
  function timer(callback, delay, time) {
    var t = new Timer();
    t.restart(callback, delay, time);
    return t;
  }
  function timerFlush() {
    now();
    ++frame;
    var t = taskHead, e;
    while (t) {
      if ((e = clockNow - t._time) >= 0) t._call.call(void 0, e);
      t = t._next;
    }
    --frame;
  }
  function wake() {
    clockNow = (clockLast = clock2.now()) + clockSkew;
    frame = timeout = 0;
    try {
      timerFlush();
    } finally {
      frame = 0;
      nap();
      clockNow = 0;
    }
  }
  function poke() {
    var now2 = clock2.now(), delay = now2 - clockLast;
    if (delay > pokeDelay) clockSkew -= delay, clockLast = now2;
  }
  function nap() {
    var t0, t1 = taskHead, t2, time = Infinity;
    while (t1) {
      if (t1._call) {
        if (time > t1._time) time = t1._time;
        t0 = t1, t1 = t1._next;
      } else {
        t2 = t1._next, t1._next = null;
        t1 = t0 ? t0._next = t2 : taskHead = t2;
      }
    }
    taskTail = t0;
    sleep(time);
  }
  function sleep(time) {
    if (frame) return;
    if (timeout) timeout = clearTimeout(timeout);
    var delay = time - clockNow;
    if (delay > 24) {
      if (time < Infinity) timeout = setTimeout(wake, time - clock2.now() - clockSkew);
      if (interval) interval = clearInterval(interval);
    } else {
      if (!interval) clockLast = clock2.now(), interval = setInterval(poke, pokeDelay);
      frame = 1, setFrame(wake);
    }
  }

  // node_modules/d3-force/src/lcg.js
  var a = 1664525;
  var c = 1013904223;
  var m = 4294967296;
  function lcg_default() {
    let s = 1;
    return () => (s = (a * s + c) % m) / m;
  }

  // node_modules/d3-force/src/simulation.js
  function x2(d2) {
    return d2.x;
  }
  function y2(d2) {
    return d2.y;
  }
  var initialRadius = 10;
  var initialAngle = Math.PI * (3 - Math.sqrt(5));
  function simulation_default(nodes) {
    var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step2), event = dispatch_default("tick", "end"), random = lcg_default();
    if (nodes == null) nodes = [];
    function step2() {
      tick2();
      event.call("tick", simulation);
      if (alpha < alphaMin) {
        stepper.stop();
        event.call("end", simulation);
      }
    }
    function tick2(iterations) {
      var i, n = nodes.length, node;
      if (iterations === void 0) iterations = 1;
      for (var k = 0; k < iterations; ++k) {
        alpha += (alphaTarget - alpha) * alphaDecay;
        forces.forEach(function(force) {
          force(alpha);
        });
        for (i = 0; i < n; ++i) {
          node = nodes[i];
          if (node.fx == null) node.x += node.vx *= velocityDecay;
          else node.x = node.fx, node.vx = 0;
          if (node.fy == null) node.y += node.vy *= velocityDecay;
          else node.y = node.fy, node.vy = 0;
        }
      }
      return simulation;
    }
    function initializeNodes() {
      for (var i = 0, n = nodes.length, node; i < n; ++i) {
        node = nodes[i], node.index = i;
        if (node.fx != null) node.x = node.fx;
        if (node.fy != null) node.y = node.fy;
        if (isNaN(node.x) || isNaN(node.y)) {
          var radius = initialRadius * Math.sqrt(0.5 + i), angle2 = i * initialAngle;
          node.x = radius * Math.cos(angle2);
          node.y = radius * Math.sin(angle2);
        }
        if (isNaN(node.vx) || isNaN(node.vy)) {
          node.vx = node.vy = 0;
        }
      }
    }
    function initializeForce(force) {
      if (force.initialize) force.initialize(nodes, random);
      return force;
    }
    initializeNodes();
    return simulation = {
      tick: tick2,
      restart: function() {
        return stepper.restart(step2), simulation;
      },
      stop: function() {
        return stepper.stop(), simulation;
      },
      nodes: function(_2) {
        return arguments.length ? (nodes = _2, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
      },
      alpha: function(_2) {
        return arguments.length ? (alpha = +_2, simulation) : alpha;
      },
      alphaMin: function(_2) {
        return arguments.length ? (alphaMin = +_2, simulation) : alphaMin;
      },
      alphaDecay: function(_2) {
        return arguments.length ? (alphaDecay = +_2, simulation) : +alphaDecay;
      },
      alphaTarget: function(_2) {
        return arguments.length ? (alphaTarget = +_2, simulation) : alphaTarget;
      },
      velocityDecay: function(_2) {
        return arguments.length ? (velocityDecay = 1 - _2, simulation) : 1 - velocityDecay;
      },
      randomSource: function(_2) {
        return arguments.length ? (random = _2, forces.forEach(initializeForce), simulation) : random;
      },
      force: function(name, _2) {
        return arguments.length > 1 ? (_2 == null ? forces.delete(name) : forces.set(name, initializeForce(_2)), simulation) : forces.get(name);
      },
      find: function(x3, y3, radius) {
        var i = 0, n = nodes.length, dx, dy, d2, node, closest;
        if (radius == null) radius = Infinity;
        else radius *= radius;
        for (i = 0; i < n; ++i) {
          node = nodes[i];
          dx = x3 - node.x;
          dy = y3 - node.y;
          d2 = dx * dx + dy * dy;
          if (d2 < radius) closest = node, radius = d2;
        }
        return closest;
      },
      on: function(name, _2) {
        return arguments.length > 1 ? (event.on(name, _2), simulation) : event.on(name);
      }
    };
  }

  // node_modules/d3-force/src/manyBody.js
  function manyBody_default() {
    var nodes, node, random, alpha, strength = constant_default(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta22 = 0.81;
    function force(_2) {
      var i, n = nodes.length, tree = quadtree(nodes, x2, y2).visitAfter(accumulate2);
      for (alpha = _2, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply3);
    }
    function initialize() {
      if (!nodes) return;
      var i, n = nodes.length, node2;
      strengths = new Array(n);
      for (i = 0; i < n; ++i) node2 = nodes[i], strengths[node2.index] = +strength(node2, i, nodes);
    }
    function accumulate2(quad) {
      var strength2 = 0, q, c2, weight = 0, x3, y3, i;
      if (quad.length) {
        for (x3 = y3 = i = 0; i < 4; ++i) {
          if ((q = quad[i]) && (c2 = Math.abs(q.value))) {
            strength2 += q.value, weight += c2, x3 += c2 * q.x, y3 += c2 * q.y;
          }
        }
        quad.x = x3 / weight;
        quad.y = y3 / weight;
      } else {
        q = quad;
        q.x = q.data.x;
        q.y = q.data.y;
        do
          strength2 += strengths[q.data.index];
        while (q = q.next);
      }
      quad.value = strength2;
    }
    function apply3(quad, x1, _2, x22) {
      if (!quad.value) return true;
      var x3 = quad.x - node.x, y3 = quad.y - node.y, w = x22 - x1, l = x3 * x3 + y3 * y3;
      if (w * w / theta22 < l) {
        if (l < distanceMax2) {
          if (x3 === 0) x3 = jiggle_default(random), l += x3 * x3;
          if (y3 === 0) y3 = jiggle_default(random), l += y3 * y3;
          if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
          node.vx += x3 * quad.value * alpha / l;
          node.vy += y3 * quad.value * alpha / l;
        }
        return true;
      } else if (quad.length || l >= distanceMax2) return;
      if (quad.data !== node || quad.next) {
        if (x3 === 0) x3 = jiggle_default(random), l += x3 * x3;
        if (y3 === 0) y3 = jiggle_default(random), l += y3 * y3;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
      }
      do
        if (quad.data !== node) {
          w = strengths[quad.data.index] * alpha / l;
          node.vx += x3 * w;
          node.vy += y3 * w;
        }
      while (quad = quad.next);
    }
    force.initialize = function(_nodes, _random) {
      nodes = _nodes;
      random = _random;
      initialize();
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : strength;
    };
    force.distanceMin = function(_2) {
      return arguments.length ? (distanceMin2 = _2 * _2, force) : Math.sqrt(distanceMin2);
    };
    force.distanceMax = function(_2) {
      return arguments.length ? (distanceMax2 = _2 * _2, force) : Math.sqrt(distanceMax2);
    };
    force.theta = function(_2) {
      return arguments.length ? (theta22 = _2 * _2, force) : Math.sqrt(theta22);
    };
    return force;
  }

  // node_modules/d3-force/src/radial.js
  function radial_default(radius, x3, y3) {
    var nodes, strength = constant_default(0.1), strengths, radiuses;
    if (typeof radius !== "function") radius = constant_default(+radius);
    if (x3 == null) x3 = 0;
    if (y3 == null) y3 = 0;
    function force(alpha) {
      for (var i = 0, n = nodes.length; i < n; ++i) {
        var node = nodes[i], dx = node.x - x3 || 1e-6, dy = node.y - y3 || 1e-6, r = Math.sqrt(dx * dx + dy * dy), k = (radiuses[i] - r) * strengths[i] * alpha / r;
        node.vx += dx * k;
        node.vy += dy * k;
      }
    }
    function initialize() {
      if (!nodes) return;
      var i, n = nodes.length;
      strengths = new Array(n);
      radiuses = new Array(n);
      for (i = 0; i < n; ++i) {
        radiuses[i] = +radius(nodes[i], i, nodes);
        strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
      }
    }
    force.initialize = function(_2) {
      nodes = _2, initialize();
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : strength;
    };
    force.radius = function(_2) {
      return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : radius;
    };
    force.x = function(_2) {
      return arguments.length ? (x3 = +_2, force) : x3;
    };
    force.y = function(_2) {
      return arguments.length ? (y3 = +_2, force) : y3;
    };
    return force;
  }

  // node_modules/d3-force/src/x.js
  function x_default3(x3) {
    var strength = constant_default(0.1), nodes, strengths, xz;
    if (typeof x3 !== "function") x3 = constant_default(x3 == null ? 0 : +x3);
    function force(alpha) {
      for (var i = 0, n = nodes.length, node; i < n; ++i) {
        node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
      }
    }
    function initialize() {
      if (!nodes) return;
      var i, n = nodes.length;
      strengths = new Array(n);
      xz = new Array(n);
      for (i = 0; i < n; ++i) {
        strengths[i] = isNaN(xz[i] = +x3(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
      }
    }
    force.initialize = function(_2) {
      nodes = _2;
      initialize();
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : strength;
    };
    force.x = function(_2) {
      return arguments.length ? (x3 = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : x3;
    };
    return force;
  }

  // node_modules/d3-force/src/y.js
  function y_default3(y3) {
    var strength = constant_default(0.1), nodes, strengths, yz;
    if (typeof y3 !== "function") y3 = constant_default(y3 == null ? 0 : +y3);
    function force(alpha) {
      for (var i = 0, n = nodes.length, node; i < n; ++i) {
        node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
      }
    }
    function initialize() {
      if (!nodes) return;
      var i, n = nodes.length;
      strengths = new Array(n);
      yz = new Array(n);
      for (i = 0; i < n; ++i) {
        strengths[i] = isNaN(yz[i] = +y3(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
      }
    }
    force.initialize = function(_2) {
      nodes = _2;
      initialize();
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : strength;
    };
    force.y = function(_2) {
      return arguments.length ? (y3 = typeof _2 === "function" ? _2 : constant_default(+_2), initialize(), force) : y3;
    };
    return force;
  }

  // node_modules/@antv/layout/lib/d3-force/index.js
  var D3ForceLayout = class {
    constructor(options) {
      this.id = "d3-force";
      this.config = {
        inputNodeAttrs: ["x", "y", "vx", "vy", "fx", "fy"],
        outputNodeAttrs: ["x", "y", "vx", "vy"],
        simulationAttrs: [
          "alpha",
          "alphaMin",
          "alphaDecay",
          "alphaTarget",
          "velocityDecay",
          "randomSource"
        ]
      };
      this.forceMap = {
        link: link_default,
        manyBody: manyBody_default,
        center: center_default,
        collide: collide_default,
        radial: radial_default,
        x: x_default3,
        y: y_default3
      };
      this.options = {
        link: {
          id: (edge) => edge.id
        },
        manyBody: {},
        center: {
          x: 0,
          y: 0
        }
      };
      this.context = {
        options: {},
        assign: false,
        nodes: [],
        edges: []
      };
      (0, import_util95.deepMix)(this.options, options);
      if (this.options.forceSimulation) {
        this.simulation = this.options.forceSimulation;
      }
    }
    execute(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.genericLayout(false, graph, options);
      });
    }
    assign(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.genericLayout(true, graph, options);
      });
    }
    stop() {
      this.simulation.stop();
    }
    tick(iterations) {
      this.simulation.tick(iterations);
      return this.getResult();
    }
    restart() {
      this.simulation.restart();
    }
    setFixedPosition(id3, position2) {
      const node = this.context.nodes.find((n) => n.id === id3);
      if (!node)
        return;
      position2.forEach((value, index2) => {
        if (typeof value === "number" || value === null) {
          const key = ["fx", "fy", "fz"][index2];
          node[key] = value;
        }
      });
    }
    getOptions(options) {
      var _a2, _b;
      const _2 = (0, import_util95.deepMix)({}, this.options, options);
      if (_2.collide && ((_a2 = _2.collide) === null || _a2 === void 0 ? void 0 : _a2.radius) === void 0) {
        _2.collide = _2.collide || {};
        _2.collide.radius = (_b = _2.nodeSize) !== null && _b !== void 0 ? _b : 10;
      }
      if (_2.iterations === void 0) {
        if (_2.link && _2.link.iterations === void 0) {
          _2.iterations = _2.link.iterations;
        }
        if (_2.collide && _2.collide.iterations === void 0) {
          _2.iterations = _2.collide.iterations;
        }
      }
      this.context.options = _2;
      return _2;
    }
    genericLayout(assign2, graph, options) {
      var _a2;
      return __awaiter(this, void 0, void 0, function* () {
        const _options = this.getOptions(options);
        const nodes = graph.getAllNodes().map(({ id: id3, data: data2 }) => Object.assign(Object.assign({ id: id3 }, data2), (0, import_util95.pick)(data2.data, this.config.inputNodeAttrs)));
        const edges = graph.getAllEdges().map((edge) => Object.assign({}, edge));
        Object.assign(this.context, { assign: assign2, nodes, edges, graph });
        const promise = new Promise((resolver) => {
          this.resolver = resolver;
        });
        const simulation = this.setSimulation(_options);
        simulation.nodes(nodes);
        (_a2 = simulation.force("link")) === null || _a2 === void 0 ? void 0 : _a2.links(edges);
        return promise;
      });
    }
    getResult() {
      const { assign: assign2, nodes, edges, graph } = this.context;
      const nodesResult = nodes.map((node) => ({
        id: node.id,
        data: Object.assign(Object.assign({}, node.data), (0, import_util95.pick)(node, this.config.outputNodeAttrs))
      }));
      const edgeResult = edges.map(({ id: id3, source, target, data: data2 }) => ({
        id: id3,
        source: typeof source === "object" ? source.id : source,
        target: typeof target === "object" ? target.id : target,
        data: data2
      }));
      if (assign2) {
        nodesResult.forEach((node) => graph.mergeNodeData(node.id, node.data));
      }
      return { nodes: nodesResult, edges: edgeResult };
    }
    initSimulation() {
      return simulation_default();
    }
    setSimulation(options) {
      const simulation = this.simulation || this.options.forceSimulation || this.initSimulation();
      if (!this.simulation) {
        this.simulation = simulation.on("tick", () => {
          var _a2;
          return (_a2 = options.onTick) === null || _a2 === void 0 ? void 0 : _a2.call(options, this.getResult());
        }).on("end", () => {
          var _a2;
          return (_a2 = this.resolver) === null || _a2 === void 0 ? void 0 : _a2.call(this, this.getResult());
        });
      }
      apply2(simulation, this.config.simulationAttrs.map((name) => [
        name,
        options[name]
      ]));
      Object.entries(this.forceMap).forEach(([name, Ctor]) => {
        const forceName = name;
        if (options[name]) {
          let force = simulation.force(forceName);
          if (!force) {
            force = Ctor();
            simulation.force(forceName, force);
          }
          apply2(force, Object.entries(options[forceName]));
        } else
          simulation.force(forceName, null);
      });
      return simulation;
    }
  };
  var apply2 = (target, params) => {
    return params.reduce((acc, [method, param]) => {
      if (!acc[method] || param === void 0)
        return acc;
      return acc[method].call(target, param);
    }, target);
  };

  // node_modules/@antv/layout/lib/dagre.js
  init_tslib_es6();
  var import_util96 = __toESM(require_lib());
  var import_dagre = __toESM(require_dagre());
  var DagreLayout = class _DagreLayout {
    constructor(options) {
      this.id = "dagre";
      this.options = {};
      Object.assign(this.options, _DagreLayout.defaultOptions, options);
    }
    execute(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.genericDagreLayout(false, graph, Object.assign(Object.assign({}, this.options), options));
      });
    }
    assign(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.genericDagreLayout(true, graph, Object.assign(Object.assign({}, this.options), options));
      });
    }
    genericDagreLayout(assign2, graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const { nodeSize } = options;
        const g = new import_dagre.graphlib.Graph();
        g.setGraph(options);
        g.setDefaultEdgeLabel(() => ({}));
        const nodes = graph.getAllNodes();
        const edges = graph.getAllEdges();
        if ([...nodes, ...edges].some(({ id: id3 }) => (0, import_util96.isNumber)(id3))) {
          console.error("Dagre layout only support string id, it will convert number to string.");
        }
        graph.getAllNodes().forEach((node) => {
          const { id: id3 } = node;
          const data2 = Object.assign({}, node.data);
          if (nodeSize !== void 0) {
            const [width2, height] = parseSize2((0, import_util96.isFunction)(nodeSize) ? nodeSize(node) : nodeSize);
            Object.assign(data2, { width: width2, height });
          }
          g.setNode(id3.toString(), data2);
        });
        graph.getAllEdges().forEach(({ id: id3, source, target }) => {
          g.setEdge(source.toString(), target.toString(), { id: id3 });
        });
        import_dagre.default.layout(g);
        const mapping = { nodes: [], edges: [] };
        g.nodes().forEach((id3) => {
          const data2 = g.node(id3);
          mapping.nodes.push({ id: id3, data: data2 });
          if (assign2)
            graph.mergeNodeData(id3, data2);
        });
        g.edges().forEach((edge) => {
          const _a2 = g.edge(edge), { id: id3 } = _a2, data2 = __rest(_a2, ["id"]);
          const { v: source, w: target } = edge;
          mapping.edges.push({ id: id3, source, target, data: data2 });
          if (assign2)
            graph.mergeEdgeData(id3, data2);
        });
        return mapping;
      });
    }
  };
  DagreLayout.defaultOptions = {};

  // node_modules/@antv/layout/lib/force-atlas2/index.js
  init_tslib_es6();
  var import_util97 = __toESM(require_lib());

  // node_modules/@antv/layout/lib/force-atlas2/body.js
  var Body = class _Body {
    constructor(params) {
      this.id = params.id || 0;
      this.rx = params.rx;
      this.ry = params.ry;
      this.fx = 0;
      this.fy = 0;
      this.mass = params.mass;
      this.degree = params.degree;
      this.g = params.g || 0;
    }
    // returns the euclidean distance
    distanceTo(bo) {
      const dx = this.rx - bo.rx;
      const dy = this.ry - bo.ry;
      return Math.hypot(dx, dy);
    }
    setPos(x3, y3) {
      this.rx = x3;
      this.ry = y3;
    }
    // resets the forces
    resetForce() {
      this.fx = 0;
      this.fy = 0;
    }
    addForce(b) {
      const dx = b.rx - this.rx;
      const dy = b.ry - this.ry;
      let dist = Math.hypot(dx, dy);
      dist = dist < 1e-4 ? 1e-4 : dist;
      const F = this.g * (this.degree + 1) * (b.degree + 1) / dist;
      this.fx += F * dx / dist;
      this.fy += F * dy / dist;
    }
    // if quad contains this body
    in(quad) {
      return quad.contains(this.rx, this.ry);
    }
    // returns a new body
    add(bo) {
      const nenwMass = this.mass + bo.mass;
      const x3 = (this.rx * this.mass + bo.rx * bo.mass) / nenwMass;
      const y3 = (this.ry * this.mass + bo.ry * bo.mass) / nenwMass;
      const dg = this.degree + bo.degree;
      const params = {
        rx: x3,
        ry: y3,
        mass: nenwMass,
        degree: dg
      };
      return new _Body(params);
    }
  };

  // node_modules/@antv/layout/lib/force-atlas2/quad.js
  var Quad3 = class _Quad {
    constructor(params) {
      this.xmid = params.xmid;
      this.ymid = params.ymid;
      this.length = params.length;
      this.massCenter = params.massCenter || [0, 0];
      this.mass = params.mass || 1;
    }
    getLength() {
      return this.length;
    }
    contains(x3, y3) {
      const halfLen = this.length / 2;
      return x3 <= this.xmid + halfLen && x3 >= this.xmid - halfLen && y3 <= this.ymid + halfLen && y3 >= this.ymid - halfLen;
    }
    // northwest quadrant
    // tslint:disable-next-line
    NW() {
      const x3 = this.xmid - this.length / 4;
      const y3 = this.ymid + this.length / 4;
      const len = this.length / 2;
      const params = {
        xmid: x3,
        ymid: y3,
        length: len
      };
      const NW = new _Quad(params);
      return NW;
    }
    // northeast
    // tslint:disable-next-line
    NE() {
      const x3 = this.xmid + this.length / 4;
      const y3 = this.ymid + this.length / 4;
      const len = this.length / 2;
      const params = {
        xmid: x3,
        ymid: y3,
        length: len
      };
      const NE = new _Quad(params);
      return NE;
    }
    // southwest
    // tslint:disable-next-line
    SW() {
      const x3 = this.xmid - this.length / 4;
      const y3 = this.ymid - this.length / 4;
      const len = this.length / 2;
      const params = {
        xmid: x3,
        ymid: y3,
        length: len
      };
      const SW = new _Quad(params);
      return SW;
    }
    // southeast
    // tslint:disable-next-line
    SE() {
      const x3 = this.xmid + this.length / 4;
      const y3 = this.ymid - this.length / 4;
      const len = this.length / 2;
      const params = {
        xmid: x3,
        ymid: y3,
        length: len
      };
      const SE = new _Quad(params);
      return SE;
    }
  };

  // node_modules/@antv/layout/lib/force-atlas2/quad-tree.js
  var QuadTree = class _QuadTree {
    // each quadtree represents a quadrant and an aggregate body
    // that represents all bodies inside the quadrant
    constructor(param) {
      this.body = null;
      this.quad = null;
      this.NW = null;
      this.NE = null;
      this.SW = null;
      this.SE = null;
      this.theta = 0.5;
      if (param != null)
        this.quad = param;
    }
    // insert a body(node) into the tree
    insert(bo) {
      if (this.body == null) {
        this.body = bo;
        return;
      }
      if (!this._isExternal()) {
        this.body = this.body.add(bo);
        this._putBody(bo);
      } else {
        if (this.quad) {
          this.NW = new _QuadTree(this.quad.NW());
          this.NE = new _QuadTree(this.quad.NE());
          this.SW = new _QuadTree(this.quad.SW());
          this.SE = new _QuadTree(this.quad.SE());
        }
        this._putBody(this.body);
        this._putBody(bo);
        this.body = this.body.add(bo);
      }
    }
    // inserts bo into a quad
    // tslint:disable-next-line
    _putBody(bo) {
      if (!this.quad)
        return;
      if (bo.in(this.quad.NW()) && this.NW)
        this.NW.insert(bo);
      else if (bo.in(this.quad.NE()) && this.NE)
        this.NE.insert(bo);
      else if (bo.in(this.quad.SW()) && this.SW)
        this.SW.insert(bo);
      else if (bo.in(this.quad.SE()) && this.SE)
        this.SE.insert(bo);
    }
    // tslint:disable-next-line
    _isExternal() {
      return this.NW == null && this.NE == null && this.SW == null && this.SE == null;
    }
    // update the forces
    updateForce(bo) {
      if (this.body == null || bo === this.body) {
        return;
      }
      if (this._isExternal())
        bo.addForce(this.body);
      else {
        const s = this.quad ? this.quad.getLength() : 0;
        const d2 = this.body.distanceTo(bo);
        if (s / d2 < this.theta)
          bo.addForce(this.body);
        else {
          this.NW && this.NW.updateForce(bo);
          this.NE && this.NE.updateForce(bo);
          this.SW && this.SW.updateForce(bo);
          this.SE && this.SE.updateForce(bo);
        }
      }
    }
  };

  // node_modules/@antv/layout/lib/force-atlas2/index.js
  var DEFAULTS_LAYOUT_OPTIONS7 = {
    center: [0, 0],
    width: 300,
    height: 300,
    kr: 5,
    kg: 1,
    mode: "normal",
    preventOverlap: false,
    dissuadeHubs: false,
    maxIteration: 0,
    ks: 0.1,
    ksmax: 10,
    tao: 0.1
  };
  var ForceAtlas2Layout = class {
    constructor(options = {}) {
      this.options = options;
      this.id = "forceAtlas2";
      this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS7), options);
    }
    /**
     * Return the positions of nodes and edges(if needed).
     */
    execute(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.genericForceAtlas2Layout(false, graph, options);
      });
    }
    /**
     * To directly assign the positions to the nodes.
     */
    assign(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.genericForceAtlas2Layout(true, graph, options);
      });
    }
    genericForceAtlas2Layout(assign2, graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const edges = graph.getAllEdges();
        const nodes = graph.getAllNodes();
        const mergedOptions = this.formatOptions(options, nodes.length);
        const { width: width2, height, prune, maxIteration, nodeSize, center } = mergedOptions;
        if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length) || nodes.length === 1) {
          return handleSingleNodeGraph(graph, assign2, center);
        }
        const calcNodes = nodes.map((node) => cloneFormatData(node, [width2, height]));
        const calcEdges = edges.filter((edge) => {
          const { source, target } = edge;
          return source !== target;
        });
        const calcGraph = new Graph2({
          nodes: calcNodes,
          edges: calcEdges
        });
        const sizes = this.getSizes(calcGraph, nodeSize);
        this.run(calcGraph, graph, maxIteration, sizes, assign2, mergedOptions);
        if (prune) {
          for (let j = 0; j < calcEdges.length; j += 1) {
            const { source, target } = calcEdges[j];
            const sourceDegree = calcGraph.getDegree(source);
            const targetDegree = calcGraph.getDegree(source);
            if (sourceDegree <= 1) {
              const targetNode = calcGraph.getNode(target);
              calcGraph.mergeNodeData(source, {
                x: targetNode.data.x,
                y: targetNode.data.y
              });
            } else if (targetDegree <= 1) {
              const sourceNode = calcGraph.getNode(source);
              calcGraph.mergeNodeData(target, {
                x: sourceNode.data.x,
                y: sourceNode.data.y
              });
            }
          }
          const postOptions = Object.assign(Object.assign({}, mergedOptions), { prune: false, barnesHut: false });
          this.run(calcGraph, graph, 100, sizes, assign2, postOptions);
        }
        return {
          nodes: calcNodes,
          edges
        };
      });
    }
    /**
     * Init the node positions if there is no initial positions.
     * And pre-calculate the size (max of width and height) for each node.
     * @param calcGraph graph for calculation
     * @param nodeSize node size config from layout options
     * @returns {SizeMap} node'id mapped to max of its width and height
     */
    getSizes(calcGraph, nodeSize) {
      const nodes = calcGraph.getAllNodes();
      const sizes = {};
      for (let i = 0; i < nodes.length; i += 1) {
        const node = nodes[i];
        sizes[node.id] = formatNodeSizeToNumber(nodeSize, void 0)(node);
      }
      return sizes;
    }
    /**
     * Format the options.
     * @param options input options
     * @param nodeNum number of nodes
     * @returns formatted options
     */
    formatOptions(options = {}, nodeNum) {
      const mergedOptions = Object.assign(Object.assign({}, this.options), options);
      const { center, width: width2, height, barnesHut, prune, maxIteration, kr, kg } = mergedOptions;
      mergedOptions.width = !width2 && typeof window !== "undefined" ? window.innerWidth : width2;
      mergedOptions.height = !height && typeof window !== "undefined" ? window.innerHeight : height;
      mergedOptions.center = !center ? [mergedOptions.width / 2, mergedOptions.height / 2] : center;
      if (barnesHut === void 0 && nodeNum > 250) {
        mergedOptions.barnesHut = true;
      }
      if (prune === void 0 && nodeNum > 100)
        mergedOptions.prune = true;
      if (maxIteration === 0 && !prune) {
        mergedOptions.maxIteration = 250;
        if (nodeNum <= 200 && nodeNum > 100)
          mergedOptions.maxIteration = 1e3;
        else if (nodeNum > 200)
          mergedOptions.maxIteration = 1200;
      } else if (maxIteration === 0 && prune) {
        mergedOptions.maxIteration = 100;
        if (nodeNum <= 200 && nodeNum > 100)
          mergedOptions.maxIteration = 500;
        else if (nodeNum > 200)
          mergedOptions.maxIteration = 950;
      }
      if (!kr) {
        mergedOptions.kr = 50;
        if (nodeNum > 100 && nodeNum <= 500)
          mergedOptions.kr = 20;
        else if (nodeNum > 500)
          mergedOptions.kr = 1;
      }
      if (!kg) {
        mergedOptions.kg = 20;
        if (nodeNum > 100 && nodeNum <= 500)
          mergedOptions.kg = 10;
        else if (nodeNum > 500)
          mergedOptions.kg = 1;
      }
      return mergedOptions;
    }
    /**
     * Loops for fa2.
     * @param calcGraph graph for calculation
     * @param graph original graph
     * @param iteration iteration number
     * @param sizes nodes' size
     * @param options formatted layout options
     * @returns
     */
    run(calcGraph, graph, iteration, sizes, assign2, options) {
      const { kr, barnesHut, onTick } = options;
      const calcNodes = calcGraph.getAllNodes();
      let sg = 0;
      let iter = iteration;
      const forces = {};
      const preForces = {};
      const bodies = {};
      for (let i = 0; i < calcNodes.length; i += 1) {
        const { data: data2, id: id3 } = calcNodes[i];
        forces[id3] = [0, 0];
        if (barnesHut) {
          const params = {
            id: i,
            rx: data2.x,
            ry: data2.y,
            mass: 1,
            g: kr,
            degree: calcGraph.getDegree(id3)
          };
          bodies[id3] = new Body(params);
        }
      }
      while (iter > 0) {
        sg = this.oneStep(calcGraph, {
          iter,
          preventOverlapIters: 50,
          krPrime: 100,
          sg,
          forces,
          preForces,
          bodies,
          sizes
        }, options);
        iter--;
        onTick === null || onTick === void 0 ? void 0 : onTick({
          nodes: calcNodes,
          edges: graph.getAllEdges()
        });
      }
      return calcGraph;
    }
    /**
     * One step for a loop.
     * @param graph graph for calculation
     * @param params parameters for a loop
     * @param options formatted layout's input options
     * @returns
     */
    oneStep(graph, params, options) {
      const { iter, preventOverlapIters, krPrime, sg, preForces, bodies, sizes } = params;
      let { forces } = params;
      const { preventOverlap, barnesHut } = options;
      const nodes = graph.getAllNodes();
      for (let i = 0; i < nodes.length; i += 1) {
        const { id: id3 } = nodes[i];
        preForces[id3] = [...forces[id3]];
        forces[id3] = [0, 0];
      }
      forces = this.getAttrForces(graph, iter, preventOverlapIters, sizes, forces, options);
      if (barnesHut && (preventOverlap && iter > preventOverlapIters || !preventOverlap)) {
        forces = this.getOptRepGraForces(graph, forces, bodies, options);
      } else {
        forces = this.getRepGraForces(graph, iter, preventOverlapIters, forces, krPrime, sizes, options);
      }
      return this.updatePos(graph, forces, preForces, sg, options);
    }
    /**
     * Calculate the attract forces for nodes.
     * @param graph graph for calculation
     * @param iter current iteration index
     * @param preventOverlapIters the iteration number for preventing overlappings
     * @param sizes nodes' sizes
     * @param forces forces for nodes, which will be modified
     * @param options formatted layout's input options
     * @returns
     */
    getAttrForces(graph, iter, preventOverlapIters, sizes, forces, options) {
      const { preventOverlap, dissuadeHubs, mode, prune } = options;
      const edges = graph.getAllEdges();
      for (let i = 0; i < edges.length; i += 1) {
        const { source, target } = edges[i];
        const sourceNode = graph.getNode(source);
        const targetNode = graph.getNode(target);
        const sourceDegree = graph.getDegree(source);
        const targetDegree = graph.getDegree(target);
        if (prune && (sourceDegree <= 1 || targetDegree <= 1))
          continue;
        const dir = [
          targetNode.data.x - sourceNode.data.x,
          targetNode.data.y - sourceNode.data.y
        ];
        let eucliDis = Math.hypot(dir[0], dir[1]);
        eucliDis = eucliDis < 1e-4 ? 1e-4 : eucliDis;
        dir[0] = dir[0] / eucliDis;
        dir[1] = dir[1] / eucliDis;
        if (preventOverlap && iter < preventOverlapIters) {
          eucliDis = eucliDis - sizes[source] - sizes[target];
        }
        let fa1 = eucliDis;
        let fa2 = fa1;
        if (mode === "linlog") {
          fa1 = Math.log(1 + eucliDis);
          fa2 = fa1;
        }
        if (dissuadeHubs) {
          fa1 = eucliDis / sourceDegree;
          fa2 = eucliDis / targetDegree;
        }
        if (preventOverlap && iter < preventOverlapIters && eucliDis <= 0) {
          fa1 = 0;
          fa2 = 0;
        } else if (preventOverlap && iter < preventOverlapIters && eucliDis > 0) {
          fa1 = eucliDis;
          fa2 = eucliDis;
        }
        forces[source][0] += fa1 * dir[0];
        forces[target][0] -= fa2 * dir[0];
        forces[source][1] += fa1 * dir[1];
        forces[target][1] -= fa2 * dir[1];
      }
      return forces;
    }
    /**
     * Calculate the repulsive forces for nodes under barnesHut mode.
     * @param graph graph for calculatiion
     * @param forces forces for nodes, which will be modified
     * @param bodies force body map
     * @param options formatted layout's input options
     * @returns
     */
    getOptRepGraForces(graph, forces, bodies, options) {
      const { kg, center, prune } = options;
      const nodes = graph.getAllNodes();
      const nodeNum = nodes.length;
      let minx = 9e10;
      let maxx = -9e10;
      let miny = 9e10;
      let maxy = -9e10;
      for (let i = 0; i < nodeNum; i += 1) {
        const { id: id3, data: data2 } = nodes[i];
        if (prune && graph.getDegree(id3) <= 1)
          continue;
        bodies[id3].setPos(data2.x, data2.y);
        if (data2.x >= maxx)
          maxx = data2.x;
        if (data2.x <= minx)
          minx = data2.x;
        if (data2.y >= maxy)
          maxy = data2.y;
        if (data2.y <= miny)
          miny = data2.y;
      }
      const width2 = Math.max(maxx - minx, maxy - miny);
      const quadParams = {
        xmid: (maxx + minx) / 2,
        ymid: (maxy + miny) / 2,
        length: width2,
        massCenter: center,
        mass: nodeNum
      };
      const quad = new Quad3(quadParams);
      const quadTree = new QuadTree(quad);
      for (let i = 0; i < nodeNum; i += 1) {
        const { id: id3 } = nodes[i];
        if (prune && graph.getDegree(id3) <= 1)
          continue;
        if (bodies[id3].in(quad))
          quadTree.insert(bodies[id3]);
      }
      for (let i = 0; i < nodeNum; i += 1) {
        const { id: id3, data: data2 } = nodes[i];
        const degree3 = graph.getDegree(id3);
        if (prune && degree3 <= 1)
          continue;
        bodies[id3].resetForce();
        quadTree.updateForce(bodies[id3]);
        forces[id3][0] -= bodies[id3].fx;
        forces[id3][1] -= bodies[id3].fy;
        const dir = [data2.x - center[0], data2.y - center[1]];
        let eucliDis = Math.hypot(dir[0], dir[1]);
        eucliDis = eucliDis < 1e-4 ? 1e-4 : eucliDis;
        dir[0] = dir[0] / eucliDis;
        dir[1] = dir[1] / eucliDis;
        const fg = kg * (degree3 + 1);
        forces[id3][0] -= fg * dir[0];
        forces[id3][1] -= fg * dir[1];
      }
      return forces;
    }
    /**
     * Calculate the repulsive forces for nodes.
     * @param graph graph for calculatiion
     * @param iter current iteration index
     * @param preventOverlapIters the iteration number for preventing overlappings
     * @param forces forces for nodes, which will be modified
     * @param krPrime larger the krPrime, larger the repulsive force
     * @param sizes nodes' sizes
     * @param options formatted layout's input options
     * @returns
     */
    getRepGraForces(graph, iter, preventOverlapIters, forces, krPrime, sizes, options) {
      const { preventOverlap, kr, kg, center, prune } = options;
      const nodes = graph.getAllNodes();
      const nodeNum = nodes.length;
      for (let i = 0; i < nodeNum; i += 1) {
        const nodei = nodes[i];
        const degreei = graph.getDegree(nodei.id);
        for (let j = i + 1; j < nodeNum; j += 1) {
          const nodej = nodes[j];
          const degreej = graph.getDegree(nodej.id);
          if (prune && (degreei <= 1 || degreej <= 1))
            continue;
          const dir2 = [nodej.data.x - nodei.data.x, nodej.data.y - nodei.data.y];
          let eucliDis2 = Math.hypot(dir2[0], dir2[1]);
          eucliDis2 = eucliDis2 < 1e-4 ? 1e-4 : eucliDis2;
          dir2[0] = dir2[0] / eucliDis2;
          dir2[1] = dir2[1] / eucliDis2;
          if (preventOverlap && iter < preventOverlapIters) {
            eucliDis2 = eucliDis2 - sizes[nodei.id] - sizes[nodej.id];
          }
          let fr = kr * (degreei + 1) * (degreej + 1) / eucliDis2;
          if (preventOverlap && iter < preventOverlapIters && eucliDis2 < 0) {
            fr = krPrime * (degreei + 1) * (degreej + 1);
          } else if (preventOverlap && iter < preventOverlapIters && eucliDis2 === 0) {
            fr = 0;
          } else if (preventOverlap && iter < preventOverlapIters && eucliDis2 > 0) {
            fr = kr * (degreei + 1) * (degreej + 1) / eucliDis2;
          }
          forces[nodei.id][0] -= fr * dir2[0];
          forces[nodej.id][0] += fr * dir2[0];
          forces[nodei.id][1] -= fr * dir2[1];
          forces[nodej.id][1] += fr * dir2[1];
        }
        const dir = [nodei.data.x - center[0], nodei.data.y - center[1]];
        const eucliDis = Math.hypot(dir[0], dir[1]);
        dir[0] = dir[0] / eucliDis;
        dir[1] = dir[1] / eucliDis;
        const fg = kg * (degreei + 1);
        forces[nodei.id][0] -= fg * dir[0];
        forces[nodei.id][1] -= fg * dir[1];
      }
      return forces;
    }
    /**
     * Update node positions.
     * @param graph graph for calculatiion
     * @param forces forces for nodes, which will be modified
     * @param preForces previous forces for nodes, which will be modified
     * @param sg constant for move distance of one step
     * @param options formatted layout's input options
     * @returns
     */
    updatePos(graph, forces, preForces, sg, options) {
      const { ks, tao, prune, ksmax } = options;
      const nodes = graph.getAllNodes();
      const nodeNum = nodes.length;
      const swgns = [];
      const trans = [];
      let swgG = 0;
      let traG = 0;
      let usingSg = sg;
      for (let i = 0; i < nodeNum; i += 1) {
        const { id: id3 } = nodes[i];
        const degree3 = graph.getDegree(id3);
        if (prune && degree3 <= 1)
          continue;
        const minus = [
          forces[id3][0] - preForces[id3][0],
          forces[id3][1] - preForces[id3][1]
        ];
        const minusNorm = Math.hypot(minus[0], minus[1]);
        const add5 = [
          forces[id3][0] + preForces[id3][0],
          forces[id3][1] + preForces[id3][1]
        ];
        const addNorm = Math.hypot(add5[0], add5[1]);
        swgns[i] = minusNorm;
        trans[i] = addNorm / 2;
        swgG += (degree3 + 1) * swgns[i];
        traG += (degree3 + 1) * trans[i];
      }
      const preSG = usingSg;
      usingSg = tao * traG / swgG;
      if (preSG !== 0) {
        usingSg = usingSg > 1.5 * preSG ? 1.5 * preSG : usingSg;
      }
      for (let i = 0; i < nodeNum; i += 1) {
        const { id: id3, data: data2 } = nodes[i];
        const degree3 = graph.getDegree(id3);
        if (prune && degree3 <= 1)
          continue;
        if ((0, import_util97.isNumber)(data2.fx) && (0, import_util97.isNumber)(data2.fy))
          continue;
        let sn = ks * usingSg / (1 + usingSg * Math.sqrt(swgns[i]));
        let absForce = Math.hypot(forces[id3][0], forces[id3][1]);
        absForce = absForce < 1e-4 ? 1e-4 : absForce;
        const max4 = ksmax / absForce;
        sn = sn > max4 ? max4 : sn;
        const dnx = sn * forces[id3][0];
        const dny = sn * forces[id3][1];
        graph.mergeNodeData(id3, {
          x: data2.x + dnx,
          y: data2.y + dny
        });
      }
      return usingSg;
    }
  };

  // node_modules/@antv/layout/lib/fruchterman.js
  init_tslib_es6();
  var import_util99 = __toESM(require_lib());
  var DEFAULTS_LAYOUT_OPTIONS8 = {
    maxIteration: 1e3,
    gravity: 10,
    speed: 5,
    clustering: false,
    clusterGravity: 10,
    width: 300,
    height: 300,
    nodeClusterBy: "cluster"
  };
  var SPEED_DIVISOR = 800;
  var FruchtermanLayout = class {
    constructor(options = {}) {
      this.options = options;
      this.id = "fruchterman";
      this.timeInterval = 0;
      this.running = false;
      this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS8), options);
    }
    /**
     * Return the positions of nodes and edges(if needed).
     */
    execute(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.genericFruchtermanLayout(false, graph, options);
      });
    }
    /**
     * To directly assign the positions to the nodes.
     */
    assign(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.genericFruchtermanLayout(true, graph, options);
      });
    }
    /**
     * Stop simulation immediately.
     */
    stop() {
      if (this.timeInterval && typeof window !== "undefined") {
        window.clearInterval(this.timeInterval);
      }
      this.running = false;
    }
    /**
     * Manually steps the simulation by the specified number of iterations.
     * @see https://github.com/d3/d3-force#simulation_tick
     */
    tick(iterations = this.options.maxIteration || 1) {
      if (this.lastResult) {
        return this.lastResult;
      }
      for (let i = 0; i < iterations; i++) {
        this.runOneStep(this.lastGraph, this.lastClusterMap, this.lastOptions);
      }
      const result = {
        nodes: this.lastLayoutNodes,
        edges: this.lastLayoutEdges
      };
      if (this.lastAssign) {
        result.nodes.forEach((node) => this.lastGraph.mergeNodeData(node.id, {
          x: node.data.x,
          y: node.data.y,
          z: this.options.dimensions === 3 ? node.data.z : void 0
        }));
      }
      return result;
    }
    genericFruchtermanLayout(assign2, graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.running)
          return;
        const formattedOptions = this.formatOptions(options);
        const { dimensions, width: width2, height, center, clustering, nodeClusterBy, maxIteration, onTick } = formattedOptions;
        const nodes = graph.getAllNodes();
        const edges = graph.getAllEdges();
        if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length)) {
          const result = { nodes: [], edges };
          this.lastResult = result;
          return result;
        }
        if (nodes.length === 1) {
          if (assign2) {
            graph.mergeNodeData(nodes[0].id, {
              x: center[0],
              y: center[1],
              z: dimensions === 3 ? center[2] : void 0
            });
          }
          const result = {
            nodes: [
              Object.assign(Object.assign({}, nodes[0]), { data: Object.assign(Object.assign({}, nodes[0].data), { x: center[0], y: center[1], z: dimensions === 3 ? center[2] : void 0 }) })
            ],
            edges
          };
          this.lastResult = result;
          return result;
        }
        const layoutNodes = nodes.map((node) => cloneFormatData(node, [width2, height]));
        const calcGraph = new Graph2({
          nodes: layoutNodes,
          edges
        });
        const clusterMap = {};
        if (clustering) {
          layoutNodes.forEach((node) => {
            const clusterValue = node.data[nodeClusterBy];
            if (!clusterMap[clusterValue]) {
              clusterMap[clusterValue] = {
                name: clusterValue,
                cx: 0,
                cy: 0,
                count: 0
              };
            }
          });
        }
        this.lastLayoutNodes = layoutNodes;
        this.lastLayoutEdges = edges;
        this.lastAssign = assign2;
        this.lastGraph = calcGraph;
        this.lastOptions = formattedOptions;
        this.lastClusterMap = clusterMap;
        if (typeof window === "undefined")
          return;
        let iter = 0;
        return new Promise((resolve) => {
          this.timeInterval = window.setInterval(() => {
            if (!this.running) {
              resolve({ nodes: layoutNodes, edges });
              return;
            }
            this.runOneStep(calcGraph, clusterMap, formattedOptions);
            if (assign2) {
              layoutNodes.forEach(({ id: id3, data: data2 }) => graph.mergeNodeData(id3, {
                x: data2.x,
                y: data2.y,
                z: dimensions === 3 ? data2.z : void 0
              }));
            }
            onTick === null || onTick === void 0 ? void 0 : onTick({
              nodes: layoutNodes,
              edges
            });
            iter++;
            if (iter >= maxIteration) {
              window.clearInterval(this.timeInterval);
              resolve({ nodes: layoutNodes, edges });
            }
          }, 0);
          this.running = true;
        });
      });
    }
    formatOptions(options = {}) {
      const mergedOptions = Object.assign(Object.assign({}, this.options), options);
      const { clustering, nodeClusterBy } = mergedOptions;
      const { center: propsCenter, width: propsWidth, height: propsHeight } = mergedOptions;
      mergedOptions.width = !propsWidth && typeof window !== "undefined" ? window.innerWidth : propsWidth;
      mergedOptions.height = !propsHeight && typeof window !== "undefined" ? window.innerHeight : propsHeight;
      mergedOptions.center = !propsCenter ? [mergedOptions.width / 2, mergedOptions.height / 2] : propsCenter;
      mergedOptions.clustering = clustering && !!nodeClusterBy;
      return mergedOptions;
    }
    runOneStep(calcGraph, clusterMap, options) {
      const { dimensions, height, width: width2, gravity, center, speed, clustering, nodeClusterBy, clusterGravity: propsClusterGravity } = options;
      const area = height * width2;
      const maxDisplace = Math.sqrt(area) / 10;
      const nodes = calcGraph.getAllNodes();
      const k2 = area / (nodes.length + 1);
      const k = Math.sqrt(k2);
      const displacements = {};
      this.applyCalculate(calcGraph, displacements, k, k2);
      if (clustering) {
        for (const key in clusterMap) {
          clusterMap[key].cx = 0;
          clusterMap[key].cy = 0;
          clusterMap[key].count = 0;
        }
        nodes.forEach((node) => {
          const { data: data2 } = node;
          const c2 = clusterMap[data2[nodeClusterBy]];
          if ((0, import_util99.isNumber)(data2.x)) {
            c2.cx += data2.x;
          }
          if ((0, import_util99.isNumber)(data2.y)) {
            c2.cy += data2.y;
          }
          c2.count++;
        });
        for (const key in clusterMap) {
          clusterMap[key].cx /= clusterMap[key].count;
          clusterMap[key].cy /= clusterMap[key].count;
        }
        const clusterGravity = propsClusterGravity || gravity;
        nodes.forEach((node, j) => {
          const { id: id3, data: data2 } = node;
          if (!(0, import_util99.isNumber)(data2.x) || !(0, import_util99.isNumber)(data2.y))
            return;
          const c2 = clusterMap[data2[nodeClusterBy]];
          const distLength = Math.sqrt((data2.x - c2.cx) * (data2.x - c2.cx) + (data2.y - c2.cy) * (data2.y - c2.cy));
          const gravityForce = k * clusterGravity;
          displacements[id3].x -= gravityForce * (data2.x - c2.cx) / distLength;
          displacements[id3].y -= gravityForce * (data2.y - c2.cy) / distLength;
        });
      }
      nodes.forEach((node, j) => {
        const { id: id3, data: data2 } = node;
        if (!(0, import_util99.isNumber)(data2.x) || !(0, import_util99.isNumber)(data2.y))
          return;
        const gravityForce = 0.01 * k * gravity;
        displacements[id3].x -= gravityForce * (data2.x - center[0]);
        displacements[id3].y -= gravityForce * (data2.y - center[1]);
        if (dimensions === 3) {
          displacements[id3].z -= gravityForce * (data2.z - center[2]);
        }
      });
      nodes.forEach((node, j) => {
        const { id: id3, data: data2 } = node;
        if ((0, import_util99.isNumber)(data2.fx) && (0, import_util99.isNumber)(data2.fy)) {
          data2.x = data2.fx;
          data2.y = data2.fy;
          if (dimensions === 3) {
            data2.z = data2.fz;
          }
          return;
        }
        if (!(0, import_util99.isNumber)(data2.x) || !(0, import_util99.isNumber)(data2.y))
          return;
        const distLength = Math.sqrt(displacements[id3].x * displacements[id3].x + displacements[id3].y * displacements[id3].y + (dimensions === 3 ? displacements[id3].z * displacements[id3].z : 0));
        if (distLength > 0) {
          const limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);
          calcGraph.mergeNodeData(id3, {
            x: data2.x + displacements[id3].x / distLength * limitedDist,
            y: data2.y + displacements[id3].y / distLength * limitedDist,
            z: dimensions === 3 ? data2.z + displacements[id3].z / distLength * limitedDist : void 0
          });
        }
      });
    }
    applyCalculate(calcGraph, displacements, k, k2) {
      this.calRepulsive(calcGraph, displacements, k2);
      this.calAttractive(calcGraph, displacements, k);
    }
    calRepulsive(calcGraph, displacements, k2) {
      const nodes = calcGraph.getAllNodes();
      nodes.forEach(({ data: v, id: vid }, i) => {
        displacements[vid] = { x: 0, y: 0, z: 0 };
        nodes.forEach(({ data: u, id: uid }, j) => {
          if (i <= j || !(0, import_util99.isNumber)(v.x) || !(0, import_util99.isNumber)(u.x) || !(0, import_util99.isNumber)(v.y) || !(0, import_util99.isNumber)(u.y)) {
            return;
          }
          let vecX = v.x - u.x;
          let vecY = v.y - u.y;
          let vecZ = this.options.dimensions === 3 ? v.z - u.z : 0;
          let lengthSqr = vecX * vecX + vecY * vecY + vecZ * vecZ;
          if (lengthSqr === 0) {
            lengthSqr = 1;
            vecX = 0.01;
            vecY = 0.01;
            vecZ = 0.01;
          }
          const common = k2 / lengthSqr;
          const dispX = vecX * common;
          const dispY = vecY * common;
          const dispZ = vecZ * common;
          displacements[vid].x += dispX;
          displacements[vid].y += dispY;
          displacements[uid].x -= dispX;
          displacements[uid].y -= dispY;
          if (this.options.dimensions === 3) {
            displacements[vid].z += dispZ;
            displacements[uid].z -= dispZ;
          }
        });
      });
    }
    calAttractive(calcGraph, displacements, k) {
      const edges = calcGraph.getAllEdges();
      edges.forEach((e) => {
        const { source, target } = e;
        if (!source || !target || source === target) {
          return;
        }
        const { data: u } = calcGraph.getNode(source);
        const { data: v } = calcGraph.getNode(target);
        if (!(0, import_util99.isNumber)(v.x) || !(0, import_util99.isNumber)(u.x) || !(0, import_util99.isNumber)(v.y) || !(0, import_util99.isNumber)(u.y)) {
          return;
        }
        const vecX = v.x - u.x;
        const vecY = v.y - u.y;
        const vecZ = this.options.dimensions === 3 ? v.z - u.z : 0;
        const common = Math.sqrt(vecX * vecX + vecY * vecY + vecZ * vecZ) / k;
        const dispX = vecX * common;
        const dispY = vecY * common;
        const dispZ = vecZ * common;
        displacements[source].x += dispX;
        displacements[source].y += dispY;
        displacements[target].x -= dispX;
        displacements[target].y -= dispY;
        if (this.options.dimensions === 3) {
          displacements[source].z += dispZ;
          displacements[target].z -= dispZ;
        }
      });
    }
  };

  // node_modules/@antv/layout/lib/grid.js
  init_tslib_es6();
  var import_util101 = __toESM(require_lib());
  var DEFAULTS_LAYOUT_OPTIONS9 = {
    begin: [0, 0],
    preventOverlap: true,
    preventOverlapPadding: 10,
    condense: false,
    rows: void 0,
    cols: void 0,
    position: void 0,
    sortBy: "degree",
    nodeSize: 30,
    width: 300,
    height: 300
  };
  var GridLayout = class {
    constructor(options = {}) {
      this.options = options;
      this.id = "grid";
      this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS9), options);
    }
    /**
     * Return the positions of nodes and edges(if needed).
     */
    execute(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.genericGridLayout(false, graph, options);
      });
    }
    /**
     * To directly assign the positions to the nodes.
     */
    assign(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.genericGridLayout(true, graph, options);
      });
    }
    genericGridLayout(assign2, graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const mergedOptions = Object.assign(Object.assign({}, this.options), options);
        const { begin = [0, 0], condense, preventOverlapPadding, preventOverlap, rows: propsRows, cols: propsCols, nodeSpacing: paramNodeSpacing, nodeSize: paramNodeSize, width: propsWidth, height: propsHeight, position: position2 } = mergedOptions;
        let { sortBy } = mergedOptions;
        const nodes = graph.getAllNodes();
        const edges = graph.getAllEdges();
        const n = nodes === null || nodes === void 0 ? void 0 : nodes.length;
        if (!n || n === 1) {
          return handleSingleNodeGraph(graph, assign2, begin);
        }
        const layoutNodes = nodes.map((node) => cloneFormatData(node));
        if (
          // `id` should be reserved keyword
          sortBy !== "id" && (!(0, import_util101.isString)(sortBy) || layoutNodes[0].data[sortBy] === void 0)
        ) {
          sortBy = "degree";
        }
        if (sortBy === "degree") {
          layoutNodes.sort((n1, n2) => graph.getDegree(n2.id, "both") - graph.getDegree(n1.id, "both"));
        } else if (sortBy === "id") {
          layoutNodes.sort((n1, n2) => {
            if ((0, import_util101.isNumber)(n2.id) && (0, import_util101.isNumber)(n1.id)) {
              return n2.id - n1.id;
            }
            return `${n1.id}`.localeCompare(`${n2.id}`);
          });
        } else {
          layoutNodes.sort((n1, n2) => n2.data[sortBy] - n1.data[sortBy]);
        }
        const width2 = !propsWidth && typeof window !== "undefined" ? window.innerWidth : propsWidth;
        const height = !propsHeight && typeof window !== "undefined" ? window.innerHeight : propsHeight;
        const cells = n;
        const rcs = { rows: propsRows, cols: propsCols };
        if (propsRows != null && propsCols != null) {
          rcs.rows = propsRows;
          rcs.cols = propsCols;
        } else if (propsRows != null && propsCols == null) {
          rcs.rows = propsRows;
          rcs.cols = Math.ceil(cells / rcs.rows);
        } else if (propsRows == null && propsCols != null) {
          rcs.cols = propsCols;
          rcs.rows = Math.ceil(cells / rcs.cols);
        } else {
          const splits = Math.sqrt(cells * height / width2);
          rcs.rows = Math.round(splits);
          rcs.cols = Math.round(width2 / height * splits);
        }
        rcs.rows = Math.max(rcs.rows, 1);
        rcs.cols = Math.max(rcs.cols, 1);
        if (rcs.cols * rcs.rows > cells) {
          const sm = small(rcs);
          const lg = large(rcs);
          if ((sm - 1) * lg >= cells) {
            small(rcs, sm - 1);
          } else if ((lg - 1) * sm >= cells) {
            large(rcs, lg - 1);
          }
        } else {
          while (rcs.cols * rcs.rows < cells) {
            const sm = small(rcs);
            const lg = large(rcs);
            if ((lg + 1) * sm >= cells) {
              large(rcs, lg + 1);
            } else {
              small(rcs, sm + 1);
            }
          }
        }
        let cellWidth = condense ? 0 : width2 / rcs.cols;
        let cellHeight = condense ? 0 : height / rcs.rows;
        if (preventOverlap || paramNodeSpacing) {
          const nodeSpacing = formatNumberFn(10, paramNodeSpacing);
          const nodeSize = formatSizeFn(30, paramNodeSize, false);
          layoutNodes.forEach((node) => {
            if (!node.data.x || !node.data.y) {
              node.data.x = 0;
              node.data.y = 0;
            }
            const oNode = graph.getNode(node.id);
            const [nodeW, nodeH] = parseSize2(nodeSize(oNode) || 30);
            const p = nodeSpacing !== void 0 ? nodeSpacing(node) : preventOverlapPadding;
            const w = nodeW + p;
            const h = nodeH + p;
            cellWidth = Math.max(cellWidth, w);
            cellHeight = Math.max(cellHeight, h);
          });
        }
        const cellUsed = {};
        const rc = { row: 0, col: 0 };
        const id2manPos = {};
        for (let i = 0; i < layoutNodes.length; i++) {
          const node = layoutNodes[i];
          let rcPos;
          if (position2) {
            rcPos = position2(graph.getNode(node.id));
          }
          if (rcPos && (rcPos.row !== void 0 || rcPos.col !== void 0)) {
            const pos = {
              row: rcPos.row,
              col: rcPos.col
            };
            if (pos.col === void 0) {
              pos.col = 0;
              while (used(cellUsed, pos)) {
                pos.col++;
              }
            } else if (pos.row === void 0) {
              pos.row = 0;
              while (used(cellUsed, pos)) {
                pos.row++;
              }
            }
            id2manPos[node.id] = pos;
            use(cellUsed, pos);
          }
          getPos(node, begin, cellWidth, cellHeight, id2manPos, rcs, rc, cellUsed);
        }
        const result = {
          nodes: layoutNodes,
          edges
        };
        if (assign2) {
          layoutNodes.forEach((node) => {
            graph.mergeNodeData(node.id, {
              x: node.data.x,
              y: node.data.y
            });
          });
        }
        return result;
      });
    }
  };
  var small = (rcs, val) => {
    let res;
    const rows = rcs.rows || 5;
    const cols = rcs.cols || 5;
    if (val == null) {
      res = Math.min(rows, cols);
    } else {
      const min4 = Math.min(rows, cols);
      if (min4 === rcs.rows) {
        rcs.rows = val;
      } else {
        rcs.cols = val;
      }
    }
    return res;
  };
  var large = (rcs, val) => {
    let result;
    const usedRows = rcs.rows || 5;
    const usedCols = rcs.cols || 5;
    if (val == null) {
      result = Math.max(usedRows, usedCols);
    } else {
      const max4 = Math.max(usedRows, usedCols);
      if (max4 === rcs.rows) {
        rcs.rows = val;
      } else {
        rcs.cols = val;
      }
    }
    return result;
  };
  var used = (cellUsed, rc) => cellUsed[`c-${rc.row}-${rc.col}`] || false;
  var use = (cellUsed, rc) => cellUsed[`c-${rc.row}-${rc.col}`] = true;
  var moveToNextCell = (rcs, rc) => {
    const cols = rcs.cols || 5;
    rc.col++;
    if (rc.col >= cols) {
      rc.col = 0;
      rc.row++;
    }
  };
  var getPos = (node, begin, cellWidth, cellHeight, id2manPos, rcs, rc, cellUsed) => {
    let x3;
    let y3;
    const rcPos = id2manPos[node.id];
    if (rcPos) {
      x3 = rcPos.col * cellWidth + cellWidth / 2 + begin[0];
      y3 = rcPos.row * cellHeight + cellHeight / 2 + begin[1];
    } else {
      while (used(cellUsed, rc)) {
        moveToNextCell(rcs, rc);
      }
      x3 = rc.col * cellWidth + cellWidth / 2 + begin[0];
      y3 = rc.row * cellHeight + cellHeight / 2 + begin[1];
      use(cellUsed, rc);
      moveToNextCell(rcs, rc);
    }
    node.data.x = x3;
    node.data.y = y3;
  };

  // node_modules/@antv/layout/lib/radial/index.js
  init_tslib_es6();
  var import_util103 = __toESM(require_lib());

  // node_modules/@antv/layout/lib/radial/mds.js
  var mds = (dimension, distances, linkDistance) => {
    try {
      const M = Matrix2.mul(Matrix2.pow(distances, 2), -0.5);
      const rowMeans = M.mean("row");
      const colMeans = M.mean("column");
      const totalMean = M.mean();
      M.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans);
      const ret = new SingularValueDecomposition2(M);
      const eigenValues = Matrix2.sqrt(ret.diagonalMatrix).diagonal();
      return ret.leftSingularVectors.toJSON().map((row2) => {
        return Matrix2.mul([row2], [eigenValues]).toJSON()[0].splice(0, dimension);
      });
    } catch (_a2) {
      const res = [];
      for (let i = 0; i < distances.length; i++) {
        const x3 = Math.random() * linkDistance;
        const y3 = Math.random() * linkDistance;
        res.push([x3, y3]);
      }
      return res;
    }
  };

  // node_modules/@antv/layout/lib/radial/radial-nonoverlap-force.js
  var SPEED_DIVISOR2 = 800;
  var DEFAULTS_LAYOUT_OPTIONS10 = {
    iterations: 10,
    height: 10,
    width: 10,
    speed: 100,
    gravity: 10,
    k: 5
  };
  var radialNonoverlapForce = (graph, options) => {
    const mergedOptions = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS10), options);
    const { positions, iterations, width: width2, k, speed = 100, strictRadial, focusIdx, radii = [], nodeSizeFunc } = mergedOptions;
    const nodes = graph.getAllNodes();
    const disp = [];
    const maxDisplace = width2 / 10;
    for (let i = 0; i < iterations; i++) {
      positions.forEach((_2, k2) => {
        disp[k2] = { x: 0, y: 0 };
      });
      getRepulsion(nodes, positions, disp, k, radii, nodeSizeFunc);
      updatePositions(positions, disp, speed, strictRadial, focusIdx, maxDisplace, width2, radii);
    }
    return positions;
  };
  var getRepulsion = (nodes, positions, disp, k, radii, nodeSizeFunc) => {
    positions.forEach((v, i) => {
      disp[i] = { x: 0, y: 0 };
      positions.forEach((u, j) => {
        if (i === j) {
          return;
        }
        if (radii[i] !== radii[j]) {
          return;
        }
        let vecx = v.x - u.x;
        let vecy = v.y - u.y;
        let vecLength = Math.sqrt(vecx * vecx + vecy * vecy);
        if (vecLength === 0) {
          vecLength = 1;
          const sign = i > j ? 1 : -1;
          vecx = 0.01 * sign;
          vecy = 0.01 * sign;
        }
        if (vecLength < nodeSizeFunc(nodes[i]) / 2 + nodeSizeFunc(nodes[j]) / 2) {
          const common = k * k / vecLength;
          disp[i].x += vecx / vecLength * common;
          disp[i].y += vecy / vecLength * common;
        }
      });
    });
  };
  var updatePositions = (positions, disp, speed, strictRadial, focusIdx, maxDisplace, width2, radii) => {
    const maxDisp = maxDisplace || width2 / 10;
    if (strictRadial) {
      disp.forEach((di, i) => {
        const vx = positions[i].x - positions[focusIdx].x;
        const vy = positions[i].y - positions[focusIdx].y;
        const vLength = Math.sqrt(vx * vx + vy * vy);
        let vpx = vy / vLength;
        let vpy = -vx / vLength;
        const diLength = Math.sqrt(di.x * di.x + di.y * di.y);
        let alpha = Math.acos((vpx * di.x + vpy * di.y) / diLength);
        if (alpha > Math.PI / 2) {
          alpha -= Math.PI / 2;
          vpx *= -1;
          vpy *= -1;
        }
        const tdispLength = Math.cos(alpha) * diLength;
        di.x = vpx * tdispLength;
        di.y = vpy * tdispLength;
      });
    }
    positions.forEach((n, i) => {
      if (i === focusIdx) {
        return;
      }
      const distLength = Math.sqrt(disp[i].x * disp[i].x + disp[i].y * disp[i].y);
      if (distLength > 0 && i !== focusIdx) {
        const limitedDist = Math.min(maxDisp * (speed / SPEED_DIVISOR2), distLength);
        n.x += disp[i].x / distLength * limitedDist;
        n.y += disp[i].y / distLength * limitedDist;
        if (strictRadial) {
          let vx = n.x - positions[focusIdx].x;
          let vy = n.y - positions[focusIdx].y;
          const nfDis = Math.sqrt(vx * vx + vy * vy);
          vx = vx / nfDis * radii[i];
          vy = vy / nfDis * radii[i];
          n.x = positions[focusIdx].x + vx;
          n.y = positions[focusIdx].y + vy;
        }
      }
    });
    return positions;
  };

  // node_modules/@antv/layout/lib/radial/index.js
  var DEFAULTS_LAYOUT_OPTIONS11 = {
    maxIteration: 1e3,
    focusNode: null,
    unitRadius: null,
    linkDistance: 50,
    preventOverlap: false,
    strictRadial: true,
    maxPreventOverlapIteration: 200,
    sortStrength: 10
  };
  var RadialLayout = class {
    constructor(options = {}) {
      this.options = options;
      this.id = "radial";
      this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS11), options);
    }
    /**
     * Return the positions of nodes and edges(if needed).
     */
    execute(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.genericRadialLayout(false, graph, options);
      });
    }
    /**
     * To directly assign the positions to the nodes.
     */
    assign(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.genericRadialLayout(true, graph, options);
      });
    }
    genericRadialLayout(assign2, graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const mergedOptions = Object.assign(Object.assign({}, this.options), options);
        const { width: propsWidth, height: propsHeight, center: propsCenter, focusNode: propsFocusNode, unitRadius: propsUnitRadius, nodeSize, nodeSpacing, strictRadial, preventOverlap, maxPreventOverlapIteration, sortBy, linkDistance = 50, sortStrength = 10, maxIteration = 1e3 } = mergedOptions;
        const nodes = graph.getAllNodes();
        const edges = graph.getAllEdges();
        const width2 = !propsWidth && typeof window !== "undefined" ? window.innerWidth : propsWidth;
        const height = !propsHeight && typeof window !== "undefined" ? window.innerHeight : propsHeight;
        const center = !propsCenter ? [width2 / 2, height / 2] : propsCenter;
        if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length) || nodes.length === 1) {
          return handleSingleNodeGraph(graph, assign2, center);
        }
        let focusNode = nodes[0];
        if ((0, import_util103.isString)(propsFocusNode)) {
          for (let i = 0; i < nodes.length; i++) {
            if (nodes[i].id === propsFocusNode) {
              focusNode = nodes[i];
              break;
            }
          }
        } else {
          focusNode = propsFocusNode || nodes[0];
        }
        const focusIndex = getIndexById(nodes, focusNode.id);
        const adjMatrix = getAdjMatrix({ nodes, edges }, false);
        const distances = floydWarshall(adjMatrix);
        const maxDistance = maxToFocus(distances, focusIndex);
        handleInfinity2(distances, focusIndex, maxDistance + 1);
        const focusNodeD = distances[focusIndex];
        let semiWidth = width2 - center[0] > center[0] ? center[0] : width2 - center[0];
        let semiHeight = height - center[1] > center[1] ? center[1] : height - center[1];
        if (semiWidth === 0) {
          semiWidth = width2 / 2;
        }
        if (semiHeight === 0) {
          semiHeight = height / 2;
        }
        const maxRadius = Math.min(semiWidth, semiHeight);
        const maxD = Math.max(...focusNodeD);
        const radii = [];
        const unitRadius = !propsUnitRadius ? maxRadius / maxD : propsUnitRadius;
        focusNodeD.forEach((value, i) => {
          radii[i] = value * unitRadius;
        });
        const idealDistances = eIdealDisMatrix(nodes, distances, linkDistance, radii, unitRadius, sortBy, sortStrength);
        const weights = getWeightMatrix(idealDistances);
        const mdsResult = mds(linkDistance, idealDistances, linkDistance);
        let positions = mdsResult.map(([x3, y3]) => ({
          x: (isNaN(x3) ? Math.random() * linkDistance : x3) - mdsResult[focusIndex][0],
          y: (isNaN(y3) ? Math.random() * linkDistance : y3) - mdsResult[focusIndex][1]
        }));
        this.run(maxIteration, positions, weights, idealDistances, radii, focusIndex);
        let nodeSizeFunc;
        if (preventOverlap) {
          nodeSizeFunc = formatNodeSizeToNumber(nodeSize, nodeSpacing);
          const nonoverlapForceParams = {
            nodes,
            nodeSizeFunc,
            positions,
            radii,
            height,
            width: width2,
            strictRadial: Boolean(strictRadial),
            focusIdx: focusIndex,
            iterations: maxPreventOverlapIteration || 200,
            k: positions.length / 4.5
          };
          positions = radialNonoverlapForce(graph, nonoverlapForceParams);
        }
        const layoutNodes = [];
        positions.forEach((p, i) => {
          const cnode = cloneFormatData(nodes[i]);
          cnode.data.x = p.x + center[0];
          cnode.data.y = p.y + center[1];
          layoutNodes.push(cnode);
        });
        if (assign2) {
          layoutNodes.forEach((node) => graph.mergeNodeData(node.id, {
            x: node.data.x,
            y: node.data.y
          }));
        }
        const result = {
          nodes: layoutNodes,
          edges
        };
        return result;
      });
    }
    run(maxIteration, positions, weights, idealDistances, radii, focusIndex) {
      for (let i = 0; i <= maxIteration; i++) {
        const param = i / maxIteration;
        this.oneIteration(param, positions, radii, idealDistances, weights, focusIndex);
      }
    }
    oneIteration(param, positions, radii, distances, weights, focusIndex) {
      const vparam = 1 - param;
      positions.forEach((v, i) => {
        const originDis = getEuclideanDistance(v, { x: 0, y: 0 });
        const reciODis = originDis === 0 ? 0 : 1 / originDis;
        if (i === focusIndex) {
          return;
        }
        let xMolecule = 0;
        let yMolecule = 0;
        let denominator = 0;
        positions.forEach((u, j) => {
          if (i === j) {
            return;
          }
          const edis = getEuclideanDistance(v, u);
          const reciEdis = edis === 0 ? 0 : 1 / edis;
          const idealDis = distances[j][i];
          denominator += weights[i][j];
          xMolecule += weights[i][j] * (u.x + idealDis * (v.x - u.x) * reciEdis);
          yMolecule += weights[i][j] * (u.y + idealDis * (v.y - u.y) * reciEdis);
        });
        const reciR = radii[i] === 0 ? 0 : 1 / radii[i];
        denominator *= vparam;
        denominator += param * reciR * reciR;
        xMolecule *= vparam;
        xMolecule += param * reciR * v.x * reciODis;
        v.x = xMolecule / denominator;
        yMolecule *= vparam;
        yMolecule += param * reciR * v.y * reciODis;
        v.y = yMolecule / denominator;
      });
    }
  };
  var eIdealDisMatrix = (nodes, distances, linkDistance, radii, unitRadius, sortBy, sortStrength) => {
    if (!nodes)
      return [];
    const result = [];
    if (distances) {
      const sortValueCache = {};
      distances.forEach((row2, i) => {
        const newRow = [];
        row2.forEach((v, j) => {
          var _a2, _b;
          if (i === j) {
            newRow.push(0);
          } else if (radii[i] === radii[j]) {
            if (sortBy === "data") {
              newRow.push(v * (Math.abs(i - j) * sortStrength) / (radii[i] / unitRadius));
            } else if (sortBy) {
              let iValue;
              let jValue;
              if (sortValueCache[nodes[i].id]) {
                iValue = sortValueCache[nodes[i].id];
              } else {
                const value = (sortBy === "id" ? nodes[i].id : (_a2 = nodes[i].data) === null || _a2 === void 0 ? void 0 : _a2[sortBy]) || 0;
                if ((0, import_util103.isString)(value)) {
                  iValue = value.charCodeAt(0);
                } else {
                  iValue = value;
                }
                sortValueCache[nodes[i].id] = iValue;
              }
              if (sortValueCache[nodes[j].id]) {
                jValue = sortValueCache[nodes[j].id];
              } else {
                const value = (sortBy === "id" ? nodes[j].id : (_b = nodes[j].data) === null || _b === void 0 ? void 0 : _b[sortBy]) || 0;
                if ((0, import_util103.isString)(value)) {
                  jValue = value.charCodeAt(0);
                } else {
                  jValue = value;
                }
                sortValueCache[nodes[j].id] = jValue;
              }
              newRow.push(v * (Math.abs(iValue - jValue) * sortStrength) / (radii[i] / unitRadius));
            } else {
              newRow.push(v * linkDistance / (radii[i] / unitRadius));
            }
          } else {
            const link = (linkDistance + unitRadius) / 2;
            newRow.push(v * link);
          }
        });
        result.push(newRow);
      });
    }
    return result;
  };
  var getWeightMatrix = (idealDistances) => {
    const rows = idealDistances.length;
    const cols = idealDistances[0].length;
    const result = [];
    for (let i = 0; i < rows; i++) {
      const row2 = [];
      for (let j = 0; j < cols; j++) {
        if (idealDistances[i][j] !== 0) {
          row2.push(1 / (idealDistances[i][j] * idealDistances[i][j]));
        } else {
          row2.push(0);
        }
      }
      result.push(row2);
    }
    return result;
  };
  var getIndexById = (array, id3) => {
    let index2 = -1;
    array.forEach((a2, i) => {
      if (a2.id === id3) {
        index2 = i;
      }
    });
    return Math.max(index2, 0);
  };
  var handleInfinity2 = (matrix3, focusIndex, step2) => {
    const length = matrix3.length;
    for (let i = 0; i < length; i++) {
      if (matrix3[focusIndex][i] === Infinity) {
        matrix3[focusIndex][i] = step2;
        matrix3[i][focusIndex] = step2;
        for (let j = 0; j < length; j++) {
          if (matrix3[i][j] !== Infinity && matrix3[focusIndex][j] === Infinity) {
            matrix3[focusIndex][j] = step2 + matrix3[i][j];
            matrix3[j][focusIndex] = step2 + matrix3[i][j];
          }
        }
      }
    }
    for (let i = 0; i < length; i++) {
      if (i === focusIndex) {
        continue;
      }
      for (let j = 0; j < length; j++) {
        if (matrix3[i][j] === Infinity) {
          let minus = Math.abs(matrix3[focusIndex][i] - matrix3[focusIndex][j]);
          minus = minus === 0 ? 1 : minus;
          matrix3[i][j] = minus;
        }
      }
    }
  };
  var maxToFocus = (matrix3, focusIndex) => {
    let max4 = 0;
    for (let i = 0; i < matrix3[focusIndex].length; i++) {
      if (matrix3[focusIndex][i] === Infinity) {
        continue;
      }
      max4 = matrix3[focusIndex][i] > max4 ? matrix3[focusIndex][i] : max4;
    }
    return max4;
  };

  // node_modules/@antv/layout/lib/random.js
  init_tslib_es6();
  var DEFAULTS_LAYOUT_OPTIONS12 = {
    center: [0, 0],
    width: 300,
    height: 300
  };
  var RandomLayout = class {
    constructor(options = {}) {
      this.options = options;
      this.id = "random";
      this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS12), options);
    }
    /**
     * Return the positions of nodes and edges(if needed).
     */
    execute(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.genericRandomLayout(false, graph, options);
      });
    }
    /**
     * To directly assign the positions to the nodes.
     */
    assign(graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.genericRandomLayout(true, graph, options);
      });
    }
    genericRandomLayout(assign2, graph, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const mergedOptions = Object.assign(Object.assign({}, this.options), options);
        const { center: propsCenter, width: propsWidth, height: propsHeight } = mergedOptions;
        const nodes = graph.getAllNodes();
        const layoutScale = 0.9;
        const width2 = !propsWidth && typeof window !== "undefined" ? window.innerWidth : propsWidth;
        const height = !propsHeight && typeof window !== "undefined" ? window.innerHeight : propsHeight;
        const center = !propsCenter ? [width2 / 2, height / 2] : propsCenter;
        const layoutNodes = [];
        if (nodes) {
          nodes.forEach((node) => {
            layoutNodes.push({
              id: node.id,
              data: {
                x: (Math.random() - 0.5) * layoutScale * width2 + center[0],
                y: (Math.random() - 0.5) * layoutScale * height + center[1]
              }
            });
          });
        }
        if (assign2) {
          layoutNodes.forEach((node) => graph.mergeNodeData(node.id, {
            x: node.data.x,
            y: node.data.y
          }));
        }
        const result = {
          nodes: layoutNodes,
          edges: graph.getAllEdges()
        };
        return result;
      });
    }
  };

  // node_modules/@antv/layout/lib/supervisor.js
  init_tslib_es6();
  var import_util105 = __toESM(require_lib());

  // node_modules/comlink/dist/esm/comlink.mjs
  var proxyMarker = Symbol("Comlink.proxy");
  var createEndpoint = Symbol("Comlink.endpoint");
  var releaseProxy = Symbol("Comlink.releaseProxy");
  var finalizer = Symbol("Comlink.finalizer");
  var throwMarker = Symbol("Comlink.thrown");
  var isObject8 = (val) => typeof val === "object" && val !== null || typeof val === "function";
  var proxyTransferHandler = {
    canHandle: (val) => isObject8(val) && val[proxyMarker],
    serialize(obj) {
      const { port1, port2 } = new MessageChannel();
      expose(obj, port1);
      return [port2, [port2]];
    },
    deserialize(port) {
      port.start();
      return wrap2(port);
    }
  };
  var throwTransferHandler = {
    canHandle: (value) => isObject8(value) && throwMarker in value,
    serialize({ value }) {
      let serialized;
      if (value instanceof Error) {
        serialized = {
          isError: true,
          value: {
            message: value.message,
            name: value.name,
            stack: value.stack
          }
        };
      } else {
        serialized = { isError: false, value };
      }
      return [serialized, []];
    },
    deserialize(serialized) {
      if (serialized.isError) {
        throw Object.assign(new Error(serialized.value.message), serialized.value);
      }
      throw serialized.value;
    }
  };
  var transferHandlers = /* @__PURE__ */ new Map([
    ["proxy", proxyTransferHandler],
    ["throw", throwTransferHandler]
  ]);
  function isAllowedOrigin(allowedOrigins, origin) {
    for (const allowedOrigin of allowedOrigins) {
      if (origin === allowedOrigin || allowedOrigin === "*") {
        return true;
      }
      if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
        return true;
      }
    }
    return false;
  }
  function expose(obj, ep = globalThis, allowedOrigins = ["*"]) {
    ep.addEventListener("message", function callback(ev) {
      if (!ev || !ev.data) {
        return;
      }
      if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
        console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
        return;
      }
      const { id: id3, type, path } = Object.assign({ path: [] }, ev.data);
      const argumentList = (ev.data.argumentList || []).map(fromWireValue);
      let returnValue;
      try {
        const parent = path.slice(0, -1).reduce((obj2, prop) => obj2[prop], obj);
        const rawValue = path.reduce((obj2, prop) => obj2[prop], obj);
        switch (type) {
          case "GET":
            {
              returnValue = rawValue;
            }
            break;
          case "SET":
            {
              parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
              returnValue = true;
            }
            break;
          case "APPLY":
            {
              returnValue = rawValue.apply(parent, argumentList);
            }
            break;
          case "CONSTRUCT":
            {
              const value = new rawValue(...argumentList);
              returnValue = proxy(value);
            }
            break;
          case "ENDPOINT":
            {
              const { port1, port2 } = new MessageChannel();
              expose(obj, port2);
              returnValue = transfer(port1, [port1]);
            }
            break;
          case "RELEASE":
            {
              returnValue = void 0;
            }
            break;
          default:
            return;
        }
      } catch (value) {
        returnValue = { value, [throwMarker]: 0 };
      }
      Promise.resolve(returnValue).catch((value) => {
        return { value, [throwMarker]: 0 };
      }).then((returnValue2) => {
        const [wireValue, transferables] = toWireValue(returnValue2);
        ep.postMessage(Object.assign(Object.assign({}, wireValue), { id: id3 }), transferables);
        if (type === "RELEASE") {
          ep.removeEventListener("message", callback);
          closeEndPoint(ep);
          if (finalizer in obj && typeof obj[finalizer] === "function") {
            obj[finalizer]();
          }
        }
      }).catch((error2) => {
        const [wireValue, transferables] = toWireValue({
          value: new TypeError("Unserializable return value"),
          [throwMarker]: 0
        });
        ep.postMessage(Object.assign(Object.assign({}, wireValue), { id: id3 }), transferables);
      });
    });
    if (ep.start) {
      ep.start();
    }
  }
  function isMessagePort(endpoint) {
    return endpoint.constructor.name === "MessagePort";
  }
  function closeEndPoint(endpoint) {
    if (isMessagePort(endpoint))
      endpoint.close();
  }
  function wrap2(ep, target) {
    const pendingListeners = /* @__PURE__ */ new Map();
    ep.addEventListener("message", function handleMessage(ev) {
      const { data: data2 } = ev;
      if (!data2 || !data2.id) {
        return;
      }
      const resolver = pendingListeners.get(data2.id);
      if (!resolver) {
        return;
      }
      try {
        resolver(data2);
      } finally {
        pendingListeners.delete(data2.id);
      }
    });
    return createProxy(ep, pendingListeners, [], target);
  }
  function throwIfProxyReleased(isReleased) {
    if (isReleased) {
      throw new Error("Proxy has been released and is not useable");
    }
  }
  function releaseEndpoint(ep) {
    return requestResponseMessage(ep, /* @__PURE__ */ new Map(), {
      type: "RELEASE"
    }).then(() => {
      closeEndPoint(ep);
    });
  }
  var proxyCounter = /* @__PURE__ */ new WeakMap();
  var proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep) => {
    const newCount = (proxyCounter.get(ep) || 0) - 1;
    proxyCounter.set(ep, newCount);
    if (newCount === 0) {
      releaseEndpoint(ep);
    }
  });
  function registerProxy(proxy2, ep) {
    const newCount = (proxyCounter.get(ep) || 0) + 1;
    proxyCounter.set(ep, newCount);
    if (proxyFinalizers) {
      proxyFinalizers.register(proxy2, ep, proxy2);
    }
  }
  function unregisterProxy(proxy2) {
    if (proxyFinalizers) {
      proxyFinalizers.unregister(proxy2);
    }
  }
  function createProxy(ep, pendingListeners, path = [], target = function() {
  }) {
    let isProxyReleased = false;
    const proxy2 = new Proxy(target, {
      get(_target, prop) {
        throwIfProxyReleased(isProxyReleased);
        if (prop === releaseProxy) {
          return () => {
            unregisterProxy(proxy2);
            releaseEndpoint(ep);
            pendingListeners.clear();
            isProxyReleased = true;
          };
        }
        if (prop === "then") {
          if (path.length === 0) {
            return { then: () => proxy2 };
          }
          const r = requestResponseMessage(ep, pendingListeners, {
            type: "GET",
            path: path.map((p) => p.toString())
          }).then(fromWireValue);
          return r.then.bind(r);
        }
        return createProxy(ep, pendingListeners, [...path, prop]);
      },
      set(_target, prop, rawValue) {
        throwIfProxyReleased(isProxyReleased);
        const [value, transferables] = toWireValue(rawValue);
        return requestResponseMessage(ep, pendingListeners, {
          type: "SET",
          path: [...path, prop].map((p) => p.toString()),
          value
        }, transferables).then(fromWireValue);
      },
      apply(_target, _thisArg, rawArgumentList) {
        throwIfProxyReleased(isProxyReleased);
        const last2 = path[path.length - 1];
        if (last2 === createEndpoint) {
          return requestResponseMessage(ep, pendingListeners, {
            type: "ENDPOINT"
          }).then(fromWireValue);
        }
        if (last2 === "bind") {
          return createProxy(ep, pendingListeners, path.slice(0, -1));
        }
        const [argumentList, transferables] = processArguments(rawArgumentList);
        return requestResponseMessage(ep, pendingListeners, {
          type: "APPLY",
          path: path.map((p) => p.toString()),
          argumentList
        }, transferables).then(fromWireValue);
      },
      construct(_target, rawArgumentList) {
        throwIfProxyReleased(isProxyReleased);
        const [argumentList, transferables] = processArguments(rawArgumentList);
        return requestResponseMessage(ep, pendingListeners, {
          type: "CONSTRUCT",
          path: path.map((p) => p.toString()),
          argumentList
        }, transferables).then(fromWireValue);
      }
    });
    registerProxy(proxy2, ep);
    return proxy2;
  }
  function myFlat(arr) {
    return Array.prototype.concat.apply([], arr);
  }
  function processArguments(argumentList) {
    const processed = argumentList.map(toWireValue);
    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];
  }
  var transferCache = /* @__PURE__ */ new WeakMap();
  function transfer(obj, transfers) {
    transferCache.set(obj, transfers);
    return obj;
  }
  function proxy(obj) {
    return Object.assign(obj, { [proxyMarker]: true });
  }
  function toWireValue(value) {
    for (const [name, handler] of transferHandlers) {
      if (handler.canHandle(value)) {
        const [serializedValue, transferables] = handler.serialize(value);
        return [
          {
            type: "HANDLER",
            name,
            value: serializedValue
          },
          transferables
        ];
      }
    }
    return [
      {
        type: "RAW",
        value
      },
      transferCache.get(value) || []
    ];
  }
  function fromWireValue(value) {
    switch (value.type) {
      case "HANDLER":
        return transferHandlers.get(value.name).deserialize(value.value);
      case "RAW":
        return value.value;
    }
  }
  function requestResponseMessage(ep, pendingListeners, msg, transfers) {
    return new Promise((resolve) => {
      const id3 = generateUUID();
      pendingListeners.set(id3, resolve);
      if (ep.start) {
        ep.start();
      }
      ep.postMessage(Object.assign({ id: id3 }, msg), transfers);
    });
  }
  function generateUUID() {
    return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
  }

  // node_modules/@antv/layout/lib/supervisor.js
  var import_meta = {};
  var Supervisor = class extends esm_default {
    constructor(graph, layout2, options) {
      super();
      this.graph = graph;
      this.layout = layout2;
      this.options = options;
      this.spawnWorker();
    }
    spawnWorker() {
      this.proxy = wrap2(
        // @ts-ignore
        new Worker(new URL("./worker.js", import_meta.url), { type: "module" })
      );
      if (this.running) {
        this.running = false;
        this.execute();
      }
    }
    execute() {
      var _a2;
      return __awaiter(this, void 0, void 0, function* () {
        if (this.running)
          return this;
        this.running = true;
        const _b = this.layout.options, { onTick } = _b, rest = __rest(_b, ["onTick"]);
        const noFunctionOptions = {};
        Object.keys(rest).forEach((name) => {
          if (!(0, import_util105.isFunction)(rest[name]))
            noFunctionOptions[name] = rest[name];
        });
        const payload = {
          layout: {
            id: this.layout.id,
            options: noFunctionOptions,
            iterations: (_a2 = this.options) === null || _a2 === void 0 ? void 0 : _a2.iterations
          },
          nodes: this.graph.getAllNodes(),
          edges: this.graph.getAllEdges()
        };
        const arraybufferWithNodesEdges = new Float32Array([0]);
        const [positions] = yield this.proxy.calculateLayout(payload, [
          arraybufferWithNodesEdges
        ]);
        return positions;
      });
    }
    stop() {
      this.running = false;
      this.proxy.stopLayout();
      return this;
    }
    kill() {
      this.proxy[releaseProxy]();
    }
    isRunning() {
      return this.running;
    }
  };

  // node_modules/@antv/g6/esm/layouts/fishbone.js
  var import_util106 = __toESM(require_lib());
  var __awaiter13 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var FishboneLayout = class _FishboneLayout extends BaseLayout {
    constructor() {
      super(...arguments);
      this.id = "fishbone";
    }
    getRoot() {
      const roots = this.context.model.getRootsData();
      if ((0, import_util106.isEmpty)(roots) || roots.length > 2)
        return;
      return roots[0];
    }
    formatSize(nodeSize) {
      const nodeSizeFunc = typeof nodeSize === "function" ? nodeSize : () => nodeSize;
      return (node) => parseSize(nodeSizeFunc(node));
    }
    doLayout(root2, options) {
      const { hGap, getRibSep, vGap, nodeSize, height } = options;
      const { model } = this.context;
      const getSize = this.formatSize(nodeSize);
      let ribX = getSize(root2)[0] + getRibSep(root2);
      const getHorizontalOffset = (node, result2 = 0) => {
        var _a2;
        result2 += hGap * ((node.children || []).length + 1);
        (_a2 = node.children) === null || _a2 === void 0 ? void 0 : _a2.forEach((childId) => {
          var _a3;
          const child = model.getNodeLikeDatum(childId);
          (_a3 = child.children) === null || _a3 === void 0 ? void 0 : _a3.forEach((grandChildId) => {
            const grandChild = model.getNodeLikeDatum(grandChildId);
            result2 = getHorizontalOffset(grandChild, result2);
          });
        });
        return result2;
      };
      const getAuxiliaryPoint = (node) => {
        if (node.depth === 1)
          return ribX;
        const parent = model.getParentData(node.id, "tree");
        if (isAtEvenDepth(node)) {
          const ancestor = model.getParentData(parent.id, "tree");
          const deltaY = calculateY(node) - calculateY(ancestor);
          return getAuxiliaryPoint(parent) + deltaY * hGap / vGap;
        } else {
          const nodeIndex = (parent.children || []).indexOf(node.id);
          const followingSiblingsIncludeSelf = model.getNodeData((parent.children || []).slice(nodeIndex));
          return calculateX(parent) - followingSiblingsIncludeSelf.reduce((acc, sibling) => acc + getHorizontalOffset(sibling), 0) - getSize(parent)[0] / 2;
        }
      };
      const calculateX = (0, import_util106.memoize)((node) => {
        if (isRoot(node))
          return getSize(node)[0] / 2;
        const parent = model.getParentData(node.id, "tree");
        if (isAtEvenDepth(node)) {
          return getAuxiliaryPoint(node) + getHorizontalOffset(node) + getSize(node)[0] / 2;
        } else {
          const deltaY = calculateY(node) - calculateY(parent);
          const ratio = hGap / vGap;
          return getAuxiliaryPoint(node) + deltaY * ratio;
        }
      }, (node) => node.id);
      const getParentY = (nodeId) => calculateY(model.getParentData(nodeId, "tree"));
      const calculateY = (0, import_util106.memoize)((node) => {
        if (isRoot(node))
          return height / 2;
        if (!isAtEvenDepth(node)) {
          if ((0, import_util106.isEmpty)(node.children))
            return getParentY(node.id) + vGap;
          const lastChild = model.getNodeLikeDatum(node.children.slice(-1)[0]);
          if ((0, import_util106.isEmpty)(lastChild.children))
            return calculateY(lastChild) + vGap;
          const lastDescendant = model.getDescendantsData(node.id).slice(-1)[0];
          return (isAtEvenDepth(lastDescendant) ? getParentY(lastDescendant.id) : calculateY(lastDescendant)) + vGap;
        } else {
          const parent = model.getParentData(node.id, "tree");
          const nodeIndex = parent.children.indexOf(node.id);
          if (nodeIndex === 0)
            return getParentY(parent.id) + vGap;
          const prevSibling = model.getNodeLikeDatum(parent.children[nodeIndex - 1]);
          if ((0, import_util106.isEmpty)(prevSibling.children))
            return calculateY(prevSibling) + vGap;
          const descendants = model.getDescendantsData(prevSibling.id);
          return Math.max(...descendants.map((descendant) => isAtEvenDepth(descendant) ? getParentY(descendant.id) : calculateY(descendant))) + vGap;
        }
      }, (node) => node.id);
      let tmpRibX = 0;
      const result = { nodes: [], edges: [] };
      const layout2 = (node) => {
        var _a2;
        (_a2 = node.children) === null || _a2 === void 0 ? void 0 : _a2.forEach((childId) => layout2(model.getNodeLikeDatum(childId)));
        const y3 = calculateY(node);
        const x3 = calculateX(node);
        result.nodes.push({ id: node.id, x: x3, y: y3 });
        if (isRoot(node))
          return;
        const edge = model.getRelatedEdgesData(node.id, "in")[0];
        const controlPoint = [getAuxiliaryPoint(node), isAtEvenDepth(node) ? y3 : getParentY(node.id)];
        result.edges.push({ id: idOf(edge), controlPoints: [controlPoint], relatedNodeId: node.id });
        tmpRibX = Math.max(tmpRibX, x3 + getRibSep(node));
        if (node.depth === 1)
          ribX = tmpRibX;
      };
      layout2(root2);
      return result;
    }
    placeAlterative(result, root2) {
      const oddIndexedRibs = (root2.children || []).filter((_2, index2) => index2 % 2 !== 0);
      if (oddIndexedRibs.length === 0)
        return result;
      const { model } = this.context;
      const rootY = result.nodes.find((node) => node.id === root2.id).y;
      const shouldFlip = (nodeId) => {
        const ancestors = model.getAncestorsData(nodeId, "tree");
        if ((0, import_util106.isEmpty)(ancestors))
          return false;
        const ribId = ancestors.length === 1 ? nodeId : ancestors[ancestors.length - 2].id;
        return oddIndexedRibs.includes(ribId);
      };
      result.nodes.forEach((node) => {
        if (shouldFlip(node.id))
          node.y = 2 * rootY - node.y;
      });
      result.edges.forEach((edge) => {
        if (shouldFlip(edge.relatedNodeId)) {
          edge.controlPoints = edge.controlPoints.map((point4) => [point4[0], 2 * rootY - point4[1]]);
        }
      });
    }
    rightToLeft(result, options) {
      result.nodes.forEach((node) => node.x = options.width - node.x);
      result.edges.forEach((edge) => {
        edge.controlPoints = edge.controlPoints.map((point4) => [options.width - point4[0], point4[1]]);
      });
      return result;
    }
    execute(data2, propOptions) {
      return __awaiter13(this, void 0, void 0, function* () {
        const options = Object.assign(Object.assign(Object.assign({}, _FishboneLayout.defaultOptions), this.options), propOptions);
        const { direction: direction2, nodeSize } = options;
        const root2 = this.getRoot();
        if (!root2)
          return data2;
        const getSize = this.formatSize(nodeSize);
        options.vGap || (options.vGap = Math.max(...(data2.nodes || []).map((node) => getSize(node)[1])));
        options.hGap || (options.hGap = Math.max(...(data2.nodes || []).map((node) => getSize(node)[0])));
        let result = this.doLayout(root2, options);
        this.placeAlterative(result, root2);
        if (direction2 === "RL") {
          result = this.rightToLeft(result, options);
        }
        const { model } = this.context;
        const nodes = [];
        const edges = [];
        result.nodes.forEach((node) => {
          const { id: id3, x: x3, y: y3 } = node;
          const nodeData = model.getNodeLikeDatum(id3);
          nodes.push(assignElementStyle(nodeData, { x: x3, y: y3 }));
        });
        result.edges.forEach((edge) => {
          const { id: id3, controlPoints } = edge;
          const edgeData = model.getEdgeDatum(id3);
          edges.push(assignElementStyle(edgeData, { controlPoints }));
        });
        return { nodes, edges };
      });
    }
  };
  FishboneLayout.defaultOptions = {
    direction: "RL",
    getRibSep: () => 60
  };
  var assignElementStyle = (element, style) => {
    return Object.assign(Object.assign({}, element), { style: Object.assign(Object.assign({}, element.style || {}), style) });
  };
  var isRoot = (node) => node.depth === 0;
  var isAtEvenDepth = (node) => (node.depth || (node.depth = 0)) % 2 === 0;

  // node_modules/@antv/g6/esm/layouts/snake.js
  var __awaiter14 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var SnakeLayout = class _SnakeLayout extends BaseLayout {
    constructor() {
      super(...arguments);
      this.id = "snake";
    }
    formatSize(nodes, size2) {
      const sizeFn = typeof size2 === "function" ? size2 : (() => size2);
      return nodes.reduce((acc, node) => {
        const [w, h] = parseSize(sizeFn(node)) || [0, 0];
        return [Math.max(acc[0], w), Math.max(acc[1], h)];
      }, [0, 0]);
    }
    /**
     * Validates the graph data to ensure it meets the requirements for linear arrangement.
     * @param data - Graph data
     * @returns false if the graph is not connected, has more than one source or sink node, or contains cycles.
     */
    validate(data2) {
      const { nodes = [], edges = [] } = data2;
      const inDegree = {};
      const outDegree = {};
      const adjList = {};
      nodes.forEach((node) => {
        inDegree[node.id] = 0;
        outDegree[node.id] = 0;
        adjList[node.id] = [];
      });
      edges.forEach((edge) => {
        inDegree[edge.target]++;
        outDegree[edge.source]++;
        adjList[edge.source].push(edge.target);
      });
      const visited = /* @__PURE__ */ new Set();
      const dfs4 = (nodeId) => {
        if (visited.has(nodeId))
          return;
        visited.add(nodeId);
        adjList[nodeId].forEach(dfs4);
      };
      dfs4(nodes[0].id);
      if (visited.size !== nodes.length)
        return false;
      const sourceNodes = nodes.filter((node) => inDegree[node.id] === 0);
      const sinkNodes = nodes.filter((node) => outDegree[node.id] === 0);
      if (sourceNodes.length !== 1 || sinkNodes.length !== 1)
        return false;
      const middleNodes = nodes.filter((node) => inDegree[node.id] === 1 && outDegree[node.id] === 1);
      if (middleNodes.length !== nodes.length - 2)
        return false;
      return true;
    }
    execute(model, options) {
      return __awaiter14(this, void 0, void 0, function* () {
        var _a2;
        if (!this.validate(model))
          return model;
        const { nodeSize: propNodeSize, padding: propPadding, sortBy, cols, colGap: propColSep, rowGap: propRowSep, clockwise, width: width2, height } = Object.assign({}, _SnakeLayout.defaultOptions, this.options, options);
        const [top, right, bottom, left] = parsePadding(propPadding);
        const nodeSize = this.formatSize(model.nodes || [], propNodeSize);
        const rows = Math.ceil((model.nodes || []).length / cols);
        let colSep = propColSep ? propColSep : (width2 - left - right - cols * nodeSize[0]) / (cols - 1);
        let rowSep = propRowSep ? propRowSep : (height - top - bottom - rows * nodeSize[1]) / (rows - 1);
        if (rowSep === Infinity || rowSep < 0)
          rowSep = 0;
        if (colSep === Infinity || colSep < 0)
          colSep = 0;
        const sortedNodes = sortBy ? (_a2 = model.nodes) === null || _a2 === void 0 ? void 0 : _a2.sort(sortBy) : topologicalSort(model);
        const nodes = (sortedNodes || []).map((node, index2) => {
          const rowIndex = Math.floor(index2 / cols);
          const colIndex = index2 % cols;
          const actualColIndex = clockwise ? rowIndex % 2 === 0 ? colIndex : cols - 1 - colIndex : rowIndex % 2 === 0 ? cols - 1 - colIndex : colIndex;
          const x3 = left + actualColIndex * (nodeSize[0] + colSep) + nodeSize[0] / 2;
          const y3 = top + rowIndex * (nodeSize[1] + rowSep) + nodeSize[1] / 2;
          return {
            id: node.id,
            style: { x: x3, y: y3 }
          };
        });
        return { nodes };
      });
    }
  };
  SnakeLayout.defaultOptions = {
    padding: 0,
    cols: 5,
    clockwise: true
  };
  function topologicalSort(data2) {
    const { nodes = [], edges = [] } = data2;
    const inDegree = {};
    const adjList = {};
    nodes.forEach((node) => {
      inDegree[node.id] = 0;
      adjList[node.id] = [];
    });
    edges.forEach((edge) => {
      inDegree[edge.target]++;
      adjList[edge.source].push(edge.target);
    });
    const queue = [];
    const sortedNodes = [];
    nodes.forEach((node) => {
      if (inDegree[node.id] === 0) {
        queue.push(node.id);
      }
    });
    while (queue.length > 0) {
      const nodeId = queue.shift();
      const node = nodes.find((n) => n.id === nodeId);
      sortedNodes.push(node);
      adjList[nodeId].forEach((neighbor) => {
        inDegree[neighbor]--;
        if (inDegree[neighbor] === 0) {
          queue.push(neighbor);
        }
      });
    }
    return sortedNodes;
  }

  // node_modules/@antv/g6/esm/palettes/index.js
  var spectral = [
    "rgb(158, 1, 66)",
    "rgb(213, 62, 79)",
    "rgb(244, 109, 67)",
    "rgb(253, 174, 97)",
    "rgb(254, 224, 139)",
    "rgb(255, 255, 191)",
    "rgb(230, 245, 152)",
    "rgb(171, 221, 164)",
    "rgb(102, 194, 165)",
    "rgb(50, 136, 189)",
    "rgb(94, 79, 162)"
  ];
  var tableau = [
    "rgb(78, 121, 167)",
    "rgb(242, 142, 44)",
    "rgb(225, 87, 89)",
    "rgb(118, 183, 178)",
    "rgb(89, 161, 79)",
    "rgb(237, 201, 73)",
    "rgb(175, 122, 161)",
    "rgb(255, 157, 167)",
    "rgb(156, 117, 95)",
    "rgb(186, 176, 171)"
  ];
  var oranges = [
    "rgb(255, 245, 235)",
    "rgb(254, 230, 206)",
    "rgb(253, 208, 162)",
    "rgb(253, 174, 107)",
    "rgb(253, 141, 60)",
    "rgb(241, 105, 19)",
    "rgb(217, 72, 1)",
    "rgb(166, 54, 3)",
    "rgb(127, 39, 4)"
  ];
  var greens = [
    "rgb(247, 252, 245)",
    "rgb(229, 245, 224)",
    "rgb(199, 233, 192)",
    "rgb(161, 217, 155)",
    "rgb(116, 196, 118)",
    "rgb(65, 171, 93)",
    "rgb(35, 139, 69)",
    "rgb(0, 109, 44)",
    "rgb(0, 68, 27)"
  ];
  var blues = [
    "rgb(247, 251, 255)",
    "rgb(222, 235, 247)",
    "rgb(198, 219, 239)",
    "rgb(158, 202, 225)",
    "rgb(107, 174, 214)",
    "rgb(66, 146, 198)",
    "rgb(33, 113, 181)",
    "rgb(8, 81, 156)",
    "rgb(8, 48, 107)"
  ];

  // node_modules/@antv/g6/esm/plugins/background/index.js
  var import_util107 = __toESM(require_lib());

  // node_modules/@antv/g6/esm/plugins/base-plugin.js
  var BasePlugin = class extends BaseExtension {
  };

  // node_modules/@antv/g6/esm/plugins/utils/dom.js
  function createPluginContainer(type, cover = true, style) {
    const container = document.createElement("div");
    container.setAttribute("class", `g6-${type}`);
    Object.assign(container.style, {
      position: "absolute",
      display: "block"
    });
    if (cover) {
      Object.assign(container.style, {
        position: "unset",
        gridArea: "1 / 1 / 2 / 2",
        inset: "0px",
        height: "100%",
        width: "100%",
        overflow: "hidden",
        pointerEvents: "none"
      });
    }
    if (style)
      Object.assign(container.style, style);
    return container;
  }
  function insertDOM(id3, tag = "div", style = {}, innerHTML = "", container = document.body) {
    const dom = document.getElementById(id3);
    if (dom)
      dom.remove();
    const div = document.createElement(tag);
    div.innerHTML = innerHTML;
    div.id = id3;
    Object.assign(div.style, style);
    container.appendChild(div);
    return div;
  }

  // node_modules/@antv/g6/esm/plugins/background/index.js
  var __awaiter15 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var Background = class _Background extends BasePlugin {
    constructor(context, options) {
      super(context, Object.assign({}, _Background.defaultOptions, options));
      this.$element = createPluginContainer("background");
      const $container = this.context.canvas.getContainer();
      $container.prepend(this.$element);
      this.update(options);
    }
    /**
     * <zh/> 更新背景图配置
     *
     * <en/> Update the background image configuration
     * @param options - <zh/> 配置项 | <en/> Options
     * @internal
     */
    update(options) {
      const _super = Object.create(null, {
        update: { get: () => super.update }
      });
      return __awaiter15(this, void 0, void 0, function* () {
        _super.update.call(this, options);
        Object.assign(this.$element.style, (0, import_util107.omit)(this.options, ["key", "type"]));
      });
    }
    /**
     * <zh/> 销毁背景图
     *
     * <en/> Destroy the background image
     * @internal
     */
    destroy() {
      super.destroy();
      this.$element.remove();
    }
  };
  Background.defaultOptions = {
    transition: "background 0.5s",
    backgroundSize: "cover",
    zIndex: "-1"
    // aviod to cover the other plugin's dom, eg: grid-line.
  };

  // node_modules/@antv/g6/esm/plugins/bubble-sets.js
  var import_util108 = __toESM(require_lib());

  // node_modules/bubblesets-js/build/index.js
  function linePtSegDistSq(lx1, ly1, lx2, ly2, x3, y3) {
    const x1 = lx1;
    const y1 = ly1;
    const x22 = lx2 - x1;
    const y22 = ly2 - y1;
    let px = x3 - x1;
    let py = y3 - y1;
    let dotprod = px * x22 + py * y22;
    let projlenSq = 0;
    if (dotprod <= 0) {
      projlenSq = 0;
    } else {
      px = x22 - px;
      py = y22 - py;
      dotprod = px * x22 + py * y22;
      if (dotprod <= 0) {
        projlenSq = 0;
      } else {
        projlenSq = dotprod * dotprod / (x22 * x22 + y22 * y22);
      }
    }
    const lenSq = px * px + py * py - projlenSq;
    if (lenSq < 0) {
      return 0;
    }
    return lenSq;
  }
  function ptsDistanceSq(x1, y1, x22, y22) {
    return (x1 - x22) * (x1 - x22) + (y1 - y22) * (y1 - y22);
  }
  function doublePointsEqual(x1, y1, x22, y22, delta) {
    return ptsDistanceSq(x1, y1, x22, y22) < delta * delta;
  }
  function round2(digits) {
    if (!Number.isFinite(digits)) {
      return (v) => v;
    }
    if (digits === 0) {
      return Math.round;
    }
    const factor = Math.pow(10, digits);
    return (v) => Math.round(v * factor) / factor;
  }
  function lineBoundingBox(line2) {
    const minX = Math.min(line2.x1, line2.x2);
    const maxX = Math.max(line2.x1, line2.x2);
    const minY = Math.min(line2.y1, line2.y2);
    const maxY = Math.max(line2.y1, line2.y2);
    return {
      x: minX,
      y: minY,
      x2: maxX,
      y2: maxY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  var Line3 = class _Line {
    constructor(x1, y1, x22, y22) {
      this.x1 = x1;
      this.y1 = y1;
      this.x2 = x22;
      this.y2 = y22;
    }
    equals(that) {
      return this.x1 === that.x1 && this.y1 === that.y1 && this.x2 === that.x2 && this.y2 === that.y2;
    }
    draw(ctx3) {
      ctx3.moveTo(this.x1, this.y1);
      ctx3.lineTo(this.x2, this.y2);
    }
    toString() {
      return `Line(from=(${this.x1},${this.y1}),to=(${this.x2},${this.y2}))`;
    }
    static from(l) {
      return new _Line(l.x1, l.y1, l.x2, l.y2);
    }
    cuts(px, py) {
      if (this.y1 === this.y2) {
        return false;
      }
      if (py < this.y1 && py <= this.y2 || py > this.y1 && py >= this.y2) {
        return false;
      }
      if (px > this.x1 && px >= this.x2) {
        return false;
      }
      if (px < this.x1 && px <= this.x2) {
        return true;
      }
      const cross3 = this.x1 + (py - this.y1) * (this.x2 - this.x1) / (this.y2 - this.y1);
      return px <= cross3;
    }
    distSquare(x3, y3) {
      return linePtSegDistSq(this.x1, this.y1, this.x2, this.y2, x3, y3);
    }
    ptClose(x3, y3, r) {
      if (this.x1 < this.x2) {
        if (x3 < this.x1 - r || x3 > this.x2 + r) {
          return false;
        }
      } else {
        if (x3 < this.x2 - r || x3 > this.x1 + r) {
          return false;
        }
      }
      if (this.y1 < this.y2) {
        if (y3 < this.y1 - r || y3 > this.y2 + r) {
          return false;
        }
      } else {
        if (y3 < this.y2 - r || y3 > this.y1 + r) {
          return false;
        }
      }
      return true;
    }
  };
  var EState;
  (function(EState2) {
    EState2[EState2["POINT"] = 1] = "POINT";
    EState2[EState2["PARALLEL"] = 2] = "PARALLEL";
    EState2[EState2["COINCIDENT"] = 3] = "COINCIDENT";
    EState2[EState2["NONE"] = 4] = "NONE";
  })(EState || (EState = {}));
  var Intersection = class {
    constructor(state, x3 = 0, y3 = 0) {
      this.state = state;
      this.x = x3;
      this.y = y3;
    }
  };
  function intersectLineLine(la, lb) {
    const uaT = (lb.x2 - lb.x1) * (la.y1 - lb.y1) - (lb.y2 - lb.y1) * (la.x1 - lb.x1);
    const ubT = (la.x2 - la.x1) * (la.y1 - lb.y1) - (la.y2 - la.y1) * (la.x1 - lb.x1);
    const uB = (lb.y2 - lb.y1) * (la.x2 - la.x1) - (lb.x2 - lb.x1) * (la.y2 - la.y1);
    if (uB) {
      const ua = uaT / uB;
      const ub = ubT / uB;
      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
        return new Intersection(EState.POINT, la.x1 + ua * (la.x2 - la.x1), la.y1 + ua * (la.y2 - la.y1));
      }
      return new Intersection(EState.NONE);
    }
    return new Intersection(uaT === 0 || ubT === 0 ? EState.COINCIDENT : EState.PARALLEL);
  }
  function fractionAlongLineA(la, lb) {
    const uaT = (lb.x2 - lb.x1) * (la.y1 - lb.y1) - (lb.y2 - lb.y1) * (la.x1 - lb.x1);
    const ubT = (la.x2 - la.x1) * (la.y1 - lb.y1) - (la.y2 - la.y1) * (la.x1 - lb.x1);
    const uB = (lb.y2 - lb.y1) * (la.x2 - la.x1) - (lb.x2 - lb.x1) * (la.y2 - la.y1);
    if (uB) {
      const ua = uaT / uB;
      const ub = ubT / uB;
      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
        return ua;
      }
    }
    return Number.POSITIVE_INFINITY;
  }
  function hasFractionToLineCenter(bounds, line2) {
    function testLine(xa, ya, xb, yb) {
      let testDistance = fractionAlongLineA(line2, new Line3(xa, ya, xb, yb));
      testDistance = Math.abs(testDistance - 0.5);
      if (testDistance >= 0 && testDistance <= 1) {
        return 1;
      }
      return 0;
    }
    let countIntersections = testLine(bounds.x, bounds.y, bounds.x2, bounds.y);
    countIntersections += testLine(bounds.x, bounds.y, bounds.x, bounds.y2);
    if (countIntersections > 1) {
      return true;
    }
    countIntersections += testLine(bounds.x, bounds.y2, bounds.x2, bounds.y2);
    if (countIntersections > 1) {
      return true;
    }
    countIntersections += testLine(bounds.x2, bounds.y, bounds.x2, bounds.y2);
    return countIntersections > 0;
  }
  var OutCode;
  (function(OutCode2) {
    OutCode2[OutCode2["LEFT"] = 0] = "LEFT";
    OutCode2[OutCode2["TOP"] = 1] = "TOP";
    OutCode2[OutCode2["RIGHT"] = 2] = "RIGHT";
    OutCode2[OutCode2["BOTTOM"] = 3] = "BOTTOM";
  })(OutCode || (OutCode = {}));
  function outcode(bounds, px, py) {
    const out = /* @__PURE__ */ new Set();
    if (bounds.width <= 0) {
      out.add(OutCode.LEFT);
      out.add(OutCode.RIGHT);
    } else if (px < bounds.x) {
      out.add(OutCode.LEFT);
    } else if (px > bounds.x + bounds.width) {
      out.add(OutCode.RIGHT);
    }
    if (bounds.height <= 0) {
      out.add(OutCode.TOP);
      out.add(OutCode.BOTTOM);
    } else if (py < bounds.y) {
      out.add(OutCode.TOP);
    } else if (py > bounds.y + bounds.height) {
      out.add(OutCode.BOTTOM);
    }
    return out;
  }
  function intersectsLine(bounds, line2) {
    let x1 = line2.x1;
    let y1 = line2.y1;
    const x22 = line2.x2;
    const y22 = line2.y2;
    const out2 = Array.from(outcode(bounds, x22, y22));
    if (out2.length === 0) {
      return true;
    }
    let out1 = outcode(bounds, x1, y1);
    while (out1.size !== 0) {
      for (const a2 of out2) {
        if (out1.has(a2)) {
          return false;
        }
      }
      if (out1.has(OutCode.RIGHT) || out1.has(OutCode.LEFT)) {
        let x3 = bounds.x;
        if (out1.has(OutCode.RIGHT)) {
          x3 += bounds.width;
        }
        y1 = y1 + (x3 - x1) * (y22 - y1) / (x22 - x1);
        x1 = x3;
      } else {
        let y3 = bounds.y;
        if (out1.has(OutCode.BOTTOM)) {
          y3 += bounds.height;
        }
        x1 = x1 + (y3 - y1) * (x22 - x1) / (y22 - y1);
        y1 = y3;
      }
      out1 = outcode(bounds, x1, y1);
    }
    return true;
  }
  function fractionToLineCenter(bounds, line2) {
    let minDistance = Number.POSITIVE_INFINITY;
    let countIntersections = 0;
    function testLine(xa, ya, xb, yb) {
      let testDistance = fractionAlongLineA(line2, new Line3(xa, ya, xb, yb));
      testDistance = Math.abs(testDistance - 0.5);
      if (testDistance >= 0 && testDistance <= 1) {
        countIntersections++;
        if (testDistance < minDistance) {
          minDistance = testDistance;
        }
      }
    }
    testLine(bounds.x, bounds.y, bounds.x2, bounds.y);
    testLine(bounds.x, bounds.y, bounds.x, bounds.y2);
    if (countIntersections > 1) {
      return minDistance;
    }
    testLine(bounds.x, bounds.y2, bounds.x2, bounds.y2);
    if (countIntersections > 1) {
      return minDistance;
    }
    testLine(bounds.x2, bounds.y, bounds.x2, bounds.y2);
    if (countIntersections === 0) {
      return -1;
    }
    return minDistance;
  }
  function testIntersection(line2, bounds) {
    let count = 0;
    const top = intersectLineLine(line2, new Line3(bounds.x, bounds.y, bounds.x2, bounds.y));
    count += top.state === EState.POINT ? 1 : 0;
    const left = intersectLineLine(line2, new Line3(bounds.x, bounds.y, bounds.x, bounds.y2));
    count += left.state === EState.POINT ? 1 : 0;
    const bottom = intersectLineLine(line2, new Line3(bounds.x, bounds.y2, bounds.x2, bounds.y2));
    count += bottom.state === EState.POINT ? 1 : 0;
    const right = intersectLineLine(line2, new Line3(bounds.x2, bounds.y, bounds.x2, bounds.y2));
    count += right.state === EState.POINT ? 1 : 0;
    return { top, left, bottom, right, count };
  }
  var Rectangle2 = class _Rectangle {
    constructor(x3, y3, width2, height) {
      this.x = x3;
      this.y = y3;
      this.width = width2;
      this.height = height;
    }
    get x2() {
      return this.x + this.width;
    }
    get y2() {
      return this.y + this.height;
    }
    get cx() {
      return this.x + this.width / 2;
    }
    get cy() {
      return this.y + this.height / 2;
    }
    get radius() {
      return Math.max(this.width, this.height) / 2;
    }
    static from(r) {
      return new _Rectangle(r.x, r.y, r.width, r.height);
    }
    equals(that) {
      return this.x === that.x && this.y === that.y && this.width === that.width && this.height === that.height;
    }
    clone() {
      return new _Rectangle(this.x, this.y, this.width, this.height);
    }
    add(that) {
      const x3 = Math.min(this.x, that.x);
      const y3 = Math.min(this.y, that.y);
      const x22 = Math.max(this.x2, that.x + that.width);
      const y22 = Math.max(this.y2, that.y + that.height);
      this.x = x3;
      this.y = y3;
      this.width = x22 - x3;
      this.height = y22 - y3;
    }
    addPoint(p) {
      const x3 = Math.min(this.x, p.x);
      const y3 = Math.min(this.y, p.y);
      const x22 = Math.max(this.x2, p.x);
      const y22 = Math.max(this.y2, p.y);
      this.x = x3;
      this.y = y3;
      this.width = x22 - x3;
      this.height = y22 - y3;
    }
    toString() {
      return `Rectangle[x=${this.x}, y=${this.y}, w=${this.width}, h=${this.height}]`;
    }
    draw(ctx3) {
      ctx3.rect(this.x, this.y, this.width, this.height);
    }
    containsPt(px, py) {
      return px >= this.x && px <= this.x2 && py >= this.y && py <= this.y2;
    }
    get area() {
      return this.width * this.height;
    }
    intersects(that) {
      if (this.area <= 0 || that.width <= 0 || that.height <= 0) {
        return false;
      }
      return that.x + that.width > this.x && that.y + that.height > this.y && that.x < this.x2 && that.y < this.y2;
    }
    distSquare(tempX, tempY) {
      if (this.containsPt(tempX, tempY)) {
        return 0;
      }
      const code = outcode(this, tempX, tempY);
      if (code.has(OutCode.TOP)) {
        if (code.has(OutCode.LEFT)) {
          return ptsDistanceSq(tempX, tempY, this.x, this.y);
        }
        if (code.has(OutCode.RIGHT)) {
          return ptsDistanceSq(tempX, tempY, this.x2, this.y);
        }
        return (this.y - tempY) * (this.y - tempY);
      }
      if (code.has(OutCode.BOTTOM)) {
        if (code.has(OutCode.LEFT)) {
          return ptsDistanceSq(tempX, tempY, this.x, this.y2);
        }
        if (code.has(OutCode.RIGHT)) {
          return ptsDistanceSq(tempX, tempY, this.x2, this.y2);
        }
        return (tempY - this.y2) * (tempY - this.y2);
      }
      if (code.has(OutCode.LEFT)) {
        return (this.x - tempX) * (this.x - tempX);
      }
      if (code.has(OutCode.RIGHT)) {
        return (tempX - this.x2) * (tempX - this.x2);
      }
      return 0;
    }
  };
  function boundingBox(path) {
    if (path.length === 0) {
      return null;
    }
    const first = path[0];
    const bb = new Rectangle2(first.x, first.y, 0, 0);
    for (const point4 of path) {
      bb.addPoint(point4);
    }
    return bb;
  }
  var Circle3 = class _Circle {
    constructor(cx, cy, radius) {
      this.cx = cx;
      this.cy = cy;
      this.radius = radius;
    }
    get x() {
      return this.cx - this.radius;
    }
    get x2() {
      return this.cx + this.radius;
    }
    get width() {
      return this.radius * 2;
    }
    get y() {
      return this.cy - this.radius;
    }
    get y2() {
      return this.cy + this.radius;
    }
    get height() {
      return this.radius * 2;
    }
    static from(r) {
      return new _Circle(r.cx, r.cy, r.radius);
    }
    containsPt(x3, y3) {
      return ptsDistanceSq(this.cx, this.cy, x3, y3) < this.radius * this.radius;
    }
    distSquare(tempX, tempY) {
      const dist = ptsDistanceSq(this.cx, this.cy, tempX, tempY);
      if (dist < this.radius * this.radius) {
        return 0;
      }
      const offset = Math.sqrt(dist) - this.radius;
      return offset * offset;
    }
    draw(ctx3) {
      ctx3.ellipse(this.cx, this.cy, this.radius, this.radius, 0, 0, Math.PI * 2);
    }
  };
  var Area = class _Area {
    constructor(pixelGroup, i = 0, j = 0, pixelX = 0, pixelY = 0, width2 = 10, height = 10, pixels = new Float32Array(Math.max(0, width2 * height)).fill(0)) {
      this.pixelGroup = pixelGroup;
      this.i = i;
      this.j = j;
      this.pixelX = pixelX;
      this.pixelY = pixelY;
      this.width = width2;
      this.height = height;
      this.area = pixels;
    }
    createSub(rect2, pixelPos) {
      return new _Area(this.pixelGroup, rect2.x, rect2.y, pixelPos.x, pixelPos.y, rect2.width, rect2.height);
    }
    static fromPixelRegion(pixelRect, pixelGroup) {
      return new _Area(pixelGroup, 0, 0, pixelRect.x, pixelRect.y, Math.ceil(pixelRect.width / pixelGroup), Math.ceil(pixelRect.height / pixelGroup));
    }
    copy(sub2, pixelPoint) {
      return new _Area(this.pixelGroup, this.scaleX(pixelPoint.x), this.scaleY(pixelPoint.y), pixelPoint.x, pixelPoint.y, sub2.width, sub2.height, sub2.area);
    }
    boundX(pos) {
      if (pos < this.i) {
        return this.i;
      }
      if (pos >= this.width) {
        return this.width - 1;
      }
      return pos;
    }
    boundY(pos) {
      if (pos < this.j) {
        return this.j;
      }
      if (pos >= this.height) {
        return this.height - 1;
      }
      return pos;
    }
    scaleX(pixel) {
      return this.boundX(Math.floor((pixel - this.pixelX) / this.pixelGroup));
    }
    scaleY(pixel) {
      return this.boundY(Math.floor((pixel - this.pixelY) / this.pixelGroup));
    }
    scale(pixelRect) {
      const x3 = this.scaleX(pixelRect.x);
      const y3 = this.scaleY(pixelRect.y);
      const x22 = this.boundX(Math.ceil((pixelRect.x + pixelRect.width - this.pixelX) / this.pixelGroup));
      const y22 = this.boundY(Math.ceil((pixelRect.y + pixelRect.height - this.pixelY) / this.pixelGroup));
      const width2 = x22 - x3;
      const height = y22 - y3;
      return new Rectangle2(x3, y3, width2, height);
    }
    invertScaleX(v) {
      return Math.round(v * this.pixelGroup + this.pixelX);
    }
    invertScaleY(v) {
      return Math.round(v * this.pixelGroup + this.pixelY);
    }
    addPadding(rect2, pixelPadding) {
      const padding = Math.ceil(pixelPadding / this.pixelGroup);
      const x3 = this.boundX(rect2.x - padding);
      const y3 = this.boundY(rect2.y - padding);
      const x22 = this.boundX(rect2.x2 + padding);
      const y22 = this.boundY(rect2.y2 + padding);
      const width2 = x22 - x3;
      const height = y22 - y3;
      return new Rectangle2(x3, y3, width2, height);
    }
    get(i, j) {
      if (i < 0 || j < 0 || i >= this.width || j >= this.height) {
        return Number.NaN;
      }
      return this.area[i + j * this.width];
    }
    inc(i, j, v) {
      if (i < 0 || j < 0 || i >= this.width || j >= this.height) {
        return;
      }
      this.area[i + j * this.width] += v;
    }
    set(i, j, v) {
      if (i < 0 || j < 0 || i >= this.width || j >= this.height) {
        return;
      }
      this.area[i + j * this.width] = v;
    }
    incArea(sub2, factor) {
      if (sub2.width <= 0 || sub2.height <= 0 || factor === 0) {
        return;
      }
      const w = this.width;
      const aw = sub2.width;
      const i1 = Math.max(0, sub2.i);
      const j1 = Math.max(0, sub2.j);
      const i2 = Math.min(sub2.i + sub2.width, w);
      const j2 = Math.min(sub2.j + sub2.height, this.height);
      if (j2 <= 0 || i2 <= 0 || i1 >= w || j2 >= this.height) {
        return;
      }
      for (let j = j1; j < j2; j++) {
        const subRow = (j - sub2.j) * aw;
        const row2 = j * w;
        for (let i = i1; i < i2; i++) {
          const v = sub2.area[i - sub2.i + subRow];
          if (v === 0) {
            continue;
          }
          this.area[i + row2] += factor * v;
        }
      }
    }
    fill(value) {
      this.area.fill(value);
    }
    fillArea(rect2, value) {
      const offset = rect2.x + rect2.y * this.width;
      for (let j = 0; j < rect2.height; j++) {
        const pos = offset + j * this.width;
        this.area.fill(value, pos, pos + rect2.width);
      }
    }
    fillHorizontalLine(i, j, width2, value) {
      const offset = i + j * this.width;
      this.area.fill(value, offset, offset + width2);
    }
    fillVerticalLine(i, j, height, value) {
      const offset = i + j * this.width;
      for (let k = 0; k < height; k++) {
        this.area[offset + k * this.width] = value;
      }
    }
    clear() {
      this.area.fill(0);
    }
    toString() {
      let r = "";
      for (let j = 0; j < this.height; j++) {
        const row2 = j * this.width;
        for (let i = 0; i < this.width; i++) {
          const v = this.area[row2 + i];
          r += v.toFixed(1).padStart(6);
          r += " ";
        }
        r += "\n";
      }
      return r;
    }
    draw(ctx3, offset = true) {
      if (this.width <= 0 || this.height <= 0) {
        return;
      }
      ctx3.save();
      if (offset) {
        ctx3.translate(this.pixelX, this.pixelY);
      }
      const min4 = this.area.reduce((acc, v) => Math.min(acc, v), Number.POSITIVE_INFINITY);
      const max4 = this.area.reduce((acc, v) => Math.max(acc, v), Number.NEGATIVE_INFINITY);
      const scale4 = (v) => (v - min4) / (max4 - min4);
      ctx3.scale(this.pixelGroup, this.pixelGroup);
      for (let i = 0; i < this.width; i++) {
        for (let j = 0; j < this.height; j++) {
          const v = this.area[i + j * this.width];
          ctx3.fillStyle = `rgba(0, 0, 0, ${scale4(v)})`;
          ctx3.fillRect(i, j, 1, 1);
        }
      }
      ctx3.restore();
    }
    drawThreshold(ctx3, threshold, offset = true) {
      if (this.width <= 0 || this.height <= 0) {
        return;
      }
      ctx3.save();
      if (offset) {
        ctx3.translate(this.pixelX, this.pixelY);
      }
      ctx3.scale(this.pixelGroup, this.pixelGroup);
      for (let i = 0; i < this.width; i++) {
        for (let j = 0; j < this.height; j++) {
          const v = this.area[i + j * this.width];
          ctx3.fillStyle = v > threshold ? "black" : "white";
          ctx3.fillRect(i, j, 1, 1);
        }
      }
      ctx3.restore();
    }
  };
  function addPadding(rect2, padding) {
    const map = (r) => ({
      x: r.x - padding,
      y: r.y - padding,
      width: r.width + 2 * padding,
      height: r.height + 2 * padding
    });
    if (Array.isArray(rect2)) {
      return rect2.map(map);
    }
    return map(rect2);
  }
  function createLineInfluenceArea(line2, potentialArea, padding) {
    return createGenericInfluenceArea(Object.assign(lineBoundingBox(line2), {
      distSquare: (x3, y3) => linePtSegDistSq(line2.x1, line2.y1, line2.x2, line2.y2, x3, y3)
    }), potentialArea, padding);
  }
  function createGenericInfluenceArea(shape, potentialArea, padding) {
    const lr = addPadding(shape, padding);
    const scaled = potentialArea.scale(lr);
    const area = potentialArea.createSub(scaled, lr);
    sample(area, potentialArea, padding, (x3, y3) => shape.distSquare(x3, y3));
    return area;
  }
  function sample(area, potentialArea, padding, distanceFunction) {
    const padding2 = padding * padding;
    for (let y3 = 0; y3 < area.height; y3++) {
      for (let x3 = 0; x3 < area.width; x3++) {
        const tempX = potentialArea.invertScaleX(area.i + x3);
        const tempY = potentialArea.invertScaleY(area.j + y3);
        const distanceSq = distanceFunction(tempX, tempY);
        if (distanceSq === 0) {
          area.set(x3, y3, padding2);
          continue;
        }
        if (distanceSq < padding2) {
          const dr = padding - Math.sqrt(distanceSq);
          area.set(x3, y3, dr * dr);
        }
      }
    }
    return area;
  }
  function createRectangleInfluenceArea(rect2, potentialArea, padding) {
    const scaled = potentialArea.scale(rect2);
    const padded = potentialArea.addPadding(scaled, padding);
    const area = potentialArea.createSub(padded, { x: rect2.x - padding, y: rect2.y - padding });
    const paddingLeft = scaled.x - padded.x;
    const paddingTop = scaled.y - padded.y;
    const paddingRight = padded.x2 - scaled.x2;
    const paddingBottom = padded.y2 - scaled.y2;
    const innerWidth = padded.width - paddingLeft - paddingRight;
    const innerHeight = padded.height - paddingTop - paddingBottom;
    const padding2 = padding * padding;
    area.fillArea({
      x: paddingLeft,
      y: paddingTop,
      width: innerWidth + 1,
      height: innerHeight + 1
    }, padding2);
    const straightDistances = [0];
    const maxPadding = Math.max(paddingTop, paddingLeft, paddingRight, paddingBottom);
    {
      const tempX = potentialArea.invertScaleX(scaled.x + scaled.width / 2);
      for (let i = 1; i < maxPadding; i++) {
        const tempY = potentialArea.invertScaleY(scaled.y - i);
        const distanceSq = rect2.distSquare(tempX, tempY);
        if (distanceSq < padding2) {
          const dr = padding - Math.sqrt(distanceSq);
          straightDistances.push(dr * dr);
        } else {
          break;
        }
      }
    }
    const cornerDistances = [];
    const maxHorizontalPadding = Math.max(paddingLeft, paddingRight);
    const maxVerticalPadding = Math.max(paddingTop, paddingRight);
    for (let i = 1; i < maxHorizontalPadding; i++) {
      const tempX = potentialArea.invertScaleX(scaled.x - i);
      const row2 = [];
      for (let j = 1; j < maxVerticalPadding; j++) {
        const tempY = potentialArea.invertScaleY(scaled.y - j);
        const distanceSq = rect2.distSquare(tempX, tempY);
        if (distanceSq < padding2) {
          const dr = padding - Math.sqrt(distanceSq);
          row2.push(dr * dr);
        } else {
          row2.push(0);
        }
      }
      cornerDistances.push(row2);
    }
    for (let y3 = 1; y3 < Math.min(paddingTop, straightDistances.length); y3++) {
      const value = straightDistances[y3];
      area.fillHorizontalLine(paddingLeft, paddingTop - y3, innerWidth + 1, value);
    }
    for (let y3 = 1; y3 < Math.min(paddingBottom, straightDistances.length); y3++) {
      const value = straightDistances[y3];
      area.fillHorizontalLine(paddingLeft, paddingTop + innerHeight + y3, innerWidth + 1, value);
    }
    for (let x3 = 1; x3 < Math.min(paddingLeft, straightDistances.length); x3++) {
      const value = straightDistances[x3];
      area.fillVerticalLine(paddingLeft - x3, paddingTop, innerHeight + 1, value);
    }
    for (let x3 = 1; x3 < Math.min(paddingBottom, straightDistances.length); x3++) {
      const value = straightDistances[x3];
      area.fillVerticalLine(paddingLeft + innerWidth + x3, paddingTop, innerHeight + 1, value);
    }
    for (let i = 1; i < paddingLeft; i++) {
      const row2 = cornerDistances[i - 1];
      const ii = paddingLeft - i;
      for (let j = 1; j < paddingTop; j++) {
        area.set(ii, paddingTop - j, row2[j - 1]);
      }
      for (let j = 1; j < paddingBottom; j++) {
        area.set(ii, paddingTop + innerHeight + j, row2[j - 1]);
      }
    }
    for (let i = 1; i < paddingRight; i++) {
      const row2 = cornerDistances[i - 1];
      const ii = paddingLeft + innerWidth + i;
      for (let j = 1; j < paddingTop; j++) {
        area.set(ii, paddingTop - j, row2[j - 1]);
      }
      for (let j = 1; j < paddingBottom; j++) {
        area.set(ii, paddingTop + innerHeight + j, row2[j - 1]);
      }
    }
    return area;
  }
  function point2(x3, y3) {
    return { x: x3, y: y3 };
  }
  function calculateVirtualEdges(items, nonMembers, maxRoutingIterations, morphBuffer) {
    if (items.length === 0) {
      return [];
    }
    const sorted = sortByDistanceToCentroid(items);
    return sorted.map((d2, i) => {
      const visited = sorted.slice(0, i);
      return connectItem(nonMembers, d2, visited, maxRoutingIterations, morphBuffer);
    }).flat();
  }
  function connectItem(nonMembers, item, visited, maxRoutingIterations, morphBuffer) {
    const itemCenter = point2(item.cx, item.cy);
    const closestNeighbor = calculateClosestNeighbor(itemCenter, visited, nonMembers);
    if (closestNeighbor == null) {
      return [];
    }
    const directLine = new Line3(itemCenter.x, itemCenter.y, closestNeighbor.cx, closestNeighbor.cy);
    const scannedLines = computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer);
    return mergeLines(scannedLines, nonMembers);
  }
  function computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer) {
    const scannedLines = [];
    const linesToCheck = [];
    linesToCheck.push(directLine);
    let hasIntersection = true;
    for (let iterations = 0; iterations < maxRoutingIterations && hasIntersection; iterations++) {
      hasIntersection = false;
      while (!hasIntersection && linesToCheck.length > 0) {
        const line2 = linesToCheck.pop();
        const closestItem = getCenterItem(nonMembers, line2);
        const intersections = closestItem ? testIntersection(line2, closestItem) : null;
        if (!closestItem || !intersections || intersections.count !== 2) {
          if (!hasIntersection) {
            scannedLines.push(line2);
          }
          continue;
        }
        let tempMorphBuffer = morphBuffer;
        let movePoint = rerouteLine(closestItem, tempMorphBuffer, intersections, true);
        let foundFirst = pointExists(movePoint, linesToCheck) || pointExists(movePoint, scannedLines);
        let pointInside = isPointInRectangles(movePoint, nonMembers);
        while (!foundFirst && pointInside && tempMorphBuffer >= 1) {
          tempMorphBuffer /= 1.5;
          movePoint = rerouteLine(closestItem, tempMorphBuffer, intersections, true);
          foundFirst = pointExists(movePoint, linesToCheck) || pointExists(movePoint, scannedLines);
          pointInside = isPointInRectangles(movePoint, nonMembers);
        }
        if (movePoint && !foundFirst && !pointInside) {
          linesToCheck.push(new Line3(line2.x1, line2.y1, movePoint.x, movePoint.y));
          linesToCheck.push(new Line3(movePoint.x, movePoint.y, line2.x2, line2.y2));
          hasIntersection = true;
        }
        if (hasIntersection) {
          continue;
        }
        tempMorphBuffer = morphBuffer;
        movePoint = rerouteLine(closestItem, tempMorphBuffer, intersections, false);
        let foundSecond = pointExists(movePoint, linesToCheck) || pointExists(movePoint, scannedLines);
        pointInside = isPointInRectangles(movePoint, nonMembers);
        while (!foundSecond && pointInside && tempMorphBuffer >= 1) {
          tempMorphBuffer /= 1.5;
          movePoint = rerouteLine(closestItem, tempMorphBuffer, intersections, false);
          foundSecond = pointExists(movePoint, linesToCheck) || pointExists(movePoint, scannedLines);
          pointInside = isPointInRectangles(movePoint, nonMembers);
        }
        if (movePoint && !foundSecond) {
          linesToCheck.push(new Line3(line2.x1, line2.y1, movePoint.x, movePoint.y));
          linesToCheck.push(new Line3(movePoint.x, movePoint.y, line2.x2, line2.y2));
          hasIntersection = true;
        }
        if (!hasIntersection) {
          scannedLines.push(line2);
        }
      }
    }
    while (linesToCheck.length > 0) {
      scannedLines.push(linesToCheck.pop());
    }
    return scannedLines;
  }
  function mergeLines(scannedLines, nonMembers) {
    const finalRoute = [];
    while (scannedLines.length > 0) {
      const line1 = scannedLines.pop();
      if (scannedLines.length === 0) {
        finalRoute.push(line1);
        break;
      }
      const line2 = scannedLines.pop();
      const mergeLine = new Line3(line1.x1, line1.y1, line2.x2, line2.y2);
      const closestItem = getCenterItem(nonMembers, mergeLine);
      if (!closestItem) {
        scannedLines.push(mergeLine);
      } else {
        finalRoute.push(line1);
        scannedLines.push(line2);
      }
    }
    return finalRoute;
  }
  function calculateClosestNeighbor(itemCenter, visited, nonMembers) {
    let minLengthSq = Number.POSITIVE_INFINITY;
    return visited.reduce((closestNeighbor, neighborItem) => {
      const distanceSq = ptsDistanceSq(itemCenter.x, itemCenter.y, neighborItem.cx, neighborItem.cy);
      if (distanceSq > minLengthSq) {
        return closestNeighbor;
      }
      const directLine = new Line3(itemCenter.x, itemCenter.y, neighborItem.cx, neighborItem.cy);
      const numberInterferenceItems = itemsCuttingLine(nonMembers, directLine);
      if (distanceSq * (numberInterferenceItems + 1) * (numberInterferenceItems + 1) < minLengthSq) {
        closestNeighbor = neighborItem;
        minLengthSq = distanceSq * (numberInterferenceItems + 1) * (numberInterferenceItems + 1);
      }
      return closestNeighbor;
    }, null);
  }
  function sortByDistanceToCentroid(items) {
    if (items.length < 2) {
      return items;
    }
    let totalX = 0;
    let totalY = 0;
    items.forEach((item) => {
      totalX += item.cx;
      totalY += item.cy;
    });
    totalX /= items.length;
    totalY /= items.length;
    return items.map((item) => {
      const diffX = totalX - item.cx;
      const diffY = totalY - item.cy;
      const dist = diffX * diffX + diffY * diffY;
      return [item, dist];
    }).sort((a2, b) => a2[1] - b[1]).map((d2) => d2[0]);
  }
  function isPointInRectangles(p, rects) {
    return rects.some((r) => r.containsPt(p.x, p.y));
  }
  function pointExists(pointToCheck, lines) {
    return lines.some((checkEndPointsLine) => {
      if (doublePointsEqual(checkEndPointsLine.x1, checkEndPointsLine.y1, pointToCheck.x, pointToCheck.y, 1e-3)) {
        return true;
      }
      if (doublePointsEqual(checkEndPointsLine.x2, checkEndPointsLine.y2, pointToCheck.x, pointToCheck.y, 1e-3)) {
        return true;
      }
      return false;
    });
  }
  function getCenterItem(items, testLine) {
    let minDistance = Number.POSITIVE_INFINITY;
    let closestItem = null;
    for (const item of items) {
      if (!intersectsLine(item, testLine)) {
        continue;
      }
      const distance6 = fractionToLineCenter(item, testLine);
      if (distance6 >= 0 && distance6 < minDistance) {
        closestItem = item;
        minDistance = distance6;
      }
    }
    return closestItem;
  }
  function itemsCuttingLine(items, testLine) {
    return items.reduce((count, item) => {
      if (intersectsLine(item, testLine) && hasFractionToLineCenter(item, testLine)) {
        return count + 1;
      }
      return count;
    }, 0);
  }
  function rerouteLine(item, rerouteBuffer, intersections, wrapNormal) {
    const topIntersect = intersections.top;
    const leftIntersect = intersections.left;
    const bottomIntersect = intersections.bottom;
    const rightIntersect = intersections.right;
    if (wrapNormal) {
      if (leftIntersect.state === EState.POINT) {
        if (topIntersect.state === EState.POINT)
          return point2(item.x - rerouteBuffer, item.y - rerouteBuffer);
        if (bottomIntersect.state === EState.POINT)
          return point2(item.x - rerouteBuffer, item.y2 + rerouteBuffer);
        const totalArea3 = item.width * item.height;
        const topArea = item.width * ((leftIntersect.y - item.y + (rightIntersect.y - item.y)) * 0.5);
        if (topArea < totalArea3 * 0.5) {
          if (leftIntersect.y > rightIntersect.y)
            return point2(item.x - rerouteBuffer, item.y - rerouteBuffer);
          return point2(item.x2 + rerouteBuffer, item.y - rerouteBuffer);
        }
        if (leftIntersect.y < rightIntersect.y)
          return point2(item.x - rerouteBuffer, item.y2 + rerouteBuffer);
        return point2(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);
      }
      if (rightIntersect.state === EState.POINT) {
        if (topIntersect.state === EState.POINT)
          return point2(item.x2 + rerouteBuffer, item.y - rerouteBuffer);
        if (bottomIntersect.state === EState.POINT)
          return point2(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);
      }
      const totalArea2 = item.height * item.width;
      const leftArea2 = item.height * ((topIntersect.x - item.x + (rightIntersect.x - item.x)) * 0.5);
      if (leftArea2 < totalArea2 * 0.5) {
        if (topIntersect.x > bottomIntersect.x)
          return point2(item.x - rerouteBuffer, item.y - rerouteBuffer);
        return point2(item.x - rerouteBuffer, item.y2 + rerouteBuffer);
      }
      if (topIntersect.x < bottomIntersect.x)
        return point2(item.x2 + rerouteBuffer, item.y - rerouteBuffer);
      return point2(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);
    }
    if (leftIntersect.state === EState.POINT) {
      if (topIntersect.state === EState.POINT)
        return point2(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);
      if (bottomIntersect.state === EState.POINT)
        return point2(item.x2 + rerouteBuffer, item.y - rerouteBuffer);
      const totalArea2 = item.height * item.width;
      const topArea = item.width * ((leftIntersect.y - item.y + (rightIntersect.y - item.y)) * 0.5);
      if (topArea < totalArea2 * 0.5) {
        if (leftIntersect.y > rightIntersect.y)
          return point2(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);
        return point2(item.x - rerouteBuffer, item.y2 + rerouteBuffer);
      }
      if (leftIntersect.y < rightIntersect.y)
        return point2(item.x2 + rerouteBuffer, item.y - rerouteBuffer);
      return point2(item.x - rerouteBuffer, item.y - rerouteBuffer);
    }
    if (rightIntersect.state === EState.POINT) {
      if (topIntersect.state === EState.POINT)
        return point2(item.x - rerouteBuffer, item.y2 + rerouteBuffer);
      if (bottomIntersect.state === EState.POINT)
        return point2(item.x - rerouteBuffer, item.y - rerouteBuffer);
    }
    const totalArea = item.height * item.width;
    const leftArea = item.height * ((topIntersect.x - item.x + (rightIntersect.x - item.x)) * 0.5);
    if (leftArea < totalArea * 0.5) {
      if (topIntersect.x > bottomIntersect.x)
        return point2(item.x2 + rerouteBuffer, item.y2 + rerouteBuffer);
      return point2(item.x2 + rerouteBuffer, item.y - rerouteBuffer);
    }
    if (topIntersect.x < bottomIntersect.x)
      return point2(item.x - rerouteBuffer, item.y2 + rerouteBuffer);
    return point2(item.x - rerouteBuffer, item.y - rerouteBuffer);
  }
  function canTakeNext(path, start, end, toleranceSquared) {
    const validEnd = path.closed ? end < path.length : end < path.length - 1;
    if (!validEnd) {
      return false;
    }
    const s = path.get(start);
    const e = path.get(end + 1);
    for (let index2 = start + 1; index2 <= end; index2++) {
      const p = path.get(index2);
      const len = linePtSegDistSq(s.x, s.y, e.x, e.y, p.x, p.y);
      if (len > toleranceSquared) {
        return false;
      }
    }
    return true;
  }
  function shapeSimplifier(tolerance2 = 0) {
    return (path) => {
      if (tolerance2 < 0 || path.length < 3) {
        return path;
      }
      const points = [];
      let start = 0;
      const toleranceSquared = tolerance2 * tolerance2;
      while (start < path.length) {
        let end = start + 1;
        while (canTakeNext(path, start, end, toleranceSquared)) {
          end++;
        }
        points.push(path.get(start));
        start = end;
      }
      return new PointPath(points);
    };
  }
  function basicFunction(i, t) {
    switch (i) {
      case -2:
        return (((-t + 3) * t - 3) * t + 1) / 6;
      case -1:
        return ((3 * t - 6) * t * t + 4) / 6;
      case 0:
        return (((-3 * t + 3) * t + 3) * t + 1) / 6;
      case 1:
        return t * t * t / 6;
      default:
        throw new Error("unknown error");
    }
  }
  function bSplineShapeGenerator(granularity = 6) {
    const ORDER = 3;
    const START_INDEX = ORDER - 1;
    const REL_END = 1;
    const REL_START = REL_END - ORDER;
    function calcPoint(path, i, t) {
      let px = 0;
      let py = 0;
      for (let j = REL_START; j <= REL_END; j++) {
        const p = path.get(i + j);
        const bf = basicFunction(j, t);
        px += bf * p.x;
        py += bf * p.y;
      }
      return { x: px, y: py };
    }
    return (path) => {
      if (path.length < 3) {
        return path;
      }
      const res = [];
      const closed = path.closed;
      const count = path.length + ORDER - 1 + (closed ? 0 : 2);
      res.push(calcPoint(path, START_INDEX - (closed ? 0 : 2), 0));
      for (let ix = START_INDEX - (closed ? 0 : 2); ix < count; ix++) {
        for (let k = 1; k <= granularity; k++) {
          res.push(calcPoint(path, ix, k / granularity));
        }
      }
      return new PointPath(res);
    };
  }
  function samplePath(skip = 8) {
    return (path) => {
      let actSkip = skip;
      let size2 = path.length;
      if (actSkip > 1) {
        size2 = Math.floor(path.length / actSkip);
        while (size2 < 3 && actSkip > 1) {
          actSkip -= 1;
          size2 = Math.floor(path.length / actSkip);
        }
      }
      const finalHull = [];
      for (let i = 0, j = 0; j < size2; j++, i += actSkip) {
        finalHull.push(path.get(i));
      }
      return new PointPath(finalHull);
    };
  }
  var PointPath = class {
    constructor(points = [], closed = true) {
      this.points = points;
      this.closed = closed;
    }
    get(index2) {
      const i = index2;
      const l = this.points.length;
      if (index2 < 0) {
        return this.closed ? this.get(index2 + l) : this.points[0];
      } else if (index2 >= l) {
        return this.closed ? this.get(index2 - l) : this.points[l - 1];
      }
      return this.points[i];
    }
    get length() {
      return this.points.length;
    }
    toString(roundToDigits = Infinity) {
      const points = this.points;
      if (points.length === 0) {
        return "";
      }
      const rounder = typeof roundToDigits === "function" ? roundToDigits : round2(roundToDigits);
      let r = "M";
      for (const p of points) {
        r += `${rounder(p.x)},${rounder(p.y)} L`;
      }
      r = r.slice(0, -1);
      if (this.closed) {
        r += " Z";
      }
      return r;
    }
    draw(ctx3) {
      const points = this.points;
      if (points.length === 0) {
        return;
      }
      ctx3.beginPath();
      ctx3.moveTo(points[0].x, points[0].y);
      for (const p of points) {
        ctx3.lineTo(p.x, p.y);
      }
      if (this.closed) {
        ctx3.closePath();
      }
    }
    sample(skip) {
      return samplePath(skip)(this);
    }
    simplify(tolerance2) {
      return shapeSimplifier(tolerance2)(this);
    }
    bSplines(granularity) {
      return bSplineShapeGenerator(granularity)(this);
    }
    apply(transformer) {
      return transformer(this);
    }
    containsElements(members) {
      const bb = boundingBox(this.points);
      if (!bb) {
        return false;
      }
      return members.every((member) => {
        return bb.containsPt(member.cx, member.cy) && this.withinArea(member.cx, member.cy);
      });
    }
    withinArea(px, py) {
      if (this.length === 0) {
        return false;
      }
      let crossings = 0;
      const first = this.points[0];
      const line2 = new Line3(first.x, first.y, first.x, first.y);
      for (let i = 1; i < this.points.length; i++) {
        const cur = this.points[i];
        line2.x1 = line2.x2;
        line2.y1 = line2.y2;
        line2.x2 = cur.x;
        line2.y2 = cur.y;
        if (line2.cuts(px, py)) {
          crossings++;
        }
      }
      line2.x1 = line2.x2;
      line2.y1 = line2.y2;
      line2.x2 = first.x;
      line2.y2 = first.y;
      if (line2.cuts(px, py)) {
        crossings++;
      }
      return crossings % 2 === 1;
    }
  };
  var PointList = class {
    constructor(size2 = 0) {
      this.count = 0;
      this.arr = [];
      this.set = /* @__PURE__ */ new Set();
      this.arr.length = size2;
    }
    add(p) {
      this.set.add(`${p.x}x${p.y}`);
      this.arr[this.count++] = p;
    }
    contains(p) {
      return this.set.has(`${p.x}x${p.y}`);
    }
    isFirst(p) {
      if (this.count === 0) {
        return false;
      }
      const o = this.arr[0];
      return o != null && o.x === p.x && o.y === p.y;
    }
    path() {
      return new PointPath(this.arr.slice(0, this.count));
    }
    clear() {
      this.set.clear();
      this.count = 0;
    }
    get(ix) {
      return this.arr[ix];
    }
    get length() {
      return this.count;
    }
  };
  var N = 0;
  var S = 1;
  var E = 2;
  var W = 3;
  function marchingSquares(potentialArea, threshold) {
    const estLength = (Math.floor(potentialArea.width) + Math.floor(potentialArea.height)) * 2;
    const contour = new PointList(estLength);
    function updateDir(x3, y3, dir, res) {
      const v = potentialArea.get(x3, y3);
      if (Number.isNaN(v)) {
        return Number.NaN;
      }
      if (v > threshold) {
        return dir + res;
      }
      return dir;
    }
    function getState(x3, y3) {
      let dir = N;
      dir = updateDir(x3, y3, dir, 1);
      dir = updateDir(x3 + 1, y3, dir, 2);
      dir = updateDir(x3, y3 + 1, dir, 4);
      dir = updateDir(x3 + 1, y3 + 1, dir, 8);
      if (Number.isNaN(dir)) {
        return -1;
      }
      return dir;
    }
    let direction2 = S;
    function doMarch(xPos, yPos) {
      let x3 = xPos;
      let y3 = yPos;
      let xPixel = potentialArea.invertScaleX(x3);
      let yPixel = potentialArea.invertScaleY(y3);
      for (let i = 0; i < potentialArea.width * potentialArea.height; i++) {
        const p = { x: xPixel, y: yPixel };
        if (contour.contains(p)) {
          if (!contour.isFirst(p)) ;
          else {
            return true;
          }
        } else {
          contour.add(p);
        }
        const state = getState(x3, y3);
        switch (state) {
          case -1:
            return true;
          case 0:
          case 3:
          case 2:
          case 7:
            direction2 = E;
            break;
          case 12:
          case 14:
          case 4:
            direction2 = W;
            break;
          case 6:
            direction2 = direction2 === N ? W : E;
            break;
          case 1:
          case 13:
          case 5:
            direction2 = N;
            break;
          case 9:
            direction2 = direction2 === E ? N : S;
            break;
          case 10:
          case 8:
          case 11:
            direction2 = S;
            break;
          default:
            console.warn("Marching squares invalid state: " + state);
            return true;
        }
        switch (direction2) {
          case N:
            y3--;
            yPixel -= potentialArea.pixelGroup;
            break;
          case S:
            y3++;
            yPixel += potentialArea.pixelGroup;
            break;
          case W:
            x3--;
            xPixel -= potentialArea.pixelGroup;
            break;
          case E:
            x3++;
            xPixel += potentialArea.pixelGroup;
            break;
          default:
            console.warn("Marching squares invalid state: " + state);
            return true;
        }
      }
      return true;
    }
    for (let x3 = 0; x3 < potentialArea.width; x3++) {
      for (let y3 = 0; y3 < potentialArea.height; y3++) {
        if (potentialArea.get(x3, y3) <= threshold) {
          continue;
        }
        const state = getState(x3, y3);
        if (state < 0 || state === 15) {
          continue;
        }
        if (doMarch(x3, y3)) {
          return contour.path();
        }
      }
    }
    return null;
  }
  var defaultOptions2 = {
    maxRoutingIterations: 100,
    maxMarchingIterations: 20,
    pixelGroup: 4,
    edgeR0: 10,
    edgeR1: 20,
    nodeR0: 15,
    nodeR1: 50,
    morphBuffer: 10,
    threshold: 1,
    memberInfluenceFactor: 1,
    edgeInfluenceFactor: 1,
    nonMemberInfluenceFactor: -0.8,
    virtualEdges: true
  };
  function isCircle(v) {
    return v != null && typeof v.radius === "number";
  }
  function isEqual8(a2, b) {
    if (isCircle(a2) !== isCircle(b)) {
      return false;
    }
    if (isCircle(a2)) {
      const bc = b;
      return a2.cx === bc.cx && a2.cy === bc.cy && a2.radius === bc.radius;
    }
    const br = b;
    return a2.x === br.x && a2.y === br.y && a2.width === br.width && a2.height === br.height;
  }
  var EDirty;
  (function(EDirty2) {
    EDirty2[EDirty2["MEMBERS"] = 0] = "MEMBERS";
    EDirty2[EDirty2["NON_MEMBERS"] = 1] = "NON_MEMBERS";
    EDirty2[EDirty2["EDGES"] = 2] = "EDGES";
  })(EDirty || (EDirty = {}));
  var BubbleSets = class {
    constructor(options = {}) {
      this.dirty = /* @__PURE__ */ new Set();
      this.members = [];
      this.nonMembers = [];
      this.virtualEdges = [];
      this.edges = [];
      this.activeRegion = new Rectangle2(0, 0, 0, 0);
      this.potentialArea = new Area(1, 0, 0, 0, 0, 0, 0);
      this.o = Object.assign({}, defaultOptions2, options);
    }
    pushMember(...members) {
      if (members.length === 0) {
        return;
      }
      this.dirty.add(EDirty.MEMBERS);
      for (const v of members) {
        this.members.push({
          raw: v,
          obj: isCircle(v) ? Circle3.from(v) : Rectangle2.from(v),
          area: null
        });
      }
    }
    removeMember(member) {
      const index2 = this.members.findIndex((d2) => isEqual8(d2.raw, member));
      if (index2 < 0) {
        return false;
      }
      this.members.splice(index2, 1);
      this.dirty.add(EDirty.MEMBERS);
      return true;
    }
    removeNonMember(nonMember) {
      const index2 = this.nonMembers.findIndex((d2) => isEqual8(d2.raw, nonMember));
      if (index2 < 0) {
        return false;
      }
      this.nonMembers.splice(index2, 1);
      this.dirty.add(EDirty.NON_MEMBERS);
      return true;
    }
    removeEdge(edge) {
      const index2 = this.edges.findIndex((d2) => d2.obj.equals(edge));
      if (index2 < 0) {
        return false;
      }
      this.edges.splice(index2, 1);
      this.dirty.add(EDirty.NON_MEMBERS);
      return true;
    }
    pushNonMember(...nonMembers) {
      if (nonMembers.length === 0) {
        return;
      }
      this.dirty.add(EDirty.NON_MEMBERS);
      for (const v of nonMembers) {
        this.nonMembers.push({
          raw: v,
          obj: isCircle(v) ? Circle3.from(v) : Rectangle2.from(v),
          area: null
        });
      }
    }
    pushEdge(...edges) {
      if (edges.length === 0) {
        return;
      }
      this.dirty.add(EDirty.EDGES);
      for (const v of edges) {
        this.edges.push({
          raw: v,
          obj: Line3.from(v),
          area: null
        });
      }
    }
    update() {
      const dirtyMembers = this.dirty.has(EDirty.MEMBERS);
      const dirtyNonMembers = this.dirty.has(EDirty.NON_MEMBERS);
      let dirtyEdges = this.dirty.has(EDirty.EDGES);
      this.dirty.clear();
      const memberObjs = this.members.map((d2) => d2.obj);
      if (this.o.virtualEdges && (dirtyMembers || dirtyNonMembers)) {
        const nonMembersAsRects = this.nonMembers.map((d2) => d2.obj);
        const virtualEdges = calculateVirtualEdges(memberObjs, nonMembersAsRects, this.o.maxRoutingIterations, this.o.morphBuffer);
        const old = new Map(this.virtualEdges.map((e) => [e.obj.toString(), e.area]));
        this.virtualEdges = virtualEdges.map((e) => {
          var _a2;
          return {
            raw: e,
            obj: e,
            area: (_a2 = old.get(e.toString())) !== null && _a2 !== void 0 ? _a2 : null
          };
        });
        dirtyEdges = true;
      }
      let activeRegionDirty = false;
      if (dirtyMembers || dirtyEdges) {
        const edgesObj = this.virtualEdges.concat(this.edges).map((e) => e.obj);
        const bb = unionBoundingBox(memberObjs, edgesObj);
        const padding = Math.max(this.o.edgeR1, this.o.nodeR1) + this.o.morphBuffer;
        const activeRegion = Rectangle2.from(addPadding(bb, padding));
        if (!activeRegion.equals(this.activeRegion)) {
          activeRegionDirty = true;
          this.activeRegion = activeRegion;
        }
      }
      if (activeRegionDirty) {
        const potentialWidth = Math.ceil(this.activeRegion.width / this.o.pixelGroup);
        const potentialHeight = Math.ceil(this.activeRegion.height / this.o.pixelGroup);
        if (this.activeRegion.x !== this.potentialArea.pixelX || this.activeRegion.y !== this.potentialArea.pixelY) {
          this.potentialArea = Area.fromPixelRegion(this.activeRegion, this.o.pixelGroup);
          this.members.forEach((m2) => m2.area = null);
          this.nonMembers.forEach((m2) => m2.area = null);
          this.edges.forEach((m2) => m2.area = null);
          this.virtualEdges.forEach((m2) => m2.area = null);
        } else if (potentialWidth !== this.potentialArea.width || potentialHeight !== this.potentialArea.height) {
          this.potentialArea = Area.fromPixelRegion(this.activeRegion, this.o.pixelGroup);
        }
      }
      const existing = /* @__PURE__ */ new Map();
      const addCache = (m2) => {
        if (m2.area) {
          const key = `${m2.obj.width}x${m2.obj.height}x${m2.obj instanceof Rectangle2 ? "R" : "C"}`;
          existing.set(key, m2.area);
        }
      };
      const createOrAddCache = (m2) => {
        if (m2.area) {
          return;
        }
        const key = `${m2.obj.width}x${m2.obj.height}x${m2.obj instanceof Rectangle2 ? "R" : "C"}`;
        if (existing.has(key)) {
          const r2 = existing.get(key);
          m2.area = this.potentialArea.copy(r2, { x: m2.obj.x - this.o.nodeR1, y: m2.obj.y - this.o.nodeR1 });
          return;
        }
        const r = m2.obj instanceof Rectangle2 ? createRectangleInfluenceArea(m2.obj, this.potentialArea, this.o.nodeR1) : createGenericInfluenceArea(m2.obj, this.potentialArea, this.o.nodeR1);
        m2.area = r;
        existing.set(key, r);
      };
      this.members.forEach(addCache);
      this.nonMembers.forEach(addCache);
      this.members.forEach(createOrAddCache);
      this.nonMembers.forEach((m2) => {
        if (!this.activeRegion.intersects(m2.obj)) {
          m2.area = null;
        } else {
          createOrAddCache(m2);
        }
      });
      this.edges.forEach((edge) => {
        if (!edge.area) {
          edge.area = createLineInfluenceArea(edge.obj, this.potentialArea, this.o.edgeR1);
        }
      });
      this.virtualEdges.forEach((edge) => {
        if (!edge.area) {
          edge.area = createLineInfluenceArea(edge.obj, this.potentialArea, this.o.edgeR1);
        }
      });
    }
    drawMembers(ctx3) {
      for (const member of this.members) {
        member.obj.draw(ctx3);
      }
    }
    drawNonMembers(ctx3) {
      for (const member of this.nonMembers) {
        member.obj.draw(ctx3);
      }
    }
    drawEdges(ctx3) {
      for (const edge of this.edges) {
        edge.obj.draw(ctx3);
      }
    }
    drawPotentialArea(ctx3, offset = true) {
      this.potentialArea.draw(ctx3, offset);
    }
    compute() {
      if (this.members.length === 0) {
        return new PointPath([]);
      }
      if (this.dirty.size > 0) {
        this.update();
      }
      const { o, potentialArea } = this;
      const members = this.members.map((m2) => m2.area);
      const edges = this.virtualEdges.concat(this.edges).map((d2) => d2.area);
      const nonMembers = this.nonMembers.filter((d2) => d2.area != null).map((d2) => d2.area);
      const memberObjs = this.members.map((m2) => m2.obj);
      return calculatePotentialOutline(potentialArea, members, edges, nonMembers, (p) => p.containsElements(memberObjs), o);
    }
  };
  function calculatePotentialOutline(potentialArea, members, edges, nonMembers, validPath, options = {}) {
    const o = Object.assign({}, defaultOptions2, options);
    let threshold = o.threshold;
    let memberInfluenceFactor = o.memberInfluenceFactor;
    let edgeInfluenceFactor = o.edgeInfluenceFactor;
    let nonMemberInfluenceFactor = o.nonMemberInfluenceFactor;
    const nodeInfA = (o.nodeR0 - o.nodeR1) * (o.nodeR0 - o.nodeR1);
    const edgeInfA = (o.edgeR0 - o.edgeR1) * (o.edgeR0 - o.edgeR1);
    for (let iterations = 0; iterations < o.maxMarchingIterations; iterations++) {
      potentialArea.clear();
      if (memberInfluenceFactor !== 0) {
        const f = memberInfluenceFactor / nodeInfA;
        for (const item of members) {
          potentialArea.incArea(item, f);
        }
      }
      if (edgeInfluenceFactor !== 0) {
        const f = edgeInfluenceFactor / edgeInfA;
        for (const area of edges) {
          potentialArea.incArea(area, f);
        }
      }
      if (nonMemberInfluenceFactor !== 0) {
        const f = nonMemberInfluenceFactor / nodeInfA;
        for (const area of nonMembers) {
          potentialArea.incArea(area, f);
        }
      }
      const contour = marchingSquares(potentialArea, threshold);
      if (contour && validPath(contour)) {
        return contour;
      }
      threshold *= 0.95;
      if (iterations <= o.maxMarchingIterations * 0.5) {
        memberInfluenceFactor *= 1.2;
        edgeInfluenceFactor *= 1.2;
      } else if (nonMemberInfluenceFactor !== 0 && nonMembers.length > 0) {
        nonMemberInfluenceFactor *= 0.8;
      } else {
        break;
      }
    }
    return new PointPath([]);
  }
  function unionBoundingBox(memberItems, edgeItems) {
    if (memberItems.length === 0) {
      return new Rectangle2(0, 0, 0, 0);
    }
    const activeRegion = Rectangle2.from(memberItems[0]);
    for (const m2 of memberItems) {
      activeRegion.add(m2);
    }
    for (const l of edgeItems) {
      activeRegion.add(lineBoundingBox(l));
    }
    return activeRegion;
  }

  // node_modules/@antv/g6/esm/plugins/bubble-sets.js
  var __rest14 = function(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  var BubbleSets2 = class _BubbleSets extends BasePlugin {
    constructor(context, options) {
      super(context, (0, import_util108.deepMix)({}, _BubbleSets.defaultOptions, options));
      this.members = /* @__PURE__ */ new Map();
      this.avoidMembers = /* @__PURE__ */ new Map();
      this.bubbleSetOptions = {};
      this.drawBubbleSets = () => {
        const { style, bubbleSetOptions } = this.parseOptions();
        if (!(0, import_util108.isEqual)(this.bubbleSetOptions, bubbleSetOptions))
          this.init();
        this.bubbleSetOptions = Object.assign({}, bubbleSetOptions);
        const finalStyle = Object.assign(Object.assign({}, style), { d: this.getPath() });
        if (!this.shape) {
          this.shape = new Contour({ style: finalStyle });
          this.context.canvas.appendChild(this.shape);
        } else {
          this.shape.update(finalStyle);
        }
      };
      this.updateBubbleSetsPath = (event) => {
        if (!this.shape)
          return;
        const id3 = idOf(event.data);
        if (![...this.options.members, ...this.options.avoidMembers].includes(id3))
          return;
        this.shape.update(Object.assign(Object.assign({}, this.parseOptions().style), { d: this.getPath(id3) }));
      };
      this.getPath = (forceUpdateId) => {
        const { graph } = this.context;
        const currMembers = this.options.members;
        const prevMembers = [...this.members.keys()];
        const currAvoidMembers = this.options.avoidMembers;
        const prevAvoidMembers = [...this.avoidMembers.keys()];
        if (!forceUpdateId && (0, import_util108.isEqual)(currMembers, prevMembers) && (0, import_util108.isEqual)(currAvoidMembers, prevAvoidMembers))
          return this.path;
        const { enter: membersToEnter = [], exit: membersToExit = [] } = arrayDiff(prevMembers, currMembers, (d2) => d2);
        const { enter: avoidMembersToEnter = [], exit: avoidMembersToExit = [] } = arrayDiff(prevAvoidMembers, currAvoidMembers, (d2) => d2);
        if (forceUpdateId) {
          membersToExit.push(forceUpdateId);
          membersToEnter.push(forceUpdateId);
        }
        const updateBubbleSets = (ids, isEntering, isMember) => {
          ids.forEach((id3) => {
            const members = isMember ? this.members : this.avoidMembers;
            const pushMember = isMember ? "pushMember" : "pushNonMember";
            const removeMember = isMember ? "removeMember" : "removeNonMember";
            if (isEntering) {
              let area;
              if (graph.getElementType(id3) === "edge") {
                [area] = convertToLine(graph, id3);
                this.bubbleSets.pushEdge(area);
              } else {
                [area] = convertToRectangle(graph, id3);
                this.bubbleSets[pushMember](area);
              }
              members.set(id3, area);
            } else {
              const area = members.get(id3);
              if (area) {
                if (graph.getElementType(id3) === "edge") {
                  this.bubbleSets.removeEdge(area);
                } else {
                  this.bubbleSets[removeMember](area);
                }
                members.delete(id3);
              }
            }
          });
        };
        updateBubbleSets(membersToExit, false, true);
        updateBubbleSets(membersToEnter, true, true);
        updateBubbleSets(avoidMembersToExit, false, false);
        updateBubbleSets(avoidMembersToEnter, true, false);
        const pointPath = this.bubbleSets.compute();
        const cleanPath = pointPath.sample(8).simplify(0).bSplines().simplify(0);
        this.path = getClosedSpline(cleanPath.points.map(parsePoint));
        return this.path;
      };
      this.bindEvents();
      this.bubbleSets = new BubbleSets(this.options);
    }
    bindEvents() {
      this.context.graph.on(GraphEvent.AFTER_RENDER, this.drawBubbleSets);
      this.context.graph.on(GraphEvent.AFTER_ELEMENT_UPDATE, this.updateBubbleSetsPath);
    }
    init() {
      this.bubbleSets = new BubbleSets(this.options);
      this.members = /* @__PURE__ */ new Map();
      this.avoidMembers = /* @__PURE__ */ new Map();
    }
    parseOptions() {
      const _a2 = this.options, { type, key, members, avoidMembers } = _a2, rest = __rest14(_a2, ["type", "key", "members", "avoidMembers"]);
      const res = Object.keys(rest).reduce((acc, key2) => {
        if (key2 in defaultOptions2) {
          acc.bubbleSetOptions[key2] = rest[key2];
        } else {
          acc.style[key2] = rest[key2];
        }
        return acc;
      }, { style: {}, bubbleSetOptions: {} });
      return Object.assign({ type, key, members, avoidMembers }, res);
    }
    /**
     * <zh/> 添加成员元素
     *
     * <en/> Add member elements
     * @param members - <zh/> 单个或多个 | <en/> single or multiple
     */
    addMember(members) {
      const membersToAdd = Array.isArray(members) ? members : [members];
      if (membersToAdd.some((member) => this.options.avoidMembers.includes(member))) {
        this.options.avoidMembers = this.options.avoidMembers.filter((id3) => !membersToAdd.includes(id3));
      }
      this.options.members = [.../* @__PURE__ */ new Set([...this.options.members, ...membersToAdd])];
      this.drawBubbleSets();
    }
    /**
     * <zh/> 移除成员元素
     *
     * <en/> Remove member elements
     * @param members - <zh/> 单个或多个 | <en/> single or multiple
     */
    removeMember(members) {
      const membersToRemove = Array.isArray(members) ? members : [members];
      this.options.members = this.options.members.filter((id3) => !membersToRemove.includes(id3));
      this.drawBubbleSets();
    }
    /**
     * <zh/> 更新成员元素
     *
     * <en/> Update member elements
     * @param members - <zh/> 值或者回调函数 | <en/> value or callback function
     */
    updateMember(members) {
      this.options.members = (0, import_util108.isFunction)(members) ? members(this.options.members) : members;
      this.drawBubbleSets();
    }
    /**
     * <zh/> 获取成员元素
     *
     * <en/> Get member elements
     * @returns <zh/> 成员元素数组 | <en/> member elements array
     */
    getMember() {
      return this.options.members;
    }
    /**
     * <zh/> 添加需要避开的元素
     *
     * <en/> Add elements to avoid
     * @param avoidMembers - <zh/> 单个或多个 | <en/> single or multiple
     */
    addAvoidMember(avoidMembers) {
      const avoidMembersToAdd = Array.isArray(avoidMembers) ? avoidMembers : [avoidMembers];
      if (avoidMembersToAdd.some((AvoidMember) => this.options.members.includes(AvoidMember))) {
        this.options.members = this.options.members.filter((id3) => !avoidMembersToAdd.includes(id3));
      }
      this.options.avoidMembers = [.../* @__PURE__ */ new Set([...this.options.avoidMembers, ...avoidMembersToAdd])];
      this.drawBubbleSets();
    }
    /**
     * <zh/> 移除需要避开的元素
     *
     * <en/> Remove elements to avoid
     * @param avoidMembers - <zh/> 单个或多个 | <en/> single or multiple
     */
    removeAvoidMember(avoidMembers) {
      const avoidMembersToRemove = Array.isArray(avoidMembers) ? avoidMembers : [avoidMembers];
      if (this.options.avoidMembers.some((member) => avoidMembersToRemove.includes(member))) {
        this.options.avoidMembers = this.options.avoidMembers.filter((id3) => !avoidMembersToRemove.includes(id3));
        this.drawBubbleSets();
      }
    }
    /**
     * <zh/> 更新需要避开的元素
     *
     * <en/> Update elements to avoid
     * @param avoidMembers - <zh/> 单个或多个 | <en/> single or multiple
     */
    updateAvoidMember(avoidMembers) {
      this.options.avoidMembers = Array.isArray(avoidMembers) ? avoidMembers : [avoidMembers];
      this.drawBubbleSets();
    }
    /**
     * <zh/> 获取需要避开的元素
     *
     * <en/> Get elements to avoid
     * @returns avoidMembers <zh/> 成员元素数组 | <en/> member elements array
     */
    getAvoidMember() {
      return this.options.avoidMembers;
    }
    /**
     * <zh/> 销毁
     *
     * <en/> Destroy
     * @internal
     */
    destroy() {
      this.context.graph.off(GraphEvent.AFTER_RENDER, this.drawBubbleSets);
      this.context.graph.off(GraphEvent.AFTER_ELEMENT_UPDATE, this.updateBubbleSetsPath);
      this.shape.destroy();
      super.destroy();
    }
  };
  BubbleSets2.defaultOptions = Object.assign({
    members: [],
    avoidMembers: [],
    /** shape style */
    fill: "lightblue",
    fillOpacity: 0.2,
    stroke: "blue",
    strokeOpacity: 0.2
  }, defaultOptions2);
  var convertToRectangle = (graph, ids) => {
    const idArr = Array.isArray(ids) ? ids : [ids];
    return idArr.map((id3) => {
      const bbox = graph.getElementRenderBounds(id3);
      return new Rectangle2(bbox.min[0], bbox.min[1], getBBoxWidth(bbox), getBBoxHeight(bbox));
    });
  };
  var convertToLine = (graph, ids) => {
    const idArr = Array.isArray(ids) ? ids : [ids];
    return idArr.map((id3) => {
      const data2 = graph.getEdgeData(id3);
      const source = graph.getElementPosition(data2.source);
      const target = graph.getElementPosition(data2.target);
      return Line3.from({ x1: source[0], y1: source[1], x2: target[0], y2: target[1] });
    });
  };

  // node_modules/@antv/g6/esm/plugins/contextmenu/util.js
  function getContentFromItems(items) {
    return `
    <ul class="g6-contextmenu-ul">
      ${items.map((item) => `<li  class="g6-contextmenu-li" value="${item.value}">${item.name}</li>`).join("")}
    </ul>
  `;
  }
  var CONTEXTMENU_CSS = `
  .g6-contextmenu {
    font-size: 12px;
    background-color: rgba(255, 255, 255, 0.96);
    border-radius: 4px;
    overflow: hidden;
    box-shadow: rgba(0, 0, 0, 0.12) 0px 6px 12px 0px;
    transition: visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1) 0s, left 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s, top 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s;
  }

  .g6-contextmenu-ul {
    max-width: 256px;
    min-width: 96px;
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .g6-contextmenu-li {
    padding: 8px 12px;
    cursor: pointer;
    user-select: none;
  }

  .g6-contextmenu-li:hover {
    background-color: #f5f5f5;
    cursor: pointer;
  }
`;

  // node_modules/@antv/g6/esm/plugins/contextmenu/index.js
  var __awaiter16 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var Contextmenu = class _Contextmenu extends BasePlugin {
    constructor(context, options) {
      super(context, Object.assign({}, _Contextmenu.defaultOptions, options));
      this.targetElement = null;
      this.onTriggerEvent = (event) => {
        var _a2;
        (_a2 = event.preventDefault) === null || _a2 === void 0 ? void 0 : _a2.call(event);
        this.show(event);
      };
      this.onMenuItemClick = (event) => {
        const { onClick, trigger } = this.options;
        if (event.target instanceof HTMLElement) {
          if (event.target.className.includes("g6-contextmenu-li")) {
            const value = event.target.getAttribute("value");
            onClick === null || onClick === void 0 ? void 0 : onClick(value, event.target, this.targetElement);
            this.hide();
          }
        }
        if (trigger !== "click")
          this.hide();
      };
      this.initElement();
      this.update(options);
    }
    initElement() {
      this.$element = createPluginContainer("contextmenu", false, { zIndex: "99" });
      const { className } = this.options;
      if (className)
        this.$element.classList.add(className);
      const $container = this.context.canvas.getContainer();
      $container.appendChild(this.$element);
      insertDOM("g6-contextmenu-css", "style", {}, CONTEXTMENU_CSS, document.head);
    }
    /**
     * <zh/> 显示上下文菜单
     *
     * <en/> Show the contextmenu
     * @param event - <zh/> 元素指针事件 | <en/> Element pointer event
     * @internal
     */
    show(event) {
      return __awaiter16(this, void 0, void 0, function* () {
        const { enable, offset } = this.options;
        if (typeof enable === "function" && !enable(event) || !enable) {
          this.hide();
          return;
        }
        const content = yield this.getDOMContent(event);
        if (content instanceof HTMLElement) {
          this.$element.innerHTML = "";
          this.$element.appendChild(content);
        } else {
          this.$element.innerHTML = content;
        }
        const clientRect = this.context.graph.getCanvas().getContainer().getBoundingClientRect();
        this.$element.style.left = `${event.client.x - clientRect.left + offset[0]}px`;
        this.$element.style.top = `${event.client.y - clientRect.top + offset[1]}px`;
        this.$element.style.display = "block";
        this.targetElement = event.target;
      });
    }
    /**
     * <zh/> 隐藏上下文菜单
     *
     * <en/> Hide the contextmenu
     */
    hide() {
      this.$element.style.display = "none";
      this.targetElement = null;
    }
    /**
     * <zh/> 更新上下文菜单的配置项
     *
     * <en/> Update the contextmenu options
     * @param options - <zh/> 配置项 | <en/> Options
     * @internal
     */
    update(options) {
      this.unbindEvents();
      super.update(options);
      this.bindEvents();
    }
    /**
     * <zh/> 销毁上下文菜单
     *
     * <en/> Destroy the contextmenu
     * @internal
     */
    destroy() {
      this.unbindEvents();
      super.destroy();
      this.$element.remove();
    }
    getDOMContent(event) {
      return __awaiter16(this, void 0, void 0, function* () {
        const { getContent, getItems } = this.options;
        if (getItems) {
          return getContentFromItems(yield getItems(event));
        }
        return yield getContent(event);
      });
    }
    bindEvents() {
      const { graph } = this.context;
      const { trigger } = this.options;
      graph.on(`canvas:${trigger}`, this.onTriggerEvent);
      graph.on(`node:${trigger}`, this.onTriggerEvent);
      graph.on(`edge:${trigger}`, this.onTriggerEvent);
      graph.on(`combo:${trigger}`, this.onTriggerEvent);
      document.addEventListener("click", this.onMenuItemClick);
    }
    unbindEvents() {
      const { graph } = this.context;
      const { trigger } = this.options;
      graph.off(`canvas:${trigger}`, this.onTriggerEvent);
      graph.off(`node:${trigger}`, this.onTriggerEvent);
      graph.off(`edge:${trigger}`, this.onTriggerEvent);
      graph.off(`combo:${trigger}`, this.onTriggerEvent);
      document.removeEventListener("click", this.onMenuItemClick);
    }
  };
  Contextmenu.defaultOptions = {
    trigger: "contextmenu",
    offset: [4, 4],
    loadingContent: '<div class="g6-contextmenu-loading">Loading...</div>',
    getContent: () => "It is a empty context menu.",
    enable: () => true
  };

  // node_modules/@antv/g6/esm/plugins/edge-bundling/index.js
  var import_util110 = __toESM(require_lib());
  var EdgeBundling = class _EdgeBundling extends BasePlugin {
    constructor(context, options) {
      super(context, Object.assign({}, _EdgeBundling.defaultOptions, options));
      this.edgeBundles = {};
      this.edgePoints = {};
      this.onBundle = () => {
        const { model, element } = this.context;
        const edges = model.getEdgeData();
        this.divideEdges(this.options.divisions);
        const { cycles, iterRate, divRate } = this.options;
        let { lambda, divisions, iterations } = this.options;
        for (let i = 0; i < cycles; i++) {
          for (let j = 0; j < iterations; j++) {
            const forces = {};
            edges.forEach((edge) => {
              var _a2;
              if (edge.source === edge.target)
                return;
              const edgeId = idOf(edge);
              forces[edgeId] = this.getEdgeForces(edge, divisions, lambda);
              for (let p = 0; p < divisions + 1; p++) {
                (_a2 = this.edgePoints)[edgeId] || (_a2[edgeId] = []);
                this.edgePoints[edgeId][p] = add(this.edgePoints[edgeId][p], forces[edgeId][p]);
              }
            });
          }
          lambda /= 2;
          divisions *= divRate;
          iterations *= iterRate;
          this.divideEdges(divisions);
        }
        edges.forEach((edge) => {
          const edgeId = idOf(edge);
          const edgeEl = element.getElement(edgeId);
          edgeEl === null || edgeEl === void 0 ? void 0 : edgeEl.update({ d: getPolylinePath(this.edgePoints[edgeId]) });
        });
      };
      this.bindEvents();
    }
    get nodeMap() {
      const nodes = this.context.model.getNodeData();
      return Object.fromEntries(nodes.map((node) => [idOf(node), toVector2(positionOf(node))]));
    }
    divideEdges(divisions) {
      const edges = this.context.model.getEdgeData();
      edges.forEach((edge) => {
        var _a2;
        const edgeId = idOf(edge);
        (_a2 = this.edgePoints)[edgeId] || (_a2[edgeId] = []);
        const source = this.nodeMap[edge.source];
        const target = this.nodeMap[edge.target];
        if (divisions === 1) {
          this.edgePoints[edgeId].push(source);
          this.edgePoints[edgeId].push(divide(add(source, target), 2));
          this.edgePoints[edgeId].push(target);
        } else {
          const edgeLength = this.edgePoints[edgeId].length === 0 ? (
            // edge is a straight line
            distance2(source, target)
          ) : (
            // edge is a polyline
            getEdgeLength(this.edgePoints[edgeId])
          );
          const divisionLength = edgeLength / (divisions + 1);
          let currentDivisionLength = divisionLength;
          const newEdgePoints = [source];
          for (let i = 1; i < this.edgePoints[edgeId].length; i++) {
            const prevEp = this.edgePoints[edgeId][i - 1];
            const ep = this.edgePoints[edgeId][i];
            let oriDivisionLength = distance2(ep, prevEp);
            while (oriDivisionLength > currentDivisionLength) {
              const ratio = currentDivisionLength / oriDivisionLength;
              const edgePoint = add(prevEp, multiply(subtract(ep, prevEp), ratio));
              newEdgePoints.push(edgePoint);
              oriDivisionLength -= currentDivisionLength;
              currentDivisionLength = divisionLength;
            }
            currentDivisionLength -= oriDivisionLength;
          }
          newEdgePoints.push(target);
          this.edgePoints[edgeId] = newEdgePoints;
        }
      });
    }
    getVectorPosition(edge) {
      const source = this.nodeMap[edge.source];
      const target = this.nodeMap[edge.target];
      const [vx, vy] = subtract(target, source);
      const length = distance2(source, target);
      return { source, target, vx, vy, length };
    }
    measureEdgeCompatibility(edge1, edge2) {
      const vector1 = this.getVectorPosition(edge1);
      const vector2 = this.getVectorPosition(edge2);
      const ac = getAngleCompatibility(vector1, vector2);
      const sc = getScaleCompatibility(vector1, vector2);
      const pc = getPositionCompatibility(vector1, vector2);
      const vc = getVisibilityCompatibility(vector1, vector2);
      return ac * sc * pc * vc;
    }
    getEdgeBundles() {
      const edgeBundles = {};
      const bundleThreshold = this.options.bundleThreshold;
      const edges = this.context.model.getEdgeData();
      edges.forEach((edge1, i) => {
        edges.forEach((edge2, j) => {
          var _a2, _b;
          if (j <= i)
            return;
          const compatibility = this.measureEdgeCompatibility(edge1, edge2);
          if (compatibility >= bundleThreshold) {
            edgeBundles[_a2 = idOf(edge1)] || (edgeBundles[_a2] = []);
            edgeBundles[idOf(edge1)].push(edge2);
            edgeBundles[_b = idOf(edge2)] || (edgeBundles[_b] = []);
            edgeBundles[idOf(edge2)].push(edge1);
          }
        });
      });
      return edgeBundles;
    }
    getSpringForce(divisions, kp) {
      const { pre, cur, next } = divisions;
      return multiply(subtract(add(pre, next), multiply(cur, 2)), kp);
    }
    getElectrostaticForce(pidx, edge) {
      if ((0, import_util110.isEmpty)(this.edgeBundles)) {
        this.edgeBundles = this.getEdgeBundles();
      }
      const edgeBundle = this.edgeBundles[idOf(edge)];
      let resForce = [0, 0];
      edgeBundle === null || edgeBundle === void 0 ? void 0 : edgeBundle.forEach((eb) => {
        const p1 = this.edgePoints[idOf(eb)][pidx];
        const p2 = this.edgePoints[idOf(edge)][pidx];
        const force = subtract(p1, p2);
        const length = distance2(p1, p2);
        resForce = add(resForce, multiply(force, 1 / length));
      });
      return resForce;
    }
    getEdgeForces(edge, divisions, lambda) {
      const source = this.nodeMap[edge.source];
      const target = this.nodeMap[edge.target];
      const kp = this.options.K / (distance2(source, target) * (divisions + 1));
      const edgePointForces = [[0, 0]];
      const edgeId = idOf(edge);
      for (let i = 1; i < divisions; i++) {
        const spring = this.getSpringForce({
          pre: this.edgePoints[edgeId][i - 1],
          cur: this.edgePoints[edgeId][i],
          next: this.edgePoints[edgeId][i + 1] || [0, 0]
        }, kp);
        const electrostatic = this.getElectrostaticForce(i, edge);
        edgePointForces.push(multiply(add(spring, electrostatic), lambda));
      }
      edgePointForces.push([0, 0]);
      return edgePointForces;
    }
    bindEvents() {
      const { graph } = this.context;
      graph.on(GraphEvent.AFTER_RENDER, this.onBundle);
    }
    unbindEvents() {
      const { graph } = this.context;
      graph.off(GraphEvent.AFTER_RENDER, this.onBundle);
    }
    destroy() {
      this.unbindEvents();
      super.destroy();
    }
  };
  EdgeBundling.defaultOptions = {
    K: 0.1,
    lambda: 0.1,
    divisions: 1,
    divRate: 2,
    cycles: 6,
    iterations: 90,
    iterRate: 2 / 3,
    bundleThreshold: 0.6
  };
  var getAngleCompatibility = (p, q) => {
    return Math.abs(dot2([p.vx, p.vy], [q.vx, q.vy]) / (p.length * q.length));
  };
  var getScaleCompatibility = (p, q) => {
    const aLength = (p.length + q.length) / 2;
    return 2 / (aLength / Math.min(p.length, q.length) + Math.max(p.length, q.length) / aLength);
  };
  var getPositionCompatibility = (p, q) => {
    const aLength = (p.length + q.length) / 2;
    const pMid = divide(add(p.source, p.target), 2);
    const qMid = divide(add(q.source, q.target), 2);
    return aLength / (aLength + distance2(pMid, qMid));
  };
  var projectPointToEdge = (p, e) => {
    if (e.source[0] === e.target[0])
      return [e.source[0], p[1]];
    if (e.source[1] === e.target[1])
      return [p[0], e.source[1]];
    const k = (e.source[1] - e.target[1]) / (e.source[0] - e.target[0]);
    const x3 = (k * k * e.source[0] + k * (p[1] - e.source[1]) + p[0]) / (k * k + 1);
    const y3 = k * (x3 - e.source[0]) + e.source[1];
    return [x3, y3];
  };
  var getEdgeVisibility = (p, q) => {
    const is = projectPointToEdge(q.source, p);
    const it = projectPointToEdge(q.target, p);
    const iMid = divide(add(is, it), 2);
    const pMid = divide(add(p.source, p.target), 2);
    if (distance2(is, it) === 0)
      return 0;
    return Math.max(0, 1 - 2 * distance2(pMid, iMid) / distance2(is, it));
  };
  var getVisibilityCompatibility = (p, q) => {
    return Math.min(getEdgeVisibility(p, q), getEdgeVisibility(q, p));
  };
  var getEdgeLength = (points) => {
    let length = 0;
    for (let i = 1; i < points.length; i++) {
      length += distance2(points[i], points[i - 1]);
    }
    return length;
  };

  // node_modules/@antv/g6/esm/plugins/edge-filter-lens/index.js
  var defaultLensStyle = {
    fill: "#fff",
    fillOpacity: 1,
    lineWidth: 1,
    stroke: "#000",
    strokeOpacity: 0.8,
    zIndex: -Infinity
  };
  var DELTA = 0.05;
  var EdgeFilterLens = class _EdgeFilterLens extends BasePlugin {
    constructor(context, options) {
      super(context, Object.assign({}, _EdgeFilterLens.defaultOptions, options));
      this.shapes = /* @__PURE__ */ new Map();
      this.r = this.options.r;
      this.onEdgeFilter = (event) => {
        if (this.options.trigger === "drag" && this.isLensOn)
          return;
        const origin = parsePoint(event.canvas);
        this.renderLens(origin);
        this.renderFocusElements();
      };
      this.renderLens = (origin) => {
        const style = Object.assign({}, defaultLensStyle, this.options.style);
        if (!this.isLensOn) {
          this.lens = new Circle2({ style });
          this.canvas.appendChild(this.lens);
        }
        Object.assign(style, toPointObject(origin), { size: this.r * 2 });
        this.lens.update(style);
      };
      this.getFilterData = () => {
        const { filter } = this.options;
        const { model } = this.context;
        const data2 = model.getData();
        if (!filter)
          return data2;
        const { nodes, edges, combos } = data2;
        return {
          nodes: nodes.filter((node) => filter(idOf(node), "node")),
          edges: edges.filter((edge) => filter(idOf(edge), "edge")),
          combos: combos.filter((combo) => filter(idOf(combo), "combo"))
        };
      };
      this.getFocusElements = (origin) => {
        const { nodes, edges } = this.getFilterData();
        const focusNodes = nodes.filter((datum) => distance2(positionOf(datum), origin) < this.r);
        const focusNodeIds = focusNodes.map((node) => idOf(node));
        const focusEdges = edges.filter((datum) => {
          const { source, target } = datum;
          const isSourceFocus = focusNodeIds.includes(source);
          const isTargetFocus = focusNodeIds.includes(target);
          switch (this.options.nodeType) {
            case "both":
              return isSourceFocus && isTargetFocus;
            case "either":
              return isSourceFocus !== isTargetFocus;
            case "source":
              return isSourceFocus && !isTargetFocus;
            case "target":
              return !isSourceFocus && isTargetFocus;
            default:
              return false;
          }
        });
        return { nodes: focusNodes, edges: focusEdges };
      };
      this.renderFocusElements = () => {
        const { element, graph } = this.context;
        if (!this.isLensOn)
          return;
        const origin = this.lens.getCenter();
        const { nodes, edges } = this.getFocusElements(origin);
        const ids = /* @__PURE__ */ new Set();
        const iterate = (datum) => {
          const id3 = idOf(datum);
          ids.add(id3);
          const shape = element.getElement(id3);
          if (!shape)
            return;
          const cloneShape = this.shapes.get(id3) || shape.cloneNode();
          cloneShape.setPosition(shape.getPosition());
          cloneShape.id = shape.id;
          if (!this.shapes.has(id3)) {
            this.canvas.appendChild(cloneShape);
            this.shapes.set(id3, cloneShape);
          } else {
            Object.entries(shape.attributes).forEach(([key, value]) => {
              if (cloneShape.style[key] !== value)
                cloneShape.style[key] = value;
            });
          }
          const elementType = graph.getElementType(id3);
          const style = this.getElementStyle(elementType, datum);
          cloneShape.update(style);
        };
        nodes.forEach(iterate);
        edges.forEach(iterate);
        this.shapes.forEach((shape, id3) => {
          if (!ids.has(id3)) {
            shape.destroy();
            this.shapes.delete(id3);
          }
        });
      };
      this.scaleRByWheel = (event) => {
        var _a2;
        if (this.options.preventDefault)
          event.preventDefault();
        const { clientX, clientY, deltaX, deltaY } = event;
        const { graph, canvas: canvas2 } = this.context;
        const scaleOrigin = graph.getCanvasByClient([clientX, clientY]);
        const origin = (_a2 = this.lens) === null || _a2 === void 0 ? void 0 : _a2.getCenter();
        if (!this.isLensOn || distance2(scaleOrigin, origin) > this.r) {
          return;
        }
        const { maxR, minR } = this.options;
        const ratio = deltaX + deltaY > 0 ? 1 / (1 - DELTA) : 1 - DELTA;
        const canvasR = Math.min(...canvas2.getSize()) / 2;
        this.r = Math.max(minR || 0, Math.min(maxR || canvasR, this.r * ratio));
        this.renderLens(origin);
        this.renderFocusElements();
      };
      this.isLensDragging = false;
      this.onDragStart = (event) => {
        var _a2;
        const dragOrigin = parsePoint(event.canvas);
        const origin = (_a2 = this.lens) === null || _a2 === void 0 ? void 0 : _a2.getCenter();
        if (!this.isLensOn || distance2(dragOrigin, origin) > this.r)
          return;
        this.isLensDragging = true;
      };
      this.onDrag = (event) => {
        if (!this.isLensDragging)
          return;
        const dragOrigin = parsePoint(event.canvas);
        this.renderLens(dragOrigin);
        this.renderFocusElements();
      };
      this.onDragEnd = () => {
        this.isLensDragging = false;
      };
      this.bindEvents();
    }
    get canvas() {
      return this.context.canvas.getLayer("transient");
    }
    get isLensOn() {
      return this.lens && !this.lens.destroyed;
    }
    getElementStyle(elementType, datum) {
      const styler = elementType === "node" ? this.options.nodeStyle : this.options.edgeStyle;
      if (typeof styler === "function")
        return styler(datum);
      return styler;
    }
    get graphDom() {
      return this.context.graph.getCanvas().getContextService().getDomElement();
    }
    bindEvents() {
      var _a2;
      const { graph } = this.context;
      const { trigger, scaleRBy } = this.options;
      const canvas2 = graph.getCanvas().getLayer();
      if (["click", "drag"].includes(trigger)) {
        canvas2.addEventListener(CommonEvent.CLICK, this.onEdgeFilter);
      }
      if (trigger === "pointermove") {
        canvas2.addEventListener(CommonEvent.POINTER_MOVE, this.onEdgeFilter);
      } else if (trigger === "drag") {
        canvas2.addEventListener(CommonEvent.DRAG_START, this.onDragStart);
        canvas2.addEventListener(CommonEvent.DRAG, this.onDrag);
        canvas2.addEventListener(CommonEvent.DRAG_END, this.onDragEnd);
      }
      if (scaleRBy === "wheel") {
        (_a2 = this.graphDom) === null || _a2 === void 0 ? void 0 : _a2.addEventListener(CommonEvent.WHEEL, this.scaleRByWheel, { passive: false });
      }
    }
    unbindEvents() {
      var _a2;
      const { graph } = this.context;
      const { trigger, scaleRBy } = this.options;
      const canvas2 = graph.getCanvas().getLayer();
      if (["click", "drag"].includes(trigger)) {
        canvas2.removeEventListener(CommonEvent.CLICK, this.onEdgeFilter);
      }
      if (trigger === "pointermove") {
        canvas2.removeEventListener(CommonEvent.POINTER_MOVE, this.onEdgeFilter);
      } else if (trigger === "drag") {
        canvas2.removeEventListener(CommonEvent.DRAG_START, this.onDragStart);
        canvas2.removeEventListener(CommonEvent.DRAG, this.onDrag);
        canvas2.removeEventListener(CommonEvent.DRAG_END, this.onDragEnd);
      }
      if (scaleRBy === "wheel") {
        (_a2 = this.graphDom) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener(CommonEvent.WHEEL, this.scaleRByWheel);
      }
    }
    update(options) {
      var _a2;
      this.unbindEvents();
      super.update(options);
      this.r = (_a2 = options.r) !== null && _a2 !== void 0 ? _a2 : this.r;
      this.bindEvents();
    }
    destroy() {
      this.unbindEvents();
      if (this.isLensOn) {
        this.lens.destroy();
      }
      this.shapes.forEach((shape, id3) => {
        shape.destroy();
        this.shapes.delete(id3);
      });
      super.destroy();
    }
  };
  EdgeFilterLens.defaultOptions = {
    trigger: "pointermove",
    r: 60,
    nodeType: "both",
    filter: () => true,
    style: { lineWidth: 2 },
    nodeStyle: { label: false },
    edgeStyle: { label: true },
    scaleRBy: "wheel",
    preventDefault: true
  };

  // node_modules/@antv/g6/esm/plugins/fisheye/index.js
  var import_util111 = __toESM(require_lib());
  var defaultLensStyle2 = {
    fill: "#ccc",
    fillOpacity: 0.1,
    lineWidth: 2,
    stroke: "#000",
    strokeOpacity: 0.8,
    labelFontSize: 12
  };
  var R_DELTA = 0.05;
  var D_DELTA = 0.1;
  var Fisheye = class _Fisheye extends BasePlugin {
    constructor(context, options) {
      super(context, Object.assign({}, _Fisheye.defaultOptions, options));
      this.r = this.options.r;
      this.d = this.options.d;
      this.onCreateFisheye = (event) => {
        if (this.options.trigger === "drag" && this.isLensOn)
          return;
        const origin = parsePoint(event.canvas);
        this.onMagnify(origin);
      };
      this.onMagnify = (origin) => {
        if (origin.some(isNaN))
          return;
        this.renderLens(origin);
        this.renderFocusElements();
      };
      this.renderLens = (origin) => {
        const style = Object.assign({}, defaultLensStyle2, this.options.style);
        if (!this.isLensOn) {
          this.lens = new Circle2({ style });
          this.canvas.appendChild(this.lens);
        }
        Object.assign(style, toPointObject(origin), {
          size: this.r * 2,
          label: this.options.showDPercent,
          labelText: this.getDPercent()
        });
        this.lens.update(style);
      };
      this.getDPercent = () => {
        const { minD, maxD } = this.options;
        const percent = Math.round((this.d - minD) / (maxD - minD) * 100);
        return `${percent}%`;
      };
      this.prevMagnifiedStyleMap = /* @__PURE__ */ new Map();
      this.prevOriginStyleMap = /* @__PURE__ */ new Map();
      this.renderFocusElements = () => {
        if (!this.isLensOn)
          return;
        const { graph } = this.context;
        const origin = this.lens.getCenter();
        const molecularParam = (this.d + 1) * this.r;
        const magnifiedStyleMap = /* @__PURE__ */ new Map();
        const originStyleMap = /* @__PURE__ */ new Map();
        const nodeData = graph.getNodeData();
        nodeData.forEach((datum) => {
          const position2 = positionOf(datum);
          const distanceToOrigin = distance2(position2, origin);
          if (distanceToOrigin > this.r)
            return;
          const magnifiedDistance = molecularParam * distanceToOrigin / (this.d * distanceToOrigin + this.r);
          const [nodeX, nodeY] = position2;
          const [originX, originY] = origin;
          const cos = (nodeX - originX) / distanceToOrigin;
          const sin = (nodeY - originY) / distanceToOrigin;
          const newPoint = [originX + magnifiedDistance * cos, originY + magnifiedDistance * sin];
          const nodeId = idOf(datum);
          const style = this.getNodeStyle(datum);
          const originStyle = (0, import_util111.pick)(graph.getElementRenderStyle(nodeId), Object.keys(style));
          magnifiedStyleMap.set(nodeId, Object.assign(Object.assign({}, toPointObject(newPoint)), style));
          originStyleMap.set(nodeId, Object.assign(Object.assign({}, toPointObject(position2)), originStyle));
        });
        this.updateStyle(magnifiedStyleMap, originStyleMap);
      };
      this.getNodeStyle = (datum) => {
        const { nodeStyle } = this.options;
        return typeof nodeStyle === "function" ? nodeStyle(datum) : nodeStyle;
      };
      this.updateStyle = (magnifiedStyleMap, originStyleMap) => {
        const { graph, element } = this.context;
        const { enter, exit, keep } = arrayDiff(Array.from(this.prevMagnifiedStyleMap.keys()), Array.from(magnifiedStyleMap.keys()), (d2) => d2);
        const relatedEdges = /* @__PURE__ */ new Set();
        const update = (nodeId, style) => {
          const node = element.getElement(nodeId);
          node === null || node === void 0 ? void 0 : node.update(style);
          graph.getRelatedEdgesData(nodeId).forEach((datum) => {
            relatedEdges.add(idOf(datum));
          });
        };
        [...enter, ...keep].forEach((nodeId) => {
          update(nodeId, magnifiedStyleMap.get(nodeId));
        });
        exit.forEach((nodeId) => {
          update(nodeId, this.prevOriginStyleMap.get(nodeId));
          this.prevOriginStyleMap.delete(nodeId);
        });
        relatedEdges.forEach((edgeId) => {
          const edge = element.getElement(edgeId);
          edge === null || edge === void 0 ? void 0 : edge.update({});
        });
        this.prevMagnifiedStyleMap = magnifiedStyleMap;
        originStyleMap.forEach((style, nodeId) => {
          if (!this.prevOriginStyleMap.has(nodeId)) {
            this.prevOriginStyleMap.set(nodeId, style);
          }
        });
      };
      this.isWheelValid = (event) => {
        if (this.options.preventDefault)
          event.preventDefault();
        if (!this.isLensOn)
          return false;
        const { clientX, clientY } = event;
        const scaleOrigin = this.context.graph.getCanvasByClient([clientX, clientY]);
        const origin = this.lens.getCenter();
        if (distance2(scaleOrigin, origin) > this.r)
          return false;
        return true;
      };
      this.scaleR = (positive) => {
        const { maxR, minR } = this.options;
        const ratio = positive ? 1 / (1 - R_DELTA) : 1 - R_DELTA;
        const canvasR = Math.min(...this.context.canvas.getSize()) / 2;
        this.r = Math.max(minR || 0, Math.min(maxR || canvasR, this.r * ratio));
      };
      this.scaleD = (positive) => {
        const { maxD, minD } = this.options;
        const newD = positive ? this.d + D_DELTA : this.d - D_DELTA;
        this.d = Math.max(minD, Math.min(maxD, newD));
      };
      this.scaleRByWheel = (event) => {
        if (!this.isWheelValid(event))
          return;
        const { deltaX, deltaY } = event;
        this.scaleR(deltaX + deltaY > 0);
        const origin = this.lens.getCenter();
        this.onMagnify(origin);
      };
      this.scaleDByWheel = (event) => {
        if (!this.isWheelValid(event))
          return;
        const { deltaX, deltaY } = event;
        this.scaleD(deltaX + deltaY > 0);
        const origin = this.lens.getCenter();
        this.onMagnify(origin);
      };
      this.isDragValid = (event) => {
        if (this.options.preventDefault)
          event.preventDefault();
        if (!this.isLensOn)
          return false;
        const dragOrigin = parsePoint(event.canvas);
        const origin = this.lens.getCenter();
        if (distance2(dragOrigin, origin) > this.r)
          return false;
        return true;
      };
      this.isLensDragging = false;
      this.onDragStart = (event) => {
        if (!this.isDragValid(event))
          return;
        this.isLensDragging = true;
      };
      this.onDrag = (event) => {
        if (!this.isLensDragging)
          return;
        const dragOrigin = parsePoint(event.canvas);
        this.onMagnify(dragOrigin);
      };
      this.onDragEnd = () => {
        this.isLensDragging = false;
      };
      this.scaleRByDrag = (event) => {
        if (!this.isLensDragging)
          return;
        const { dx, dy } = event;
        this.scaleR(dx - dy > 0);
        const origin = this.lens.getCenter();
        this.onMagnify(origin);
      };
      this.scaleDByDrag = (event) => {
        if (!this.isLensDragging)
          return;
        const { dx, dy } = event;
        this.scaleD(dx - dy > 0);
        const origin = this.lens.getCenter();
        this.onMagnify(origin);
      };
      this.bindEvents();
    }
    get canvas() {
      return this.context.canvas.getLayer("transient");
    }
    get isLensOn() {
      return this.lens && !this.lens.destroyed;
    }
    get graphDom() {
      return this.context.graph.getCanvas().getContextService().getDomElement();
    }
    bindEvents() {
      var _a2;
      const { graph } = this.context;
      const { trigger, scaleRBy, scaleDBy } = this.options;
      const canvas2 = graph.getCanvas().getLayer();
      if (["click", "drag"].includes(trigger)) {
        canvas2.addEventListener(CommonEvent.CLICK, this.onCreateFisheye);
      }
      if (trigger === "pointermove") {
        canvas2.addEventListener(CommonEvent.POINTER_MOVE, this.onCreateFisheye);
      }
      if (trigger === "drag" || scaleRBy === "drag" || scaleDBy === "drag") {
        canvas2.addEventListener(CommonEvent.DRAG_START, this.onDragStart);
        canvas2.addEventListener(CommonEvent.DRAG_END, this.onDragEnd);
        const dragFunc = trigger === "drag" ? this.onDrag : scaleRBy === "drag" ? this.scaleRByDrag : this.scaleDByDrag;
        canvas2.addEventListener(CommonEvent.DRAG, dragFunc);
      }
      if (scaleRBy === "wheel" || scaleDBy === "wheel") {
        const wheelFunc = scaleRBy === "wheel" ? this.scaleRByWheel : this.scaleDByWheel;
        (_a2 = this.graphDom) === null || _a2 === void 0 ? void 0 : _a2.addEventListener(CommonEvent.WHEEL, wheelFunc, { passive: false });
      }
    }
    unbindEvents() {
      var _a2;
      const { graph } = this.context;
      const { trigger, scaleRBy, scaleDBy } = this.options;
      const canvas2 = graph.getCanvas().getLayer();
      if (["click", "drag"].includes(trigger)) {
        canvas2.removeEventListener(CommonEvent.CLICK, this.onCreateFisheye);
      }
      if (trigger === "pointermove") {
        canvas2.removeEventListener(CommonEvent.POINTER_MOVE, this.onCreateFisheye);
      }
      if (trigger === "drag" || scaleRBy === "drag" || scaleDBy === "drag") {
        canvas2.removeEventListener(CommonEvent.DRAG_START, this.onDragStart);
        canvas2.removeEventListener(CommonEvent.DRAG_END, this.onDragEnd);
        const dragFunc = trigger === "drag" ? this.onDrag : scaleRBy === "drag" ? this.scaleRByDrag : this.scaleDByDrag;
        canvas2.removeEventListener(CommonEvent.DRAG, dragFunc);
      }
      if (scaleRBy === "wheel" || scaleDBy === "wheel") {
        const wheelFunc = scaleRBy === "wheel" ? this.scaleRByWheel : this.scaleDByWheel;
        (_a2 = this.graphDom) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener(CommonEvent.WHEEL, wheelFunc);
      }
    }
    update(options) {
      var _a2, _b;
      this.unbindEvents();
      super.update(options);
      this.r = (_a2 = options.r) !== null && _a2 !== void 0 ? _a2 : this.r;
      this.d = (_b = options.d) !== null && _b !== void 0 ? _b : this.d;
      this.bindEvents();
    }
    destroy() {
      var _a2;
      this.unbindEvents();
      if (this.isLensOn) {
        (_a2 = this.lens) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      }
      this.prevMagnifiedStyleMap.clear();
      this.prevOriginStyleMap.clear();
      super.destroy();
    }
  };
  Fisheye.defaultOptions = {
    trigger: "pointermove",
    r: 120,
    d: 1.5,
    maxD: 5,
    minD: 0,
    showDPercent: true,
    style: {},
    nodeStyle: { label: true },
    preventDefault: true
  };

  // node_modules/@antv/g6/esm/plugins/fullscreen/index.js
  var Fullscreen = class _Fullscreen extends BasePlugin {
    constructor(context, options) {
      super(context, Object.assign({}, _Fullscreen.defaultOptions, options));
      this.$el = this.context.canvas.getContainer();
      this.graphSize = [0, 0];
      this.onFullscreenChange = () => {
        var _a2, _b, _c, _d;
        const isFull = !!document.fullscreenElement;
        if (this.options.autoFit)
          this.setGraphSize(isFull);
        if (isFull) {
          (_b = (_a2 = this.options).onEnter) === null || _b === void 0 ? void 0 : _b.call(_a2);
        } else {
          (_d = (_c = this.options).onExit) === null || _d === void 0 ? void 0 : _d.call(_c);
        }
      };
      this.shortcut = new Shortcut(context.graph);
      this.bindEvents();
      this.style = document.createElement("style");
      document.head.appendChild(this.style);
      this.style.innerHTML = `
      :not(:root):fullscreen::backdrop {
        background: transparent;
      }
    `;
    }
    bindEvents() {
      this.unbindEvents();
      this.shortcut.unbindAll();
      const { request = [], exit = [] } = this.options.trigger;
      this.shortcut.bind(request, this.request);
      this.shortcut.bind(exit, this.exit);
      const events = ["webkitfullscreenchange", "mozfullscreenchange", "fullscreenchange", "MSFullscreenChange"];
      events.forEach((eventName) => {
        document.addEventListener(eventName, this.onFullscreenChange, false);
      });
    }
    unbindEvents() {
      this.shortcut.unbindAll();
      const events = ["webkitfullscreenchange", "mozfullscreenchange", "fullscreenchange", "MSFullscreenChange"];
      events.forEach((eventName) => {
        document.removeEventListener(eventName, this.onFullscreenChange, false);
      });
    }
    setGraphSize(fullScreen = true) {
      var _a2, _b;
      let width2, height;
      if (fullScreen) {
        width2 = ((_a2 = globalThis.screen) === null || _a2 === void 0 ? void 0 : _a2.width) || 0;
        height = ((_b = globalThis.screen) === null || _b === void 0 ? void 0 : _b.height) || 0;
        this.graphSize = this.context.graph.getSize();
      } else {
        [width2, height] = this.graphSize;
      }
      this.context.graph.setSize(width2, height);
      this.context.graph.render();
    }
    /**
     * <zh/> 请求全屏
     *
     * <en/> Request full screen
     */
    request() {
      if (document.fullscreenElement || !isFullscreenEnabled())
        return;
      this.$el.requestFullscreen().catch((err) => {
        print.warn(`Error attempting to enable full-screen: ${err.message} (${err.name})`);
      });
    }
    /**
     * <zh/> 退出全屏
     *
     * <en/> Exit full screen
     */
    exit() {
      if (!document.fullscreenElement)
        return;
      document.exitFullscreen();
    }
    /**
     * <zh/> 更新配置
     *
     * <en/> Update options
     * @param options - <zh/> 配置项 | <en/> Options
     * @internal
     */
    update(options) {
      this.unbindEvents();
      super.update(options);
      this.bindEvents();
    }
    destroy() {
      this.exit();
      this.style.remove();
      super.destroy();
    }
  };
  Fullscreen.defaultOptions = {
    trigger: {},
    autoFit: true
  };
  function isFullscreenEnabled() {
    return document.fullscreenEnabled || // <zh/> 使用 Reflect 语法规避 ts 检查 | <en/> use Reflect to avoid ts checking
    Reflect.get(document, "webkitFullscreenEnabled") || Reflect.get(document, "mozFullscreenEnabled") || Reflect.get(document, "msFullscreenEnabled");
  }

  // node_modules/@antv/g6/esm/plugins/grid-line.js
  var import_util112 = __toESM(require_lib());
  var GridLine = class _GridLine extends BasePlugin {
    constructor(context, options) {
      super(context, Object.assign({}, _GridLine.defaultOptions, options));
      this.$element = createPluginContainer("grid-line", true);
      this.offset = [0, 0];
      this.currentScale = 1;
      this.followZoom = (event) => {
        const { data: { scale: scale4, origin } } = event;
        if (!scale4 || origin === void 0 && this.context.viewport === void 0)
          return;
        const prevScale = this.currentScale;
        this.currentScale = scale4;
        const deltaScale = scale4 / prevScale;
        const positionOffset = multiply(origin || this.context.graph.getCanvasCenter(), 1 - deltaScale);
        const scaledSize = this.baseSize * scale4;
        const scaledOffset = multiply(this.offset, deltaScale);
        const modulatedOffset = mod2(scaledOffset, scaledSize);
        const newOffset = add(modulatedOffset, positionOffset);
        this.$element.style.backgroundSize = `${scaledSize}px ${scaledSize}px`;
        this.$element.style.backgroundPosition = `${newOffset[0]}px ${newOffset[1]}px`;
        this.offset = mod2(newOffset, scaledSize);
      };
      this.followTranslate = (event) => {
        if (!this.options.follow)
          return;
        const { data: { translate: translate3 } } = event;
        if (translate3)
          this.updateOffset(translate3);
      };
      this.onTransform = (event) => {
        const follow = this.parseFollow(this.options.follow);
        if (follow.zoom)
          this.followZoom(event);
        if (follow.translate)
          this.followTranslate(event);
      };
      const $container = this.context.canvas.getContainer();
      $container.prepend(this.$element);
      this.baseSize = this.options.size;
      this.updateStyle();
      this.bindEvents();
    }
    /**
     * <zh/> 更新网格线配置
     *
     * <en/> Update the configuration of the grid line
     * @param options - <zh/> 配置项 | <en/> options
     * @internal
     */
    update(options) {
      super.update(options);
      if (options.size !== void 0) {
        this.baseSize = options.size;
      }
      this.updateStyle();
    }
    bindEvents() {
      const { graph } = this.context;
      graph.on(GraphEvent.AFTER_TRANSFORM, this.onTransform);
    }
    updateStyle() {
      const { stroke, lineWidth, border, borderLineWidth, borderStroke, borderStyle } = this.options;
      const scaledSize = this.baseSize * this.currentScale;
      Object.assign(this.$element.style, {
        border: border ? `${borderLineWidth}px ${borderStyle} ${borderStroke}` : "none",
        backgroundImage: `linear-gradient(${stroke} ${lineWidth}px, transparent ${lineWidth}px), linear-gradient(90deg, ${stroke} ${lineWidth}px, transparent ${lineWidth}px)`,
        backgroundSize: `${scaledSize}px ${scaledSize}px`,
        backgroundRepeat: "repeat"
      });
    }
    updateOffset(delta) {
      const scaledSize = this.baseSize * this.currentScale;
      this.offset = mod2(add(this.offset, delta), scaledSize);
      this.$element.style.backgroundPosition = `${this.offset[0]}px ${this.offset[1]}px`;
    }
    parseFollow(follow) {
      var _a2, _b;
      return (0, import_util112.isBoolean)(follow) ? { translate: follow, zoom: follow } : { translate: (_a2 = follow === null || follow === void 0 ? void 0 : follow.translate) !== null && _a2 !== void 0 ? _a2 : false, zoom: (_b = follow === null || follow === void 0 ? void 0 : follow.zoom) !== null && _b !== void 0 ? _b : false };
    }
    /**
     * <zh/> 销毁网格线
     *
     * <en/> Destroy the grid line
     * @internal
     */
    destroy() {
      this.context.graph.off(GraphEvent.AFTER_TRANSFORM, this.onTransform);
      this.$element.remove();
      super.destroy();
    }
  };
  GridLine.defaultOptions = {
    border: true,
    borderLineWidth: 1,
    borderStroke: "#eee",
    borderStyle: "solid",
    lineWidth: 1,
    size: 20,
    stroke: "#eee"
  };

  // node_modules/@antv/g6/esm/plugins/history/util.js
  var import_util114 = __toESM(require_lib());

  // node_modules/@antv/g6/esm/utils/change.js
  var import_util113 = __toESM(require_lib());
  function reduceDataChanges(changes) {
    const results = {
      Added: /* @__PURE__ */ new Map(),
      Updated: /* @__PURE__ */ new Map(),
      Removed: /* @__PURE__ */ new Map()
    };
    changes.forEach((change) => {
      const { type, value } = change;
      const id3 = idOf(value);
      if (type === "NodeAdded" || type === "EdgeAdded" || type === "ComboAdded") {
        results.Added.set(id3, change);
      } else if (type === "NodeUpdated" || type === "EdgeUpdated" || type === "ComboUpdated") {
        if (results.Added.has(id3)) {
          results.Added.set(id3, { type: type.replace("Updated", "Added"), value });
        } else if (results.Updated.has(id3)) {
          const { original } = results.Updated.get(id3);
          results.Updated.set(id3, { type, value, original });
        } else if (results.Removed.has(id3)) {
        } else
          results.Updated.set(id3, change);
      } else if (type === "NodeRemoved" || type === "EdgeRemoved" || type === "ComboRemoved") {
        if (results.Added.has(id3)) {
          results.Added.delete(id3);
        } else if (results.Updated.has(id3)) {
          results.Updated.delete(id3);
          results.Removed.set(id3, change);
        } else {
          results.Removed.set(id3, change);
        }
      }
    });
    return [
      ...Array.from(results.Added.values()),
      ...Array.from(results.Updated.values()),
      ...Array.from(results.Removed.values())
    ];
  }
  function groupByChangeType(changes) {
    const { NodeAdded = [], NodeUpdated = [], NodeRemoved = [], EdgeAdded = [], EdgeUpdated = [], EdgeRemoved = [], ComboAdded = [], ComboUpdated = [], ComboRemoved = [] } = (0, import_util113.groupBy)(changes, (change) => change.type);
    return {
      add: {
        nodes: NodeAdded,
        edges: EdgeAdded,
        combos: ComboAdded
      },
      update: {
        nodes: NodeUpdated,
        edges: EdgeUpdated,
        combos: ComboUpdated
      },
      remove: {
        nodes: NodeRemoved,
        edges: EdgeRemoved,
        combos: ComboRemoved
      }
    };
  }

  // node_modules/@antv/g6/esm/plugins/history/util.js
  function alignFields(refObject, targetObject) {
    for (const key in refObject) {
      if ((0, import_util114.isObject)(refObject[key]) && !Array.isArray(refObject[key]) && refObject[key] !== null) {
        if (!targetObject[key])
          targetObject[key] = {};
        alignFields(refObject[key], targetObject[key]);
      } else if (targetObject[key] === void 0) {
        targetObject[key] = inferDefaultValue(key);
      }
    }
  }
  function parseCommand(changes, animation = false, context) {
    const cmd = {
      animation,
      current: { add: {}, update: {}, remove: {} },
      original: { add: {}, update: {}, remove: {} }
    };
    const { add: add5, update, remove } = groupByChangeType(reduceDataChanges(changes));
    ["nodes", "edges", "combos"].forEach((category) => {
      if (update[category]) {
        update[category].forEach((item) => {
          var _a2, _b;
          const newValue = Object.assign({}, item.value);
          let newOriginal = Object.assign({}, item.original);
          if (context) {
            const itemType = context.graph.getElementType(idOf(item.original));
            const colorKey = itemType === "edge" ? "stroke" : "fill";
            const style = context.element.getElementComputedStyle(itemType, item.original);
            newOriginal = Object.assign(Object.assign({}, item.original), { style: Object.assign({ [colorKey]: style[colorKey] }, item.original.style) });
          }
          alignFields(newValue, newOriginal);
          (_a2 = cmd.current.update)[category] || (_a2[category] = []);
          cmd.current.update[category].push(newValue);
          (_b = cmd.original.update)[category] || (_b[category] = []);
          cmd.original.update[category].push(newOriginal);
        });
      }
      if (add5[category]) {
        add5[category].forEach((item) => {
          var _a2, _b;
          const newValue = Object.assign({}, item.value);
          (_a2 = cmd.current.add)[category] || (_a2[category] = []);
          cmd.current.add[category].push(newValue);
          (_b = cmd.original.remove)[category] || (_b[category] = []);
          cmd.original.remove[category].push(newValue);
        });
      }
      if (remove[category]) {
        remove[category].forEach((item) => {
          var _a2, _b;
          const newValue = Object.assign({}, item.value);
          (_a2 = cmd.current.remove)[category] || (_a2[category] = []);
          cmd.current.remove[category].push(newValue);
          (_b = cmd.original.add)[category] || (_b[category] = []);
          cmd.original.add[category].push(newValue);
        });
      }
    });
    return cmd;
  }

  // node_modules/@antv/g6/esm/plugins/history/index.js
  var History2 = class _History extends BasePlugin {
    constructor(context, options) {
      super(context, Object.assign({}, _History.defaultOptions, options));
      this.batchChanges = null;
      this.batchAnimation = false;
      this.undoStack = [];
      this.redoStack = [];
      this.freezed = false;
      this.executeCommand = (cmd, revert = true) => {
        var _a2, _b, _c;
        this.freezed = true;
        (_b = (_a2 = this.options).executeCommand) === null || _b === void 0 ? void 0 : _b.call(_a2, cmd);
        const values2 = revert ? cmd.original : cmd.current;
        this.context.graph.addData(values2.add);
        this.context.graph.updateData(values2.update);
        this.context.graph.removeData(idsOf(values2.remove, false));
        (_c = this.context.element) === null || _c === void 0 ? void 0 : _c.draw({ silence: true, animation: cmd.animation });
        this.freezed = false;
      };
      this.addCommand = (event) => {
        var _a2;
        if (this.freezed)
          return;
        if (event.type === GraphEvent.AFTER_DRAW) {
          const { dataChanges = [], animation = true } = event.data;
          if ((_a2 = this.context.batch) === null || _a2 === void 0 ? void 0 : _a2.isBatching) {
            if (!this.batchChanges)
              return;
            this.batchChanges.push(dataChanges);
            this.batchAnimation && (this.batchAnimation = animation);
            return;
          }
          this.batchChanges = [dataChanges];
          this.batchAnimation = animation;
        }
        this.undoStackPush(parseCommand(this.batchChanges.flat(), this.batchAnimation, this.context));
        this.notify(HistoryEvent.ADD, this.undoStack[this.undoStack.length - 1]);
      };
      this.initBatchCommand = (event) => {
        const { initiate } = event.data;
        this.batchAnimation = false;
        if (initiate) {
          this.batchChanges = [];
        } else {
          const cmd = this.undoStack.pop();
          if (!cmd)
            this.batchChanges = null;
        }
      };
      this.emitter = new esm_default();
      const { graph } = this.context;
      graph.on(GraphEvent.AFTER_DRAW, this.addCommand);
      graph.on(GraphEvent.BATCH_START, this.initBatchCommand);
      graph.on(GraphEvent.BATCH_END, this.addCommand);
    }
    /**
     * <zh/> 是否可以执行撤销操作
     *
     * <en/> Whether undo can be done
     * @returns <zh/> 是否可以执行撤销操作 | <en/> Whether undo can be done
     */
    canUndo() {
      return this.undoStack.length > 0;
    }
    /**
     * <zh/> 是否可以执行重做操作
     *
     * <en/> Whether redo can be done
     * @returns <zh/> 是否可以执行重做操作 | <en/> Whether redo can be done
     */
    canRedo() {
      return this.redoStack.length > 0;
    }
    /**
     * <zh/> 执行撤销
     *
     * <en/> Execute undo
     * @returns <zh/> 返回当前实例 | <en/> Return the current instance
     */
    undo() {
      var _a2, _b, _c, _d;
      const cmd = this.undoStack.pop();
      if (cmd) {
        this.executeCommand(cmd);
        const before = (_b = (_a2 = this.options).beforeAddCommand) === null || _b === void 0 ? void 0 : _b.call(_a2, cmd, false);
        if (before === false)
          return;
        this.redoStack.push(cmd);
        (_d = (_c = this.options).afterAddCommand) === null || _d === void 0 ? void 0 : _d.call(_c, cmd, false);
        this.notify(HistoryEvent.UNDO, cmd);
      }
      return this;
    }
    /**
     * <zh/> 执行重做
     *
     * <en/> Execute redo
     * @returns <zh/> 返回当前实例 | <en/> Return the current instance
     */
    redo() {
      const cmd = this.redoStack.pop();
      if (cmd) {
        this.executeCommand(cmd, false);
        this.undoStackPush(cmd);
        this.notify(HistoryEvent.REDO, cmd);
      }
      return this;
    }
    /**
     * <zh/> 执行撤销且不计入历史记录
     *
     * <en/> Execute undo and do not record in history
     * @returns <zh/> 返回当前实例 | <en/> Return the current instance
     */
    undoAndCancel() {
      const cmd = this.undoStack.pop();
      if (cmd) {
        this.executeCommand(cmd, false);
        this.redoStack = [];
        this.notify(HistoryEvent.CANCEL, cmd);
      }
      return this;
    }
    undoStackPush(cmd) {
      var _a2, _b, _c, _d;
      const { stackSize } = this.options;
      if (stackSize !== 0 && this.undoStack.length >= stackSize) {
        this.undoStack.shift();
      }
      const before = (_b = (_a2 = this.options).beforeAddCommand) === null || _b === void 0 ? void 0 : _b.call(_a2, cmd, true);
      if (before === false)
        return;
      this.undoStack.push(cmd);
      (_d = (_c = this.options).afterAddCommand) === null || _d === void 0 ? void 0 : _d.call(_c, cmd, true);
    }
    /**
     * <zh/> 清空历史记录
     *
     * <en/> Clear history
     */
    clear() {
      this.undoStack = [];
      this.redoStack = [];
      this.batchChanges = null;
      this.batchAnimation = false;
      this.notify(HistoryEvent.CLEAR, null);
    }
    notify(event, cmd) {
      this.emitter.emit(event, { cmd });
      this.emitter.emit(HistoryEvent.CHANGE, { cmd });
    }
    /**
     * <zh/> 监听历史记录事件
     *
     * <en/> Listen to history events
     * @param event  - <zh/> 事件名称 | <en/> Event name
     * @param handler - <zh/> 事件处理函数 | <en/> Event handler
     */
    on(event, handler) {
      this.emitter.on(event, handler);
    }
    /**
     * <zh/> 销毁
     *
     * <en/> Destroy
     * @internal
     */
    destroy() {
      const { graph } = this.context;
      graph.off(GraphEvent.AFTER_DRAW, this.addCommand);
      graph.off(GraphEvent.BATCH_START, this.initBatchCommand);
      graph.off(GraphEvent.BATCH_END, this.addCommand);
      this.emitter.off();
      super.destroy();
      this.undoStack = [];
      this.redoStack = [];
    }
  };
  History2.defaultOptions = {
    stackSize: 0
  };

  // node_modules/@antv/g6/esm/plugins/hull/index.js
  var import_util116 = __toESM(require_lib());

  // node_modules/@antv/g6/esm/plugins/hull/hull/format.js
  var formatUtil = {
    toXy(pointset, format2) {
      if (!format2)
        return [...pointset];
      const xProperty = format2[0].slice(1);
      const yProperty = format2[1].slice(1);
      return pointset.map((pt) => [pt[xProperty], pt[yProperty]]);
    },
    fromXy(coordinates, format2) {
      if (!format2)
        return [...coordinates];
      const xProperty = format2[0].slice(1);
      const yProperty = format2[1].slice(1);
      return coordinates.map(([x3, y3]) => ({
        [xProperty]: x3,
        [yProperty]: y3
      }));
    }
  };

  // node_modules/@antv/g6/esm/plugins/hull/hull/grid_handle.js
  var Grid = class {
    constructor(points, cellSize) {
      this._cells = [];
      this._cellSize = cellSize;
      this._reverseCellSize = 1 / cellSize;
      for (const point4 of points) {
        const x3 = this.coordToCellNum(point4[0]);
        const y3 = this.coordToCellNum(point4[1]);
        if (!this._cells[x3]) {
          this._cells[x3] = [];
        }
        if (!this._cells[x3][y3]) {
          this._cells[x3][y3] = [];
        }
        this._cells[x3][y3].push(point4);
      }
    }
    cellPoints(x3, y3) {
      var _a2;
      return ((_a2 = this._cells[x3]) === null || _a2 === void 0 ? void 0 : _a2[y3]) || [];
    }
    rangePoints(bbox) {
      const tlCellX = this.coordToCellNum(bbox[0]);
      const tlCellY = this.coordToCellNum(bbox[1]);
      const brCellX = this.coordToCellNum(bbox[2]);
      const brCellY = this.coordToCellNum(bbox[3]);
      const points = [];
      for (let x3 = tlCellX; x3 <= brCellX; x3++) {
        for (let y3 = tlCellY; y3 <= brCellY; y3++) {
          const cell = this.cellPoints(x3, y3);
          for (const point4 of cell) {
            points.push(point4);
          }
        }
      }
      return points;
    }
    removePoint(point4) {
      const cellX = this.coordToCellNum(point4[0]);
      const cellY = this.coordToCellNum(point4[1]);
      const cell = this._cells[cellX][cellY];
      const index2 = cell.findIndex(([px, py]) => px === point4[0] && py === point4[1]);
      if (index2 > -1) {
        cell.splice(index2, 1);
      }
      return cell;
    }
    trunc(val) {
      return Math.trunc(val);
    }
    coordToCellNum(x3) {
      return this.trunc(x3 * this._reverseCellSize);
    }
    extendBbox(bbox, scaleFactor) {
      return [
        bbox[0] - scaleFactor * this._cellSize,
        bbox[1] - scaleFactor * this._cellSize,
        bbox[2] + scaleFactor * this._cellSize,
        bbox[3] + scaleFactor * this._cellSize
      ];
    }
  };
  function grid(points, cellSize) {
    return new Grid(points, cellSize);
  }

  // node_modules/@antv/g6/esm/plugins/hull/hull/two-product.js
  var SPLITTER = +(Math.pow(2, 27) + 1);
  function twoProduct(a2, b, result) {
    const x3 = a2 * b;
    const c2 = SPLITTER * a2;
    const a_big = c2 - a2;
    const ahi = c2 - a_big;
    const alo = a2 - ahi;
    const d2 = SPLITTER * b;
    const b_big = d2 - b;
    const bhi = d2 - b_big;
    const blo = b - bhi;
    const err1 = x3 - ahi * bhi;
    const err2 = err1 - alo * bhi;
    const err3 = err2 - ahi * blo;
    const y3 = alo * blo - err3;
    if (result) {
      result[0] = y3;
      result[1] = x3;
      return result;
    }
    return [y3, x3];
  }

  // node_modules/@antv/g6/esm/plugins/hull/hull/two-sum.js
  function fastTwoSum(a2, b, result) {
    const x3 = a2 + b;
    const bv = x3 - a2;
    const av = x3 - bv;
    const br = b - bv;
    const ar = a2 - av;
    if (result) {
      result[0] = ar + br;
      result[1] = x3;
      return result;
    }
    return [ar + br, x3];
  }

  // node_modules/@antv/g6/esm/plugins/hull/hull/robust-scale.js
  function scaleLinearExpansion(e, scale4) {
    const n = e.length;
    if (n === 1) {
      const ts = twoProduct(e[0], scale4);
      if (ts[0]) {
        return ts;
      }
      return [ts[1]];
    }
    const g = new Array(2 * n);
    const q = [0.1, 0.1];
    const t = [0.1, 0.1];
    let count = 0;
    twoProduct(e[0], scale4, q);
    if (q[0]) {
      g[count++] = q[0];
    }
    for (let i = 1; i < n; ++i) {
      twoProduct(e[i], scale4, t);
      const pq = q[1];
      fastTwoSum(pq, t[0], q);
      if (q[0]) {
        g[count++] = q[0];
      }
      const a2 = t[1];
      const b = q[1];
      const x3 = a2 + b;
      const bv = x3 - a2;
      const y3 = b - bv;
      q[1] = x3;
      if (y3) {
        g[count++] = y3;
      }
    }
    if (q[1]) {
      g[count++] = q[1];
    }
    if (count === 0) {
      g[count++] = 0;
    }
    g.length = count;
    return g;
  }

  // node_modules/@antv/g6/esm/plugins/hull/hull/robust-subtract.js
  function scalarScalar(a2, b) {
    const x3 = a2 + b;
    const bv = x3 - a2;
    const av = x3 - bv;
    const br = b - bv;
    const ar = a2 - av;
    const y3 = ar + br;
    if (y3) {
      return [y3, x3];
    }
    return [x3];
  }
  function robustSubtract(e, f) {
    const ne = e.length | 0;
    const nf = f.length | 0;
    if (ne === 1 && nf === 1) {
      return scalarScalar(e[0], -f[0]);
    }
    const n = ne + nf;
    const g = new Array(n);
    let count = 0;
    let ep_tr = 0;
    let fp_tr = 0;
    const abs = Math.abs;
    let ei = e[ep_tr];
    let ea = abs(ei);
    let fi = -f[fp_tr];
    let fa = abs(fi);
    let a2, b;
    if (ea < fa) {
      b = ei;
      ep_tr += 1;
      if (ep_tr < ne) {
        ei = e[ep_tr];
        ea = abs(ei);
      }
    } else {
      b = fi;
      fp_tr += 1;
      if (fp_tr < nf) {
        fi = -f[fp_tr];
        fa = abs(fi);
      }
    }
    if (ep_tr < ne && ea < fa || fp_tr >= nf) {
      a2 = ei;
      ep_tr += 1;
      if (ep_tr < ne) {
        ei = e[ep_tr];
        ea = abs(ei);
      }
    } else {
      a2 = fi;
      fp_tr += 1;
      if (fp_tr < nf) {
        fi = -f[fp_tr];
        fa = abs(fi);
      }
    }
    let x3 = a2 + b;
    let bv = x3 - a2;
    let y3 = b - bv;
    let q0 = y3;
    let q1 = x3;
    let _x, _bv, _av, _br, _ar;
    while (ep_tr < ne && fp_tr < nf) {
      if (ea < fa) {
        a2 = ei;
        ep_tr += 1;
        if (ep_tr < ne) {
          ei = e[ep_tr];
          ea = abs(ei);
        }
      } else {
        a2 = fi;
        fp_tr += 1;
        if (fp_tr < nf) {
          fi = -f[fp_tr];
          fa = abs(fi);
        }
      }
      b = q0;
      x3 = a2 + b;
      bv = x3 - a2;
      y3 = b - bv;
      if (y3) {
        g[count++] = y3;
      }
      _x = q1 + x3;
      _bv = _x - q1;
      _av = _x - _bv;
      _br = x3 - _bv;
      _ar = q1 - _av;
      q0 = _ar + _br;
      q1 = _x;
    }
    while (ep_tr < ne) {
      a2 = ei;
      b = q0;
      x3 = a2 + b;
      bv = x3 - a2;
      y3 = b - bv;
      if (y3) {
        g[count++] = y3;
      }
      _x = q1 + x3;
      _bv = _x - q1;
      _av = _x - _bv;
      _br = x3 - _bv;
      _ar = q1 - _av;
      q0 = _ar + _br;
      q1 = _x;
      ep_tr += 1;
      if (ep_tr < ne) {
        ei = e[ep_tr];
      }
    }
    while (fp_tr < nf) {
      a2 = fi;
      b = q0;
      x3 = a2 + b;
      bv = x3 - a2;
      y3 = b - bv;
      if (y3) {
        g[count++] = y3;
      }
      _x = q1 + x3;
      _bv = _x - q1;
      _av = _x - _bv;
      _br = x3 - _bv;
      _ar = q1 - _av;
      q0 = _ar + _br;
      q1 = _x;
      fp_tr += 1;
      if (fp_tr < nf) {
        fi = -f[fp_tr];
      }
    }
    if (q0) {
      g[count++] = q0;
    }
    if (q1) {
      g[count++] = q1;
    }
    if (!count) {
      g[count++] = 0;
    }
    g.length = count;
    return g;
  }

  // node_modules/@antv/g6/esm/plugins/hull/hull/robust-sum.js
  function scalarScalar2(a2, b) {
    const x3 = a2 + b;
    const bv = x3 - a2;
    const av = x3 - bv;
    const br = b - bv;
    const ar = a2 - av;
    const y3 = ar + br;
    if (y3) {
      return [y3, x3];
    }
    return [x3];
  }
  function linearExpansionSum(e, f) {
    const ne = e.length | 0;
    const nf = f.length | 0;
    if (ne === 1 && nf === 1) {
      return scalarScalar2(e[0], f[0]);
    }
    const n = ne + nf;
    const g = new Array(n);
    let count = 0;
    let ep_tr = 0;
    let fp_tr = 0;
    const abs = Math.abs;
    let ei = e[ep_tr];
    let ea = abs(ei);
    let fi = f[fp_tr];
    let fa = abs(fi);
    let a2, b;
    if (ea < fa) {
      b = ei;
      ep_tr += 1;
      if (ep_tr < ne) {
        ei = e[ep_tr];
        ea = abs(ei);
      }
    } else {
      b = fi;
      fp_tr += 1;
      if (fp_tr < nf) {
        fi = f[fp_tr];
        fa = abs(fi);
      }
    }
    if (ep_tr < ne && ea < fa || fp_tr >= nf) {
      a2 = ei;
      ep_tr += 1;
      if (ep_tr < ne) {
        ei = e[ep_tr];
        ea = abs(ei);
      }
    } else {
      a2 = fi;
      fp_tr += 1;
      if (fp_tr < nf) {
        fi = f[fp_tr];
        fa = abs(fi);
      }
    }
    let x3 = a2 + b;
    let bv = x3 - a2;
    let y3 = b - bv;
    let q0 = y3;
    let q1 = x3;
    let _x, _bv, _av, _br, _ar;
    while (ep_tr < ne && fp_tr < nf) {
      if (ea < fa) {
        a2 = ei;
        ep_tr += 1;
        if (ep_tr < ne) {
          ei = e[ep_tr];
          ea = abs(ei);
        }
      } else {
        a2 = fi;
        fp_tr += 1;
        if (fp_tr < nf) {
          fi = f[fp_tr];
          fa = abs(fi);
        }
      }
      b = q0;
      x3 = a2 + b;
      bv = x3 - a2;
      y3 = b - bv;
      if (y3) {
        g[count++] = y3;
      }
      _x = q1 + x3;
      _bv = _x - q1;
      _av = _x - _bv;
      _br = x3 - _bv;
      _ar = q1 - _av;
      q0 = _ar + _br;
      q1 = _x;
    }
    while (ep_tr < ne) {
      a2 = ei;
      b = q0;
      x3 = a2 + b;
      bv = x3 - a2;
      y3 = b - bv;
      if (y3) {
        g[count++] = y3;
      }
      _x = q1 + x3;
      _bv = _x - q1;
      _av = _x - _bv;
      _br = x3 - _bv;
      _ar = q1 - _av;
      q0 = _ar + _br;
      q1 = _x;
      ep_tr += 1;
      if (ep_tr < ne) {
        ei = e[ep_tr];
      }
    }
    while (fp_tr < nf) {
      a2 = fi;
      b = q0;
      x3 = a2 + b;
      bv = x3 - a2;
      y3 = b - bv;
      if (y3) {
        g[count++] = y3;
      }
      _x = q1 + x3;
      _bv = _x - q1;
      _av = _x - _bv;
      _br = x3 - _bv;
      _ar = q1 - _av;
      q0 = _ar + _br;
      q1 = _x;
      fp_tr += 1;
      if (fp_tr < nf) {
        fi = f[fp_tr];
      }
    }
    if (q0) {
      g[count++] = q0;
    }
    if (q1) {
      g[count++] = q1;
    }
    if (!count) {
      g[count++] = 0;
    }
    g.length = count;
    return g;
  }

  // node_modules/@antv/g6/esm/plugins/hull/hull/robust-orientation.js
  var NUM_EXPAND = 5;
  var EPSILON2 = 11102230246251565e-32;
  var ERR_BOUND_3 = (3 + 16 * EPSILON2) * EPSILON2;
  var ERR_BOUND_4 = (7 + 56 * EPSILON2) * EPSILON2;
  function orientation_3(sum, prod, scale4, sub2) {
    return function orientation3Exact2(m0, m1, m2) {
      const p = sum(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])));
      const n = sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0]));
      const d2 = sub2(p, n);
      return d2[d2.length - 1];
    };
  }
  function orientation_4(sum, prod, scale4, sub2) {
    return function orientation4Exact2(m0, m1, m2, m3) {
      const p = sum(sum(scale4(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale4(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale4(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), sum(scale4(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale4(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale4(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))));
      const n = sum(sum(scale4(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale4(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale4(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), sum(scale4(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale4(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale4(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))));
      const d2 = sub2(p, n);
      return d2[d2.length - 1];
    };
  }
  function orientation_5(sum, prod, scale4, sub2) {
    return function orientation5Exact(m0, m1, m2, m3, m4) {
      const p = sum(sum(sum(scale4(sum(scale4(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m2[2]), sum(scale4(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), -m3[2]), scale4(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m4[2]))), m1[3]), sum(scale4(sum(scale4(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m1[2]), sum(scale4(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m3[2]), scale4(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m4[2]))), -m2[3]), scale4(sum(scale4(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m1[2]), sum(scale4(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m2[2]), scale4(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m4[2]))), m3[3]))), sum(scale4(sum(scale4(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale4(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale4(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), -m4[3]), sum(scale4(sum(scale4(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m1[2]), sum(scale4(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m3[2]), scale4(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m4[2]))), m0[3]), scale4(sum(scale4(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m0[2]), sum(scale4(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m3[2]), scale4(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), m4[2]))), -m1[3])))), sum(sum(scale4(sum(scale4(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), m0[2]), sum(scale4(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m1[2]), scale4(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m4[2]))), m3[3]), sum(scale4(sum(scale4(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale4(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale4(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))), -m4[3]), scale4(sum(scale4(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale4(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale4(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), m0[3]))), sum(scale4(sum(scale4(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale4(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale4(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), -m1[3]), sum(scale4(sum(scale4(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale4(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale4(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))), m2[3]), scale4(sum(scale4(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale4(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale4(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))), -m3[3])))));
      const n = sum(sum(sum(scale4(sum(scale4(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m2[2]), sum(scale4(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), -m3[2]), scale4(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m4[2]))), m0[3]), scale4(sum(scale4(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m0[2]), sum(scale4(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m3[2]), scale4(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), m4[2]))), -m2[3])), sum(scale4(sum(scale4(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m0[2]), sum(scale4(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m2[2]), scale4(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m4[2]))), m3[3]), scale4(sum(scale4(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale4(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale4(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), -m4[3]))), sum(sum(scale4(sum(scale4(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m1[2]), sum(scale4(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m2[2]), scale4(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m4[2]))), m0[3]), scale4(sum(scale4(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m0[2]), sum(scale4(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m2[2]), scale4(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m4[2]))), -m1[3])), sum(scale4(sum(scale4(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), m0[2]), sum(scale4(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m1[2]), scale4(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m4[2]))), m2[3]), scale4(sum(scale4(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale4(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale4(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))), -m4[3]))));
      const d2 = sub2(p, n);
      return d2[d2.length - 1];
    };
  }
  function orientation(n) {
    const fn = n === 3 ? orientation_3 : n === 4 ? orientation_4 : orientation_5;
    return fn(linearExpansionSum, twoProduct, scaleLinearExpansion, robustSubtract);
  }
  var orientation3Exact = orientation(3);
  var orientation4Exact = orientation(4);
  var CACHED = [
    function orientation0() {
      return 0;
    },
    function orientation1() {
      return 0;
    },
    function orientation2(a2, b) {
      return b[0] - a2[0];
    },
    function orientation3(a2, b, c2) {
      const l = (a2[1] - c2[1]) * (b[0] - c2[0]);
      const r = (a2[0] - c2[0]) * (b[1] - c2[1]);
      const det = l - r;
      let s;
      if (l > 0) {
        if (r <= 0) {
          return det;
        } else {
          s = l + r;
        }
      } else if (l < 0) {
        if (r >= 0) {
          return det;
        } else {
          s = -(l + r);
        }
      } else {
        return det;
      }
      const tol = ERR_BOUND_3 * s;
      if (det >= tol || det <= -tol) {
        return det;
      }
      return orientation3Exact(a2, b, c2);
    },
    function orientation4(a2, b, c2, d2) {
      const adx = a2[0] - d2[0];
      const bdx = b[0] - d2[0];
      const cdx = c2[0] - d2[0];
      const ady = a2[1] - d2[1];
      const bdy = b[1] - d2[1];
      const cdy = c2[1] - d2[1];
      const adz = a2[2] - d2[2];
      const bdz = b[2] - d2[2];
      const cdz = c2[2] - d2[2];
      const bdx_cdy = bdx * cdy;
      const cdx_bdy = cdx * bdy;
      const cdx_ady = cdx * ady;
      const adx_cdy = adx * cdy;
      const adx_bdy = adx * bdy;
      const bdx_ady = bdx * ady;
      const det = adz * (bdx_cdy - cdx_bdy) + bdz * (cdx_ady - adx_cdy) + cdz * (adx_bdy - bdx_ady);
      const permanent = (Math.abs(bdx_cdy) + Math.abs(cdx_bdy)) * Math.abs(adz) + (Math.abs(cdx_ady) + Math.abs(adx_cdy)) * Math.abs(bdz) + (Math.abs(adx_bdy) + Math.abs(bdx_ady)) * Math.abs(cdz);
      const tol = ERR_BOUND_4 * permanent;
      if (det > tol || -det > tol) {
        return det;
      }
      return orientation4Exact(a2, b, c2, d2);
    }
  ];
  function slowOrient(args) {
    let proc2 = CACHED[args.length];
    if (!proc2) {
      proc2 = CACHED[args.length] = orientation(args.length);
    }
    return proc2.apply(void 0, ...args);
  }
  function proc(slow, o0, o1, o2, o3, o4, o5) {
    return function getOrientation(...args) {
      switch (args.length) {
        case 0:
        case 1:
          return 0;
        case 2:
          return o2(args[0], args[1]);
        case 3:
          return o3(args[0], args[1], args[2]);
        case 4:
          return o4(args[0], args[1], args[2], args[3]);
        case 5:
          return o5(args[0], args[1], args[2], args[3], args[4]);
      }
      return slow(args);
    };
  }
  function generateOrientationProc() {
    while (CACHED.length <= NUM_EXPAND) {
      CACHED.push(orientation(CACHED.length));
    }
    const orientationProc = proc(void 0, slowOrient, ...CACHED);
    for (let i = 0; i <= NUM_EXPAND; ++i) {
      orientationProc[i] = CACHED[i];
    }
    return orientationProc;
  }
  var robust_orientation_default = generateOrientationProc();

  // node_modules/@antv/g6/esm/plugins/hull/hull/monotone-convex-hull-2d.js
  var orient = robust_orientation_default[3];
  function monotoneConvexHull2D(points) {
    const n = points.length;
    if (n < 3) {
      const result2 = new Array(n);
      for (let i = 0; i < n; ++i) {
        result2[i] = i;
      }
      if (n === 2 && points[0][0] === points[1][0] && points[0][1] === points[1][1]) {
        return [0];
      }
      return result2;
    }
    const sorted = new Array(n);
    for (let i = 0; i < n; ++i) {
      sorted[i] = i;
    }
    sorted.sort((a2, b) => {
      const d2 = points[a2][0] - points[b][0];
      if (d2) {
        return d2;
      }
      return points[a2][1] - points[b][1];
    });
    const lower2 = [sorted[0], sorted[1]];
    const upper2 = [sorted[0], sorted[1]];
    for (let i = 2; i < n; ++i) {
      const idx = sorted[i];
      const p = points[idx];
      let m2 = lower2.length;
      while (m2 > 1 && orient(points[lower2[m2 - 2]], points[lower2[m2 - 1]], p) <= 0) {
        m2 -= 1;
        lower2.pop();
      }
      lower2.push(idx);
      m2 = upper2.length;
      while (m2 > 1 && orient(points[upper2[m2 - 2]], points[upper2[m2 - 1]], p) >= 0) {
        m2 -= 1;
        upper2.pop();
      }
      upper2.push(idx);
    }
    const result = new Array(upper2.length + lower2.length - 2);
    let ptr = 0;
    for (let i = 0, nl = lower2.length; i < nl; ++i) {
      result[ptr++] = lower2[i];
    }
    for (let j = upper2.length - 2; j > 0; --j) {
      result[ptr++] = upper2[j];
    }
    return result;
  }

  // node_modules/@antv/g6/esm/plugins/hull/hull/robust-segment-intersect.js
  function checkCollinear(a0, a1, b0, b1) {
    for (let d2 = 0; d2 < 2; ++d2) {
      const x0 = a0[d2];
      const y0 = a1[d2];
      const [l0, h0] = [Math.min(x0, y0), Math.max(x0, y0)];
      const x1 = b0[d2];
      const y1 = b1[d2];
      const [l1, h1] = [Math.min(x1, y1), Math.max(x1, y1)];
      if (h1 < l0 || h0 < l1)
        return false;
    }
    return true;
  }
  function segmentsIntersect(a0, a1, b0, b1) {
    const x0 = robust_orientation_default(a0, b0, b1);
    const y0 = robust_orientation_default(a1, b0, b1);
    if (x0 > 0 && y0 > 0 || x0 < 0 && y0 < 0)
      return false;
    const x1 = robust_orientation_default(b0, a0, a1);
    const y1 = robust_orientation_default(b1, a0, a1);
    if (x1 > 0 && y1 > 0 || x1 < 0 && y1 < 0)
      return false;
    if (x0 === 0 && y0 === 0 && x1 === 0 && y1 === 0) {
      return checkCollinear(a0, a1, b0, b1);
    }
    return true;
  }

  // node_modules/@antv/g6/esm/plugins/hull/hull/index.js
  function _filterDuplicates(pointset) {
    const unique = [pointset[0]];
    let lastPoint = pointset[0];
    for (let i = 1; i < pointset.length; i++) {
      const currentPoint = pointset[i];
      if (lastPoint[0] !== currentPoint[0] || lastPoint[1] !== currentPoint[1]) {
        unique.push(currentPoint);
      }
      lastPoint = currentPoint;
    }
    return unique;
  }
  function _sortByX(pointset) {
    return pointset.sort(function(a2, b) {
      return a2[0] - b[0] || a2[1] - b[1];
    });
  }
  function _sqLength(a2, b) {
    return Math.pow(b[0] - a2[0], 2) + Math.pow(b[1] - a2[1], 2);
  }
  function _cos(o, a2, b) {
    const aShifted = [a2[0] - o[0], a2[1] - o[1]], bShifted = [b[0] - o[0], b[1] - o[1]], sqALen = _sqLength(o, a2), sqBLen = _sqLength(o, b), dot4 = aShifted[0] * bShifted[0] + aShifted[1] * bShifted[1];
    return dot4 / Math.sqrt(sqALen * sqBLen);
  }
  function _intersect(segment, pointset) {
    for (let i = 0; i < pointset.length - 1; i++) {
      const seg = [pointset[i], pointset[i + 1]];
      if (segment[0][0] === seg[0][0] && segment[0][1] === seg[0][1] || segment[0][0] === seg[1][0] && segment[0][1] === seg[1][1]) {
        continue;
      }
      if (segmentsIntersect(segment[0], segment[1], seg[0], seg[1])) {
        return true;
      }
    }
    return false;
  }
  function _occupiedArea(pointset) {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    for (let i = pointset.length - 1; i >= 0; i--) {
      if (pointset[i][0] < minX) {
        minX = pointset[i][0];
      }
      if (pointset[i][1] < minY) {
        minY = pointset[i][1];
      }
      if (pointset[i][0] > maxX) {
        maxX = pointset[i][0];
      }
      if (pointset[i][1] > maxY) {
        maxY = pointset[i][1];
      }
    }
    return [
      maxX - minX,
      // width
      maxY - minY
      // height
    ];
  }
  function _bBoxAround(edge) {
    return [
      Math.min(edge[0][0], edge[1][0]),
      // left
      Math.min(edge[0][1], edge[1][1]),
      // top
      Math.max(edge[0][0], edge[1][0]),
      // right
      Math.max(edge[0][1], edge[1][1])
      // bottom
    ];
  }
  function _midPoint(edge, innerPoints, convex) {
    let point4 = null, angle1Cos = MAX_CONCAVE_ANGLE_COS, angle2Cos = MAX_CONCAVE_ANGLE_COS, a1Cos, a2Cos;
    for (let i = 0; i < innerPoints.length; i++) {
      a1Cos = _cos(edge[0], edge[1], innerPoints[i]);
      a2Cos = _cos(edge[1], edge[0], innerPoints[i]);
      if (a1Cos > angle1Cos && a2Cos > angle2Cos && !_intersect([edge[0], innerPoints[i]], convex) && !_intersect([edge[1], innerPoints[i]], convex)) {
        angle1Cos = a1Cos;
        angle2Cos = a2Cos;
        point4 = innerPoints[i];
      }
    }
    return point4;
  }
  function _concave(convex, maxSqEdgeLen, maxSearchArea, grid2, edgeSkipList) {
    let midPointInserted = false;
    for (let i = 0; i < convex.length - 1; i++) {
      const edge = [convex[i], convex[i + 1]];
      const keyInSkipList = edge[0][0] + "," + edge[0][1] + "," + edge[1][0] + "," + edge[1][1];
      if (_sqLength(edge[0], edge[1]) < maxSqEdgeLen || edgeSkipList.has(keyInSkipList)) {
        continue;
      }
      let scaleFactor = 0;
      let bBoxAround = _bBoxAround(edge);
      let bBoxWidth;
      let bBoxHeight;
      let midPoint;
      do {
        bBoxAround = grid2.extendBbox(bBoxAround, scaleFactor);
        bBoxWidth = bBoxAround[2] - bBoxAround[0];
        bBoxHeight = bBoxAround[3] - bBoxAround[1];
        midPoint = _midPoint(edge, grid2.rangePoints(bBoxAround), convex);
        scaleFactor++;
      } while (midPoint === null && (maxSearchArea[0] > bBoxWidth || maxSearchArea[1] > bBoxHeight));
      if (bBoxWidth >= maxSearchArea[0] && bBoxHeight >= maxSearchArea[1]) {
        edgeSkipList.add(keyInSkipList);
      }
      if (midPoint !== null) {
        convex.splice(i + 1, 0, midPoint);
        grid2.removePoint(midPoint);
        midPointInserted = true;
      }
    }
    if (midPointInserted) {
      return _concave(convex, maxSqEdgeLen, maxSearchArea, grid2, edgeSkipList);
    }
    return convex;
  }
  function hull(pointset, concavity, format2) {
    const maxEdgeLen = concavity || 20;
    const points = _filterDuplicates(_sortByX(formatUtil.toXy(pointset, format2)));
    if (points.length < 4) {
      const concave2 = points.concat([points[0]]);
      return format2 ? formatUtil.fromXy(concave2, format2) : concave2;
    }
    const occupiedArea = _occupiedArea(points);
    const maxSearchArea = [
      occupiedArea[0] * MAX_SEARCH_BBOX_SIZE_PERCENT,
      occupiedArea[1] * MAX_SEARCH_BBOX_SIZE_PERCENT
    ];
    const convex = monotoneConvexHull2D(points).reverse().map((idx) => points[idx]);
    convex.push(convex[0]);
    const innerPoints = points.filter(function(pt) {
      return convex.indexOf(pt) < 0;
    });
    const cellSize = Math.ceil(1 / (points.length / (occupiedArea[0] * occupiedArea[1])));
    const concave = _concave(convex, Math.pow(maxEdgeLen, 2), maxSearchArea, grid(innerPoints, cellSize), /* @__PURE__ */ new Set());
    return format2 ? formatUtil.fromXy(concave, format2) : concave;
  }
  var MAX_CONCAVE_ANGLE_COS = Math.cos(90 / (180 / Math.PI));
  var MAX_SEARCH_BBOX_SIZE_PERCENT = 0.6;

  // node_modules/@antv/g6/esm/plugins/hull/util.js
  function computeHullPath(points, padding, corner) {
    if (points.length === 1)
      return genSinglePointHullPath(points[0], padding, corner);
    if (points.length === 2)
      return genTwoPointsHullPath(points, padding, corner);
    if (points.length === 3) {
      const [p1, p2, p3] = sortByClockwise(points);
      if (isCollinear(p1, p2, p3))
        return genTwoPointsHullPath([p1, p3], padding, corner);
    }
    switch (corner) {
      case "smooth":
        return genMultiPointsSmoothHull(points, padding);
      case "sharp":
        return genMultiPointsSharpHull(points, padding);
      case "rounded":
      default:
        return genMultiPointsRoundedHull(points, padding);
    }
  }
  var genSinglePointHullPath = (point4, padding, corner) => {
    if (corner === "sharp")
      return [
        ["M", point4[0] - padding, point4[1] - padding],
        ["L", point4[0] + padding, point4[1] - padding],
        ["L", point4[0] + padding, point4[1] + padding],
        ["L", point4[0] - padding, point4[1] + padding],
        ["Z"]
      ];
    const arcData = [padding, padding, 0, 0, 0];
    return [
      ["M", point4[0], point4[1] - padding],
      ["A", ...arcData, point4[0], point4[1] + padding],
      ["A", ...arcData, point4[0], point4[1] - padding]
    ];
  };
  var genTwoPointsHullPath = (points, padding, corner) => {
    const arcData = [padding, padding, 0, 0, 0];
    const point1 = corner === "sharp" ? add(points[0], scale2(normalize2(subtract(points[0], points[1])), padding)) : points[0];
    const point22 = corner === "sharp" ? add(points[1], scale2(normalize2(subtract(points[1], points[0])), padding)) : points[1];
    const offsetVector = scale2(normalize2(perpendicular(subtract(point1, point22), false)), padding);
    const invOffsetVector = scale2(offsetVector, -1);
    const prev = add(point1, offsetVector);
    const current2 = add(point22, offsetVector);
    const p2 = add(point22, invOffsetVector);
    const p3 = add(point1, invOffsetVector);
    if (corner === "sharp") {
      return [["M", prev[0], prev[1]], ["L", current2[0], current2[1]], ["L", p2[0], p2[1]], ["L", p3[0], p3[1]], ["Z"]];
    }
    return [
      ["M", prev[0], prev[1]],
      ["L", current2[0], current2[1]],
      ["A", ...arcData, p2[0], p2[1]],
      ["L", p3[0], p3[1]],
      ["A", ...arcData, prev[0], prev[1]]
    ];
  };
  var genMultiPointsRoundedHull = (points, padding) => {
    const segments = sortByClockwise(points).map((current2, i) => {
      const prev2Index = (i - 2 + points.length) % points.length;
      const prevIndex = (i - 1 + points.length) % points.length;
      const nextIndex = (i + 1) % points.length;
      const prev2 = points[prev2Index];
      const prev = points[prevIndex];
      const next = points[nextIndex];
      const v0 = subtract(prev2, prev);
      const v1 = subtract(prev, current2);
      const v2 = subtract(current2, next);
      const isConcave = (v12, v22) => {
        return angle(v12, v22, true) < Math.PI;
      };
      const concavePrev = isConcave(v0, v1);
      const concaveNext = isConcave(v1, v2);
      const offsetVector = (v) => scale2(normalize2(perpendicular(v, false)), padding);
      const offset = offsetVector(v1);
      return [
        {
          p: toVector2(concavePrev ? add(prev, offsetVector(v0)) : add(prev, offset)),
          concave: concavePrev && prev
        },
        {
          p: toVector2(concaveNext ? add(current2, offsetVector(v2)) : add(current2, offset)),
          concave: concaveNext && current2
        }
      ];
    });
    const arcData = [padding, padding, 0, 0, 0];
    const startIndex = segments.findIndex((segment, i) => !segments[(i - 1 + segments.length) % segments.length][0].concave && !segments[(i - 1 + segments.length) % segments.length][1].concave && !segment[0].concave && !segment[0].concave && !segment[1].concave);
    const sortedSegments = segments.slice(startIndex).concat(segments.slice(0, startIndex));
    let concavePoints = [];
    return sortedSegments.flatMap((segment, i) => {
      const pathFragment = [];
      const lastSegment = sortedSegments[segments.length - 1];
      if (i === 0)
        pathFragment.push(["M", ...lastSegment[1].p]);
      if (!segment[0].concave) {
        pathFragment.push(["A", ...arcData, ...segment[0].p]);
      } else {
        concavePoints.push(segment[0].p, segment[1].p);
      }
      if (!segment[1].concave) {
        pathFragment.push(["L", ...segment[1].p]);
      } else {
        concavePoints.unshift(segment[1].p);
      }
      if (concavePoints.length === 3) {
        pathFragment.pop();
        pathFragment.push(["C", ...concavePoints.flat()]);
        concavePoints = [];
      }
      return pathFragment;
    });
  };
  var genMultiPointsSmoothHull = (points, padding) => {
    const hullPoints = sortByClockwise(points).map((p, i) => {
      const pNext = points[(i + 1) % points.length];
      return { p, v: normalize2(subtract(pNext, p)) };
    });
    hullPoints.forEach((hp, i) => {
      const priorIndex = i > 0 ? i - 1 : points.length - 1;
      const prevV = hullPoints[priorIndex].v;
      const extensionVec = normalize2(add(prevV, scale2(hp.v, angle(prevV, hp.v, true) < Math.PI ? 1 : -1)));
      hp.p = add(hp.p, scale2(extensionVec, padding));
    });
    return getClosedSpline(hullPoints.map((obj) => obj.p));
  };
  var genMultiPointsSharpHull = (points, padding) => {
    const segments = points.map((current2, i) => {
      const prev = points[i === 0 ? points.length - 1 : i - 1];
      const offset = toVector3(scale2(normalize2(perpendicular(subtract(prev, current2), false)), padding));
      return [add(prev, offset), add(current2, offset)];
    });
    const arr = segments.flat();
    const vertices = arr.map((_2, i) => {
      if (i % 2 === 0)
        return null;
      const l1 = [arr[(i - 1) % arr.length], arr[i % arr.length]];
      const l2 = [arr[(i + 1) % arr.length], arr[(i + 2) % arr.length]];
      return getLinesIntersection(l1, l2, true);
    }).filter(Boolean);
    return vertices.map((point4, i) => [i === 0 ? "M" : "L", point4[0], point4[1]]).concat([["Z"]]);
  };

  // node_modules/@antv/g6/esm/plugins/hull/index.js
  var __rest15 = function(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  var Hull = class _Hull extends BasePlugin {
    constructor(context, options) {
      super(context, Object.assign({}, _Hull.defaultOptions, options));
      this.hullMemberIds = [];
      this.drawHull = () => {
        if (!this.shape) {
          this.shape = new Contour({ style: this.getHullStyle() });
          this.context.canvas.appendChild(this.shape);
        } else {
          const forceUpdate = !(0, import_util116.isEqual)(this.optionsCache, this.options);
          this.shape.update(this.getHullStyle(forceUpdate));
        }
        this.optionsCache = Object.assign({}, this.options);
      };
      this.updateHullPath = (event) => {
        if (!this.shape)
          return;
        if (!this.options.members.includes(idOf(event.data)))
          return;
        this.shape.update({ d: this.getHullPath(true) });
      };
      this.getHullPath = (forceUpdate = false) => {
        const { graph } = this.context;
        const members = this.getMember();
        if (members.length === 0)
          return "";
        const data2 = members.map((id3) => graph.getNodeData(id3));
        const vertices = hull(data2.map(positionOf), this.options.concavity).slice(1).reverse();
        const hullMemberIds = vertices.flatMap((point4) => data2.filter((m2) => (0, import_util116.isEqual)(positionOf(m2), point4)).map(idOf));
        if ((0, import_util116.isEqual)(hullMemberIds, this.hullMemberIds) && !forceUpdate)
          return this.path;
        this.hullMemberIds = hullMemberIds;
        this.path = computeHullPath(vertices, this.getPadding(), this.options.corner);
        return this.path;
      };
      this.bindEvents();
    }
    bindEvents() {
      this.context.graph.on(GraphEvent.AFTER_RENDER, this.drawHull);
      this.context.graph.on(GraphEvent.AFTER_ELEMENT_UPDATE, this.updateHullPath);
    }
    unbindEvents() {
      this.context.graph.off(GraphEvent.AFTER_RENDER, this.drawHull);
      this.context.graph.off(GraphEvent.AFTER_ELEMENT_UPDATE, this.updateHullPath);
    }
    getHullStyle(forceUpdate) {
      const _a2 = this.options, { members, padding, corner } = _a2, style = __rest15(_a2, ["members", "padding", "corner"]);
      return Object.assign(Object.assign({}, style), { d: this.getHullPath(forceUpdate) });
    }
    getPadding() {
      const { graph } = this.context;
      const memberPadding = this.hullMemberIds.reduce((acc, id3) => {
        const { halfExtents } = graph.getElementRenderBounds(id3);
        const size2 = Math.max(halfExtents[0], halfExtents[1]);
        return Math.max(acc, size2);
      }, 0);
      return memberPadding + this.options.padding;
    }
    /**
     * <zh/> 添加 Hull 成员
     *
     * <en/> Add Hull member
     * @param members - <zh/> 元素 Ids | <en/> Element Ids
     */
    addMember(members) {
      const membersToAdd = Array.isArray(members) ? members : [members];
      this.options.members = [.../* @__PURE__ */ new Set([...this.options.members, ...membersToAdd])];
      this.shape.update({ d: this.getHullPath() });
    }
    /**
     * <zh/> 移除 Hull 成员
     *
     * <en/> Remove Hull member
     * @param members - <zh/> 元素 Ids | <en/> Element Ids
     */
    removeMember(members) {
      const membersToRemove = Array.isArray(members) ? members : [members];
      this.options.members = this.options.members.filter((id3) => !membersToRemove.includes(id3));
      if (membersToRemove.some((id3) => this.hullMemberIds.includes(id3))) {
        this.shape.update({ d: this.getHullPath() });
      }
    }
    /**
     * <zh/> 更新 Hull 成员
     *
     * <en/> Update Hull member
     * @param members - <zh/> 元素 Ids | <en/> Element Ids
     */
    updateMember(members) {
      this.options.members = (0, import_util116.isFunction)(members) ? members(this.options.members) : members;
      this.shape.update(this.getHullStyle(true));
    }
    /**
     * <zh/> 获取 Hull 成员
     *
     * <en/> Get Hull member
     * @returns <zh/> 元素 Ids | <en/> Element Ids
     */
    getMember() {
      return this.options.members;
    }
    /**
     * <zh/> 销毁 Hull
     *
     * <en/> Destroy Hull
     * @internal
     */
    destroy() {
      this.unbindEvents();
      this.shape.destroy();
      this.hullMemberIds = [];
      super.destroy();
    }
  };
  Hull.defaultOptions = {
    members: [],
    padding: 10,
    corner: "rounded",
    concavity: Infinity,
    /** hull style */
    fill: "lightblue",
    fillOpacity: 0.2,
    labelOpacity: 1,
    stroke: "blue",
    strokeOpacity: 0.2
  };

  // node_modules/@antv/component/esm/core/component.js
  init_tslib_es6();

  // node_modules/@antv/component/esm/shapes/Text.js
  init_tslib_es6();

  // node_modules/@antv/component/esm/util/offscreen.js
  init_tslib_es6();

  // node_modules/@antv/component/esm/util/traverse.js
  function traverse(element, callback) {
    callback(element);
    if (element.children) {
      element.children.forEach(function(child) {
        if (child)
          traverse(child, callback);
      });
    }
  }

  // node_modules/@antv/component/esm/util/visibility.js
  function show(element) {
    visibility(element, true);
  }
  function hide(element) {
    visibility(element, false);
  }
  function visibility(element, visible) {
    var value = visible ? "visible" : "hidden";
    traverse(element, function(node) {
      node.attr("visibility", value);
    });
  }

  // node_modules/@antv/component/esm/util/offscreen.js
  var OffscreenGroup = (
    /** @class */
    (function(_super) {
      __extends(OffscreenGroup2, _super);
      function OffscreenGroup2() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var _this2 = _super.apply(this, __spreadArray([], __read(args), false)) || this;
        _this2.isMutationObserved = true;
        _this2.addEventListener(ElementEvent.INSERTED, function() {
          hide(_this2);
        });
        return _this2;
      }
      return OffscreenGroup2;
    })(Group)
  );
  function createOffscreenGroup(container) {
    var group2 = container.appendChild(new OffscreenGroup({
      class: "offscreen"
    }));
    hide(group2);
    return group2;
  }
  function isInOffscreenGroup(group2) {
    var ancestor = group2;
    while (ancestor) {
      if (ancestor.className === "offscreen") {
        return true;
      }
      ancestor = ancestor.parent;
    }
    return false;
  }

  // node_modules/@antv/component/esm/shapes/Text.js
  var Text2 = (
    /** @class */
    (function(_super) {
      __extends(Text3, _super);
      function Text3(_a2) {
        if (_a2 === void 0) {
          _a2 = {};
        }
        var style = _a2.style, restOptions = __rest(_a2, ["style"]);
        return _super.call(this, __assign({ style: __assign({ text: "", fill: "black", fontFamily: "sans-serif", fontSize: 16, fontStyle: "normal", fontVariant: "normal", fontWeight: "normal", lineWidth: 1, textAlign: "start", textBaseline: "middle" }, style) }, restOptions)) || this;
      }
      Object.defineProperty(Text3.prototype, "offscreenGroup", {
        get: function() {
          if (!this._offscreen)
            this._offscreen = createOffscreenGroup(this);
          return this._offscreen;
        },
        enumerable: false,
        configurable: true
      });
      Text3.prototype.disconnectedCallback = function() {
        var _a2;
        (_a2 = this._offscreen) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      };
      return Text3;
    })(Text)
  );

  // node_modules/@antv/component/esm/util/angle-converter.js
  function degToRad(deg) {
    return deg * Math.PI / 180;
  }
  function radToDeg(rad2) {
    return Number((rad2 * 180 / Math.PI).toPrecision(5));
  }

  // node_modules/@antv/component/esm/util/bbox.js
  var BBox = (
    /** @class */
    (function() {
      function BBox2(x3, y3, width2, height) {
        if (x3 === void 0) {
          x3 = 0;
        }
        if (y3 === void 0) {
          y3 = 0;
        }
        if (width2 === void 0) {
          width2 = 0;
        }
        if (height === void 0) {
          height = 0;
        }
        this.x = 0;
        this.y = 0;
        this.width = 0;
        this.height = 0;
        this.x = x3;
        this.y = y3;
        this.width = width2;
        this.height = height;
      }
      Object.defineProperty(BBox2.prototype, "bottom", {
        get: function() {
          return this.y + this.height;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BBox2.prototype, "left", {
        get: function() {
          return this.x;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BBox2.prototype, "right", {
        get: function() {
          return this.x + this.width;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BBox2.prototype, "top", {
        get: function() {
          return this.y;
        },
        enumerable: false,
        configurable: true
      });
      BBox2.fromRect = function(other) {
        return new BBox2(other.x, other.y, other.width, other.height);
      };
      BBox2.prototype.toJSON = function() {
        return {
          x: this.x,
          y: this.y,
          width: this.width,
          height: this.height,
          top: this.top,
          right: this.right,
          bottom: this.bottom,
          left: this.left
        };
      };
      BBox2.prototype.isPointIn = function(x3, y3) {
        return x3 >= this.left && x3 <= this.right && y3 >= this.top && y3 <= this.bottom;
      };
      return BBox2;
    })()
  );

  // node_modules/@antv/component/esm/util/callback.js
  init_tslib_es6();
  var import_util118 = __toESM(require_lib());
  function getCallbackValue(value, params) {
    return (0, import_util118.isFunction)(value) ? value.apply(void 0, __spreadArray([], __read(params), false)) : value;
  }

  // node_modules/@antv/component/esm/util/classnames.js
  init_tslib_es6();
  var classNames = function(cls, prefix) {
    var PREFIX = function(str) {
      return "".concat(prefix, "-").concat(str);
    };
    var obj = Object.fromEntries(Object.entries(cls).map(function(_a2) {
      var _b = __read(_a2, 2), k = _b[0], v = _b[1];
      var name = PREFIX(v);
      return [
        k,
        {
          name,
          class: ".".concat(name),
          id: "#".concat(name),
          toString: function() {
            return name;
          }
        }
      ];
    }));
    Object.assign(obj, { prefix: PREFIX });
    return obj;
  };

  // node_modules/@antv/component/esm/util/deep-assign.js
  init_tslib_es6();
  var import_util119 = __toESM(require_lib());
  var MAX_MIX_LEVEL = 5;
  var deep = function(dist, src, level, maxLevel) {
    if (level === void 0) {
      level = 0;
    }
    if (maxLevel === void 0) {
      maxLevel = MAX_MIX_LEVEL;
    }
    Object.entries(src).forEach(function(_a2) {
      var _b = __read(_a2, 2), key = _b[0], value = _b[1];
      var res = dist;
      if (Object.prototype.hasOwnProperty.call(src, key)) {
        if (!value) {
          res[key] = value;
        } else if ((0, import_util119.isPlainObject)(value)) {
          if (!(0, import_util119.isPlainObject)(dist[key])) {
            res[key] = {};
          }
          if (level < maxLevel) {
            deep(dist[key], value, level + 1, maxLevel);
          } else {
            res[key] = src[key];
          }
        } else if ((0, import_util119.isArray)(value)) {
          res[key] = [];
          res[key] = res[key].concat(value);
        } else {
          res[key] = value;
        }
      }
    });
  };
  var deepAssign = function(rst) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    for (var i = 0; i < args.length; i += 1) {
      deep(rst, args[i]);
    }
    return rst;
  };

  // node_modules/@antv/component/esm/util/defined.js
  var defined = function(x3) {
    return x3 !== void 0 && x3 != null && !Number.isNaN(x3);
  };

  // node_modules/@antv/component/esm/util/text.js
  var import_util120 = __toESM(require_lib());
  var ctx2;
  var mockMeasureTextWidth;
  var measureTextWidth = (0, import_util120.memoize)(function(text, font) {
    var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
    if (mockMeasureTextWidth) {
      return mockMeasureTextWidth(text, fontSize);
    }
    if (!ctx2) {
      ctx2 = runtime.offscreenCanvasCreator.getOrCreateContext(void 0);
    }
    ctx2.font = [fontStyle, fontVariant, fontWeight, "".concat(fontSize, "px"), fontFamily].join(" ");
    return ctx2.measureText(text).width;
  }, function(text, font) {
    return [text, Object.values(font || getFont(text)).join()].join("");
  }, 4096);
  var getFont = function(textShape) {
    var fontFamily = textShape.style.fontFamily || "sans-serif";
    var fontWeight = textShape.style.fontWeight || "normal";
    var fontStyle = textShape.style.fontStyle || "normal";
    var fontVariant = textShape.style.fontVariant;
    var fontSize = textShape.style.fontSize;
    fontSize = typeof fontSize === "object" ? fontSize.value : fontSize;
    return { fontSize, fontFamily, fontWeight, fontStyle, fontVariant };
  };
  function textOf(node) {
    if (node.nodeName === "text") {
      return node;
    }
    if (node.nodeName === "g" && node.children.length === 1 && node.children[0].nodeName === "text") {
      return node.children[0];
    }
    return null;
  }
  function applyToText(node, style) {
    var text = textOf(node);
    if (text)
      text.attr(style);
  }

  // node_modules/@antv/component/esm/util/ellipsis.js
  function ellipsisIt(node, w, suffix) {
    if (suffix === void 0) {
      suffix = "...";
    }
    applyToText(node, { wordWrap: true, wordWrapWidth: w, maxLines: 1, textOverflow: suffix });
  }

  // node_modules/@antv/component/esm/util/wrap.js
  function wrapIt(node, wordWrapWidth, maxLines, textBaseline) {
    if (maxLines === void 0) {
      maxLines = 2;
    }
    if (textBaseline === void 0) {
      textBaseline = "top";
    }
    applyToText(node, { wordWrap: true, wordWrapWidth, maxLines, textBaseline });
  }

  // node_modules/@antv/component/esm/util/event.js
  function getEventPos(e) {
    var canvas2 = e.canvas, touches = e.touches, offsetX = e.offsetX, offsetY = e.offsetY;
    if (canvas2) {
      var x3 = canvas2.x, y3 = canvas2.y;
      return [x3, y3];
    }
    if (touches) {
      var _a2 = touches[0], clientX = _a2.clientX, clientY = _a2.clientY;
      return [clientX, clientY];
    }
    if (offsetX && offsetY)
      return [offsetX, offsetY];
    return [0, 0];
  }

  // node_modules/@antv/component/esm/util/extend-display-object.js
  init_tslib_es6();
  var import_util121 = __toESM(require_lib());
  function renderExtDo(el) {
    if (typeof el === "function")
      return el();
    return (0, import_util121.isString)(el) || (0, import_util121.isNumber)(el) ? new Text2({ style: { text: String(el) } }) : el;
  }
  function renderHtmlExtDo(el, style) {
    if (typeof el === "function")
      return el();
    return (0, import_util121.isString)(el) || (0, import_util121.isNumber)(el) ? new HTML({ style: __assign(__assign({}, style), { innerHTML: String(el) }) }) : el;
  }

  // node_modules/@antv/component/esm/util/group-by.js
  function groupBy4(source, by) {
    return source.reduce(function(acc, curr) {
      (acc[curr[by]] = acc[curr[by]] || []).push(curr);
      return acc;
    }, {});
  }

  // node_modules/@antv/component/esm/util/if-show.js
  function ifShow(show2, container, creator, removeChildren, removeHandler) {
    if (removeChildren === void 0) {
      removeChildren = true;
    }
    if (removeHandler === void 0) {
      removeHandler = function(g) {
        g.node().removeChildren();
      };
    }
    if (show2) {
      return creator(container);
    }
    if (removeChildren)
      removeHandler(container);
    return null;
  }

  // node_modules/@antv/component/esm/util/in-range.js
  function inRange(n, start, end, includeLeft, includeRight) {
    if (includeLeft === void 0) {
      includeLeft = true;
    }
    if (includeRight === void 0) {
      includeRight = false;
    }
    if (includeLeft && n === start || includeRight && n === end)
      return true;
    return n > start && n < end;
  }

  // node_modules/@antv/component/esm/util/interpolate.js
  init_tslib_es6();
  var numberInterpolate = function(from, to) {
    return function(t) {
      return from * (1 - t) + to * t;
    };
  };
  function arrayInterpolate(from, to) {
    var nb = to ? to.length : 0;
    var na = from ? Math.min(nb, from.length) : 0;
    return function(t) {
      var x3 = new Array(na);
      var c2 = new Array(nb);
      var i = 0;
      for (i = 0; i < na; ++i)
        x3[i] = interpolate2(from[i], to[i]);
      for (; i < nb; ++i)
        c2[i] = to[i];
      for (i = 0; i < na; ++i)
        c2[i] = x3[i](t);
      return c2;
    };
  }
  function objectInterpolate(from, to) {
    if (from === void 0) {
      from = {};
    }
    if (to === void 0) {
      to = {};
    }
    var i = {};
    var c2 = {};
    Object.entries(to).forEach(function(_a2) {
      var _b = __read(_a2, 2), k = _b[0], v = _b[1];
      if (k in from)
        i[k] = interpolate2(from[k], v);
      else
        c2[k] = v;
    });
    return function(t) {
      Object.entries(i).forEach(function(_a2) {
        var _b = __read(_a2, 2), k = _b[0], v = _b[1];
        return c2[k] = v(t);
      });
      return c2;
    };
  }
  function interpolate2(from, to) {
    if (typeof from === "number" && typeof to === "number") {
      return numberInterpolate(from, to);
    }
    if (Array.isArray(from) && Array.isArray(to)) {
      return arrayInterpolate(from, to);
    }
    if (typeof from === "object" && typeof to === "object") {
      return objectInterpolate(from, to);
    }
    return (function(t) {
      return from;
    });
  }

  // node_modules/@antv/component/esm/util/keyframe-interpolate.js
  init_tslib_es6();
  function keyframeInterpolate(element, from, to, options) {
    if (!options) {
      element.attr("__keyframe_data__", to);
      return null;
    }
    var _a2 = options.duration, duration = _a2 === void 0 ? 0 : _a2;
    var int = interpolate2(from, to);
    var count = Math.ceil(+duration / 16);
    var keyframes = new Array(count).fill(0).map(function(datum, index2, array) {
      return { __keyframe_data__: int(index2 / (array.length - 1)) };
    });
    return element.animate(keyframes, __assign({ fill: "both" }, options));
  }

  // node_modules/@antv/component/esm/util/matrix.js
  function scale3(vec, s) {
    return [vec[0] * s, vec[1] * s];
  }
  function add4(vec1, vec23) {
    return [vec1[0] + vec23[0], vec1[1] + vec23[1]];
  }
  function sub(vec1, vec23) {
    return [vec1[0] - vec23[0], vec1[1] - vec23[1]];
  }
  function min2(vec1, vec23) {
    return [Math.min(vec1[0], vec23[0]), Math.min(vec1[1], vec23[1])];
  }
  function max2(vec1, vec23) {
    return [Math.max(vec1[0], vec23[0]), Math.max(vec1[1], vec23[1])];
  }
  function distance4(vec1, vec23) {
    return Math.sqrt(Math.pow(vec1[0] - vec23[0], 2) + Math.pow(vec1[1] - vec23[1], 2));
  }
  function normalize3(vec) {
    if (vec[0] === 0 && vec[1] === 0)
      return [0, 0];
    var len = Math.sqrt(Math.pow(vec[0], 2) + Math.pow(vec[1], 2));
    return [vec[0] / len, vec[1] / len];
  }
  function vertical(vec, flag) {
    return flag ? [vec[1], -vec[0]] : [-vec[1], vec[0]];
  }

  // node_modules/@antv/component/esm/util/number.js
  function toPrecision(num, precision) {
    return +num.toPrecision(precision);
  }

  // node_modules/@antv/component/esm/util/omit.js
  function omit2(obj, keys) {
    var res = {};
    var innerKeys = Array.isArray(keys) ? keys : [keys];
    for (var key in obj) {
      if (!innerKeys.includes(key)) {
        res[key] = obj[key];
      }
    }
    return res;
  }

  // node_modules/@antv/component/esm/util/path.js
  init_tslib_es6();
  function smoothBezier(points, smooth2, isLoop, constraint) {
    var _a2;
    var cps = [];
    var hasConstraint = !!constraint;
    var prevPoint;
    var nextPoint;
    var min4 = [Infinity, Infinity];
    var max4 = [-Infinity, -Infinity];
    var nextCp0;
    var cp1;
    var cp0;
    if (hasConstraint) {
      _a2 = __read(constraint, 2), min4 = _a2[0], max4 = _a2[1];
      for (var i = 0, l = points.length; i < l; i += 1) {
        var point4 = points[i];
        min4 = min2(min4, point4);
        max4 = max2(max4, point4);
      }
    }
    for (var i = 0, len = points.length; i < len; i += 1) {
      var point4 = points[i];
      if (i === 0 && !isLoop) {
        cp0 = point4;
      } else if (i === len - 1 && !isLoop) {
        cp1 = point4;
        cps.push(cp0);
        cps.push(cp1);
      } else {
        var prevIdx = [i ? i - 1 : len - 1, i - 1][isLoop ? 0 : 1];
        prevPoint = points[prevIdx];
        nextPoint = points[isLoop ? (i + 1) % len : i + 1];
        var v = [0, 0];
        v = sub(nextPoint, prevPoint);
        v = scale3(v, smooth2);
        var d0 = distance4(point4, prevPoint);
        var d1 = distance4(point4, nextPoint);
        var sum = d0 + d1;
        if (sum !== 0) {
          d0 /= sum;
          d1 /= sum;
        }
        var v1 = scale3(v, -d0);
        var v2 = scale3(v, d1);
        cp1 = add4(point4, v1);
        nextCp0 = add4(point4, v2);
        nextCp0 = min2(nextCp0, max2(nextPoint, point4));
        nextCp0 = max2(nextCp0, min2(nextPoint, point4));
        v1 = sub(nextCp0, point4);
        v1 = scale3(v1, -d0 / d1);
        cp1 = add4(point4, v1);
        cp1 = min2(cp1, max2(prevPoint, point4));
        cp1 = max2(cp1, min2(prevPoint, point4));
        v2 = sub(point4, cp1);
        v2 = scale3(v2, d1 / d0);
        nextCp0 = add4(point4, v2);
        if (hasConstraint) {
          cp1 = max2(cp1, min4);
          cp1 = min2(cp1, max4);
          nextCp0 = max2(nextCp0, min4);
          nextCp0 = min2(nextCp0, max4);
        }
        cps.push(cp0);
        cps.push(cp1);
        cp0 = nextCp0;
      }
    }
    if (isLoop) {
      cps.push(cps.shift());
    }
    return cps;
  }
  function catmullRom2Bezier(crp, z, constraint) {
    var _a2;
    if (z === void 0) {
      z = false;
    }
    if (constraint === void 0) {
      constraint = [
        [0, 0],
        [1, 1]
      ];
    }
    var isLoop = !!z;
    var pointList = [];
    for (var i = 0, l = crp.length; i < l; i += 2) {
      pointList.push([crp[i], crp[i + 1]]);
    }
    var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
    var len = pointList.length;
    var d1 = [];
    var cp1;
    var cp2;
    var p;
    for (var i = 0; i < len - 1; i += 1) {
      cp1 = controlPointList[i * 2];
      cp2 = controlPointList[i * 2 + 1];
      p = pointList[i + 1];
      d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
    }
    if (isLoop) {
      cp1 = controlPointList[len];
      cp2 = controlPointList[len + 1];
      _a2 = __read(pointList, 1), p = _a2[0];
      d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
    }
    return d1;
  }

  // node_modules/@antv/component/esm/util/primitive.js
  var PRIMILTIVE_ATTRIBUTES = [
    "$el",
    "cx",
    "cy",
    "d",
    "dx",
    "dy",
    "fill",
    "fillOpacity",
    "filter",
    "fontFamily",
    "fontSize",
    "fontStyle",
    "fontVariant",
    "fontWeight",
    "height",
    "img",
    "increasedLineWidthForHitTesting",
    "innerHTML",
    "isBillboard",
    "billboardRotation",
    "isSizeAttenuation",
    "isClosed",
    "isOverflowing",
    "leading",
    "letterSpacing",
    "lineDash",
    "lineHeight",
    "lineWidth",
    "markerEnd",
    "markerEndOffset",
    "markerMid",
    "markerStart",
    "markerStartOffset",
    "maxLines",
    "metrics",
    "miterLimit",
    "offsetX",
    "offsetY",
    "opacity",
    "path",
    "points",
    "r",
    "radius",
    "rx",
    "ry",
    "shadowColor",
    "src",
    "stroke",
    "strokeOpacity",
    "text",
    "textAlign",
    "textBaseline",
    "textDecorationColor",
    "textDecorationLine",
    "textDecorationStyle",
    "textOverflow",
    "textPath",
    "textPathSide",
    "textPathStartOffset",
    "transform",
    "transformOrigin",
    "visibility",
    "width",
    "wordWrap",
    "wordWrapWidth",
    "x",
    "x1",
    "x2",
    "y",
    "y1",
    "y2",
    "z1",
    "z2",
    "zIndex"
  ];
  function isPrimitiveAttribute(key) {
    return PRIMILTIVE_ATTRIBUTES.includes(key);
  }
  function getPrimitiveAttributes(attributes) {
    var object = {};
    for (var key in attributes) {
      if (isPrimitiveAttribute(key))
        object[key] = attributes[key];
    }
    return object;
  }

  // node_modules/@antv/component/esm/util/sampling.js
  function sampling(data2, size2) {
    if (data2.length <= size2)
      return data2;
    var step2 = Math.floor(data2.length / size2);
    var result = [];
    for (var i = 0; i < data2.length; i += step2) {
      result.push(data2[i]);
    }
    return result;
  }

  // node_modules/@antv/component/esm/util/scale-to-pixel.js
  function scaleToPixel(el, size2, applyScale) {
    if (applyScale === void 0) {
      applyScale = false;
    }
    var _a2 = el.getBBox(), width2 = _a2.width, height = _a2.height;
    var scale4 = size2 / Math.max(width2, height);
    if (applyScale) {
      el.style.transform = "scale(".concat(scale4, ")");
    }
    return scale4;
  }

  // node_modules/@antv/component/esm/util/selection.js
  init_tslib_es6();
  var import_util122 = __toESM(require_lib());

  // node_modules/@antv/component/esm/util/group.js
  function group(array, keyFunc) {
    var grouped = /* @__PURE__ */ new Map();
    array.forEach(function(item) {
      var key = keyFunc(item);
      if (!grouped.has(key)) {
        grouped.set(key, []);
      }
      grouped.get(key).push(item);
    });
    return grouped;
  }

  // node_modules/@antv/component/esm/util/selection.js
  function error(msg) {
    throw new Error(msg);
  }
  var Selection = (
    /** @class */
    (function() {
      function Selection2(elements, data2, parent, document2, selections, transitions, updateElements) {
        if (elements === void 0) {
          elements = null;
        }
        if (data2 === void 0) {
          data2 = null;
        }
        if (parent === void 0) {
          parent = null;
        }
        if (document2 === void 0) {
          document2 = null;
        }
        if (selections === void 0) {
          selections = [null, null, null, null, null];
        }
        if (transitions === void 0) {
          transitions = [];
        }
        if (updateElements === void 0) {
          updateElements = [];
        }
        _Selection_instances.add(this);
        this._elements = Array.from(elements);
        this._data = data2;
        this._parent = parent;
        this._document = document2;
        this._enter = selections[0];
        this._update = selections[1];
        this._exit = selections[2];
        this._merge = selections[3];
        this._split = selections[4];
        this._transitions = transitions;
        this._facetElements = updateElements;
      }
      Selection2.prototype.selectAll = function(selector) {
        var elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
        return new _a2(elements, null, this._elements[0], this._document);
      };
      Selection2.prototype.selectFacetAll = function(selector) {
        var elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
        return new _a2(this._elements, null, this._parent, this._document, void 0, void 0, elements);
      };
      Selection2.prototype.select = function(selector) {
        var element = typeof selector === "string" ? this._parent.querySelectorAll(selector)[0] || null : selector;
        return new _a2([element], null, element, this._document);
      };
      Selection2.prototype.append = function(node) {
        var _this2 = this;
        var callback = typeof node === "function" ? node : function() {
          return _this2.createElement(node);
        };
        var elements = [];
        if (this._data !== null) {
          for (var i = 0; i < this._data.length; i++) {
            var d2 = this._data[i];
            var _b = __read(Array.isArray(d2) ? d2 : [d2, null], 2), datum = _b[0], from = _b[1];
            var newElement = callback(datum, i);
            newElement.__data__ = datum;
            if (from !== null)
              newElement.__fromElements__ = from;
            this._parent.appendChild(newElement);
            elements.push(newElement);
          }
          return new _a2(elements, null, this._parent, this._document);
        }
        for (var i = 0; i < this._elements.length; i++) {
          var element = this._elements[i];
          var datum = element.__data__;
          var newElement = callback(datum, i);
          element.appendChild(newElement);
          elements.push(newElement);
        }
        return new _a2(elements, null, elements[0], this._document);
      };
      Selection2.prototype.maybeAppend = function(id3, node) {
        var element = __classPrivateFieldGet(this, _Selection_instances, "m", _Selection_maybeAppend).call(this, id3[0] === "#" ? id3 : "#".concat(id3), node);
        element.attr("id", id3);
        return element;
      };
      Selection2.prototype.maybeAppendByClassName = function(className, node) {
        var cls = className.toString();
        var element = __classPrivateFieldGet(this, _Selection_instances, "m", _Selection_maybeAppend).call(this, cls[0] === "." ? cls : ".".concat(cls), node);
        element.attr("className", cls);
        return element;
      };
      Selection2.prototype.maybeAppendByName = function(name, node) {
        var element = __classPrivateFieldGet(this, _Selection_instances, "m", _Selection_maybeAppend).call(this, '[name="'.concat(name, '"]'), node);
        element.attr("name", name);
        return element;
      };
      Selection2.prototype.data = function(data2, id3, groupId) {
        var e_1, _b;
        if (id3 === void 0) {
          id3 = function(d2) {
            return d2;
          };
        }
        if (groupId === void 0) {
          groupId = function() {
            return null;
          };
        }
        var enter = [];
        var update = [];
        var exit = new Set(this._elements);
        var merge = [];
        var split = /* @__PURE__ */ new Set();
        var keyElement = new Map(this._elements.map(function(d2, i2) {
          return [id3(d2.__data__, i2), d2];
        }));
        var keyUpdateElement = new Map(this._facetElements.map(function(d2, i2) {
          return [id3(d2.__data__, i2), d2];
        }));
        var groupKeyElements = group(this._elements, function(d2) {
          return groupId(d2.__data__);
        });
        for (var i = 0; i < data2.length; i++) {
          var datum = data2[i];
          var key = id3(datum, i);
          var groupKey = groupId(datum, i);
          if (keyElement.has(key)) {
            var element = keyElement.get(key);
            element.__data__ = datum;
            element.__facet__ = false;
            update.push(element);
            exit.delete(element);
            keyElement.delete(key);
          } else if (keyUpdateElement.has(key)) {
            var element = keyUpdateElement.get(key);
            element.__data__ = datum;
            element.__facet__ = true;
            update.push(element);
            keyUpdateElement.delete(key);
          } else if (groupKeyElements.has(key)) {
            var group_2 = groupKeyElements.get(key);
            merge.push([datum, group_2]);
            try {
              for (var group_1 = (e_1 = void 0, __values(group_2)), group_1_1 = group_1.next(); !group_1_1.done; group_1_1 = group_1.next()) {
                var element = group_1_1.value;
                exit.delete(element);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (group_1_1 && !group_1_1.done && (_b = group_1.return)) _b.call(group_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
            groupKeyElements.delete(key);
          } else if (keyElement.has(groupKey)) {
            var element = keyElement.get(groupKey);
            if (element.__toData__)
              element.__toData__.push(datum);
            else
              element.__toData__ = [datum];
            split.add(element);
            exit.delete(element);
          } else {
            enter.push(datum);
          }
        }
        var S2 = [
          new _a2([], enter, this._parent, this._document),
          new _a2(update, null, this._parent, this._document),
          new _a2(exit, null, this._parent, this._document),
          new _a2([], merge, this._parent, this._document),
          new _a2(split, null, this._parent, this._document)
        ];
        return new _a2(this._elements, null, this._parent, this._document, S2);
      };
      Selection2.prototype.merge = function(other) {
        var elements = __spreadArray(__spreadArray([], __read(this._elements), false), __read(other._elements), false);
        var transitions = __spreadArray(__spreadArray([], __read(this._transitions), false), __read(other._transitions), false);
        return new _a2(elements, null, this._parent, this._document, void 0, transitions);
      };
      Selection2.prototype.createElement = function(type) {
        if (this._document) {
          return this._document.createElement(type, {});
        }
        var Ctor = _a2.registry[type];
        if (Ctor)
          return new Ctor();
        return error("Unknown node type: ".concat(type));
      };
      Selection2.prototype.join = function(enter, update, exit, merge, split) {
        if (enter === void 0) {
          enter = function(d2) {
            return d2;
          };
        }
        if (update === void 0) {
          update = function(d2) {
            return d2;
          };
        }
        if (exit === void 0) {
          exit = function(d2) {
            return d2.remove();
          };
        }
        if (merge === void 0) {
          merge = function(d2) {
            return d2;
          };
        }
        if (split === void 0) {
          split = function(d2) {
            return d2.remove();
          };
        }
        var newEnter = enter(this._enter);
        var newUpdate = update(this._update);
        var newExit = exit(this._exit);
        var newMerge = merge(this._merge);
        var newSplit = split(this._split);
        return newUpdate.merge(newEnter).merge(newExit).merge(newMerge).merge(newSplit);
      };
      Selection2.prototype.remove = function() {
        var _loop_1 = function(i2) {
          var element = this_1._elements[i2];
          var transition2 = this_1._transitions[i2];
          if (transition2) {
            transition2.then(function() {
              return element.remove();
            });
          } else {
            element.remove();
          }
        };
        var this_1 = this;
        for (var i = 0; i < this._elements.length; i++) {
          _loop_1(i);
        }
        return new _a2([], null, this._parent, this._document, void 0, this._transitions);
      };
      Selection2.prototype.each = function(callback) {
        for (var i = 0; i < this._elements.length; i++) {
          var element = this._elements[i];
          var datum = element.__data__;
          callback.call(element, datum, i);
        }
        return this;
      };
      Selection2.prototype.attr = function(key, value) {
        var callback = typeof value !== "function" ? function() {
          return value;
        } : value;
        return this.each(function(d2, i) {
          if (value !== void 0)
            this[key] = callback.call(this, d2, i);
        });
      };
      Selection2.prototype.style = function(key, value, callable) {
        if (callable === void 0) {
          callable = true;
        }
        var callback = typeof value !== "function" || !callable ? function() {
          return value;
        } : value;
        return this.each(function(d2, i) {
          if (value !== void 0)
            this.style[key] = callback.call(this, d2, i);
        });
      };
      Selection2.prototype.styles = function(style, callable) {
        if (style === void 0) {
          style = {};
        }
        if (callable === void 0) {
          callable = true;
        }
        return this.each(function(d2, i) {
          var _this2 = this;
          Object.entries(style).forEach(function(_b) {
            var _c = __read(_b, 2), key = _c[0], value = _c[1];
            var callback = typeof value !== "function" || !callable ? function() {
              return value;
            } : value;
            if (value !== void 0)
              _this2.attr(key, callback.call(_this2, d2, i));
          });
        });
      };
      Selection2.prototype.update = function(option, callable) {
        if (callable === void 0) {
          callable = true;
        }
        var callback = typeof option !== "function" || !callable ? function() {
          return option;
        } : option;
        return this.each(function(d2, i) {
          if (option && this.update)
            this.update(callback.call(this, d2, i));
        });
      };
      Selection2.prototype.maybeUpdate = function(option, callable) {
        if (callable === void 0) {
          callable = true;
        }
        var callback = typeof option !== "function" || !callable ? function() {
          return option;
        } : option;
        return this.each(function(d2, i) {
          if (option && this.update)
            this.update(callback.call(this, d2, i));
        });
      };
      Selection2.prototype.transition = function(callback) {
        var T = this._transitions;
        var newTransitions = new Array(this._elements.length);
        this.each(function(d2, i) {
          newTransitions[i] = callback.call(this, d2, i);
        });
        this._transitions = (0, import_util122.flatten)(newTransitions);
        return this;
      };
      Selection2.prototype.on = function(event, handler) {
        this.each(function() {
          this.addEventListener(event, handler);
        });
        return this;
      };
      Selection2.prototype.call = function(callback) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        callback.call.apply(callback, __spreadArray([this._parent, this], __read(args), false));
        return this;
      };
      Selection2.prototype.node = function() {
        return this._elements[0];
      };
      Selection2.prototype.nodes = function() {
        return this._elements;
      };
      Selection2.prototype.transitions = function() {
        return this._transitions.filter(function(t) {
          return !!t;
        });
      };
      Selection2.prototype.parent = function() {
        return this._parent;
      };
      var _Selection_instances, _a2, _Selection_maybeAppend;
      _a2 = Selection2, _Selection_instances = /* @__PURE__ */ new WeakSet(), _Selection_maybeAppend = function _Selection_maybeAppend2(selector, node) {
        var element = this._elements[0];
        var child = element.querySelector(selector);
        if (child)
          return new _a2([child], null, this._parent, this._document);
        var newChild = typeof node === "string" ? this.createElement(node) : node();
        element.appendChild(newChild);
        return new _a2([newChild], null, this._parent, this._document);
      };
      Selection2.registry = {
        g: Group,
        rect: Rect,
        circle: Circle,
        path: Path,
        text: Text2,
        ellipse: Ellipse,
        image: Image2,
        line: Line,
        polygon: Polygon,
        polyline: Polyline,
        html: HTML
      };
      return Selection2;
    })()
  );
  function select(node) {
    return new Selection([node], null, node, node.ownerDocument);
  }
  function maybeAppend(parent, selector, node) {
    if (!parent.querySelector(selector)) {
      return select(parent).append(node);
    }
    return select(parent).select(selector);
  }

  // node_modules/@antv/component/esm/util/series.js
  var import_util123 = __toESM(require_lib());
  function parseSeriesAttr(series) {
    if ((0, import_util123.isNumber)(series)) {
      return [series, series, series, series];
    }
    if ((0, import_util123.isArray)(series)) {
      var len = series.length;
      if (len === 1) {
        return [series[0], series[0], series[0], series[0]];
      }
      if (len === 2) {
        return [series[0], series[1], series[0], series[1]];
      }
      if (len === 3) {
        return [series[0], series[1], series[2], series[1]];
      }
      if (len === 4) {
        return series;
      }
    }
    return [0, 0, 0, 0];
  }

  // node_modules/@antv/component/esm/util/shape.js
  init_tslib_es6();
  function getLocalBBox(shape) {
    var _a2 = shape.getLocalBounds(), min4 = _a2.min, max4 = _a2.max;
    var _b = __read([min4, max4], 2), _c = __read(_b[0], 2), x1 = _c[0], y1 = _c[1], _d = __read(_b[1], 2), x22 = _d[0], y22 = _d[1];
    return { x: x1, y: y1, width: x22 - x1, height: y22 - y1, left: x1, bottom: y22, top: y1, right: x22 };
  }
  function isHorizontal2(p1, p2) {
    var _a2 = __read(p1, 2), x1 = _a2[0], y1 = _a2[1];
    var _b = __read(p2, 2), x22 = _b[0], y22 = _b[1];
    return x1 !== x22 && y1 === y22;
  }
  function copyAttributes(target, source) {
    var e_1, _a2;
    var attributes = source.attributes;
    try {
      for (var _b = __values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
        if (key !== "id" && key !== "className")
          target.attr(key, value);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
  }

  // node_modules/@antv/component/esm/util/string.js
  function toUppercaseFirstLetter(string) {
    return string.toString().charAt(0).toUpperCase() + string.toString().slice(1);
  }
  function toLowercaseFirstLetter(string) {
    return string.toString().charAt(0).toLowerCase() + string.toString().slice(1);
  }
  function addPrefix2(string, prefix) {
    return "".concat(prefix).concat(toUppercaseFirstLetter(string));
  }
  function removePrefix2(string, prefix, lowercaseFirstLetter) {
    var _a2;
    if (lowercaseFirstLetter === void 0) {
      lowercaseFirstLetter = true;
    }
    var inferPrefix = prefix || ((_a2 = string.match(/^([a-z][a-z0-9]+)/)) === null || _a2 === void 0 ? void 0 : _a2[0]) || "";
    var withoutPrefix = string.replace(new RegExp("^(".concat(inferPrefix, ")")), "");
    return lowercaseFirstLetter ? toLowercaseFirstLetter(withoutPrefix) : withoutPrefix;
  }

  // node_modules/@antv/component/esm/util/style.js
  init_tslib_es6();
  function applyStyleSheet(element, style) {
    Object.entries(style).forEach(function(_a2) {
      var _b = __read(_a2, 2), selector = _b[0], styleString = _b[1];
      __spreadArray([element], __read(element.querySelectorAll(selector)), false).filter(function(el) {
        return el.matches(selector);
      }).forEach(function(target) {
        if (!target)
          return;
        var temp = target;
        temp.style.cssText += Object.entries(styleString).reduce(function(total, currVal) {
          return "".concat(total).concat(currVal.join(":"), ";");
        }, "");
      });
    });
  }
  var startsWith2 = function(text, prefix) {
    if (!(text === null || text === void 0 ? void 0 : text.startsWith(prefix)))
      return false;
    var nextChart = text[prefix.length];
    return nextChart >= "A" && nextChart <= "Z";
  };
  function subStyleProps2(style, prefix, invert) {
    if (invert === void 0) {
      invert = false;
    }
    var result = {};
    Object.entries(style).forEach(function(_a2) {
      var _b = __read(_a2, 2), key = _b[0], value = _b[1];
      if (key === "className" || key === "class") {
      } else if (startsWith2(key, "show") && startsWith2(removePrefix2(key, "show"), prefix) !== invert) {
        if (key === addPrefix2(prefix, "show"))
          result[key] = value;
        else
          result[key.replace(new RegExp(toUppercaseFirstLetter(prefix)), "")] = value;
      } else if (!startsWith2(key, "show") && startsWith2(key, prefix) !== invert) {
        var name_1 = removePrefix2(key, prefix);
        if (name_1 === "filter" && typeof value === "function") {
        } else
          result[name_1] = value;
      }
    });
    return result;
  }
  function superStyleProps(style, prefix) {
    return Object.entries(style).reduce(function(acc, _a2) {
      var _b = __read(_a2, 2), key = _b[0], value = _b[1];
      if (key.startsWith("show"))
        acc["show".concat(prefix).concat(key.slice(4))] = value;
      else
        acc["".concat(prefix).concat(toUppercaseFirstLetter(key))] = value;
      return acc;
    }, {});
  }
  function splitStyle(style, ignoreStyleDict) {
    if (ignoreStyleDict === void 0) {
      ignoreStyleDict = ["x", "y", "class", "className"];
    }
    var groupStyleDict = [
      "transform",
      "transformOrigin",
      "anchor",
      "visibility",
      "pointerEvents",
      "zIndex",
      "cursor",
      "clipPath",
      "clipPathTargets",
      "offsetPath",
      "offsetPathTargets",
      "offsetDistance",
      "draggable",
      "droppable"
    ];
    var output = {};
    var groupStyle = {};
    Object.entries(style).forEach(function(_a2) {
      var _b = __read(_a2, 2), key = _b[0], val = _b[1];
      if (ignoreStyleDict.includes(key)) {
      } else if (groupStyleDict.indexOf(key) !== -1)
        groupStyle[key] = val;
      else
        output[key] = val;
    });
    return [output, groupStyle];
  }

  // node_modules/@antv/component/esm/util/time.js
  function formatTime(date, mask) {
    var timeMap = {
      YYYY: date.getFullYear(),
      MM: date.getMonth() + 1,
      DD: date.getDate(),
      HH: date.getHours(),
      mm: date.getMinutes(),
      ss: date.getSeconds()
    };
    var strftime = mask;
    Object.keys(timeMap).forEach(function(key) {
      var val = timeMap[key];
      strftime = strftime.replace(key, key === "YYYY" ? "".concat(val) : "".concat(val).padStart(2, "0"));
    });
    return strftime;
  }

  // node_modules/@antv/component/esm/util/transform.js
  init_tslib_es6();
  function getTranslate(node, x3, y3) {
    var _a2 = node.getBBox(), width2 = _a2.width, height = _a2.height;
    var _b = __read([x3, y3].map(function(v, i) {
      var _a3;
      return v.includes("%") ? parseFloat(((_a3 = v.match(/[+-]?([0-9]*[.])?[0-9]+/)) === null || _a3 === void 0 ? void 0 : _a3[0]) || "0") / 100 * (i === 0 ? width2 : height) : v;
    }), 2), tx = _b[0], ty = _b[1];
    return [tx, ty];
  }
  function percentTransform(node, val) {
    if (!val)
      return;
    try {
      var reg = /translate\(([+-]*[\d]+[%]*),[ ]*([+-]*[\d]+[%]*)\)/g;
      var computedVal = val.replace(reg, function(match2, x3, y3) {
        return "translate(".concat(getTranslate(node, x3, y3), ")");
      });
      node.attr("transform", computedVal);
    } catch (e) {
    }
  }

  // node_modules/@antv/component/esm/util/transpose.js
  function transpose(m2) {
    var _a2;
    return ((_a2 = m2[0]) === null || _a2 === void 0 ? void 0 : _a2.map(function(x3, i) {
      return m2.map(function(x4) {
        return x4[i];
      });
    })) || [];
  }

  // node_modules/@antv/component/esm/util/replace-children.js
  init_tslib_es6();
  var replaceChildren = function(el, content) {
    if (content == null) {
      el.innerHTML = "";
      return;
    }
    if (el.replaceChildren) {
      if (Array.isArray(content)) {
        el.replaceChildren.apply(el, __spreadArray([], __read(content), false));
      } else {
        el.replaceChildren(content);
      }
    } else {
      el.innerHTML = "";
      if (Array.isArray(content)) {
        content.forEach(function(child) {
          return el.appendChild(child);
        });
      } else {
        el.appendChild(content);
      }
    }
  };

  // node_modules/@antv/component/esm/util/pase-position.js
  function parsePosition(position2) {
    if (!/\S+-\S+/g.test(position2))
      return position2.length > 2 ? [position2[0]] : position2.split("");
    return position2.split("-").map(function(str) {
      return str[0];
    });
  }

  // node_modules/@antv/component/esm/util/parse-height-from-html.js
  init_tslib_es6();
  var parseHeightFromHTML = function(html) {
    var parser2 = new DOMParser();
    var doc = parser2.parseFromString(html, "text/html");
    var el = doc.body.firstElementChild;
    console.log(el === null || el === void 0 ? void 0 : el.getClientRects(), 11);
    if (!el)
      return 0;
    var style = el.getAttribute("style") || "";
    var rules = Object.fromEntries(style.split(";").map(function(r) {
      return r.trim();
    }).filter(function(r) {
      return r.includes(":");
    }).map(function(r) {
      var _a2 = __read(r.split(":").map(function(s) {
        return s.trim();
      }), 2), key = _a2[0], value = _a2[1];
      return [key.toLowerCase(), value];
    }));
    var parsePx = function(v) {
      if (!v)
        return 0;
      var match3 = v.match(/([\d.]+)px/);
      return match3 ? parseFloat(match3[1]) : 0;
    };
    if (rules.height) {
      return parsePx(rules.height);
    }
    var fontSize = parsePx(rules["font-size"]) || 16;
    var lineHeight = rules["line-height"];
    var baseHeight;
    if (!lineHeight || lineHeight === "normal") {
      baseHeight = 1.2 * fontSize;
    } else if (lineHeight.endsWith("px")) {
      baseHeight = parsePx(lineHeight);
    } else if (/^[\d.]+$/.test(lineHeight)) {
      baseHeight = parseFloat(lineHeight) * fontSize;
    } else {
      baseHeight = fontSize;
    }
    var paddingTop = parsePx(rules["padding-top"]);
    var paddingBottom = parsePx(rules["padding-bottom"]);
    if (rules.padding) {
      var parts = rules.padding.split(/\s+/).map(parsePx);
      if (parts.length === 1) {
        paddingTop = parts[0];
        paddingBottom = parts[0];
      } else if (parts.length === 2) {
        paddingTop = parts[0];
        paddingBottom = parts[0];
      } else if (parts.length === 3) {
        paddingTop = parts[0];
        paddingBottom = parts[2];
      } else if (parts.length === 4) {
        paddingTop = parts[0];
        paddingBottom = parts[2];
      }
    }
    var borderTop = parsePx(rules["border-top-width"]);
    var borderBottom = parsePx(rules["border-bottom-width"]);
    if (rules.border) {
      var match2 = rules.border.match(/([\d.]+)px/);
      if (match2) {
        borderTop = parseFloat(match2[1]);
        borderBottom = parseFloat(match2[1]);
      }
    }
    if (rules["border-width"]) {
      var parts = rules["border-width"].split(/\s+/).map(parsePx);
      if (parts.length === 1) {
        borderTop = parts[0];
        borderBottom = parts[0];
      } else if (parts.length === 2) {
        borderTop = parts[0];
        borderBottom = parts[0];
      } else if (parts.length === 3) {
        borderTop = parts[0];
        borderBottom = parts[2];
      } else if (parts.length === 4) {
        borderTop = parts[0];
        borderBottom = parts[2];
      }
    }
    return baseHeight + paddingTop + paddingBottom + borderTop + borderBottom;
  };

  // node_modules/@antv/component/esm/core/component.js
  function applyVisibility() {
    visibility(this, this.attributes.visibility !== "hidden");
  }
  var Component = (
    /** @class */
    (function(_super) {
      __extends(Component2, _super);
      function Component2(options, defaultStyleProps) {
        if (defaultStyleProps === void 0) {
          defaultStyleProps = {};
        }
        var _this2 = _super.call(this, deepAssign({}, { style: defaultStyleProps }, options)) || this;
        _this2.initialized = false;
        _this2._defaultOptions = defaultStyleProps;
        return _this2;
      }
      Object.defineProperty(Component2.prototype, "offscreenGroup", {
        get: function() {
          if (!this._offscreen)
            this._offscreen = createOffscreenGroup(this);
          return this._offscreen;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Component2.prototype, "defaultOptions", {
        get: function() {
          return this._defaultOptions;
        },
        enumerable: false,
        configurable: true
      });
      Component2.prototype.connectedCallback = function() {
        this.render(this.attributes, this);
        this.bindEvents(this.attributes, this);
        this.initialized = true;
      };
      Component2.prototype.disconnectedCallback = function() {
        var _a2;
        (_a2 = this._offscreen) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      };
      Component2.prototype.attributeChangedCallback = function(name) {
        if (name === "visibility") {
          applyVisibility.call(this);
        }
      };
      Component2.prototype.update = function(attr2, animate2) {
        var _a2;
        this.attr(deepAssign({}, this.attributes, attr2 || {}));
        return (_a2 = this.render) === null || _a2 === void 0 ? void 0 : _a2.call(this, this.attributes, this, animate2);
      };
      Component2.prototype.clear = function() {
        this.removeChildren();
      };
      Component2.prototype.bindEvents = function(attributes, container) {
      };
      Component2.prototype.getSubShapeStyle = function(attributes) {
        var x3 = attributes.x, y3 = attributes.y, transform = attributes.transform, transformOrigin = attributes.transformOrigin, _class = attributes.class, className = attributes.className, zIndex = attributes.zIndex, style = __rest(attributes, ["x", "y", "transform", "transformOrigin", "class", "className", "zIndex"]);
        return style;
      };
      return Component2;
    })(CustomElement)
  );

  // node_modules/@antv/component/esm/ui/marker/index.js
  init_tslib_es6();
  var import_util126 = __toESM(require_lib());

  // node_modules/@antv/component/esm/ui/marker/symbol.js
  var circle2 = function(x3, y3, r) {
    return [["M", x3 - r, y3], ["A", r, r, 0, 1, 0, x3 + r, y3], ["A", r, r, 0, 1, 0, x3 - r, y3], ["Z"]];
  };
  var point3 = circle2;
  var square = function(x3, y3, r) {
    return [["M", x3 - r, y3 - r], ["L", x3 + r, y3 - r], ["L", x3 + r, y3 + r], ["L", x3 - r, y3 + r], ["Z"]];
  };
  var diamond2 = function(x3, y3, r) {
    return [["M", x3 - r, y3], ["L", x3, y3 - r], ["L", x3 + r, y3], ["L", x3, y3 + r], ["Z"]];
  };
  var triangle2 = function(x3, y3, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x3 - r, y3 + diffY], ["L", x3, y3 - diffY], ["L", x3 + r, y3 + diffY], ["Z"]];
  };
  var triangleDown = function(x3, y3, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x3 - r, y3 - diffY], ["L", x3 + r, y3 - diffY], ["L", x3, y3 + diffY], ["Z"]];
  };
  var hexagon = function(x3, y3, r) {
    var diffX = r / 2 * Math.sqrt(3);
    return [
      ["M", x3, y3 - r],
      ["L", x3 + diffX, y3 - r / 2],
      ["L", x3 + diffX, y3 + r / 2],
      ["L", x3, y3 + r],
      ["L", x3 - diffX, y3 + r / 2],
      ["L", x3 - diffX, y3 - r / 2],
      ["Z"]
    ];
  };
  var bowtie = function(x3, y3, r) {
    var diffY = r - 1.5;
    return [["M", x3 - r, y3 - diffY], ["L", x3 + r, y3 + diffY], ["L", x3 + r, y3 - diffY], ["L", x3 - r, y3 + diffY], ["Z"]];
  };
  var line = function(x3, y3, r) {
    return [
      ["M", x3, y3 + r],
      ["L", x3, y3 - r]
    ];
  };
  var cross2 = function(x3, y3, r) {
    return [
      ["M", x3 - r, y3 - r],
      ["L", x3 + r, y3 + r],
      ["M", x3 + r, y3 - r],
      ["L", x3 - r, y3 + r]
    ];
  };
  var tick = function(x3, y3, r) {
    return [
      ["M", x3 - r / 2, y3 - r],
      ["L", x3 + r / 2, y3 - r],
      ["M", x3, y3 - r],
      ["L", x3, y3 + r],
      ["M", x3 - r / 2, y3 + r],
      ["L", x3 + r / 2, y3 + r]
    ];
  };
  var plus = function(x3, y3, r) {
    return [
      ["M", x3 - r, y3],
      ["L", x3 + r, y3],
      ["M", x3, y3 - r],
      ["L", x3, y3 + r]
    ];
  };
  var hyphen = function(x3, y3, r) {
    return [
      ["M", x3 - r, y3],
      ["L", x3 + r, y3]
    ];
  };
  var dot3 = function(x3, y3, r) {
    return [
      ["M", x3 - r, y3],
      ["L", x3 + r, y3]
    ];
  };
  var dash = dot3;
  var smooth = function(x3, y3, r) {
    return [
      ["M", x3 - r, y3],
      ["A", r / 2, r / 2, 0, 1, 1, x3, y3],
      ["A", r / 2, r / 2, 0, 1, 0, x3 + r, y3]
    ];
  };
  var hv = function(x3, y3, r) {
    return [
      ["M", x3 - r - 1, y3 - 2.5],
      ["L", x3, y3 - 2.5],
      ["L", x3, y3 + 2.5],
      ["L", x3 + r + 1, y3 + 2.5]
    ];
  };
  var vh = function(x3, y3, r) {
    return [
      ["M", x3 - r - 1, y3 + 2.5],
      ["L", x3, y3 + 2.5],
      ["L", x3, y3 - 2.5],
      ["L", x3 + r + 1, y3 - 2.5]
    ];
  };
  var hvh = function(x3, y3, r) {
    return [
      ["M", x3 - (r + 1), y3 + 2.5],
      ["L", x3 - r / 2, y3 + 2.5],
      ["L", x3 - r / 2, y3 - 2.5],
      ["L", x3 + r / 2, y3 - 2.5],
      ["L", x3 + r / 2, y3 + 2.5],
      ["L", x3 + r + 1, y3 + 2.5]
    ];
  };
  function vhv(x3, y3) {
    return [
      ["M", x3 - 5, y3 + 2.5],
      ["L", x3 - 5, y3],
      ["L", x3, y3],
      ["L", x3, y3 - 3],
      ["L", x3, y3 + 3],
      ["L", x3 + 6.5, y3 + 3]
    ];
  }
  var button = function(x3, y3, r) {
    return [["M", x3 - r, y3 - r], ["L", x3 + r, y3], ["L", x3 - r, y3 + r], ["Z"]];
  };
  var focus = function(x3, y3, r) {
    var outerRadius = r;
    var innerRadius = r * 0.2;
    var crossLength = r * 0.7;
    return [
      // 外圆
      ["M", x3 - outerRadius, y3],
      ["A", outerRadius, outerRadius, 0, 1, 0, x3 + outerRadius, y3],
      ["A", outerRadius, outerRadius, 0, 1, 0, x3 - outerRadius, y3],
      ["Z"],
      // 水平十字线 (简单线条)
      ["M", x3 - crossLength, y3],
      ["L", x3 - innerRadius, y3],
      ["M", x3 + innerRadius, y3],
      ["L", x3 + crossLength, y3],
      // 垂直十字线 (简单线条)
      ["M", x3, y3 - crossLength],
      ["L", x3, y3 - innerRadius],
      ["M", x3, y3 + innerRadius],
      ["L", x3, y3 + crossLength]
    ];
  };

  // node_modules/@antv/component/esm/ui/marker/utils.js
  var import_util125 = __toESM(require_lib());
  function parseMarker(icon) {
    var type = "default";
    if ((0, import_util125.isObject)(icon) && icon instanceof Image)
      type = "image";
    else if ((0, import_util125.isFunction)(icon))
      type = "symbol";
    else if ((0, import_util125.isString)(icon)) {
      var dataURLsPattern = new RegExp("data:(image|text)");
      if (icon.match(dataURLsPattern)) {
        type = "base64";
      } else if (/^(https?:\/\/(([a-zA-Z0-9]+-?)+[a-zA-Z0-9]+\.)+[a-zA-Z]+)(:\d+)?(\/.*)?(\?.*)?(#.*)?$/.test(icon)) {
        type = "url";
      } else {
        type = "symbol";
      }
    }
    return type;
  }

  // node_modules/@antv/component/esm/ui/marker/index.js
  function getType(symbol) {
    var markerType = parseMarker(symbol);
    if (["base64", "url", "image"].includes(markerType)) {
      return "image";
    }
    if (symbol && markerType === "symbol") {
      return "path";
    }
    return null;
  }
  var Marker = (
    /** @class */
    (function(_super) {
      __extends(Marker2, _super);
      function Marker2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Marker2.prototype.render = function(attributes, container) {
        var _a2 = attributes.x, x3 = _a2 === void 0 ? 0 : _a2, _b = attributes.y, y3 = _b === void 0 ? 0 : _b;
        var _c = this.getSubShapeStyle(attributes), symbol = _c.symbol, _d = _c.size, size2 = _d === void 0 ? 16 : _d, style = __rest(_c, ["symbol", "size"]);
        var type = getType(symbol);
        ifShow(!!type, select(container), function(group2) {
          group2.maybeAppendByClassName("marker", type).attr("className", "marker ".concat(type, "-marker")).call(function(selection) {
            if (type === "image") {
              var r = size2 * 2;
              selection.styles({
                img: symbol,
                width: r,
                height: r,
                x: x3 - size2,
                y: y3 - size2
              });
            } else {
              var r = size2 / 2;
              var symbolFn = (0, import_util126.isFunction)(symbol) ? symbol : Marker2.getSymbol(symbol);
              selection.styles(__assign({ d: symbolFn === null || symbolFn === void 0 ? void 0 : symbolFn(x3, y3, r) }, style));
            }
          });
        });
      };
      Marker2.MARKER_SYMBOL_MAP = /* @__PURE__ */ new Map();
      Marker2.registerSymbol = function(type, symbol) {
        Marker2.MARKER_SYMBOL_MAP.set(type, symbol);
      };
      Marker2.getSymbol = function(type) {
        return Marker2.MARKER_SYMBOL_MAP.get(type);
      };
      Marker2.getSymbols = function() {
        return Array.from(Marker2.MARKER_SYMBOL_MAP.keys());
      };
      return Marker2;
    })(Component)
  );
  Marker.registerSymbol("cross", cross2);
  Marker.registerSymbol("hyphen", hyphen);
  Marker.registerSymbol("line", line);
  Marker.registerSymbol("plus", plus);
  Marker.registerSymbol("tick", tick);
  Marker.registerSymbol("circle", circle2);
  Marker.registerSymbol("point", point3);
  Marker.registerSymbol("bowtie", bowtie);
  Marker.registerSymbol("hexagon", hexagon);
  Marker.registerSymbol("square", square);
  Marker.registerSymbol("diamond", diamond2);
  Marker.registerSymbol("triangle", triangle2);
  Marker.registerSymbol("triangle-down", triangleDown);
  Marker.registerSymbol("line", line);
  Marker.registerSymbol("dot", dot3);
  Marker.registerSymbol("dash", dash);
  Marker.registerSymbol("smooth", smooth);
  Marker.registerSymbol("hv", hv);
  Marker.registerSymbol("vh", vh);
  Marker.registerSymbol("hvh", hvh);
  Marker.registerSymbol("vhv", vhv);
  Marker.registerSymbol("focus", focus);

  // node_modules/@antv/component/esm/ui/sparkline/index.js
  init_tslib_es6();

  // node_modules/@antv/scale/esm/utils/compose.js
  function compose(fn, ...rest) {
    return rest.reduce((pre, cur) => (x3) => pre(cur(x3)), fn);
  }

  // node_modules/@antv/scale/esm/utils/normalize.js
  function createNormalize(a2, b) {
    return b - a2 ? (t) => (t - a2) / (b - a2) : (_2) => 0.5;
  }

  // node_modules/@antv/scale/esm/utils/clamp.js
  function createClamp(a2, b) {
    const lo = b < a2 ? b : a2;
    const hi = a2 > b ? a2 : b;
    return (x3) => Math.min(Math.max(lo, x3), hi);
  }

  // node_modules/@antv/scale/esm/utils/bisect.js
  function bisect(array, x3, lo, hi, getter) {
    let i = lo || 0;
    let j = hi || array.length;
    const get9 = getter || ((x4) => x4);
    while (i < j) {
      const mid = Math.floor((i + j) / 2);
      if (get9(array[mid]) > x3) {
        j = mid;
      } else {
        i = mid + 1;
      }
    }
    return i;
  }

  // node_modules/@antv/scale/esm/utils/ticks.js
  var e10 = Math.sqrt(50);
  var e5 = Math.sqrt(10);
  var e2 = Math.sqrt(2);
  function tickIncrement(start, stop, count) {
    const step2 = (stop - start) / Math.max(0, count);
    const power = Math.floor(Math.log(step2) / Math.LN10);
    const error2 = step2 / 10 ** power;
    if (power >= 0) {
      return (error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e2 ? 2 : 1) * 10 ** power;
    }
    return -(10 ** -power) / (error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e2 ? 2 : 1);
  }

  // node_modules/@antv/scale/esm/utils/d3-linear-nice.js
  var d3LinearNice = (min4, max4, count = 5) => {
    const d2 = [min4, max4];
    let i0 = 0;
    let i1 = d2.length - 1;
    let start = d2[i0];
    let stop = d2[i1];
    let step2;
    if (stop < start) {
      [start, stop] = [stop, start];
      [i0, i1] = [i1, i0];
    }
    step2 = tickIncrement(start, stop, count);
    if (step2 > 0) {
      start = Math.floor(start / step2) * step2;
      stop = Math.ceil(stop / step2) * step2;
      step2 = tickIncrement(start, stop, count);
    } else if (step2 < 0) {
      start = Math.ceil(start * step2) / step2;
      stop = Math.floor(stop * step2) / step2;
      step2 = tickIncrement(start, stop, count);
    }
    if (step2 > 0) {
      d2[i0] = Math.floor(start / step2) * step2;
      d2[i1] = Math.ceil(stop / step2) * step2;
    } else if (step2 < 0) {
      d2[i0] = Math.ceil(start * step2) / step2;
      d2[i1] = Math.floor(stop * step2) / step2;
    }
    return d2;
  };

  // node_modules/@antv/scale/esm/utils/is-valid.js
  var import_util128 = __toESM(require_lib());
  function isValid(x3) {
    return !(0, import_util128.isUndefined)(x3) && !(0, import_util128.isNull)(x3) && !Number.isNaN(x3);
  }

  // node_modules/@antv/scale/esm/utils/color.js
  var import_color_string = __toESM(require_color_string());
  function hue2rgb(p, q, m2) {
    let t = m2;
    if (t < 0)
      t += 1;
    if (t > 1)
      t -= 1;
    if (t < 1 / 6)
      return p + (q - p) * 6 * t;
    if (t < 1 / 2)
      return q;
    if (t < 2 / 3)
      return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  }
  function hsl2rbg(hsl2) {
    const h = hsl2[0] / 360;
    const s = hsl2[1] / 100;
    const l = hsl2[2] / 100;
    const a2 = hsl2[3];
    if (s === 0)
      return [l * 255, l * 255, l * 255, a2];
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    const r = hue2rgb(p, q, h + 1 / 3);
    const g = hue2rgb(p, q, h);
    const b = hue2rgb(p, q, h - 1 / 3);
    return [r * 255, g * 255, b * 255, a2];
  }
  function string2rbg(s) {
    const color2 = import_color_string.default.get(s);
    if (!color2)
      return null;
    const { model, value } = color2;
    if (model === "rgb")
      return value;
    if (model === "hsl")
      return hsl2rbg(value);
    return null;
  }

  // node_modules/@antv/scale/esm/utils/interpolate.js
  var createInterpolateNumber = (a2, b) => {
    return (t) => a2 * (1 - t) + b * t;
  };
  var createInterpolateColor = (a2, b) => {
    const c1 = string2rbg(a2);
    const c2 = string2rbg(b);
    if (c1 === null || c2 === null)
      return c1 ? () => a2 : () => b;
    return (t) => {
      const values2 = new Array(4);
      for (let i = 0; i < 4; i += 1) {
        const from = c1[i];
        const to = c2[i];
        values2[i] = from * (1 - t) + to * t;
      }
      const [r, g, b2, a3] = values2;
      return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b2)}, ${a3})`;
    };
  };
  var createInterpolateValue = (a2, b) => {
    if (typeof a2 === "number" && typeof b === "number")
      return createInterpolateNumber(a2, b);
    if (typeof a2 === "string" && typeof b === "string")
      return createInterpolateColor(a2, b);
    return () => a2;
  };
  var createInterpolateRound = (a2, b) => {
    const interpolateNumber = createInterpolateNumber(a2, b);
    return (t) => Math.round(interpolateNumber(t));
  };

  // node_modules/@antv/scale/esm/utils/internMap.js
  function internGet({ map, initKey }, value) {
    const key = initKey(value);
    return map.has(key) ? map.get(key) : value;
  }
  function internSet({ map, initKey }, value) {
    const key = initKey(value);
    if (map.has(key))
      return map.get(key);
    map.set(key, value);
    return value;
  }
  function internDelete({ map, initKey }, value) {
    const key = initKey(value);
    if (map.has(key)) {
      value = map.get(key);
      map.delete(key);
    }
    return value;
  }
  function keyof(value) {
    return typeof value === "object" ? value.valueOf() : value;
  }
  var InternMap = class extends Map {
    constructor(entries) {
      super();
      this.map = /* @__PURE__ */ new Map();
      this.initKey = keyof;
      if (entries !== null) {
        for (const [key, value] of entries) {
          this.set(key, value);
        }
      }
    }
    get(key) {
      return super.get(internGet({ map: this.map, initKey: this.initKey }, key));
    }
    has(key) {
      return super.has(internGet({ map: this.map, initKey: this.initKey }, key));
    }
    set(key, value) {
      return super.set(internSet({ map: this.map, initKey: this.initKey }, key), value);
    }
    delete(key) {
      return super.delete(internDelete({ map: this.map, initKey: this.initKey }, key));
    }
  };

  // node_modules/@antv/scale/esm/scales/base.js
  var import_util129 = __toESM(require_lib());
  var Base = class {
    /**
     * 构造函数，根据自定义的选项和默认选项生成当前选项
     * @param options 需要自定义配置的选项
     */
    constructor(options) {
      this.options = (0, import_util129.deepMix)({}, this.getDefaultOptions());
      this.update(options);
    }
    /**
     * 返回当前的所有选项
     * @returns 当前的所有选项
     */
    getOptions() {
      return this.options;
    }
    /**
     * 更新选项和比例尺的内部状态
     * @param updateOptions 需要更新的选项
     */
    update(updateOptions = {}) {
      this.options = (0, import_util129.deepMix)({}, this.options, updateOptions);
      this.rescale(updateOptions);
    }
    /**
     * 根据需要更新 options 和更新后的 options 更新 scale 的内部状态，
     * 在函数内部可以用 this.options 获得更新后的 options
     * @param options 需要更新的 options
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    rescale(options) {
    }
  };

  // node_modules/@antv/scale/esm/scales/ordinal.js
  var defaultUnknown = Symbol("defaultUnknown");
  function updateIndexMap(target, arr, key) {
    for (let i = 0; i < arr.length; i += 1) {
      if (!target.has(arr[i])) {
        target.set(key(arr[i]), i);
      }
    }
  }
  function mapBetweenArrByMapIndex(options) {
    const { value, from, to, mapper, notFoundReturn } = options;
    let mappedIndex = mapper.get(value);
    if (mappedIndex === void 0) {
      if (notFoundReturn !== defaultUnknown) {
        return notFoundReturn;
      }
      mappedIndex = from.push(value) - 1;
      mapper.set(value, mappedIndex);
    }
    return to[mappedIndex % to.length];
  }
  function createKey(d2) {
    if (d2 instanceof Date)
      return (d3) => `${d3}`;
    if (typeof d2 === "object")
      return (d3) => JSON.stringify(d3);
    return (d3) => d3;
  }
  var Ordinal = class _Ordinal extends Base {
    // 覆盖默认配置
    getDefaultOptions() {
      return {
        domain: [],
        range: [],
        unknown: defaultUnknown
      };
    }
    // 显示指定 options 的类型为 OrdinalOptions，从而推断出 O 的类型
    constructor(options) {
      super(options);
    }
    map(x3) {
      if (this.domainIndexMap.size === 0) {
        updateIndexMap(this.domainIndexMap, this.getDomain(), this.domainKey);
      }
      return mapBetweenArrByMapIndex({
        value: this.domainKey(x3),
        mapper: this.domainIndexMap,
        from: this.getDomain(),
        to: this.getRange(),
        notFoundReturn: this.options.unknown
      });
    }
    invert(y3) {
      if (this.rangeIndexMap.size === 0) {
        updateIndexMap(this.rangeIndexMap, this.getRange(), this.rangeKey);
      }
      return mapBetweenArrByMapIndex({
        value: this.rangeKey(y3),
        mapper: this.rangeIndexMap,
        from: this.getRange(),
        to: this.getDomain(),
        notFoundReturn: this.options.unknown
      });
    }
    // 因为 ordinal 比例尺更新内部状态的开销较大，所以按需更新
    rescale(options) {
      const [d2] = this.options.domain;
      const [r] = this.options.range;
      this.domainKey = createKey(d2);
      this.rangeKey = createKey(r);
      if (!this.rangeIndexMap) {
        this.rangeIndexMap = /* @__PURE__ */ new Map();
        this.domainIndexMap = /* @__PURE__ */ new Map();
        return;
      }
      if (!options || options.range) {
        this.rangeIndexMap.clear();
      }
      if (!options || options.domain || options.compare) {
        this.domainIndexMap.clear();
        this.sortedDomain = void 0;
      }
    }
    clone() {
      return new _Ordinal(this.options);
    }
    getRange() {
      return this.options.range;
    }
    getDomain() {
      if (this.sortedDomain)
        return this.sortedDomain;
      const { domain, compare } = this.options;
      this.sortedDomain = compare ? [...domain].sort(compare) : domain;
      return this.sortedDomain;
    }
  };

  // node_modules/@antv/scale/esm/scales/band.js
  function normalize4(array) {
    const min4 = Math.min(...array);
    return array.map((d2) => d2 / min4);
  }
  function splice3(array, n) {
    const sn = array.length;
    const diff = n - sn;
    return diff > 0 ? [...array, ...new Array(diff).fill(1)] : diff < 0 ? array.slice(0, n) : array;
  }
  function pretty(n) {
    return Math.round(n * 1e12) / 1e12;
  }
  function computeFlexBandState(options) {
    const { domain, range, paddingOuter, paddingInner, flex: F, round: round3, align } = options;
    const n = domain.length;
    const flex = splice3(F, n);
    const [start, end] = range;
    const width2 = end - start;
    const ratio = 2 / n * paddingOuter + 1 - 1 / n * paddingInner;
    const stepSum = width2 / ratio;
    const PI = stepSum * paddingInner / n;
    const bandWidthSum = stepSum - n * PI;
    const normalizedFlex = normalize4(flex);
    const flexSum = normalizedFlex.reduce((sum, value) => sum + value);
    const minBandWidth = bandWidthSum / flexSum;
    const valueBandWidth = new InternMap(domain.map((d2, i) => {
      const bandWidth = normalizedFlex[i] * minBandWidth;
      return [d2, round3 ? Math.floor(bandWidth) : bandWidth];
    }));
    const valueStep = new InternMap(domain.map((d2, i) => {
      const bandWidth = normalizedFlex[i] * minBandWidth;
      const step2 = bandWidth + PI;
      return [d2, round3 ? Math.floor(step2) : step2];
    }));
    const finalStepSum = Array.from(valueStep.values()).reduce((sum, value) => sum + value);
    const outerPaddingSum = width2 - (finalStepSum - finalStepSum / n * paddingInner);
    const offset = outerPaddingSum * align;
    const bandStart = start + offset;
    let prev = round3 ? Math.round(bandStart) : bandStart;
    const adjustedRange = new Array(n);
    for (let i = 0; i < n; i += 1) {
      adjustedRange[i] = pretty(prev);
      const value = domain[i];
      prev += valueStep.get(value);
    }
    return {
      valueBandWidth,
      valueStep,
      adjustedRange
    };
  }
  function computeBandState(options) {
    var _a2;
    const { domain } = options;
    const n = domain.length;
    if (n === 0) {
      return {
        valueBandWidth: void 0,
        valueStep: void 0,
        adjustedRange: []
      };
    }
    const hasFlex = !!((_a2 = options.flex) === null || _a2 === void 0 ? void 0 : _a2.length);
    if (hasFlex) {
      return computeFlexBandState(options);
    }
    const { range, paddingOuter, paddingInner, round: round3, align } = options;
    let step2;
    let bandWidth;
    let rangeStart = range[0];
    const rangeEnd = range[1];
    const deltaRange = rangeEnd - rangeStart;
    const outerTotal = paddingOuter * 2;
    const innerTotal = n - paddingInner;
    step2 = deltaRange / Math.max(1, outerTotal + innerTotal);
    if (round3) {
      step2 = Math.floor(step2);
    }
    rangeStart += (deltaRange - step2 * (n - paddingInner)) * align;
    bandWidth = step2 * (1 - paddingInner);
    if (round3) {
      rangeStart = Math.round(rangeStart);
      bandWidth = Math.round(bandWidth);
    }
    const adjustedRange = new Array(n).fill(0).map((_2, i) => rangeStart + i * step2);
    return {
      valueStep: step2,
      valueBandWidth: bandWidth,
      adjustedRange
    };
  }
  var Band = class _Band extends Ordinal {
    // 覆盖默认配置
    getDefaultOptions() {
      return {
        domain: [],
        range: [0, 1],
        align: 0.5,
        round: false,
        paddingInner: 0,
        paddingOuter: 0,
        padding: 0,
        unknown: defaultUnknown,
        flex: []
      };
    }
    // 显示指定 options 的类型为 OrdinalOptions，从而推断出 O 的类型
    constructor(options) {
      super(options);
    }
    clone() {
      return new _Band(this.options);
    }
    getStep(x3) {
      if (this.valueStep === void 0)
        return 1;
      if (typeof this.valueStep === "number") {
        return this.valueStep;
      }
      if (x3 === void 0)
        return Array.from(this.valueStep.values())[0];
      return this.valueStep.get(x3);
    }
    getBandWidth(x3) {
      if (this.valueBandWidth === void 0)
        return 1;
      if (typeof this.valueBandWidth === "number") {
        return this.valueBandWidth;
      }
      if (x3 === void 0)
        return Array.from(this.valueBandWidth.values())[0];
      return this.valueBandWidth.get(x3);
    }
    getRange() {
      return this.adjustedRange;
    }
    getPaddingInner() {
      const { padding, paddingInner } = this.options;
      return padding > 0 ? padding : paddingInner;
    }
    getPaddingOuter() {
      const { padding, paddingOuter } = this.options;
      return padding > 0 ? padding : paddingOuter;
    }
    rescale() {
      super.rescale();
      const { align, domain, range, round: round3, flex } = this.options;
      const { adjustedRange, valueBandWidth, valueStep } = computeBandState({
        align,
        range,
        round: round3,
        flex,
        paddingInner: this.getPaddingInner(),
        paddingOuter: this.getPaddingOuter(),
        domain
      });
      this.valueStep = valueStep;
      this.valueBandWidth = valueBandWidth;
      this.adjustedRange = adjustedRange;
    }
  };

  // node_modules/@antv/scale/esm/tick-methods/d3-ticks.js
  var d3Ticks = (begin, end, count) => {
    let n;
    let ticks;
    let start = begin;
    let stop = end;
    if (start === stop && count > 0) {
      return [start];
    }
    let step2 = tickIncrement(start, stop, count);
    if (step2 === 0 || !Number.isFinite(step2)) {
      return [];
    }
    if (step2 > 0) {
      start = Math.ceil(start / step2);
      stop = Math.floor(stop / step2);
      ticks = new Array(n = Math.ceil(stop - start + 1));
      for (let i = 0; i < n; i += 1) {
        ticks[i] = (start + i) * step2;
      }
    } else {
      step2 = -step2;
      start = Math.ceil(start * step2);
      stop = Math.floor(stop * step2);
      ticks = new Array(n = Math.ceil(stop - start + 1));
      for (let i = 0; i < n; i += 1) {
        ticks[i] = (start + i) / step2;
      }
    }
    return ticks;
  };

  // node_modules/@antv/scale/esm/scales/linear.js
  var import_util131 = __toESM(require_lib());

  // node_modules/@antv/scale/esm/scales/continuous.js
  var import_util130 = __toESM(require_lib());
  var createBiMap = (domain, range, createInterpolate) => {
    const [d0, d1] = domain;
    const [r0, r1] = range;
    let normalize5;
    let interpolate3;
    if (d0 < d1) {
      normalize5 = createNormalize(d0, d1);
      interpolate3 = createInterpolate(r0, r1);
    } else {
      normalize5 = createNormalize(d1, d0);
      interpolate3 = createInterpolate(r1, r0);
    }
    return compose(interpolate3, normalize5);
  };
  var createPolyMap = (domain, range, createInterpolate) => {
    const len = Math.min(domain.length, range.length) - 1;
    const normalizeList = new Array(len);
    const interpolateList = new Array(len);
    const reverse = domain[0] > domain[len];
    const ascendingDomain = reverse ? [...domain].reverse() : domain;
    const ascendingRange = reverse ? [...range].reverse() : range;
    for (let i = 0; i < len; i += 1) {
      normalizeList[i] = createNormalize(ascendingDomain[i], ascendingDomain[i + 1]);
      interpolateList[i] = createInterpolate(ascendingRange[i], ascendingRange[i + 1]);
    }
    return (x3) => {
      const i = bisect(domain, x3, 1, len) - 1;
      const normalize5 = normalizeList[i];
      const interpolate3 = interpolateList[i];
      return compose(interpolate3, normalize5)(x3);
    };
  };
  var choosePiecewise = (domain, range, interpolate3, shouldRound) => {
    const n = Math.min(domain.length, range.length);
    const createPiecewise = n > 2 ? createPolyMap : createBiMap;
    const createInterpolate = shouldRound ? createInterpolateRound : interpolate3;
    return createPiecewise(domain, range, createInterpolate);
  };
  var Continuous = class extends Base {
    getDefaultOptions() {
      return {
        domain: [0, 1],
        range: [0, 1],
        nice: false,
        clamp: false,
        round: false,
        interpolate: createInterpolateNumber,
        tickCount: 5
      };
    }
    /**
     * y = interpolate(normalize(clamp(transform(x))))
     */
    map(x3) {
      if (!isValid(x3))
        return this.options.unknown;
      return this.output(x3);
    }
    /**
     * x = transform(clamp(interpolate(normalize(y))))
     */
    invert(x3) {
      if (!isValid(x3))
        return this.options.unknown;
      return this.input(x3);
    }
    nice() {
      if (!this.options.nice)
        return;
      const [min4, max4, tickCount, ...rest] = this.getTickMethodOptions();
      this.options.domain = this.chooseNice()(min4, max4, tickCount, ...rest);
    }
    getTicks() {
      const { tickMethod } = this.options;
      const [min4, max4, tickCount, ...rest] = this.getTickMethodOptions();
      return tickMethod(min4, max4, tickCount, ...rest);
    }
    getTickMethodOptions() {
      const { domain, tickCount } = this.options;
      const min4 = domain[0];
      const max4 = domain[domain.length - 1];
      return [min4, max4, tickCount];
    }
    chooseNice() {
      return d3LinearNice;
    }
    rescale() {
      this.nice();
      const [transform, untransform] = this.chooseTransforms();
      this.composeOutput(transform, this.chooseClamp(transform));
      this.composeInput(transform, untransform, this.chooseClamp(untransform));
    }
    chooseClamp(transform) {
      const { clamp: shouldClamp, range } = this.options;
      const domain = this.options.domain.map(transform);
      const n = Math.min(domain.length, range.length);
      return shouldClamp ? createClamp(domain[0], domain[n - 1]) : import_util130.identity;
    }
    composeOutput(transform, clamp12) {
      const { domain, range, round: round3, interpolate: interpolate3 } = this.options;
      const piecewise = choosePiecewise(domain.map(transform), range, interpolate3, round3);
      this.output = compose(piecewise, clamp12, transform);
    }
    composeInput(transform, untransform, clamp12) {
      const { domain, range } = this.options;
      const piecewise = choosePiecewise(range, domain.map(transform), createInterpolateNumber);
      this.input = compose(untransform, clamp12, piecewise);
    }
  };

  // node_modules/@antv/scale/esm/scales/linear.js
  var Linear = class _Linear extends Continuous {
    getDefaultOptions() {
      return {
        domain: [0, 1],
        range: [0, 1],
        unknown: void 0,
        nice: false,
        clamp: false,
        round: false,
        interpolate: createInterpolateValue,
        tickMethod: d3Ticks,
        tickCount: 5
      };
    }
    chooseTransforms() {
      return [import_util131.identity, import_util131.identity];
    }
    clone() {
      return new _Linear(this.options);
    }
  };

  // node_modules/@antv/component/esm/ui/sparkline/index.js
  var import_util139 = __toESM(require_lib());

  // node_modules/@antv/component/esm/ui/sparkline/columns.js
  init_tslib_es6();
  var import_util132 = __toESM(require_lib());
  var Columns = (
    /** @class */
    (function(_super) {
      __extends(Columns2, _super);
      function Columns2(_a2) {
        var _this2 = this;
        var style = _a2.style, rest = __rest(_a2, ["style"]);
        _this2 = _super.call(this, (0, import_util132.deepMix)({}, { type: "column" }, __assign({ style }, rest))) || this;
        _this2.columnsGroup = new Group({ name: "columns" });
        _this2.appendChild(_this2.columnsGroup);
        _this2.render();
        return _this2;
      }
      Columns2.prototype.render = function() {
        var _a2 = this.attributes, columns = _a2.columns, x3 = _a2.x, y3 = _a2.y;
        this.columnsGroup.style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
        select(this.columnsGroup).selectAll(".column").data(columns.flat()).join(function(enter) {
          return enter.append("rect").attr("className", "column").each(function(style) {
            this.attr(style);
          });
        }, function(update) {
          return update.each(function(style) {
            this.attr(style);
          });
        }, function(exit) {
          return exit.remove();
        });
      };
      Columns2.prototype.update = function(attr2) {
        this.attr(deepAssign({}, this.attributes, attr2));
        this.render();
      };
      Columns2.prototype.clear = function() {
        this.removeChildren();
      };
      return Columns2;
    })(DisplayObject)
  );

  // node_modules/@antv/component/esm/ui/sparkline/lines.js
  init_tslib_es6();
  var import_util134 = __toESM(require_lib());
  var Lines = (
    /** @class */
    (function(_super) {
      __extends(Lines2, _super);
      function Lines2(_a2) {
        var _this2 = this;
        var style = _a2.style, rest = __rest(_a2, ["style"]);
        _this2 = _super.call(this, (0, import_util134.deepMix)({}, { type: "lines" }, __assign({ style }, rest))) || this;
        _this2.linesGroup = _this2.appendChild(new Group());
        _this2.areasGroup = _this2.appendChild(new Group());
        _this2.render();
        return _this2;
      }
      Lines2.prototype.render = function() {
        var _a2 = this.attributes, lines = _a2.lines, areas = _a2.areas, x3 = _a2.x, y3 = _a2.y;
        this.style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
        if (lines)
          this.renderLines(lines);
        if (areas)
          this.renderAreas(areas);
      };
      Lines2.prototype.clear = function() {
        this.linesGroup.removeChildren();
        this.areasGroup.removeChildren();
      };
      Lines2.prototype.update = function(attr2) {
        this.attr(deepAssign({}, this.attributes, attr2));
        this.render();
      };
      Lines2.prototype.renderLines = function(lines) {
        select(this.linesGroup).selectAll(".line").data(lines).join(function(enter) {
          return enter.append("path").attr("className", "line").each(function(style) {
            this.attr(style);
          });
        }, function(update) {
          return update.each(function(style) {
            this.attr(style);
          });
        }, function(exit) {
          return exit.remove();
        });
      };
      Lines2.prototype.renderAreas = function(areas) {
        select(this.linesGroup).selectAll(".area").data(areas).join(function(enter) {
          return enter.append("path").attr("className", "area").each(function(style) {
            this.attr(style);
          });
        }, function(update) {
          return update.each(function(style) {
            this.style(style);
          });
        }, function(exit) {
          return exit.remove();
        });
      };
      return Lines2;
    })(DisplayObject)
  );

  // node_modules/@antv/component/esm/ui/sparkline/path.js
  init_tslib_es6();
  var import_util136 = __toESM(require_lib());
  function dataToLines(data2, scales) {
    var _a2;
    var x3 = scales.x, y3 = scales.y;
    var _b = __read(y3.getOptions().range || [0, 0], 2), max4 = _b[0], min4 = _b[1];
    if (min4 > max4)
      _a2 = __read([max4, min4], 2), min4 = _a2[0], max4 = _a2[1];
    return data2.map(function(points) {
      var lines = points.map(function(val, idx) {
        return [x3.map(idx), (0, import_util136.clamp)(y3.map(val), min4, max4)];
      });
      return lines;
    });
  }
  function lineToLinePath(line2, reverse) {
    if (reverse === void 0) {
      reverse = false;
    }
    var M = reverse ? line2.length - 1 : 0;
    var linePath = line2.map(function(point4, idx) {
      return __spreadArray([idx === M ? "M" : "L"], __read(point4), false);
    });
    return reverse ? linePath.reverse() : linePath;
  }
  function lineToCurvePath(line2, reverse) {
    if (reverse === void 0) {
      reverse = false;
    }
    if (line2.length <= 2) {
      return lineToLinePath(line2);
    }
    var data2 = [];
    var len = line2.length;
    for (var idx = 0; idx < len; idx += 1) {
      var point4 = reverse ? line2[len - idx - 1] : line2[idx];
      if (!(0, import_util136.isEqual)(point4, data2.slice(-2))) {
        data2.push.apply(data2, __spreadArray([], __read(point4), false));
      }
    }
    var path = catmullRom2Bezier(data2, false);
    if (reverse) {
      path.unshift(__spreadArray(["M"], __read(line2[len - 1]), false));
    } else {
      path.unshift(__spreadArray(["M"], __read(line2[0]), false));
    }
    return path;
  }
  function closePathByBaseLine(path, width2, baseline) {
    var closedPath = (0, import_util136.clone)(path);
    closedPath.push(["L", width2, baseline], ["L", 0, baseline], ["Z"]);
    return closedPath;
  }
  function linesToAreaPaths(lines, smooth2, width2, baseline) {
    return lines.map(function(line2) {
      return closePathByBaseLine(smooth2 ? lineToCurvePath(line2) : lineToLinePath(line2), width2, baseline);
    });
  }
  function linesToStackAreaPaths(lines, width2, baseline) {
    var paths = [];
    for (var idx = lines.length - 1; idx >= 0; idx -= 1) {
      var currLine = lines[idx];
      var currCurvePath = lineToLinePath(currLine);
      var path = void 0;
      if (idx === 0) {
        path = closePathByBaseLine(currCurvePath, width2, baseline);
      } else {
        var belowLine = lines[idx - 1];
        var belowCurvePath = lineToLinePath(belowLine, true);
        belowCurvePath[0][0] = "L";
        path = __spreadArray(__spreadArray(__spreadArray([], __read(currCurvePath), false), __read(belowCurvePath), false), [["Z"]], false);
      }
      paths.push(path);
    }
    return paths;
  }
  function linesToStackCurveAreaPaths(lines, width2, baseline) {
    var paths = [];
    for (var idx = lines.length - 1; idx >= 0; idx -= 1) {
      var currLine = lines[idx];
      var currCurvePath = lineToCurvePath(currLine);
      var path = void 0;
      if (idx === 0) {
        path = closePathByBaseLine(currCurvePath, width2, baseline);
      } else {
        var belowLine = lines[idx - 1];
        var belowCurvePath = lineToCurvePath(belowLine, true);
        var A3 = currLine[0];
        belowCurvePath[0][0] = "L";
        path = __spreadArray(__spreadArray(__spreadArray([], __read(currCurvePath), false), __read(belowCurvePath), false), [__spreadArray(["M"], __read(A3), false), ["Z"]], false);
      }
      paths.push(path);
    }
    return paths;
  }

  // node_modules/@antv/component/esm/ui/sparkline/utils.js
  init_tslib_es6();
  var import_util138 = __toESM(require_lib());
  function getRange(data2) {
    if (data2.length === 0)
      return [0, 0];
    return [
      (0, import_util138.min)((0, import_util138.minBy)(data2, function(arr) {
        return (0, import_util138.min)(arr) || 0;
      })),
      (0, import_util138.max)((0, import_util138.maxBy)(data2, function(arr) {
        return (0, import_util138.max)(arr) || 0;
      }))
    ];
  }
  function getStackedData(_2) {
    var data2 = (0, import_util138.clone)(_2);
    var datumLen = data2[0].length;
    var _a2 = __read([Array(datumLen).fill(0), Array(datumLen).fill(0)], 2), positivePrev = _a2[0], negativePrev = _a2[1];
    for (var i = 0; i < data2.length; i += 1) {
      var datum = data2[i];
      for (var j = 0; j < datumLen; j += 1) {
        if (datum[j] >= 0) {
          datum[j] += positivePrev[j];
          positivePrev[j] = datum[j];
        } else {
          datum[j] += negativePrev[j];
          negativePrev[j] = datum[j];
        }
      }
    }
    return data2;
  }

  // node_modules/@antv/component/esm/ui/sparkline/index.js
  var Sparkline = (
    /** @class */
    (function(_super) {
      __extends(Sparkline2, _super);
      function Sparkline2(options) {
        return _super.call(this, options, {
          type: "line",
          x: 0,
          y: 0,
          width: 200,
          height: 20,
          isStack: false,
          color: ["#83daad", "#edbf45", "#d2cef9", "#e290b3", "#6f63f4"],
          smooth: true,
          lineLineWidth: 1,
          areaOpacity: 0,
          isGroup: false,
          columnLineWidth: 1,
          columnStroke: "#fff",
          scale: 1,
          spacing: 0
        }) || this;
      }
      Object.defineProperty(Sparkline2.prototype, "rawData", {
        /**
         * 将data统一格式化为数组形式
         * 如果堆叠，则生成堆叠数据
         */
        get: function() {
          var rawData = this.attributes.data;
          if (!rawData || (rawData === null || rawData === void 0 ? void 0 : rawData.length) === 0)
            return [[]];
          var data2 = (0, import_util139.clone)(rawData);
          return (0, import_util139.isNumber)(data2[0]) ? [data2] : data2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sparkline2.prototype, "data", {
        get: function() {
          if (this.attributes.isStack)
            return getStackedData(this.rawData);
          return this.rawData;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sparkline2.prototype, "scales", {
        get: function() {
          return this.createScales(this.data);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sparkline2.prototype, "baseline", {
        /**
         * 基准线，默认为 0
         */
        get: function() {
          var y3 = this.scales.y;
          var _a2 = __read(y3.getOptions().domain || [0, 0], 2), y1 = _a2[0], y22 = _a2[1];
          if (y22 < 0) {
            return y3.map(y22);
          }
          return y3.map(y1 < 0 ? 0 : y1);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sparkline2.prototype, "containerShape", {
        get: function() {
          var _a2 = this.attributes, width2 = _a2.width, height = _a2.height;
          return { width: width2, height };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sparkline2.prototype, "linesStyle", {
        get: function() {
          var _this2 = this;
          var _a2 = this.attributes, type = _a2.type, isStack = _a2.isStack, smooth2 = _a2.smooth;
          if (type !== "line")
            throw new Error("linesStyle can only be used in line type");
          var areaStyle = subStyleProps2(this.attributes, "area");
          var lineStyle = subStyleProps2(this.attributes, "line");
          var width2 = this.containerShape.width;
          var data2 = this.data;
          if (data2[0].length === 0)
            return { lines: [], areas: [] };
          var _b = this.scales, x3 = _b.x, y3 = _b.y;
          var lines = dataToLines(data2, { type: "line", x: x3, y: y3 });
          var areas = [];
          if (areaStyle) {
            var baseline = this.baseline;
            if (isStack) {
              areas = smooth2 ? linesToStackCurveAreaPaths(lines, width2, baseline) : linesToStackAreaPaths(lines, width2, baseline);
            } else {
              areas = linesToAreaPaths(lines, smooth2, width2, baseline);
            }
          }
          return {
            lines: lines.map(function(line2, idx) {
              return __assign({ stroke: _this2.getColor(idx), d: smooth2 ? lineToCurvePath(line2) : lineToLinePath(line2) }, lineStyle);
            }),
            areas: areas.map(function(path, idx) {
              return __assign({ d: path, fill: _this2.getColor(idx) }, areaStyle);
            })
          };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sparkline2.prototype, "columnsStyle", {
        get: function() {
          var _this2 = this;
          var columnStyle = subStyleProps2(this.attributes, "column");
          var _a2 = this.attributes, isStack = _a2.isStack, type = _a2.type, scale4 = _a2.scale;
          if (type !== "column")
            throw new Error("columnsStyle can only be used in column type");
          var height = this.containerShape.height;
          var data2 = this.rawData;
          if (!data2)
            return { columns: [] };
          if (isStack)
            data2 = getStackedData(data2);
          var _b = this.createScales(data2), x3 = _b.x, y3 = _b.y;
          var _c = __read(getRange(data2), 2), minVal = _c[0], maxVal = _c[1];
          var heightScale = new Linear({
            domain: [0, maxVal - (minVal > 0 ? 0 : minVal)],
            range: [0, height * scale4]
          });
          var bandWidth = x3.getBandWidth();
          var rawData = this.rawData;
          return {
            columns: data2.map(function(column, i) {
              return column.map(function(val, j) {
                var barWidth = bandWidth / data2.length;
                var getShape2 = function() {
                  return {
                    x: x3.map(j) + barWidth * i,
                    y: val >= 0 ? y3.map(val) : y3.map(0),
                    width: barWidth,
                    height: heightScale.map(Math.abs(val))
                  };
                };
                var getStackShape = function() {
                  return {
                    x: x3.map(j),
                    y: y3.map(val),
                    width: bandWidth,
                    height: heightScale.map(rawData[i][j])
                  };
                };
                return __assign(__assign({ fill: _this2.getColor(i) }, columnStyle), isStack ? getStackShape() : getShape2());
              });
            })
          };
        },
        enumerable: false,
        configurable: true
      });
      Sparkline2.prototype.render = function(attributes, container) {
        maybeAppend(container, ".container", "rect").attr("className", "container").node();
        var type = attributes.type, x3 = attributes.x, y3 = attributes.y;
        var className = "spark".concat(type);
        var style = __assign({ x: x3, y: y3 }, type === "line" ? this.linesStyle : this.columnsStyle);
        select(container).selectAll(".spark").data([type]).join(function(enter) {
          return enter.append(function(type2) {
            if (type2 === "line")
              return new Lines({ className, style });
            return new Columns({ className, style });
          }).attr("className", "spark ".concat(className));
        }, function(update) {
          return update.update(style);
        }, function(exit) {
          return exit.remove();
        });
      };
      Sparkline2.prototype.getColor = function(index2) {
        var color2 = this.attributes.color;
        if ((0, import_util139.isArray)(color2)) {
          return color2[index2 % color2.length];
        }
        if ((0, import_util139.isFunction)(color2)) {
          return color2.call(null, index2);
        }
        return color2;
      };
      Sparkline2.prototype.createScales = function(data2) {
        var _a2, _b;
        var _c = this.attributes, type = _c.type, scale4 = _c.scale, _d = _c.range, range = _d === void 0 ? [] : _d, spacing = _c.spacing;
        var _e = this.containerShape, width2 = _e.width, height = _e.height;
        var _f = __read(getRange(data2), 2), minVal = _f[0], maxVal = _f[1];
        var yScale = new Linear({
          domain: [(_a2 = range[0]) !== null && _a2 !== void 0 ? _a2 : minVal, (_b = range[1]) !== null && _b !== void 0 ? _b : maxVal],
          range: [height, height * (1 - scale4)]
        });
        if (type === "line") {
          return {
            type,
            x: new Linear({
              domain: [0, data2[0].length - 1],
              range: [0, width2]
            }),
            y: yScale
          };
        }
        return {
          type,
          x: new Band({
            domain: data2[0].map(function(val, idx) {
              return idx;
            }),
            range: [0, width2],
            paddingInner: spacing,
            paddingOuter: spacing / 2,
            align: 0.5
          }),
          y: yScale
        };
      };
      Sparkline2.tag = "sparkline";
      return Sparkline2;
    })(Component)
  );

  // node_modules/@antv/component/esm/ui/slider/index.js
  init_tslib_es6();
  var import_util145 = __toESM(require_lib());

  // node_modules/@antv/component/esm/animation/utils.js
  init_tslib_es6();
  var import_util141 = __toESM(require_lib());
  function isStandardAnimationOption(option) {
    if (typeof option === "boolean")
      return false;
    return "enter" in option && "update" in option && "exit" in option;
  }
  function parseAnimationOption(option) {
    if (!option)
      return { enter: false, update: false, exit: false };
    var keys = ["enter", "update", "exit"];
    var baseOption = Object.fromEntries(Object.entries(option).filter(function(_a2) {
      var _b = __read(_a2, 1), k = _b[0];
      return !keys.includes(k);
    }));
    return Object.fromEntries(keys.map(function(k) {
      if (isStandardAnimationOption(option)) {
        if (option[k] === false)
          return [k, false];
        return [k, __assign(__assign({}, option[k]), baseOption)];
      }
      return [k, baseOption];
    }));
  }
  function onAnimateFinished(animation, callback) {
    if (!animation)
      callback();
    else
      animation.finished.then(callback);
  }
  function onAnimatesFinished(animations, callback) {
    if (animations.length === 0)
      callback();
    else
      Promise.all(animations.map(function(a2) {
        return a2 === null || a2 === void 0 ? void 0 : a2.finished;
      })).then(callback);
  }
  function attr(target, value) {
    if ("update" in target)
      target.update(value);
    else
      target.attr(value);
  }
  function animate(target, keyframes, options) {
    if (keyframes.length === 0)
      return null;
    if (!options) {
      var state = keyframes.slice(-1)[0];
      attr(target, { style: state });
      return null;
    }
    return target.animate(keyframes, options);
  }
  function identicalTextNode(source, target) {
    if (source.nodeName !== "text" || target.nodeName !== "text")
      return false;
    if (source.attributes.text !== target.attributes.text)
      return false;
    return true;
  }
  function transitionShape(source, target, options, after) {
    if (after === void 0) {
      after = "destroy";
    }
    if (identicalTextNode(source, target)) {
      source.remove();
      return [null];
    }
    var afterTransition = function() {
      if (after === "destroy")
        source.destroy();
      else if (after === "hide")
        hide(source);
      if (target.isVisible())
        show(target);
    };
    if (!options) {
      afterTransition();
      return [null];
    }
    var _a2 = options.duration, duration = _a2 === void 0 ? 0 : _a2, _b = options.delay, delay = _b === void 0 ? 0 : _b;
    var middle = Math.ceil(+duration / 2);
    var offset = +duration / 4;
    var _c = __read(source.getGeometryBounds().center, 2), sx = _c[0], sy = _c[1];
    var _d = __read(target.getGeometryBounds().center, 2), ex = _d[0], ey = _d[1];
    var _e = __read([(sx + ex) / 2 - sx, (sy + ey) / 2 - sy], 2), mx = _e[0], my = _e[1];
    var _f = source.style.opacity, so = _f === void 0 ? 1 : _f;
    var _g = target.style.opacity, to = _g === void 0 ? 1 : _g;
    var st = source.style.transform || "";
    var tt = target.style.transform || "";
    var sourceAnimation = source.animate([
      { opacity: so, transform: "translate(0, 0) ".concat(st) },
      { opacity: 0, transform: "translate(".concat(mx, ", ").concat(my, ") ").concat(st) }
    ], __assign(__assign({ fill: "both" }, options), { duration: delay + middle + offset }));
    var targetAnimation = target.animate([
      { opacity: 0, transform: "translate(".concat(-mx, ", ").concat(-my, ") ").concat(tt), offset: 0.01 },
      { opacity: to, transform: "translate(0, 0) ".concat(tt) }
    ], __assign(__assign({ fill: "both" }, options), { duration: middle + offset, delay: delay + middle - offset }));
    onAnimateFinished(targetAnimation, afterTransition);
    return [sourceAnimation, targetAnimation];
  }
  function transition(target, state, options) {
    var from = {};
    var to = {};
    Object.entries(state).forEach(function(_a2) {
      var _b = __read(_a2, 2), key = _b[0], tarStyle = _b[1];
      if (!(0, import_util141.isNil)(tarStyle)) {
        var currStyle = target.style[key] || target.parsedStyle[key] || 0;
        if (currStyle !== tarStyle) {
          from[key] = currStyle;
          to[key] = tarStyle;
        }
      }
    });
    if (!options) {
      attr(target, to);
      return null;
    }
    return animate(target, [from, to], __assign({ fill: "both" }, options));
  }

  // node_modules/@antv/component/esm/animation/fadeOut.js
  function fadeOut_default(element, options) {
    if (!element.style.opacity)
      element.style.opacity = 1;
    return transition(element, { opacity: 0 }, options);
  }

  // node_modules/@antv/component/esm/ui/slider/constant.js
  var HANDLE_ICON_DEFAULT_CFG = {
    fill: "#fff",
    lineWidth: 1,
    radius: 2,
    size: 10,
    stroke: "#bfbfbf",
    strokeOpacity: 1,
    zIndex: 0
  };
  var HANDLE_LABEL_DEFAULT_CFG = {
    fill: "#000",
    fillOpacity: 0.45,
    fontSize: 12,
    textAlign: "center",
    textBaseline: "middle",
    zIndex: 1
  };
  var HANDLE_DEFAULT_CFG = {
    x: 0,
    y: 0,
    orientation: "horizontal",
    showLabel: true,
    type: "start"
  };
  var CLASS_NAMES = classNames({
    foreground: "foreground",
    handle: "handle",
    selection: "selection",
    sparkline: "sparkline",
    sparklineGroup: "sparkline-group",
    track: "track",
    brushArea: "brush-area"
  }, "slider");

  // node_modules/@antv/component/esm/ui/slider/handle.js
  init_tslib_es6();
  var CLASS_NAMES2 = classNames({
    labelGroup: "label-group",
    label: "label",
    iconGroup: "icon-group",
    icon: "icon",
    iconRect: "icon-rect",
    iconLine: "icon-line"
  }, "handle");
  var HandleIcon = (
    /** @class */
    (function(_super) {
      __extends(HandleIcon2, _super);
      function HandleIcon2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      HandleIcon2.prototype.render = function(attributes, container) {
        var x3 = attributes.x, y3 = attributes.y, _a2 = attributes.size, size2 = _a2 === void 0 ? 10 : _a2, _b = attributes.radius, radius = _b === void 0 ? size2 / 4 : _b, orientation5 = attributes.orientation, iconStyle = __rest(attributes, ["x", "y", "size", "radius", "orientation"]);
        var width2 = size2;
        var height = width2 * 2.4;
        var rect2 = select(container).maybeAppendByClassName(CLASS_NAMES2.iconRect, "rect").styles(__assign(__assign({}, iconStyle), { width: width2, height, radius, x: x3 - width2 / 2, y: y3 - height / 2, transformOrigin: "center" }));
        var x1 = x3 + 1 / 3 * width2 - width2 / 2;
        var x22 = x3 + 2 / 3 * width2 - width2 / 2;
        var y1 = y3 + 1 / 4 * height - height / 2;
        var y22 = y3 + 3 / 4 * height - height / 2;
        rect2.maybeAppendByClassName("".concat(CLASS_NAMES2.iconLine, "-1"), "line").styles(__assign({ x1, x2: x1, y1, y2: y22 }, iconStyle));
        rect2.maybeAppendByClassName("".concat(CLASS_NAMES2.iconLine, "-2"), "line").styles(__assign({ x1: x22, x2: x22, y1, y2: y22 }, iconStyle));
        if (orientation5 === "vertical")
          rect2.node().style.transform = "rotate(90)";
      };
      return HandleIcon2;
    })(Component)
  );
  var Handle = (
    /** @class */
    (function(_super) {
      __extends(Handle3, _super);
      function Handle3(options) {
        return _super.call(this, options, HANDLE_DEFAULT_CFG) || this;
      }
      Handle3.prototype.renderLabel = function(container) {
        var _this2 = this;
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, showLabel = _a2.showLabel;
        var _b = subStyleProps2(this.attributes, "label"), _c = _b.x, labelX = _c === void 0 ? 0 : _c, _d = _b.y, labelY = _d === void 0 ? 0 : _d, transform = _b.transform, transformOrigin = _b.transformOrigin, style = __rest(_b, ["x", "y", "transform", "transformOrigin"]);
        var _e = __read(splitStyle(style, []), 2), labelStyle = _e[0], groupStyle = _e[1];
        var labelGroup = select(container).maybeAppendByClassName(CLASS_NAMES2.labelGroup, "g").styles(groupStyle);
        var _f = __assign(__assign({}, HANDLE_LABEL_DEFAULT_CFG), labelStyle), text = _f.text, rest = __rest(_f, ["text"]);
        ifShow(!!showLabel, labelGroup, function(group2) {
          _this2.label = group2.maybeAppendByClassName(CLASS_NAMES2.label, "text").styles(__assign(__assign({}, rest), { x: x3 + labelX, y: y3 + labelY, transform, transformOrigin, text: "".concat(text) }));
          _this2.label.on("mousedown", function(e) {
            e.stopPropagation();
          });
          _this2.label.on("touchstart", function(e) {
            e.stopPropagation();
          });
        });
      };
      Handle3.prototype.renderIcon = function(container) {
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, orientation5 = _a2.orientation, type = _a2.type;
        var iconStyle = __assign(__assign({ x: x3, y: y3, orientation: orientation5 }, HANDLE_ICON_DEFAULT_CFG), subStyleProps2(this.attributes, "icon"));
        var _b = this.attributes.iconShape, iconShape = _b === void 0 ? function() {
          return new HandleIcon({ style: iconStyle });
        } : _b;
        var iconGroup = select(container).maybeAppendByClassName(CLASS_NAMES2.iconGroup, "g");
        iconGroup.selectAll(CLASS_NAMES2.icon.class).data([iconShape]).join(function(enter) {
          return enter.append(typeof iconShape === "string" ? iconShape : function() {
            return iconShape(type);
          }).attr("className", CLASS_NAMES2.icon.name);
        }, function(update) {
          return update.update(iconStyle);
        }, function(exit) {
          return exit.remove();
        });
      };
      Handle3.prototype.render = function(attributes, container) {
        this.renderIcon(container);
        this.renderLabel(container);
      };
      return Handle3;
    })(Component)
  );

  // node_modules/@antv/component/esm/ui/slider/index.js
  var Slider = (
    /** @class */
    (function(_super) {
      __extends(Slider2, _super);
      function Slider2(options) {
        var _this2 = _super.call(this, options, __assign(__assign(__assign({ x: 0, y: 0, animate: { duration: 100, fill: "both" }, brushable: true, formatter: function(val) {
          return val.toString();
        }, handleSpacing: 2, orientation: "horizontal", padding: 0, autoFitLabel: true, scrollable: true, selectionFill: "#5B8FF9", selectionFillOpacity: 0.45, selectionZIndex: 2, showHandle: true, showLabel: true, slidable: true, trackFill: "#416180", trackLength: 200, trackOpacity: 0.05, trackSize: 20, trackZIndex: -1, values: [0, 1], type: "range", selectionType: "select", handleIconOffset: 0 }, superStyleProps(HANDLE_DEFAULT_CFG, "handle")), superStyleProps(HANDLE_ICON_DEFAULT_CFG, "handleIcon")), superStyleProps(HANDLE_LABEL_DEFAULT_CFG, "handleLabel"))) || this;
        _this2.range = [0, 1];
        _this2.onDragStart = function(target) {
          return function(e) {
            e.stopPropagation();
            _this2.target = target;
            _this2.prevPos = _this2.getOrientVal(getEventPos(e));
            var _a2 = _this2.availableSpace, x3 = _a2.x, y3 = _a2.y;
            var _b = _this2.getBBox(), X = _b.x, Y = _b.y;
            _this2.selectionStartPos = _this2.getRatio(_this2.prevPos - _this2.getOrientVal([x3, y3]) - _this2.getOrientVal([+X, +Y]));
            _this2.selectionWidth = 0;
            document.addEventListener("pointermove", _this2.onDragging);
            document.addEventListener("pointerup", _this2.onDragEnd);
          };
        };
        _this2.onDragging = function(e) {
          var _a2 = _this2.attributes, slidable = _a2.slidable, brushable = _a2.brushable, type = _a2.type;
          e.stopPropagation();
          var currPos = _this2.getOrientVal(getEventPos(e));
          var diffPos = currPos - _this2.prevPos;
          if (!diffPos)
            return;
          var deltaVal = _this2.getRatio(diffPos);
          switch (_this2.target) {
            case "start":
              if (slidable)
                _this2.setValuesOffset(deltaVal);
              break;
            case "end":
              if (slidable)
                _this2.setValuesOffset(0, deltaVal);
              break;
            case "selection":
              if (slidable)
                _this2.setValuesOffset(deltaVal, deltaVal);
              break;
            case "track":
              if (!brushable)
                return;
              _this2.selectionWidth += deltaVal;
              if (type === "range") {
                _this2.innerSetValues([_this2.selectionStartPos, _this2.selectionStartPos + _this2.selectionWidth].sort(), true);
              } else
                _this2.innerSetValues([0, _this2.selectionStartPos + _this2.selectionWidth], true);
              break;
            default:
              break;
          }
          _this2.prevPos = currPos;
        };
        _this2.onDragEnd = function() {
          document.removeEventListener("pointermove", _this2.onDragging);
          document.removeEventListener("pointermove", _this2.onDragging);
          document.removeEventListener("pointerup", _this2.onDragEnd);
          _this2.target = "";
          _this2.updateHandlesPosition(false);
        };
        _this2.onValueChange = function(oldValue) {
          var _a2 = _this2.attributes, onChange = _a2.onChange, type = _a2.type;
          var internalOldValue = type === "range" ? oldValue : oldValue[1];
          var value = type === "range" ? _this2.getValues() : _this2.getValues()[1];
          var evt = new CustomEvent("valuechange", {
            detail: { oldValue: internalOldValue, value }
          });
          _this2.dispatchEvent(evt);
          onChange === null || onChange === void 0 ? void 0 : onChange(value);
        };
        _this2.selectionStartPos = 0;
        _this2.selectionWidth = 0;
        _this2.prevPos = 0;
        _this2.target = "";
        return _this2;
      }
      Object.defineProperty(Slider2.prototype, "values", {
        get: function() {
          return this.attributes.values;
        },
        set: function(values2) {
          this.attributes.values = this.clampValues(values2);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Slider2.prototype, "sparklineStyle", {
        get: function() {
          var orientation5 = this.attributes.orientation;
          if (orientation5 !== "horizontal")
            return null;
          var attr2 = subStyleProps2(this.attributes, "sparkline");
          return __assign(__assign({ zIndex: 0 }, this.availableSpace), attr2);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Slider2.prototype, "shape", {
        get: function() {
          var _a2 = this.attributes, trackLength = _a2.trackLength, trackSize = _a2.trackSize;
          var _b = __read(this.getOrientVal([
            [trackLength, trackSize],
            [trackSize, trackLength]
          ]), 2), width2 = _b[0], height = _b[1];
          return { width: width2, height };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Slider2.prototype, "availableSpace", {
        get: function() {
          var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, padding = _a2.padding;
          var _b = __read(parseSeriesAttr(padding), 4), top = _b[0], right = _b[1], bottom = _b[2], left = _b[3];
          var _c = this.shape, width2 = _c.width, height = _c.height;
          return {
            x: left,
            y: top,
            width: width2 - (left + right),
            height: height - (top + bottom)
          };
        },
        enumerable: false,
        configurable: true
      });
      Slider2.prototype.getValues = function() {
        return this.values;
      };
      Slider2.prototype.setValues = function(values2, animate2) {
        if (values2 === void 0) {
          values2 = [0, 0];
        }
        if (animate2 === void 0) {
          animate2 = false;
        }
        this.attributes.values = values2;
        var animation = animate2 === false ? false : this.attributes.animate;
        this.updateSelectionArea(animation);
        this.updateHandlesPosition(animation);
      };
      Slider2.prototype.updateSelectionArea = function(animation) {
        var newSelectionArea = this.calcSelectionArea();
        this.foregroundGroup.selectAll(CLASS_NAMES.selection.class).each(function(datum, index2) {
          transition(this, newSelectionArea[index2], animation);
        });
      };
      Slider2.prototype.updateHandlesPosition = function(animation) {
        if (!this.attributes.showHandle)
          return;
        this.startHandle && transition(this.startHandle, this.getHandleStyle("start"), animation);
        this.endHandle && transition(this.endHandle, this.getHandleStyle("end"), animation);
      };
      Slider2.prototype.innerSetValues = function(values2, trigger) {
        if (values2 === void 0) {
          values2 = [0, 0];
        }
        if (trigger === void 0) {
          trigger = false;
        }
        var oldValues = this.values;
        var newValues = this.clampValues(values2);
        this.attributes.values = newValues;
        this.setValues(newValues);
        if (trigger) {
          this.onValueChange(oldValues);
        }
      };
      Slider2.prototype.renderTrack = function(container) {
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y;
        var style = subStyleProps2(this.attributes, "track");
        this.trackShape = select(container).maybeAppendByClassName(CLASS_NAMES.track, "rect").styles(__assign(__assign({ x: x3, y: y3 }, this.shape), style));
      };
      Slider2.prototype.renderBrushArea = function(container) {
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, brushable = _a2.brushable;
        this.brushArea = select(container).maybeAppendByClassName(CLASS_NAMES.brushArea, "rect").styles(__assign({ x: x3, y: y3, fill: "transparent", cursor: brushable ? "crosshair" : "default" }, this.shape));
      };
      Slider2.prototype.renderSparkline = function(container) {
        var _this2 = this;
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, orientation5 = _a2.orientation;
        var sparklineGroup = select(container).maybeAppendByClassName(CLASS_NAMES.sparklineGroup, "g");
        ifShow(orientation5 === "horizontal", sparklineGroup, function(group2) {
          var style = __assign(__assign({}, _this2.sparklineStyle), { x: x3, y: y3 });
          group2.maybeAppendByClassName(CLASS_NAMES.sparkline, function() {
            return new Sparkline({ style });
          }).update(style);
        });
      };
      Slider2.prototype.renderHandles = function() {
        var _this2 = this;
        var _a2;
        var _b = this.attributes, showHandle = _b.showHandle, type = _b.type;
        var availableHandle = type === "range" ? ["start", "end"] : ["end"];
        var data2 = showHandle ? availableHandle : [];
        var that = this;
        (_a2 = this.foregroundGroup) === null || _a2 === void 0 ? void 0 : _a2.selectAll(CLASS_NAMES.handle.class).data(data2.map(function(type2) {
          return { type: type2 };
        }), function(d2) {
          return d2.type;
        }).join(function(enter) {
          return enter.append(function(_a3) {
            var type2 = _a3.type;
            return new Handle({ style: _this2.getHandleStyle(type2) });
          }).each(function(_a3) {
            var type2 = _a3.type;
            this.attr("class", "".concat(CLASS_NAMES.handle.name, " ").concat(type2, "-handle"));
            var name = "".concat(type2, "Handle");
            that[name] = this;
            this.addEventListener("pointerdown", that.onDragStart(type2));
          });
        }, function(update) {
          return update.each(function(_a3) {
            var type2 = _a3.type;
            this.update(that.getHandleStyle(type2));
          });
        }, function(exit) {
          return exit.each(function(_a3) {
            var type2 = _a3.type;
            var name = "".concat(type2, "Handle");
            that[name] = void 0;
          }).remove();
        });
      };
      Slider2.prototype.renderSelection = function(container) {
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, type = _a2.type, selectionType = _a2.selectionType;
        this.foregroundGroup = select(container).maybeAppendByClassName(CLASS_NAMES.foreground, "g");
        var selectionStyle = subStyleProps2(this.attributes, "selection");
        var applyStyle = function(selection) {
          return selection.style("visibility", function(d2) {
            return d2.show ? "visible" : "hidden";
          }).style("cursor", function(d2) {
            if (selectionType === "select")
              return "grab";
            if (selectionType === "invert")
              return "crosshair";
            return "default";
          }).styles(__assign(__assign({}, selectionStyle), { transform: "translate(".concat(x3, ", ").concat(y3, ")") }));
        };
        var that = this;
        this.foregroundGroup.selectAll(CLASS_NAMES.selection.class).data(type === "value" ? [] : this.calcSelectionArea().map(function(area, index2) {
          return {
            style: __assign({}, area),
            index: index2,
            // 是否可见
            show: selectionType === "select" ? index2 === 1 : index2 !== 1
          };
        }), function(d2) {
          return d2.index;
        }).join(function(enter) {
          return enter.append("rect").attr("className", CLASS_NAMES.selection.name).call(applyStyle).each(function(datum, index2) {
            var _this2 = this;
            if (index2 === 1) {
              that.selectionShape = select(this);
              this.on("pointerdown", function(e) {
                _this2.attr("cursor", "grabbing");
                that.onDragStart("selection")(e);
              });
              that.dispatchCustomEvent(this, "pointerenter", "selectionMouseenter");
              that.dispatchCustomEvent(this, "pointerleave", "selectionMouseleave");
              that.dispatchCustomEvent(this, "click", "selectionClick");
              this.addEventListener("pointerdown", function() {
                _this2.attr("cursor", "grabbing");
              });
              this.addEventListener("pointerup", function() {
                _this2.attr("cursor", "pointer");
              });
              this.addEventListener("pointerover", function() {
                _this2.attr("cursor", "pointer");
              });
            } else {
              this.on("pointerdown", that.onDragStart("track"));
            }
          });
        }, function(update) {
          return update.call(applyStyle);
        }, function(exit) {
          return exit.remove();
        });
        this.updateSelectionArea(false);
        this.renderHandles();
      };
      Slider2.prototype.render = function(attributes, container) {
        this.renderTrack(container);
        this.renderSparkline(container);
        this.renderBrushArea(container);
        this.renderSelection(container);
      };
      Slider2.prototype.clampValues = function(values2, precision) {
        var _a2;
        if (precision === void 0) {
          precision = 4;
        }
        var _b = __read(this.range, 2), min4 = _b[0], max4 = _b[1];
        var _c = __read(this.getValues().map(function(num) {
          return toPrecision(num, precision);
        }), 2), prevStart = _c[0], prevEnd = _c[1];
        var internalValues = Array.isArray(values2) ? values2 : [prevStart, values2 !== null && values2 !== void 0 ? values2 : prevEnd];
        var _d = __read((internalValues || [prevStart, prevEnd]).map(function(num) {
          return toPrecision(num, precision);
        }), 2), startVal = _d[0], endVal = _d[1];
        if (this.attributes.type === "value")
          return [0, (0, import_util145.clamp)(endVal, min4, max4)];
        if (startVal > endVal) {
          _a2 = __read([endVal, startVal], 2), startVal = _a2[0], endVal = _a2[1];
        }
        var range = endVal - startVal;
        if (range > max4 - min4)
          return [min4, max4];
        if (startVal < min4) {
          if (prevStart === min4 && prevEnd === endVal)
            return [min4, endVal];
          return [min4, range + min4];
        }
        if (endVal > max4) {
          if (prevEnd === max4 && prevStart === startVal)
            return [startVal, max4];
          return [max4 - range, max4];
        }
        return [startVal, endVal];
      };
      Slider2.prototype.calcSelectionArea = function(values2) {
        var _a2 = __read(this.clampValues(values2), 2), start = _a2[0], end = _a2[1];
        var _b = this.availableSpace, x3 = _b.x, y3 = _b.y, width2 = _b.width, height = _b.height;
        return this.getOrientVal([
          [
            { y: y3, height, x: x3, width: start * width2 },
            { y: y3, height, x: start * width2 + x3, width: (end - start) * width2 },
            { y: y3, height, x: end * width2, width: (1 - end) * width2 }
          ],
          [
            { x: x3, width: width2, y: y3, height: start * height },
            { x: x3, width: width2, y: start * height + y3, height: (end - start) * height },
            { x: x3, width: width2, y: end * height, height: (1 - end) * height }
          ]
        ]);
      };
      Slider2.prototype.calcHandlePosition = function(handleType) {
        var handleIconOffset = this.attributes.handleIconOffset;
        var _a2 = this.availableSpace, x3 = _a2.x, y3 = _a2.y, width2 = _a2.width, height = _a2.height;
        var _b = __read(this.clampValues(), 2), stVal = _b[0], endVal = _b[1];
        var offset = handleType === "start" ? -handleIconOffset : handleIconOffset;
        var L = (handleType === "start" ? stVal : endVal) * this.getOrientVal([width2, height]) + offset;
        return {
          x: x3 + this.getOrientVal([L, width2 / 2]),
          y: y3 + this.getOrientVal([height / 2, L])
        };
      };
      Slider2.prototype.inferTextStyle = function(handleType) {
        var orientation5 = this.attributes.orientation;
        if (orientation5 === "horizontal")
          return {};
        if (handleType === "start")
          return { transformOrigin: "left center", transform: "rotate(90)", textAlign: "start" };
        if (handleType === "end")
          return { transformOrigin: "right center", transform: "rotate(90)", textAlign: "end" };
        return {};
      };
      Slider2.prototype.calcHandleText = function(handleType) {
        var _a2;
        var _b = this.attributes, type = _b.type, orientation5 = _b.orientation, formatter2 = _b.formatter, autoFitLabel = _b.autoFitLabel;
        var handleStyle = subStyleProps2(this.attributes, "handle");
        var labelStyle = subStyleProps2(handleStyle, "label");
        var spacing = handleStyle.spacing;
        var size2 = this.getHandleSize();
        var values2 = this.clampValues();
        var value = handleType === "start" ? values2[0] : values2[1];
        var text = formatter2(value);
        var temp = new Text2({
          style: __assign(__assign(__assign({}, labelStyle), this.inferTextStyle(handleType)), { text })
        });
        var _c = temp.getBBox(), textWidth = _c.width, textHeight = _c.height;
        temp.destroy();
        if (!autoFitLabel) {
          if (type === "value")
            return { text, x: 0, y: -textHeight - spacing };
          var finaleWidth = spacing + size2 + (orientation5 === "horizontal" ? textWidth / 2 : 0);
          return _a2 = { text }, _a2[orientation5 === "horizontal" ? "x" : "y"] = handleType === "start" ? -finaleWidth : finaleWidth, _a2;
        }
        var x3 = 0;
        var y3 = 0;
        var _d = this.availableSpace, iW = _d.width, iH = _d.height;
        var _e = this.calcSelectionArea()[1], fX = _e.x, fY = _e.y, fW = _e.width, fH = _e.height;
        var totalSpacing = spacing + size2;
        if (orientation5 === "horizontal") {
          var finalWidth = totalSpacing + textWidth / 2;
          if (handleType === "start") {
            var left = fX - totalSpacing - textWidth;
            x3 = left > 0 ? -finalWidth : finalWidth;
          } else {
            var sign = iW - fX - fW - totalSpacing > textWidth;
            x3 = sign ? finalWidth : -finalWidth;
          }
        } else {
          var positiveSize = totalSpacing;
          var negativeSize = textHeight + totalSpacing;
          if (handleType === "start") {
            y3 = fY - size2 > textHeight ? -negativeSize : positiveSize;
          } else {
            y3 = iH - (fY + fH) - size2 > textHeight ? negativeSize : -positiveSize;
          }
        }
        return { x: x3, y: y3, text };
      };
      Slider2.prototype.getHandleLabelStyle = function(handleType) {
        var style = subStyleProps2(this.attributes, "handleLabel");
        return __assign(__assign(__assign({}, style), this.calcHandleText(handleType)), this.inferTextStyle(handleType));
      };
      Slider2.prototype.getHandleIconStyle = function() {
        var shape = this.attributes.handleIconShape;
        var style = subStyleProps2(this.attributes, "handleIcon");
        var cursor = this.getOrientVal(["ew-resize", "ns-resize"]);
        var size2 = this.getHandleSize();
        return __assign({ cursor, shape, size: size2 }, style);
      };
      Slider2.prototype.getHandleStyle = function(handleType) {
        var _a2 = this.attributes, ox = _a2.x, oy = _a2.y, showLabel = _a2.showLabel, showLabelOnInteraction = _a2.showLabelOnInteraction, orientation5 = _a2.orientation;
        var _b = this.calcHandlePosition(handleType), x3 = _b.x, y3 = _b.y;
        var textStyle = this.calcHandleText(handleType);
        var internalShowLabel = showLabel;
        if (!showLabel && showLabelOnInteraction) {
          if (this.target)
            internalShowLabel = true;
          else
            internalShowLabel = false;
        }
        return __assign(__assign(__assign({}, superStyleProps(this.getHandleIconStyle(), "icon")), superStyleProps(__assign(__assign({}, this.getHandleLabelStyle(handleType)), textStyle), "label")), { transform: "translate(".concat(x3 + ox, ", ").concat(y3 + oy, ")"), orientation: orientation5, showLabel: internalShowLabel, type: handleType, zIndex: 3 });
      };
      Slider2.prototype.getHandleSize = function() {
        var _a2 = this.attributes, size2 = _a2.handleIconSize, width2 = _a2.width, height = _a2.height;
        if (size2)
          return size2;
        return Math.floor((this.getOrientVal([+height, +width2]) + 4) / 2.4);
      };
      Slider2.prototype.getOrientVal = function(_a2) {
        var _b = __read(_a2, 2), x3 = _b[0], y3 = _b[1];
        var orientation5 = this.attributes.orientation;
        return orientation5 === "horizontal" ? x3 : y3;
      };
      Slider2.prototype.setValuesOffset = function(stOffset, endOffset) {
        if (endOffset === void 0) {
          endOffset = 0;
        }
        var type = this.attributes.type;
        var _a2 = __read(this.getValues(), 2), oldStartVal = _a2[0], oldEndVal = _a2[1];
        var internalStartOffset = type === "range" ? stOffset : 0;
        var values2 = [oldStartVal + internalStartOffset, oldEndVal + endOffset].sort();
        this.innerSetValues(values2, true);
      };
      Slider2.prototype.getRatio = function(val) {
        var _a2 = this.availableSpace, width2 = _a2.width, height = _a2.height;
        return val / this.getOrientVal([width2, height]);
      };
      Slider2.prototype.dispatchCustomEvent = function(target, event, name) {
        var _this2 = this;
        target.on(event, function(e) {
          e.stopPropagation();
          _this2.dispatchEvent(new CustomEvent(name, { detail: e }));
        });
      };
      Slider2.prototype.bindEvents = function() {
        this.addEventListener("wheel", this.onScroll);
        var brushArea = this.brushArea;
        this.dispatchCustomEvent(brushArea, "click", "trackClick");
        this.dispatchCustomEvent(brushArea, "pointerenter", "trackMouseenter");
        this.dispatchCustomEvent(brushArea, "pointerleave", "trackMouseleave");
        brushArea.on("pointerdown", this.onDragStart("track"));
      };
      Slider2.prototype.onScroll = function(event) {
        var scrollable = this.attributes.scrollable;
        if (scrollable) {
          var deltaX = event.deltaX, deltaY = event.deltaY;
          var offset = deltaY || deltaX;
          var deltaVal = this.getRatio(offset);
          this.setValuesOffset(deltaVal, deltaVal);
        }
      };
      Slider2.tag = "slider";
      return Slider2;
    })(Component)
  );

  // node_modules/@antv/component/esm/ui/axis/axis.js
  init_tslib_es6();

  // node_modules/@antv/component/esm/ui/axis/constant.js
  var import_util147 = __toESM(require_lib());
  var AXIS_BASE_DEFAULT_ATTR = {
    data: [],
    animate: {
      enter: false,
      update: {
        duration: 100,
        easing: "ease-in-out-sine",
        fill: "both"
      },
      exit: {
        duration: 100,
        fill: "both"
      }
    },
    showArrow: true,
    showGrid: true,
    showLabel: true,
    showLine: true,
    showTick: true,
    showTitle: true,
    showTrunc: false,
    dataThreshold: 100,
    lineLineWidth: 1,
    lineStroke: "black",
    crossPadding: 10,
    titleFill: "black",
    titleFontSize: 12,
    titlePosition: "lb",
    titleSpacing: 0,
    titleTextAlign: "center",
    titleTextBaseline: "middle",
    lineArrow: function() {
      return new Path({
        style: {
          d: [["M", 10, 10], ["L", -10, 0], ["L", 10, -10], ["L", 0, 0], ["L", 10, 10], ["Z"]],
          fill: "black",
          transformOrigin: "center"
        }
      });
    },
    labelAlign: "parallel",
    labelDirection: "positive",
    labelFontSize: 12,
    labelSpacing: 0,
    gridConnect: "line",
    gridControlAngles: [],
    gridDirection: "positive",
    gridLength: 0,
    gridType: "segment",
    lineArrowOffset: 15,
    lineArrowSize: 10,
    tickDirection: "positive",
    tickLength: 5,
    tickLineWidth: 1,
    tickStroke: "black",
    labelOverlap: [
      // { type: 'rotate', optionalAngles: [0, 45, 90] },
      // { type: 'ellipsis', suffix: '...', minLength: 14, maxLength: 160 },
      // { type: 'hide' },
    ]
  };
  var ARC_DEFAULT_OPTIONS = (0, import_util147.deepMix)({}, AXIS_BASE_DEFAULT_ATTR, {
    style: {
      type: "arc"
    }
  });
  var HELIX_DEFAULT_OPTIONS = (0, import_util147.deepMix)({}, AXIS_BASE_DEFAULT_ATTR, {
    style: {}
  });
  var CLASS_NAMES3 = classNames({
    mainGroup: "main-group",
    gridGroup: "grid-group",
    grid: "grid",
    lineGroup: "line-group",
    line: "line",
    tickGroup: "tick-group",
    tick: "tick",
    tickItem: "tick-item",
    labelGroup: "label-group",
    label: "label",
    labelItem: "label-item",
    titleGroup: "title-group",
    title: "title",
    lineFirst: "line-first",
    lineSecond: "line-second"
  }, "axis");

  // node_modules/@antv/component/esm/ui/axis/guides/grid.js
  init_tslib_es6();
  var import_util154 = __toESM(require_lib());

  // node_modules/@antv/component/esm/ui/grid/index.js
  init_tslib_es6();
  var CLASS_NAMES4 = classNames({
    lineGroup: "line-group",
    line: "line",
    regionGroup: "region-group",
    region: "region"
  }, "grid");
  function getStraightPath(points) {
    return points.reduce(function(acc, curr, idx) {
      acc.push(__spreadArray([idx === 0 ? "M" : "L"], __read(curr), false));
      return acc;
    }, []);
  }
  function getSurroundPath(points, attr2, reversed) {
    var _a2 = attr2.connect, connect = _a2 === void 0 ? "line" : _a2, center = attr2.center;
    if (connect === "line")
      return getStraightPath(points);
    if (!center)
      return [];
    var radius = distance4(points[0], center);
    var sweepFlag = reversed ? 0 : 1;
    return points.reduce(function(r, p, idx) {
      if (idx === 0)
        r.push(__spreadArray(["M"], __read(p), false));
      else
        r.push(__spreadArray(["A", radius, radius, 0, 0, sweepFlag], __read(p), false));
      return r;
    }, []);
  }
  function getLinePath(points, cfg, reversed) {
    if (cfg.type === "surround")
      return getSurroundPath(points, cfg, reversed);
    return getStraightPath(points);
  }
  function connectPaths(from, to, cfg) {
    var type = cfg.type, connect = cfg.connect, center = cfg.center, closed = cfg.closed;
    var closeFlag = closed ? [["Z"]] : [];
    var _a2 = __read([getLinePath(from, cfg), getLinePath(to.slice().reverse(), cfg, true)], 2), path1 = _a2[0], path2 = _a2[1];
    var _b = __read([from[0], to.slice(-1)[0]], 2), startOfFrom = _b[0], endOfTo = _b[1];
    var createPath = function(insertA, insertB) {
      return [path1, insertA, path2, insertB, closeFlag].flat();
    };
    if (connect === "line" || type === "surround") {
      return createPath([__spreadArray(["L"], __read(endOfTo), false)], [__spreadArray(["L"], __read(startOfFrom), false)]);
    }
    if (!center)
      throw new Error("Arc grid need to specified center");
    var _c = __read([distance4(endOfTo, center), distance4(startOfFrom, center)], 2), raduis1 = _c[0], radius2 = _c[1];
    return createPath([
      __spreadArray(["A", raduis1, raduis1, 0, 0, 1], __read(endOfTo), false),
      __spreadArray(["L"], __read(endOfTo), false)
    ], [
      __spreadArray(["A", radius2, radius2, 0, 0, 0], __read(startOfFrom), false),
      __spreadArray(["L"], __read(startOfFrom), false)
    ]);
  }
  function renderGridLine(container, data2, attr2, style) {
    var animate2 = attr2.animate, isBillboard = attr2.isBillboard;
    var lines = data2.map(function(item, idx) {
      return {
        id: item.id || "grid-line-".concat(idx),
        d: getLinePath(item.points, attr2)
      };
    });
    return container.selectAll(CLASS_NAMES4.line.class).data(lines, function(d2) {
      return d2.id;
    }).join(function(enter) {
      return enter.append("path").each(function(datum, index2) {
        var lineStyle = getCallbackValue(getPrimitiveAttributes(__assign({ d: datum.d }, style)), [datum, index2, lines]);
        this.attr(__assign({ class: CLASS_NAMES4.line.name, stroke: "#D9D9D9", lineWidth: 1, lineDash: [4, 4], isBillboard }, lineStyle));
      });
    }, function(update) {
      return update.transition(function(datum, index2) {
        var lineStyle = getCallbackValue(getPrimitiveAttributes(__assign({ d: datum.d }, style)), [datum, index2, lines]);
        return transition(this, lineStyle, animate2.update);
      });
    }, function(exit) {
      return exit.transition(function() {
        var _this2 = this;
        var animation = fadeOut_default(this, animate2.exit);
        onAnimateFinished(animation, function() {
          return _this2.remove();
        });
        return animation;
      });
    }).transitions();
  }
  function renderAlternateRegion(container, data2, style) {
    var animate2 = style.animate, connect = style.connect, areaFill = style.areaFill;
    if (data2.length < 2 || !areaFill || !connect)
      return [];
    var colors = Array.isArray(areaFill) ? areaFill : [areaFill, "transparent"];
    var getColor2 = function(idx2) {
      return colors[idx2 % colors.length];
    };
    var regions = [];
    for (var idx = 0; idx < data2.length - 1; idx++) {
      var _a2 = __read([data2[idx].points, data2[idx + 1].points], 2), prev = _a2[0], curr = _a2[1];
      var path = connectPaths(prev, curr, style);
      regions.push({ d: path, fill: getColor2(idx) });
    }
    return container.selectAll(CLASS_NAMES4.region.class).data(regions, function(_2, i) {
      return i;
    }).join(function(enter) {
      return enter.append("path").each(function(datum, index2) {
        var regionStyle = getCallbackValue(datum, [datum, index2, regions]);
        this.attr(regionStyle);
      }).attr("className", CLASS_NAMES4.region.name);
    }, function(update) {
      return update.transition(function(datum, index2) {
        var regionStyle = getCallbackValue(datum, [datum, index2, regions]);
        return transition(this, regionStyle, animate2.update);
      });
    }, function(exit) {
      return exit.transition(function() {
        var _this2 = this;
        var animation = fadeOut_default(this, animate2.exit);
        onAnimateFinished(animation, function() {
          return _this2.remove();
        });
        return animation;
      });
    }).transitions();
  }
  function getData(attr2) {
    var _a2 = attr2.data, data2 = _a2 === void 0 ? [] : _a2, closed = attr2.closed;
    if (!closed)
      return data2;
    return data2.map(function(datum) {
      var points = datum.points;
      var _a3 = __read(points, 1), start = _a3[0];
      return __assign(__assign({}, datum), { points: __spreadArray(__spreadArray([], __read(points), false), [start], false) });
    });
  }
  var Grid2 = (
    /** @class */
    (function(_super) {
      __extends(Grid3, _super);
      function Grid3() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Grid3.prototype.render = function(attributes, container) {
        var type = attributes.type, center = attributes.center, areaFill = attributes.areaFill, closed = attributes.closed, style = __rest(attributes, ["type", "center", "areaFill", "closed"]);
        var data2 = getData(attributes);
        var lineGroup = select(container).maybeAppendByClassName(CLASS_NAMES4.lineGroup, "g");
        var regionGroup = select(container).maybeAppendByClassName(CLASS_NAMES4.regionGroup, "g");
        var lineTransitions = renderGridLine(lineGroup, data2, attributes, style);
        var reigionTransitions = renderAlternateRegion(regionGroup, data2, attributes);
        return __spreadArray(__spreadArray([], __read(lineTransitions), false), __read(reigionTransitions), false);
      };
      return Grid3;
    })(Component)
  );

  // node_modules/@antv/component/esm/ui/axis/guides/line.js
  init_tslib_es6();
  var import_util152 = __toESM(require_lib());

  // node_modules/@antv/component/esm/ui/axis/guides/utils.js
  init_tslib_es6();
  var import_util150 = __toESM(require_lib());
  function getCallbackStyle(style, params) {
    return Object.fromEntries(Object.entries(style).map(function(_a2) {
      var _b = __read(_a2, 2), key = _b[0], val = _b[1];
      return [key, getCallbackValue(val, params)];
    }));
  }
  function filterExec(data2, filter) {
    return !!filter && (0, import_util150.isFunction)(filter) ? data2.filter(filter) : data2;
  }
  function getLineAngle(value, attr2) {
    var startAngle = attr2.startAngle, endAngle = attr2.endAngle;
    return (endAngle - startAngle) * value + startAngle;
  }
  function getLineTangentVector(value, attr2) {
    if (attr2.type === "linear") {
      var _a2 = __read(attr2.startPos, 2), startX = _a2[0], startY = _a2[1], _b = __read(attr2.endPos, 2), endX = _b[0], endY = _b[1];
      var _c = __read([endX - startX, endY - startY], 2), dx = _c[0], dy = _c[1];
      return normalize3([dx, dy]);
    }
    var angle2 = degToRad(getLineAngle(value, attr2));
    return [-Math.sin(angle2), Math.cos(angle2)];
  }
  function getDirectionVector(value, direction2, attr2) {
    var tangentVector = getLineTangentVector(value, attr2);
    return vertical(tangentVector, direction2 !== "positive");
  }
  function getLabelVector(value, attr2) {
    return getDirectionVector(value, attr2.labelDirection, attr2);
  }

  // node_modules/@antv/component/esm/ui/axis/guides/line.js
  function getLinearValuePos(value, attr2) {
    var _a2 = __read(attr2.startPos, 2), sx = _a2[0], sy = _a2[1], _b = __read(attr2.endPos, 2), ex = _b[0], ey = _b[1];
    var _c = __read([ex - sx, ey - sy], 2), dx = _c[0], dy = _c[1];
    return [sx + dx * value, sy + dy * value];
  }
  function getArcValuePos(value, attr2) {
    var radius = attr2.radius, _a2 = __read(attr2.center, 2), cx = _a2[0], cy = _a2[1];
    var angle2 = degToRad(getLineAngle(value, attr2));
    return [cx + radius * Math.cos(angle2), cy + radius * Math.sin(angle2)];
  }
  function getValuePos(value, attr2) {
    if (attr2.type === "linear")
      return getLinearValuePos(value, attr2);
    return getArcValuePos(value, attr2);
  }
  function isAxisHorizontal(attr2) {
    return getLineTangentVector(0, attr2)[1] === 0;
  }
  function isAxisVertical(attr2) {
    return getLineTangentVector(0, attr2)[0] === 0;
  }
  function isCircle2(startAngle, endAngle) {
    return endAngle - startAngle === 360;
  }
  function getArcPath(startAngle, endAngle, cx, cy, radius) {
    var diffAngle = endAngle - startAngle;
    var _a2 = __read([radius, radius], 2), rx = _a2[0], ry = _a2[1];
    var _b = __read([degToRad(startAngle), degToRad(endAngle)], 2), startAngleRadians = _b[0], endAngleRadians = _b[1];
    var getPosByAngle = function(angle2) {
      return [cx + radius * Math.cos(angle2), cy + radius * Math.sin(angle2)];
    };
    var _c = __read(getPosByAngle(startAngleRadians), 2), x1 = _c[0], y1 = _c[1];
    var _d = __read(getPosByAngle(endAngleRadians), 2), x22 = _d[0], y22 = _d[1];
    if (isCircle2(startAngle, endAngle)) {
      var middleAngleRadians = (endAngleRadians + startAngleRadians) / 2;
      var _e = __read(getPosByAngle(middleAngleRadians), 2), xm = _e[0], ym = _e[1];
      return [
        ["M", x1, y1],
        ["A", rx, ry, 0, 1, 0, xm, ym],
        ["A", rx, ry, 0, 1, 0, x22, y22]
      ];
    }
    var large2 = diffAngle > 180 ? 1 : 0;
    var sweep = startAngle > endAngle ? 0 : 1;
    var isClosePath = false;
    return isClosePath ? "M".concat(cx, ",").concat(cy, ",L").concat(x1, ",").concat(y1, ",A").concat(rx, ",").concat(ry, ",0,").concat(large2, ",").concat(sweep, ",").concat(x22, ",").concat(y22, ",L").concat(cx, ",").concat(cy) : "M".concat(x1, ",").concat(y1, ",A").concat(rx, ",").concat(ry, ",0,").concat(large2, ",").concat(sweep, ",").concat(x22, ",").concat(y22);
  }
  function getArcAttr(arc2) {
    var _a2 = arc2.attributes, startAngle = _a2.startAngle, endAngle = _a2.endAngle, center = _a2.center, radius = _a2.radius;
    return __spreadArray(__spreadArray([startAngle, endAngle], __read(center), false), [radius], false);
  }
  function renderArc(container, attr2, style, animate2) {
    var startAngle = attr2.startAngle, endAngle = attr2.endAngle, center = attr2.center, radius = attr2.radius;
    return container.selectAll(CLASS_NAMES3.line.class).data([{ d: getArcPath.apply(void 0, __spreadArray(__spreadArray([startAngle, endAngle], __read(center), false), [radius], false)) }], function(d2, i) {
      return i;
    }).join(function(enter) {
      return enter.append("path").attr("className", CLASS_NAMES3.line.name).styles(attr2).styles({ d: function(d2) {
        return d2.d;
      } });
    }, function(update) {
      return update.transition(function() {
        var _this2 = this;
        var animation = keyframeInterpolate(this, getArcAttr(this), __spreadArray(__spreadArray([startAngle, endAngle], __read(center), false), [radius], false), animate2.update);
        if (animation) {
          var layout2 = function() {
            var data2 = (0, import_util152.get)(_this2.attributes, "__keyframe_data__");
            _this2.style.d = getArcPath.apply(void 0, __spreadArray([], __read(data2), false));
          };
          animation.onframe = layout2;
          animation.onfinish = layout2;
        }
        return animation;
      }).styles(attr2);
    }, function(exit) {
      return exit.remove();
    }).styles(style).transitions();
  }
  function renderTruncation(container, _a2) {
    var truncRange = _a2.truncRange, truncShape = _a2.truncShape, lineExtension = _a2.lineExtension;
  }
  function extendLine(startPos, endPos, range) {
    if (range === void 0) {
      range = [0, 0];
    }
    var _a2 = __read([startPos, endPos, range], 3), _b = __read(_a2[0], 2), x1 = _b[0], y1 = _b[1], _c = __read(_a2[1], 2), x22 = _c[0], y22 = _c[1], _d = __read(_a2[2], 2), l1 = _d[0], l2 = _d[1];
    var _e = __read([x22 - x1, y22 - y1], 2), x3 = _e[0], y3 = _e[1];
    var L = Math.sqrt(Math.pow(x3, 2) + Math.pow(y3, 2));
    var _f = __read([-l1 / L, l2 / L], 2), s1 = _f[0], s2 = _f[1];
    return [s1 * x3, s1 * y3, s2 * x3, s2 * y3];
  }
  function getLinePath2(points) {
    var _a2 = __read(points, 2), _b = __read(_a2[0], 2), x1 = _b[0], y1 = _b[1], _c = __read(_a2[1], 2), x22 = _c[0], y22 = _c[1];
    return { x1, y1, x2: x22, y2: y22 };
  }
  function renderLinear(container, attr2, style, animate2) {
    var showTrunc = attr2.showTrunc, startPos = attr2.startPos, endPos = attr2.endPos, truncRange = attr2.truncRange, lineExtension = attr2.lineExtension;
    var _a2 = __read([startPos, endPos], 2), _b = __read(_a2[0], 2), x1 = _b[0], y1 = _b[1], _c = __read(_a2[1], 2), x22 = _c[0], y22 = _c[1];
    var _d = __read(lineExtension ? extendLine(startPos, endPos, lineExtension) : new Array(4).fill(0), 4), ox1 = _d[0], oy1 = _d[1], ox2 = _d[2], oy2 = _d[3];
    var renderLine = function(data2) {
      return container.selectAll(CLASS_NAMES3.line.class).data(data2, function(d2, i) {
        return i;
      }).join(function(enter) {
        return enter.append("line").attr("className", function(d2) {
          return "".concat(CLASS_NAMES3.line.name, " ").concat(d2.className);
        }).styles(style).transition(function(d2) {
          return transition(this, getLinePath2(d2.line), false);
        });
      }, function(update) {
        return update.styles(style).transition(function(_a3) {
          var line2 = _a3.line;
          return transition(this, getLinePath2(line2), animate2.update);
        });
      }, function(exit) {
        return exit.remove();
      }).transitions();
    };
    if (!showTrunc || !truncRange) {
      return renderLine([
        {
          line: [
            [x1 + ox1, y1 + oy1],
            [x22 + ox2, y22 + oy2]
          ],
          className: CLASS_NAMES3.line.name
        }
      ]);
    }
    var _e = __read(truncRange, 2), r1 = _e[0], r2 = _e[1];
    var dx = x22 - x1;
    var dy = y22 - y1;
    var _f = __read([x1 + dx * r1, y1 + dy * r1], 2), x3 = _f[0], y3 = _f[1];
    var _g = __read([x1 + dx * r2, y1 + dy * r2], 2), x4 = _g[0], y4 = _g[1];
    var animation = renderLine([
      {
        line: [
          [x1 + ox1, y1 + oy1],
          [x3, y3]
        ],
        className: CLASS_NAMES3.lineFirst.name
      },
      {
        line: [
          [x4, y4],
          [x22 + ox2, y22 + oy2]
        ],
        className: CLASS_NAMES3.lineSecond.name
      }
    ]);
    renderTruncation(container, attr2);
    return animation;
  }
  function renderAxisArrow(container, type, attr2, style) {
    var showArrow = attr2.showArrow, showTrunc = attr2.showTrunc, lineArrow = attr2.lineArrow, lineArrowOffset = attr2.lineArrowOffset, lineArrowSize = attr2.lineArrowSize;
    var shapeToAddArrow;
    if (type === "arc")
      shapeToAddArrow = container.select(CLASS_NAMES3.line.class);
    else if (showTrunc)
      shapeToAddArrow = container.select(CLASS_NAMES3.lineSecond.class);
    else
      shapeToAddArrow = container.select(CLASS_NAMES3.line.class);
    if (!showArrow || !lineArrow || attr2.type === "arc" && isCircle2(attr2.startAngle, attr2.endAngle)) {
      var node = shapeToAddArrow.node();
      if (node)
        node.style.markerEnd = void 0;
      return;
    }
    var arrow2 = renderExtDo(lineArrow);
    arrow2.attr(style);
    scaleToPixel(arrow2, lineArrowSize, true);
    shapeToAddArrow.style("markerEnd", arrow2).style("markerEndOffset", -lineArrowOffset);
  }
  function renderAxisLine(container, attr2, animate2) {
    var type = attr2.type;
    var animation;
    var style = subStyleProps2(attr2, "line");
    if (type === "linear")
      animation = renderLinear(container, attr2, omit2(style, "arrow"), animate2);
    else
      animation = renderArc(container, attr2, omit2(style, "arrow"), animate2);
    renderAxisArrow(container, type, attr2, style);
    return animation;
  }

  // node_modules/@antv/component/esm/ui/axis/guides/grid.js
  function getGridVector(value, attr2) {
    return getDirectionVector(value, attr2.gridDirection, attr2);
  }
  function getGridCenter(attr2) {
    var type = attr2.type, gridCenter = attr2.gridCenter;
    if (type === "linear")
      return gridCenter;
    return gridCenter || attr2.center;
  }
  function renderStraight(data2, attr2) {
    var gridLength = attr2.gridLength;
    return data2.map(function(_a2, index2) {
      var value = _a2.value;
      var _b = __read(getValuePos(value, attr2), 2), x3 = _b[0], y3 = _b[1];
      var _c = __read(scale3(getGridVector(value, attr2), gridLength), 2), dx = _c[0], dy = _c[1];
      return {
        id: index2,
        points: [
          [x3, y3],
          [x3 + dx, y3 + dy]
        ]
      };
    });
  }
  function renderSurround(data2, attr2) {
    var controlAngles = attr2.gridControlAngles;
    var center = getGridCenter(attr2);
    if (!center)
      throw new Error("grid center is not provide");
    if (data2.length < 2)
      throw new Error("Invalid grid data");
    if (!controlAngles || controlAngles.length === 0)
      throw new Error("Invalid gridControlAngles");
    var _a2 = __read(center, 2), cx = _a2[0], cy = _a2[1];
    return data2.map(function(_a3, index2) {
      var value = _a3.value;
      var _b = __read(getValuePos(value, attr2), 2), sx = _b[0], sy = _b[1];
      var _c = __read([sx - cx, sy - cy], 2), dx = _c[0], dy = _c[1];
      var points = [];
      controlAngles.forEach(function(angle2) {
        var angleInRad = degToRad(angle2);
        var _a4 = __read([Math.cos(angleInRad), Math.sin(angleInRad)], 2), cosa = _a4[0], sina = _a4[1];
        var x3 = dx * cosa - dy * sina + cx;
        var y3 = dx * sina + dy * cosa + cy;
        points.push([x3, y3]);
      });
      return { points, id: index2 };
    });
  }
  function renderGrid(container, data2, attr2, animate2) {
    var gridAttr = subStyleProps2(attr2, "grid");
    var type = gridAttr.type, areaFill = gridAttr.areaFill;
    var center = getGridCenter(attr2);
    var finalData = filterExec(data2, attr2.gridFilter);
    var gridItems = type === "segment" ? renderStraight(finalData, attr2) : renderSurround(finalData, attr2);
    var style = __assign(__assign({}, gridAttr), { center, areaFill: (0, import_util154.isFunction)(areaFill) ? finalData.map(function(datum, index2) {
      return getCallbackValue(areaFill, [datum, index2, finalData]);
    }) : areaFill, animate: animate2, data: gridItems });
    return container.selectAll(CLASS_NAMES3.grid.class).data([1]).join(function(enter) {
      return enter.append(function() {
        return new Grid2({ style });
      }).attr("className", CLASS_NAMES3.grid.name);
    }, function(update) {
      return update.transition(function() {
        return this.update(style);
      });
    }, function(exit) {
      return exit.remove();
    }).transitions();
  }

  // node_modules/@antv/component/esm/ui/axis/guides/labels.js
  init_tslib_es6();
  var import_util163 = __toESM(require_lib());

  // node_modules/@antv/component/esm/ui/axis/overlap/autoEllipsis.js
  init_tslib_es6();
  var import_util158 = __toESM(require_lib());

  // node_modules/@antv/component/esm/ui/axis/utils/test.js
  init_tslib_es6();

  // node_modules/@antv/component/esm/ui/axis/utils/bounds.js
  init_tslib_es6();
  var Bounds = (
    /** @class */
    (function() {
      function Bounds2(x1, y1, x22, y22) {
        this.set(x1, y1, x22, y22);
      }
      Object.defineProperty(Bounds2.prototype, "left", {
        get: function() {
          return this.x1;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Bounds2.prototype, "top", {
        get: function() {
          return this.y1;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Bounds2.prototype, "right", {
        get: function() {
          return this.x2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Bounds2.prototype, "bottom", {
        get: function() {
          return this.y2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Bounds2.prototype, "width", {
        get: function() {
          return this.defined("x2") && this.defined("x1") ? this.x2 - this.x1 : void 0;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Bounds2.prototype, "height", {
        get: function() {
          return this.defined("y2") && this.defined("y1") ? this.y2 - this.y1 : void 0;
        },
        enumerable: false,
        configurable: true
      });
      Bounds2.prototype.rotatedPoints = function(radian, x3, y3) {
        var _a2 = this, x1 = _a2.x1, y1 = _a2.y1, x22 = _a2.x2, y22 = _a2.y2;
        var cos = Math.cos(radian);
        var sin = Math.sin(radian);
        var cx = x3 - x3 * cos + y3 * sin;
        var cy = y3 - x3 * sin - y3 * cos;
        var points = [
          [cos * x1 - sin * y22 + cx, sin * x1 + cos * y22 + cy],
          [cos * x22 - sin * y22 + cx, sin * x22 + cos * y22 + cy],
          [cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy],
          [cos * x22 - sin * y1 + cx, sin * x22 + cos * y1 + cy]
        ];
        return points;
      };
      Bounds2.prototype.set = function(x1, y1, x22, y22) {
        if (x22 < x1) {
          this.x2 = x1;
          this.x1 = x22;
        } else {
          this.x1 = x1;
          this.x2 = x22;
        }
        if (y22 < y1) {
          this.y2 = y1;
          this.y1 = y22;
        } else {
          this.y1 = y1;
          this.y2 = y22;
        }
        return this;
      };
      Bounds2.prototype.defined = function(key) {
        return this[key] !== Number.MAX_VALUE && this[key] !== -Number.MAX_VALUE;
      };
      return Bounds2;
    })()
  );
  function getBounds(item, margin) {
    var angle2 = item.getEulerAngles() || 0;
    item.setEulerAngles(0);
    var _a2 = item.getBounds(), _b = __read(_a2.min, 2), x3 = _b[0], y3 = _b[1], _c = __read(_a2.max, 2), right = _c[0], bottom = _c[1];
    var _d = item.getBBox(), w = _d.width, h = _d.height;
    var height = h;
    var dx = 0;
    var dy = 0;
    var anchorX = x3;
    var anchorY = y3;
    var text = textOf(item);
    if (text) {
      height -= 1.5;
      var a2 = text.style.textAlign;
      var b_1 = text.style.textBaseline;
      if (a2 === "center") {
        anchorX = (x3 + right) / 2;
      } else if (a2 === "right" || a2 === "end") {
        anchorX = right;
      } else {
      }
      if (b_1 === "middle") {
        anchorY = (y3 + bottom) / 2;
      } else if (b_1 === "bottom") {
        anchorY = bottom;
      }
    }
    var _e = __read(parseSeriesAttr(margin), 4), _f = _e[0], t = _f === void 0 ? 0 : _f, _g = _e[1], r = _g === void 0 ? 0 : _g, _h = _e[2], b = _h === void 0 ? t : _h, _j = _e[3], l = _j === void 0 ? r : _j;
    var bounds = new Bounds((dx += x3) - l, (dy += y3) - t, dx + w + r, dy + height + b);
    item.setEulerAngles(angle2);
    return bounds.rotatedPoints(degToRad(angle2), anchorX, anchorY);
  }

  // node_modules/@antv/component/esm/ui/axis/utils/contain.js
  function onLine(line2, point4) {
    return point4[0] <= Math.max(line2[0][0], line2[1][0]) && point4[0] <= Math.min(line2[0][0], line2[1][0]) && point4[1] <= Math.max(line2[0][1], line2[1][1]) && point4[1] <= Math.min(line2[0][1], line2[1][1]);
  }
  function direction(a2, b, c2) {
    var val = (b[1] - a2[1]) * (c2[0] - b[0]) - (b[0] - a2[0]) * (c2[1] - b[1]);
    if (val === 0)
      return 0;
    return val < 0 ? 2 : 1;
  }
  function isIntersect(line1, line2) {
    var dir1 = direction(line1[0], line1[1], line2[0]);
    var dir2 = direction(line1[0], line1[1], line2[1]);
    var dir3 = direction(line2[0], line2[1], line1[0]);
    var dir4 = direction(line2[0], line2[1], line1[1]);
    if (dir1 !== dir2 && dir3 !== dir4)
      return true;
    if (dir1 === 0 && onLine(line1, line2[0]))
      return true;
    if (dir2 === 0 && onLine(line1, line2[1]))
      return true;
    if (dir3 === 0 && onLine(line2, line1[0]))
      return true;
    if (dir4 === 0 && onLine(line2, line1[1]))
      return true;
    return false;
  }
  function isPointInsideRectangle(polygon, point4) {
    var n = polygon.length;
    if (n < 3)
      return false;
    var lineToInfinity = [point4, [9999, point4[1]]];
    var count = 0;
    var i = 0;
    do {
      var side = [polygon[i], polygon[(i + 1) % n]];
      if (isIntersect(side, lineToInfinity)) {
        if (direction(side[0], point4, side[1]) === 0)
          return onLine(side, point4);
        count++;
      }
      i = (i + 1) % n;
    } while (i !== 0);
    return !!(count & 1);
  }
  function isRectangleBInsideA(rectA, rectB) {
    return rectB.every(function(point4) {
      return isPointInsideRectangle(rectA, point4);
    });
  }
  function contain(container, child, margin) {
    var x1 = container.x1, x22 = container.x2, y1 = container.y1, y22 = container.y2;
    var parent = [
      [x1, y1],
      [x22, y1],
      [x22, y22],
      [x1, y22]
    ];
    var element = getBounds(child, margin);
    return isRectangleBInsideA(parent, element);
  }

  // node_modules/@antv/component/esm/ui/axis/utils/intersect.js
  init_tslib_es6();
  function lineToLine(line1, line2) {
    var _a2 = __read(line1, 4), x0 = _a2[0], y0 = _a2[1], x1 = _a2[2], y1 = _a2[3];
    var _b = __read(line2, 4), x22 = _b[0], y22 = _b[1], x3 = _b[2], y3 = _b[3];
    var s10x = x1 - x0;
    var s10y = y1 - y0;
    var s32x = x3 - x22;
    var s32y = y3 - y22;
    var denom = s10x * s32y - s32x * s10y;
    if (denom === 0)
      return false;
    var denomPositive = denom > 0;
    var s02x = x0 - x22;
    var s02y = y0 - y22;
    var sNum = s10x * s02y - s10y * s02x;
    if (sNum < 0 === denomPositive)
      return false;
    var tNum = s32x * s02y - s32y * s02x;
    if (tNum < 0 === denomPositive)
      return false;
    if (sNum > denom === denomPositive || tNum > denom === denomPositive)
      return false;
    return true;
  }
  function intersectBoxLine(box2, line2) {
    var lines = [
      [box2[0], box2[1], box2[2], box2[3]],
      [box2[2], box2[3], box2[4], box2[5]],
      [box2[4], box2[5], box2[6], box2[7]],
      [box2[6], box2[7], box2[0], box2[1]]
    ];
    return lines.some(function(boxLine) {
      return lineToLine(line2, boxLine);
    });
  }
  function intersect(a2, b, margin) {
    var e_1, _a2;
    var p = getBounds(a2, margin).flat(1);
    var q = getBounds(b, margin).flat(1);
    var linesP = [
      [p[0], p[1], p[2], p[3]],
      [p[0], p[1], p[4], p[5]],
      [p[4], p[5], p[6], p[7]],
      [p[2], p[3], p[6], p[7]]
    ];
    try {
      for (var linesP_1 = __values(linesP), linesP_1_1 = linesP_1.next(); !linesP_1_1.done; linesP_1_1 = linesP_1.next()) {
        var line2 = linesP_1_1.value;
        if (intersectBoxLine(q, line2))
          return true;
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (linesP_1_1 && !linesP_1_1.done && (_a2 = linesP_1.return)) _a2.call(linesP_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    return false;
  }

  // node_modules/@antv/component/esm/ui/axis/utils/test.js
  function createCrossBBox(attr2, padding) {
    var type = attr2.type, labelDirection = attr2.labelDirection, crossSize = attr2.crossSize;
    if (!crossSize)
      return false;
    if (type === "arc") {
      var center = attr2.center, radius = attr2.radius;
      var _a2 = __read(center, 2), cx = _a2[0], cy = _a2[1];
      var size2 = labelDirection === "negative" ? 0 : crossSize;
      var dMin = -radius - size2;
      var dMax = radius + size2;
      var _b = __read(parseSeriesAttr(padding), 4), top_1 = _b[0], right_1 = _b[1], bottom_1 = _b[2], left_1 = _b[3];
      return new Bounds(cx + dMin - left_1, cy + dMin - top_1, cx + dMax + right_1, cy + dMax + bottom_1);
    }
    var _c = __read(attr2.startPos, 2), sx = _c[0], sy = _c[1], _d = __read(attr2.endPos, 2), ex = _d[0], ey = _d[1];
    var _e = __read(isAxisVertical(attr2) ? [-padding, 0, padding, 0] : [0, padding, 0, -padding], 4), top = _e[0], right = _e[1], bottom = _e[2], left = _e[3];
    var labelVector = getLabelVector(0, attr2);
    var diff = scale3(labelVector, crossSize);
    var bbox = new Bounds(sx, sy, ex, ey);
    bbox.x1 += left;
    bbox.y1 += top;
    bbox.x2 += right + diff[0];
    bbox.y2 += bottom + diff[1];
    return bbox;
  }
  function boundTest(items, attr2, margin) {
    var e_1, _a2;
    var crossPadding = attr2.crossPadding;
    var resultSet = /* @__PURE__ */ new Set();
    var prev = null;
    var crossBBox = createCrossBBox(attr2, crossPadding);
    var testContain = function(item) {
      if (crossBBox)
        return contain(crossBBox, item);
      return true;
    };
    var testIntersect = function(prevItem, currItem) {
      if (!prevItem || !prevItem.firstChild)
        return true;
      return !intersect(prevItem.firstChild, currItem.firstChild, parseSeriesAttr(margin));
    };
    try {
      for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
        var curr = items_1_1.value;
        if (!testContain(curr)) {
          resultSet.add(curr);
        } else if (!prev || testIntersect(prev, curr)) {
          prev = curr;
        } else {
          resultSet.add(prev);
          resultSet.add(curr);
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (items_1_1 && !items_1_1.done && (_a2 = items_1.return)) _a2.call(items_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    return Array.from(resultSet);
  }

  // node_modules/@antv/component/esm/ui/axis/overlap/autoEllipsis.js
  function parseLengthString(str, font) {
    if (font === void 0) {
      font = {};
    }
    if ((0, import_util158.isNil)(str))
      return 0;
    if (typeof str === "number")
      return str;
    return Math.floor(measureTextWidth(str, font));
  }
  function ellipseLabels(labels, overlapCfg, attr2, utils) {
    if (labels.length <= 0)
      return;
    var _a2 = overlapCfg.suffix, suffix = _a2 === void 0 ? "..." : _a2, minLength = overlapCfg.minLength, _b = overlapCfg.maxLength, maxLength = _b === void 0 ? Infinity : _b, _c = overlapCfg.step, ellipsisStep = _c === void 0 ? " " : _c, _d = overlapCfg.margin, margin = _d === void 0 ? [0, 0, 0, 0] : _d;
    var font = getFont(utils.getTextShape(labels[0]));
    var step2 = parseLengthString(ellipsisStep, font);
    var min4 = minLength ? parseLengthString(minLength, font) : step2;
    var max4 = parseLengthString(maxLength, font);
    if ((0, import_util158.isNil)(max4) || max4 === Infinity) {
      max4 = Math.max.apply(null, labels.map(function(d2) {
        return d2.getBBox().width;
      }));
    }
    var source = labels.slice();
    var _e = __read(margin, 4), _f = _e[0], top = _f === void 0 ? 0 : _f, _g = _e[1], right = _g === void 0 ? 0 : _g, _h = _e[2], bottom = _h === void 0 ? top : _h, _j = _e[3], left = _j === void 0 ? right : _j;
    var _loop_1 = function(allowedLength2) {
      source.forEach(function(label) {
        utils.ellipsis(utils.getTextShape(label), allowedLength2, suffix);
      });
      source = boundTest(labels, attr2, margin);
      if (source.length < 1)
        return { value: void 0 };
    };
    for (var allowedLength = max4; allowedLength > min4 + step2; allowedLength -= step2) {
      var state_1 = _loop_1(allowedLength);
      if (typeof state_1 === "object")
        return state_1.value;
    }
  }

  // node_modules/@antv/component/esm/ui/axis/overlap/autoHide.js
  init_tslib_es6();
  var methods = {
    parity: function(items, _a2) {
      var _b = _a2.seq, seq = _b === void 0 ? 2 : _b;
      return items.filter(function(item, i) {
        return i % seq ? (hide(item), false) : true;
      });
    }
  };
  var filterDefined = function(arr) {
    return arr.filter(defined);
  };
  function hideLabels(labels, overlapCfg, attr2, utils) {
    var count = labels.length;
    var keepHeader = overlapCfg.keepHeader, keepTail = overlapCfg.keepTail;
    if (count <= 1 || count === 2 && keepHeader && keepTail)
      return;
    var parityHide = methods.parity;
    var reset = function(els) {
      return els.forEach(utils.show), els;
    };
    var seq = 2;
    var source = labels.slice();
    var target = labels.slice();
    var minLabelWidth = Math.min.apply(Math, __spreadArray([1], __read(labels.map(function(d2) {
      return d2.getBBox().width;
    })), false));
    if (attr2.type === "linear" && (isAxisHorizontal(attr2) || isAxisVertical(attr2))) {
      var minX = getLocalBBox(labels[0]).left;
      var maxX = getLocalBBox(labels[count - 1]).right;
      var distance6 = Math.abs(maxX - minX) || 1;
      seq = Math.max(Math.floor(count * minLabelWidth / distance6), seq);
    }
    var first;
    var last2;
    if (keepHeader)
      first = source.splice(0, 1)[0];
    if (keepTail) {
      last2 = source.splice(-1, 1)[0];
      source.reverse();
    }
    reset(source);
    while (seq < labels.length && boundTest(filterDefined(last2 ? __spreadArray(__spreadArray([last2], __read(target), false), [first], false) : __spreadArray([first], __read(target), false)), attr2, overlapCfg === null || overlapCfg === void 0 ? void 0 : overlapCfg.margin).length) {
      if (last2 && !first && seq % 2 === 0) {
        var rest = source.splice(0, 1);
        rest.forEach(utils.hide);
      } else if (last2 && first) {
        var rest = source.splice(0, 1);
        rest.forEach(utils.hide);
      }
      target = parityHide(reset(source), { seq });
      seq++;
    }
  }

  // node_modules/@antv/component/esm/ui/axis/overlap/autoRotate.js
  init_tslib_es6();
  function rotateLabels(labels, overlapCfg, attr2, utils) {
    var e_1, _a2;
    var _b = overlapCfg.optionalAngles, optionalAngles = _b === void 0 ? [0, 45, 90] : _b, margin = overlapCfg.margin, _c = overlapCfg.recoverWhenFailed, recoverWhenFailed = _c === void 0 ? true : _c;
    var defaultAngles = labels.map(function(label) {
      return label.getLocalEulerAngles();
    });
    var runAndPassed = function() {
      return boundTest(labels, attr2, margin).length < 1;
    };
    var setLabelsRotate = function(angle3) {
      return labels.forEach(function(label, index2) {
        var rotate3 = Array.isArray(angle3) ? angle3[index2] : angle3;
        utils.rotate(label, +rotate3);
      });
    };
    try {
      for (var optionalAngles_1 = __values(optionalAngles), optionalAngles_1_1 = optionalAngles_1.next(); !optionalAngles_1_1.done; optionalAngles_1_1 = optionalAngles_1.next()) {
        var angle2 = optionalAngles_1_1.value;
        setLabelsRotate(angle2);
        if (runAndPassed())
          return;
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (optionalAngles_1_1 && !optionalAngles_1_1.done && (_a2 = optionalAngles_1.return)) _a2.call(optionalAngles_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    if (recoverWhenFailed) {
      setLabelsRotate(defaultAngles);
    }
  }

  // node_modules/@antv/component/esm/ui/axis/overlap/autoWrap.js
  init_tslib_es6();
  function inferTextBaseline(attr2) {
    var type = attr2.type, labelDirection = attr2.labelDirection;
    if (type === "linear" && isAxisHorizontal(attr2)) {
      return labelDirection === "negative" ? "bottom" : "top";
    }
    return "middle";
  }
  function wrapLabels(labels, overlapCfg, attr2, utils, main) {
    var _a2;
    var _b = overlapCfg.maxLines, maxLines = _b === void 0 ? 3 : _b, _c = overlapCfg.recoverWhenFailed, recoverWhenFailed = _c === void 0 ? true : _c, _d = overlapCfg.margin, margin = _d === void 0 ? [0, 0, 0, 0] : _d;
    var wordWrapWidth = getCallbackValue((_a2 = overlapCfg.wordWrapWidth) !== null && _a2 !== void 0 ? _a2 : 50, [main]);
    var defaultLines = labels.map(function(label) {
      return label.attr("maxLines") || 1;
    });
    var minLines = Math.min.apply(Math, __spreadArray([], __read(defaultLines), false));
    var runAndPassed = function() {
      return boundTest(labels, attr2, margin).length < 1;
    };
    var textBaseline = inferTextBaseline(attr2);
    var setLabelsWrap = function(lines2) {
      return labels.forEach(function(label, index2) {
        var maxLines2 = Array.isArray(lines2) ? lines2[index2] : lines2;
        utils.wrap(label, wordWrapWidth, maxLines2, textBaseline);
      });
    };
    if (minLines > maxLines)
      return;
    if (attr2.type === "linear" && isAxisHorizontal(attr2)) {
      setLabelsWrap(maxLines);
      if (runAndPassed()) {
        return;
      }
    } else {
      for (var lines = minLines; lines <= maxLines; lines++) {
        setLabelsWrap(lines);
        if (runAndPassed())
          return;
      }
    }
    if (recoverWhenFailed) {
      setLabelsWrap(defaultLines);
    }
  }

  // node_modules/@antv/component/esm/ui/axis/overlap/index.js
  var OverlapUtils = /* @__PURE__ */ new Map([
    ["hide", hideLabels],
    ["rotate", rotateLabels],
    ["ellipsis", ellipseLabels],
    ["wrap", wrapLabels]
  ]);
  function canProcessOverlap(labels, attr2, type) {
    if (attr2.labelOverlap.length < 1)
      return false;
    if (type === "hide")
      return !isInOffscreenGroup(labels[0]);
    if (type === "rotate")
      return !labels.some(function(label) {
        var _a2;
        return !!((_a2 = label.attr("transform")) === null || _a2 === void 0 ? void 0 : _a2.includes("rotate"));
      });
    if (type === "ellipsis" || type === "wrap")
      return labels.filter(function(item) {
        return item.querySelector("text");
      }).length >= 1;
    return true;
  }
  function processOverlap(labels, attr2, main, utils) {
    var _a2 = attr2.labelOverlap, labelOverlap = _a2 === void 0 ? [] : _a2;
    if (!labelOverlap.length)
      return;
    labelOverlap.forEach(function(overlapCfg) {
      var type = overlapCfg.type;
      var util = OverlapUtils.get(type);
      if (canProcessOverlap(labels, attr2, type))
        util === null || util === void 0 ? void 0 : util(labels, overlapCfg, attr2, utils, main);
    });
  }

  // node_modules/@antv/component/esm/ui/axis/utils/index.js
  function getFactor() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var fn = function(str) {
      return str === "positive" ? -1 : 1;
    };
    return args.reduce(function(acc, cur) {
      return acc * fn(cur);
    }, 1);
  }

  // node_modules/@antv/component/esm/ui/axis/guides/labels.js
  function angleNormalizer(angle2) {
    var normalizedAngle = angle2;
    while (normalizedAngle < 0)
      normalizedAngle += 360;
    return Math.round(normalizedAngle % 360);
  }
  function getAngle2(v1, v2) {
    var _a2 = __read(v1, 2), x1 = _a2[0], y1 = _a2[1];
    var _b = __read(v2, 2), x22 = _b[0], y22 = _b[1];
    var _c = __read([x1 * x22 + y1 * y22, x1 * y22 - y1 * x22], 2), dot4 = _c[0], det = _c[1];
    return Math.atan2(det, dot4);
  }
  function correctLabelRotation(_rotate) {
    var rotate3 = (_rotate + 360) % 180;
    if (!inRange(rotate3, -90, 90))
      rotate3 += 180;
    return rotate3;
  }
  function getLabelRotation(datum, label, attr2) {
    var _a2;
    var labelAlign = attr2.labelAlign;
    var customRotate = (_a2 = label.style.transform) === null || _a2 === void 0 ? void 0 : _a2.includes("rotate");
    if (customRotate)
      return label.getLocalEulerAngles();
    var rotate3 = 0;
    var labelVector = getLabelVector(datum.value, attr2);
    var tangentVector = getLineTangentVector(datum.value, attr2);
    if (labelAlign === "horizontal")
      return 0;
    if (labelAlign === "perpendicular")
      rotate3 = getAngle2([1, 0], labelVector);
    else
      rotate3 = getAngle2([tangentVector[0] < 0 ? -1 : 1, 0], tangentVector);
    return correctLabelRotation(radToDeg(rotate3));
  }
  function getLabelStyle(value, rotate3, attr2) {
    var type = attr2.type, labelAlign = attr2.labelAlign;
    var labelVector = getLabelVector(value, attr2);
    var labelAngle = angleNormalizer(rotate3);
    var tickAngle = angleNormalizer(radToDeg(getAngle2([1, 0], labelVector)));
    var textAlign = "center";
    var textBaseline = "middle";
    if (type === "linear") {
      if ([90, 270].includes(tickAngle) && labelAngle === 0) {
        textAlign = "center";
        textBaseline = labelVector[1] === 1 ? "top" : "bottom";
      } else if (!(tickAngle % 180) && [90, 270].includes(labelAngle)) {
        textAlign = "center";
      } else if (tickAngle === 0) {
        if (inRange(labelAngle, 0, 90, false, true)) {
          textAlign = "start";
        } else if (inRange(labelAngle, 0, 90) || inRange(labelAngle, 270, 360)) {
          textAlign = "start";
        }
      } else if (tickAngle === 90) {
        if (inRange(labelAngle, 0, 90, false, true)) {
          textAlign = "start";
        } else if (inRange(labelAngle, 90, 180) || inRange(labelAngle, 270, 360)) {
          textAlign = "end";
        }
      } else if (tickAngle === 270) {
        if (inRange(labelAngle, 0, 90, false, true)) {
          textAlign = "end";
        } else if (inRange(labelAngle, 90, 180) || inRange(labelAngle, 270, 360)) {
          textAlign = "start";
        }
      } else if (tickAngle === 180) {
        if (labelAngle === 90) {
          textAlign = "start";
        } else if (inRange(labelAngle, 0, 90) || inRange(labelAngle, 270, 360)) {
          textAlign = "end";
        }
      }
    } else {
      if (labelAlign === "parallel") {
        if (inRange(tickAngle, 0, 180, true)) {
          textBaseline = "top";
        } else {
          textBaseline = "bottom";
        }
      } else if (labelAlign === "horizontal") {
        if (inRange(tickAngle, 90, 270, false)) {
          textAlign = "end";
        } else if (inRange(tickAngle, 270, 360, false) || inRange(tickAngle, 0, 90)) {
          textAlign = "start";
        }
      } else if (labelAlign === "perpendicular") {
        if (inRange(tickAngle, 90, 270)) {
          textAlign = "end";
        } else {
          textAlign = "start";
        }
      }
    }
    return { textAlign, textBaseline };
  }
  function setRotateAndAdjustLabelAlign(rotate3, group2, attr2) {
    group2.setLocalEulerAngles(rotate3);
    var value = group2.__data__.value;
    var textStyle = getLabelStyle(value, rotate3, attr2);
    var label = group2.querySelector(CLASS_NAMES3.labelItem.class);
    if (label)
      applyTextStyle(label, textStyle);
  }
  function getLabelPos(datum, data2, attr2) {
    var showTick = attr2.showTick, tickLength = attr2.tickLength, tickDirection = attr2.tickDirection, labelDirection = attr2.labelDirection, labelSpacing = attr2.labelSpacing;
    var index2 = data2.indexOf(datum);
    var finalLabelSpacing = getCallbackValue(labelSpacing, [datum, index2, data2]);
    var _a2 = __read([getLabelVector(datum.value, attr2), getFactor(labelDirection, tickDirection)], 2), labelVector = _a2[0], unionFactor = _a2[1];
    var extraLength = unionFactor === 1 ? getCallbackValue(showTick ? tickLength : 0, [datum, index2, data2]) : 0;
    var _b = __read(add4(scale3(labelVector, finalLabelSpacing + extraLength), getValuePos(datum.value, attr2)), 2), x3 = _b[0], y3 = _b[1];
    return { x: x3, y: y3 };
  }
  function formatter(datum, index2, data2, attr2) {
    var labelFormatter2 = attr2.labelFormatter;
    var element = (0, import_util163.isFunction)(labelFormatter2) ? function() {
      return renderExtDo(getCallbackValue(labelFormatter2, [datum, index2, data2, getLabelVector(datum.value, attr2)]));
    } : function() {
      return renderExtDo(datum.label || "");
    };
    return element;
  }
  function renderHTMLLabel(datum, index2, data2, attr2) {
    var labelRender = attr2.labelRender;
    var elementWidth = ((0, import_util163.get)(attr2, "endPos.0", 400) - (0, import_util163.get)(attr2, "startPos.0", 0)) / data2.length;
    var elStr = (0, import_util163.isFunction)(labelRender) ? getCallbackValue(labelRender, [datum, index2, data2, getLabelVector(datum.value, attr2)]) : datum.label || "";
    var elementHeight = parseHeightFromHTML(elStr) || 30;
    return function() {
      return renderHtmlExtDo(elStr, {
        width: elementWidth,
        height: elementHeight
      });
    };
  }
  function applyTextStyle(node, style) {
    if (["text", "html"].includes(node.nodeName))
      node.attr(style);
  }
  function overlapHandler(attr2, main) {
    processOverlap(this.node().childNodes, attr2, main, {
      hide,
      show,
      rotate: function(label, angle2) {
        setRotateAndAdjustLabelAlign(+angle2, label, attr2);
      },
      ellipsis: function(label, len, suffix) {
        label && ellipsisIt(label, len || Infinity, suffix);
      },
      wrap: function(label, width2, lines) {
        label && wrapIt(label, width2, lines);
      },
      getTextShape: function(label) {
        return label.querySelector("text");
      }
    });
  }
  function renderLabel(container, datum, data2, style, attr2) {
    var index2 = data2.indexOf(datum);
    var labelRender = attr2.labelRender;
    var label = select(container).append(labelRender ? renderHTMLLabel(datum, index2, data2, attr2) : formatter(datum, index2, data2, attr2)).attr("className", CLASS_NAMES3.labelItem.name).node();
    var _a2 = __read(splitStyle(getCallbackStyle(style, [datum, index2, data2])), 2), labelStyle = _a2[0], _b = _a2[1], transform = _b.transform, groupStyle = __rest(_b, ["transform"]);
    percentTransform(label, transform);
    var rotate3 = getLabelRotation(datum, label, attr2);
    if (!label.getLocalEulerAngles()) {
      label.setLocalEulerAngles(rotate3);
    }
    applyTextStyle(label, __assign(__assign({}, getLabelStyle(datum.value, rotate3, attr2)), labelStyle));
    container.attr(groupStyle);
    return label;
  }
  function renderLabels(container, data2, attr2, animate2, main) {
    var finalData = filterExec(data2, attr2.labelFilter);
    var style = subStyleProps2(attr2, "label");
    var _exit;
    var transitions = container.selectAll(CLASS_NAMES3.label.class).data(finalData, function(d2, i) {
      return i;
    }).join(function(enter) {
      return enter.append("g").attr("className", CLASS_NAMES3.label.name).transition(function(datum) {
        renderLabel(this, datum, data2, style, attr2);
        var _a2 = getLabelPos(datum, data2, attr2), x3 = _a2.x, y3 = _a2.y;
        this.style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
        return null;
      });
    }, function(update) {
      return update.transition(function(datum) {
        var prevLabel = this.querySelector(CLASS_NAMES3.labelItem.class);
        var label = renderLabel(this, datum, data2, style, attr2);
        var shapeAnimation = transitionShape(prevLabel, label, animate2.update);
        var _a2 = getLabelPos(datum, data2, attr2), x3 = _a2.x, y3 = _a2.y;
        var animation = transition(this, { transform: "translate(".concat(x3, ", ").concat(y3, ")") }, animate2.update);
        return __spreadArray(__spreadArray([], __read(shapeAnimation), false), [animation], false);
      });
    }, function(exit) {
      _exit = exit;
      exit.transition(function() {
        var _this2 = this;
        var animation = fadeOut_default(this.childNodes[0], animate2.exit);
        onAnimateFinished(animation, function() {
          return select(_this2).remove();
        });
        return animation;
      });
      return _exit;
    }).transitions();
    onAnimatesFinished(transitions, function() {
      overlapHandler.call(container, attr2, main);
    });
    return transitions;
  }

  // node_modules/@antv/component/esm/ui/axis/guides/ticks.js
  init_tslib_es6();
  var import_util165 = __toESM(require_lib());
  function getTickVector(value, attr2) {
    return getDirectionVector(value, attr2.tickDirection, attr2);
  }
  function getTickPoints(unitVector, tickLength) {
    var _a2 = __read(unitVector, 2), dx = _a2[0], dy = _a2[1];
    return [
      [0, 0],
      [dx * tickLength, dy * tickLength]
    ];
  }
  function getTickLineLayout(datum, index2, data2, tickVector, attr2) {
    var tickLength = attr2.tickLength;
    var _a2 = __read(getTickPoints(tickVector, getCallbackValue(tickLength, [datum, index2, data2])), 2), _b = __read(_a2[0], 2), x1 = _b[0], y1 = _b[1], _c = __read(_a2[1], 2), x22 = _c[0], y22 = _c[1];
    return { x1, x2: x22, y1, y2: y22 };
  }
  function createTickEl(container, datum, index2, data2, attr2) {
    var formatter2 = attr2.tickFormatter;
    var tickVector = getTickVector(datum.value, attr2);
    var el = "line";
    if ((0, import_util165.isFunction)(formatter2))
      el = function() {
        return getCallbackValue(formatter2, [datum, index2, data2, tickVector]);
      };
    return container.append(el).attr("className", CLASS_NAMES3.tickItem.name);
  }
  function applyTickStyle(datum, index2, data2, tick2, group2, attr2, style) {
    var tickVector = getTickVector(datum.value, attr2);
    var _a2 = getTickLineLayout(datum, index2, data2, tickVector, attr2), x1 = _a2.x1, x22 = _a2.x2, y1 = _a2.y1, y22 = _a2.y2;
    var _b = __read(splitStyle(getCallbackStyle(style, [datum, index2, data2, tickVector])), 2), tickStyle = _b[0], groupStyle = _b[1];
    tick2.node().nodeName === "line" && tick2.styles(__assign({ x1, x2: x22, y1, y2: y22 }, tickStyle));
    group2.attr(groupStyle);
    tick2.styles(tickStyle);
  }
  function createTick(datum, index2, data2, attr2, tickAttr, animate2) {
    var tick2 = createTickEl(select(this), datum, index2, data2, attr2);
    applyTickStyle(datum, index2, data2, tick2, this, attr2, tickAttr);
    var _a2 = __read(getValuePos(datum.value, attr2), 2), x3 = _a2[0], y3 = _a2[1];
    return transition(this, { transform: "translate(".concat(x3, ", ").concat(y3, ")") }, animate2);
  }
  function renderTicks(container, axisData, attr2, animate2) {
    var finalData = filterExec(axisData, attr2.tickFilter);
    var tickAttr = subStyleProps2(attr2, "tick");
    return container.selectAll(CLASS_NAMES3.tick.class).data(finalData, function(d2) {
      return d2.id || d2.label;
    }).join(function(enter) {
      return enter.append("g").attr("className", CLASS_NAMES3.tick.name).transition(function(datum, index2) {
        return createTick.call(this, datum, index2, finalData, attr2, tickAttr, false);
      });
    }, function(update) {
      return update.transition(function(datum, index2) {
        this.removeChildren();
        return createTick.call(this, datum, index2, finalData, attr2, tickAttr, animate2.update);
      });
    }, function(exit) {
      return exit.transition(function() {
        var _this2 = this;
        var animation = fadeOut_default(this.childNodes[0], animate2.exit);
        onAnimateFinished(animation, function() {
          return _this2.remove();
        });
        return animation;
      });
    }).transitions();
  }

  // node_modules/@antv/component/esm/ui/axis/guides/title.js
  init_tslib_es6();
  function getTitlePosition(mainGroup, titleGroup, attr2) {
    var _a2 = attr2.titlePosition, position2 = _a2 === void 0 ? "lb" : _a2, spacing = attr2.titleSpacing;
    var pos = parsePosition(position2);
    var _b = mainGroup.node().getLocalBounds(), _c = __read(_b.min, 2), mainX = _c[0], mainY = _c[1], _d = __read(_b.halfExtents, 2), mainHalfWidth = _d[0], mainHalfHeight = _d[1];
    var _e = __read(titleGroup.node().getLocalBounds().halfExtents, 2), titleHalfWidth = _e[0], titleHalfHeight = _e[1];
    var _f = __read([mainX + mainHalfWidth, mainY + mainHalfHeight], 2), x3 = _f[0], y3 = _f[1];
    var _g = __read(parseSeriesAttr(spacing), 4), spacingTop = _g[0], spacingRight = _g[1], spacingBottom = _g[2], spacingLeft = _g[3];
    if (["start", "end"].includes(position2) && attr2.type === "linear") {
      var startPos = attr2.startPos, endPos = attr2.endPos;
      var _h = __read(position2 === "start" ? [startPos, endPos] : [endPos, startPos], 2), from = _h[0], to = _h[1];
      var direction2 = normalize3([-to[0] + from[0], -to[1] + from[1]]);
      var _j = __read(scale3(direction2, spacingTop), 2), dx = _j[0], dy = _j[1];
      return { x: from[0] + dx, y: from[1] + dy };
    }
    if (pos.includes("t"))
      y3 -= mainHalfHeight + titleHalfHeight + spacingTop;
    if (pos.includes("r"))
      x3 += mainHalfWidth + titleHalfWidth + spacingRight;
    if (pos.includes("l"))
      x3 -= mainHalfWidth + titleHalfWidth + spacingLeft;
    if (pos.includes("b"))
      y3 += mainHalfHeight + titleHalfHeight + spacingBottom;
    return { x: x3, y: y3 };
  }
  function inferTransform(n, direction2, position2) {
    var halfExtents = n.getGeometryBounds().halfExtents;
    var height = halfExtents[1] * 2;
    if (direction2 === "vertical") {
      if (position2 === "left")
        return "rotate(-90) translate(0, ".concat(height / 2, ")");
      if (position2 === "right")
        return "rotate(-90) translate(0, -".concat(height / 2, ")");
    }
    return "";
  }
  function applyTitleStyle(title, group2, axis, attr2, animate2) {
    var style = subStyleProps2(attr2, "title");
    var _a2 = __read(splitStyle(style), 2), titleStyle = _a2[0], _b = _a2[1], specified = _b.transform, transformOrigin = _b.transformOrigin, groupStyle = __rest(_b, ["transform", "transformOrigin"]);
    group2.styles(groupStyle);
    var transform = specified || inferTransform(title.node(), titleStyle.direction, titleStyle.position);
    title.styles(__assign(__assign({}, titleStyle), { transformOrigin }));
    percentTransform(title.node(), transform);
    var _c = getTitlePosition(
      // @ts-ignore
      select(axis._offscreen || axis.querySelector(CLASS_NAMES3.mainGroup.class)),
      group2,
      attr2
    ), x3 = _c.x, y3 = _c.y;
    var animation = transition(group2.node(), { transform: "translate(".concat(x3, ", ").concat(y3, ")") }, animate2);
    return animation;
  }
  function renderTitle(container, axis, attr2, animate2) {
    var titleText = attr2.titleText;
    return container.selectAll(CLASS_NAMES3.title.class).data([{ title: titleText }].filter(function(d2) {
      return !!d2.title;
    }), function(d2, i) {
      return d2.title;
    }).join(function(enter) {
      return enter.append(function() {
        return renderExtDo(titleText);
      }).attr("className", CLASS_NAMES3.title.name).transition(function() {
        return applyTitleStyle(select(this), container, axis, attr2, animate2.enter);
      });
    }, function(update) {
      return update.transition(function() {
        return applyTitleStyle(select(this), container, axis, attr2, animate2.update);
      });
    }, function(exit) {
      return exit.remove();
    }).transitions();
  }

  // node_modules/@antv/component/esm/ui/axis/axis.js
  function renderAxisMain(attributes, container, data2, animation) {
    var showLine = attributes.showLine, showTick = attributes.showTick, showLabel = attributes.showLabel;
    var lineGroup = container.maybeAppendByClassName(CLASS_NAMES3.lineGroup, "g");
    var lineTransitions = ifShow(showLine, lineGroup, function(group2) {
      return renderAxisLine(group2, attributes, animation);
    }) || [];
    var tickGroup = container.maybeAppendByClassName(CLASS_NAMES3.tickGroup, "g");
    var tickTransitions = ifShow(showTick, tickGroup, function(group2) {
      return renderTicks(group2, data2, attributes, animation);
    }) || [];
    var labelGroup = container.maybeAppendByClassName(CLASS_NAMES3.labelGroup, "g");
    var labelTransitions = ifShow(showLabel, labelGroup, function(group2) {
      return renderLabels(group2, data2, attributes, animation, container.node());
    }) || [];
    return __spreadArray(__spreadArray(__spreadArray([], __read(lineTransitions), false), __read(tickTransitions), false), __read(labelTransitions), false).filter(function(t) {
      return !!t;
    });
  }
  var Axis = (
    /** @class */
    (function(_super) {
      __extends(Axis2, _super);
      function Axis2(options) {
        return _super.call(this, options, AXIS_BASE_DEFAULT_ATTR) || this;
      }
      Axis2.prototype.render = function(attributes, container, specificAnimation) {
        var _this2 = this;
        var titleText = attributes.titleText, data2 = attributes.data, animate2 = attributes.animate, showTitle = attributes.showTitle, showGrid = attributes.showGrid, dataThreshold = attributes.dataThreshold, truncRange = attributes.truncRange;
        var sampledData = sampling(data2, dataThreshold).filter(function(_a2) {
          var value = _a2.value;
          if (truncRange && value > truncRange[0] && value < truncRange[1])
            return false;
          return true;
        });
        var finalAnimation = parseAnimationOption(specificAnimation === void 0 ? animate2 : specificAnimation);
        var gridGroup = select(container).maybeAppendByClassName(CLASS_NAMES3.gridGroup, "g");
        var gridTransitions = ifShow(showGrid, gridGroup, function(group2) {
          return renderGrid(group2, sampledData, attributes, finalAnimation);
        }) || [];
        var mainGroup = select(container).maybeAppendByClassName(CLASS_NAMES3.mainGroup, "g");
        if (titleText && (!this.initialized && finalAnimation.enter || this.initialized && finalAnimation.update)) {
          renderAxisMain(attributes, select(this.offscreenGroup), sampledData, parseAnimationOption(false));
        }
        var mainTransitions = renderAxisMain(attributes, select(mainGroup.node()), sampledData, finalAnimation);
        var titleGroup = select(container).maybeAppendByClassName(CLASS_NAMES3.titleGroup, "g");
        var titleTransitions = ifShow(showTitle, titleGroup, function(group2) {
          return renderTitle(group2, _this2, attributes, finalAnimation);
        }) || [];
        return __spreadArray(__spreadArray(__spreadArray([], __read(gridTransitions), false), __read(mainTransitions), false), __read(titleTransitions), false).flat().filter(function(t) {
          return !!t;
        });
      };
      return Axis2;
    })(Component)
  );

  // node_modules/@antv/component/esm/ui/legend/category.js
  init_tslib_es6();

  // node_modules/@antv/component/esm/ui/legend/title/index.js
  init_tslib_es6();
  var CLASS_NAMES5 = classNames({
    text: "text"
  }, "title");
  function getBBox(title, content) {
    var _a2 = title.attributes, position2 = _a2.position, spacing = _a2.spacing, inset = _a2.inset, text = _a2.text;
    var titleBBox = title.getBBox();
    var contentBBox = content.getBBox();
    var pos = parsePosition(position2);
    var _b = __read(parseSeriesAttr(text ? spacing : 0), 4), spacingTop = _b[0], spacingRight = _b[1], spacingBottom = _b[2], spacingLeft = _b[3];
    var _c = __read(parseSeriesAttr(inset), 4), insetTop = _c[0], insetRight = _c[1], insetBottom = _c[2], insetLeft = _c[3];
    var _d = __read([spacingLeft + spacingRight, spacingTop + spacingBottom], 2), spacingWidth = _d[0], spacingHeight = _d[1];
    var _e = __read([insetLeft + insetRight, insetTop + insetBottom], 2), insetWidth = _e[0], insetHeight = _e[1];
    if (pos[0] === "l") {
      return new BBox(titleBBox.x, titleBBox.y, contentBBox.width + titleBBox.width + spacingWidth + insetWidth, Math.max(contentBBox.height + insetHeight, titleBBox.height));
    }
    if (pos[0] === "t") {
      return new BBox(titleBBox.x, titleBBox.y, Math.max(contentBBox.width + insetWidth, titleBBox.width), contentBBox.height + titleBBox.height + spacingHeight + insetHeight);
    }
    var _f = __read([
      content.attributes.width || contentBBox.width,
      content.attributes.height || contentBBox.height
    ], 2), contentWidth = _f[0], contentHeight = _f[1];
    return new BBox(contentBBox.x, contentBBox.y, contentWidth + titleBBox.width + spacingWidth + insetWidth, contentHeight + titleBBox.height + spacingHeight + insetHeight);
  }
  function mayApplyStyle(el, style) {
    var finalStyle = Object.entries(style).reduce(function(acc, _a2) {
      var _b = __read(_a2, 2), key = _b[0], value = _b[1];
      var currAttr = el.node().attr(key);
      if (!currAttr)
        acc[key] = value;
      return acc;
    }, {});
    el.styles(finalStyle);
  }
  function getTitleLayout(cfg) {
    var _a2, _b, _c, _d;
    var _e = cfg, width2 = _e.width, height = _e.height, position2 = _e.position;
    var _f = __read([+width2 / 2, +height / 2], 2), hW = _f[0], hH = _f[1];
    var _g = __read([+hW, +hH, "center", "middle"], 4), x3 = _g[0], y3 = _g[1], textAlign = _g[2], textBaseline = _g[3];
    var pos = parsePosition(position2);
    if (pos.includes("l"))
      _a2 = __read([0, "start"], 2), x3 = _a2[0], textAlign = _a2[1];
    if (pos.includes("r"))
      _b = __read([+width2, "end"], 2), x3 = _b[0], textAlign = _b[1];
    if (pos.includes("t"))
      _c = __read([0, "top"], 2), y3 = _c[0], textBaseline = _c[1];
    if (pos.includes("b"))
      _d = __read([+height, "bottom"], 2), y3 = _d[0], textBaseline = _d[1];
    return { x: x3, y: y3, textAlign, textBaseline };
  }
  var Title = (
    /** @class */
    (function(_super) {
      __extends(Title3, _super);
      function Title3(options) {
        return _super.call(this, options, {
          text: "",
          width: 0,
          height: 0,
          fill: "#4a505a",
          fontWeight: "bold",
          fontSize: 12,
          fontFamily: "sans-serif",
          inset: 0,
          spacing: 0,
          position: "top-left"
        }) || this;
      }
      Title3.prototype.getAvailableSpace = function() {
        var container = this;
        var _a2 = this.attributes, containerWidth = _a2.width, containerHeight = _a2.height, position2 = _a2.position, spacing = _a2.spacing, inset = _a2.inset;
        var title = container.querySelector(CLASS_NAMES5.text.class);
        if (!title)
          return new BBox(0, 0, +containerWidth, +containerHeight);
        var _b = title.getBBox(), titleWidth = _b.width, titleHeight = _b.height;
        var _c = __read(parseSeriesAttr(spacing), 4), spacingTop = _c[0], spacingRight = _c[1], spacingBottom = _c[2], spacingLeft = _c[3];
        var _d = __read([0, 0, +containerWidth, +containerHeight], 4), x3 = _d[0], y3 = _d[1], width2 = _d[2], height = _d[3];
        var pos = parsePosition(position2);
        if (pos.includes("i"))
          return new BBox(x3, y3, width2, height);
        pos.forEach(function(p, i) {
          var _a3, _b2, _c2, _d2;
          if (p === "t")
            _a3 = __read(i === 0 ? [titleHeight + spacingBottom, +containerHeight - titleHeight - spacingBottom] : [0, +containerHeight], 2), y3 = _a3[0], height = _a3[1];
          if (p === "r")
            _b2 = __read([+containerWidth - titleWidth - spacingLeft], 1), width2 = _b2[0];
          if (p === "b")
            _c2 = __read([+containerHeight - titleHeight - spacingTop], 1), height = _c2[0];
          if (p === "l")
            _d2 = __read(i === 0 ? [titleWidth + spacingRight, +containerWidth - titleWidth - spacingRight] : [0, +containerWidth], 2), x3 = _d2[0], width2 = _d2[1];
        });
        var _e = __read(parseSeriesAttr(inset), 4), insetTop = _e[0], insetRight = _e[1], insetBottom = _e[2], insetLeft = _e[3];
        var _f = __read([insetLeft + insetRight, insetTop + insetBottom], 2), insetWidth = _f[0], insetHeight = _f[1];
        return new BBox(x3 + insetLeft, y3 + insetTop, width2 - insetWidth, height - insetHeight);
      };
      Title3.prototype.getBBox = function() {
        if (this.title)
          return this.title.getBBox();
        return new BBox(0, 0, 0, 0);
      };
      Title3.prototype.render = function(attributes, container) {
        var _this2 = this;
        var width2 = attributes.width, height = attributes.height, position2 = attributes.position, spacing = attributes.spacing, restStyle = __rest(attributes, ["width", "height", "position", "spacing"]);
        var _a2 = __read(splitStyle(restStyle), 1), titleStyle = _a2[0];
        var _b = getTitleLayout(attributes), x3 = _b.x, y3 = _b.y, textAlign = _b.textAlign, textBaseline = _b.textBaseline;
        ifShow(!!restStyle.text, select(container), function(group2) {
          _this2.title = group2.maybeAppendByClassName(CLASS_NAMES5.text, "text").styles(titleStyle).call(mayApplyStyle, { x: x3, y: y3, textAlign, textBaseline }).node();
        });
      };
      return Title3;
    })(Component)
  );

  // node_modules/@antv/component/esm/ui/legend/category/items.js
  init_tslib_es6();
  var import_util176 = __toESM(require_lib());

  // node_modules/@antv/component/esm/ui/navigator/index.js
  init_tslib_es6();
  var import_util170 = __toESM(require_lib());
  var CLASS_NAMES6 = classNames({
    prevBtnGroup: "prev-btn-group",
    prevBtn: "prev-btn",
    nextBtnGroup: "next-btn-group",
    nextBtn: "next-btn",
    pageInfoGroup: "page-info-group",
    pageInfo: "page-info",
    playWindow: "play-window",
    contentGroup: "content-group",
    controller: "controller",
    clipPath: "clip-path"
  }, "navigator");
  var Navigator = (
    /** @class */
    (function(_super) {
      __extends(Navigator2, _super);
      function Navigator2(options) {
        var _this2 = _super.call(this, options, {
          x: 0,
          y: 0,
          animate: {
            easing: "linear",
            duration: 200,
            fill: "both"
          },
          buttonCursor: "pointer",
          buttonFill: "black",
          buttonD: button(0, 0, 6),
          buttonSize: 12,
          controllerPadding: 5,
          controllerSpacing: 5,
          formatter: function(curr, total) {
            return "".concat(curr, "/").concat(total);
          },
          defaultPage: 0,
          loop: false,
          orientation: "horizontal",
          pageNumFill: "black",
          pageNumFontSize: 12,
          pageNumTextAlign: "start",
          pageNumTextBaseline: "middle"
        }) || this;
        _this2.playState = "idle";
        _this2.contentGroup = _this2.appendChild(new Group({ class: CLASS_NAMES6.contentGroup.name }));
        _this2.playWindow = _this2.contentGroup.appendChild(new Group({ class: CLASS_NAMES6.playWindow.name }));
        _this2.innerCurrPage = _this2.defaultPage;
        return _this2;
      }
      Object.defineProperty(Navigator2.prototype, "defaultPage", {
        get: function() {
          var defaultPage = this.attributes.defaultPage;
          return (0, import_util170.clamp)(defaultPage, 0, Math.max(this.pageViews.length - 1, 0));
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Navigator2.prototype, "pageViews", {
        get: function() {
          return this.playWindow.children;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Navigator2.prototype, "controllerShape", {
        // todo fixme
        get: function() {
          return this.totalPages > 1 ? { width: 55, height: 0 } : { width: 0, height: 0 };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Navigator2.prototype, "pageShape", {
        get: function() {
          var pageViews = this.pageViews;
          var _a2 = __read(transpose(pageViews.map(function(pageView) {
            var _a3 = pageView.getBBox(), width2 = _a3.width, height = _a3.height;
            return [width2, height];
          })).map(function(arr) {
            return Math.max.apply(Math, __spreadArray([], __read(arr), false));
          }), 2), maxWidth = _a2[0], maxHeight = _a2[1];
          var _b = this.attributes, _c = _b.pageWidth, pageWidth = _c === void 0 ? maxWidth : _c, _d = _b.pageHeight, pageHeight = _d === void 0 ? maxHeight : _d;
          return { pageWidth, pageHeight };
        },
        enumerable: false,
        configurable: true
      });
      Navigator2.prototype.getContainer = function() {
        return this.playWindow;
      };
      Object.defineProperty(Navigator2.prototype, "totalPages", {
        get: function() {
          return this.pageViews.length;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Navigator2.prototype, "currPage", {
        get: function() {
          return this.innerCurrPage;
        },
        enumerable: false,
        configurable: true
      });
      Navigator2.prototype.getBBox = function() {
        var _a2 = _super.prototype.getBBox.call(this), x3 = _a2.x, y3 = _a2.y;
        var controllerShape = this.controllerShape;
        var _b = this.pageShape, pageWidth = _b.pageWidth, pageHeight = _b.pageHeight;
        return new BBox(x3, y3, pageWidth + controllerShape.width, pageHeight);
      };
      Navigator2.prototype.goTo = function(pageNum) {
        var _this2 = this;
        var animateOptions = this.attributes.animate;
        var _a2 = this, currPage = _a2.currPage, playState = _a2.playState, playWindow = _a2.playWindow, pageViews = _a2.pageViews;
        if (playState !== "idle" || pageNum < 0 || pageViews.length <= 0 || pageNum >= pageViews.length)
          return null;
        pageViews[currPage].setLocalPosition(0, 0);
        this.prepareFollowingPage(pageNum);
        var _b = __read(this.getFollowingPageDiff(pageNum), 2), dx = _b[0], dy = _b[1];
        this.playState = "running";
        var animation = animate(playWindow, [{ transform: "translate(0, 0)" }, { transform: "translate(".concat(-dx, ", ").concat(-dy, ")") }], animateOptions);
        onAnimateFinished(animation, function() {
          _this2.innerCurrPage = pageNum;
          _this2.playState = "idle";
          _this2.setVisiblePages([pageNum]);
          _this2.updatePageInfo();
        });
        return animation;
      };
      Navigator2.prototype.prev = function() {
        var loop = this.attributes.loop;
        var pages = this.pageViews.length;
        var page = this.currPage;
        if (!loop && page <= 0)
          return null;
        var following = loop ? (page - 1 + pages) % pages : (0, import_util170.clamp)(page - 1, 0, pages);
        return this.goTo(following);
      };
      Navigator2.prototype.next = function() {
        var loop = this.attributes.loop;
        var pages = this.pageViews.length;
        var page = this.currPage;
        if (!loop && page >= pages - 1)
          return null;
        var following = loop ? (page + 1) % pages : (0, import_util170.clamp)(page + 1, 0, pages);
        return this.goTo(following);
      };
      Navigator2.prototype.renderClipPath = function(container) {
        var _a2 = this.pageShape, pageWidth = _a2.pageWidth, pageHeight = _a2.pageHeight;
        if (!pageWidth || !pageHeight) {
          this.contentGroup.style.clipPath = void 0;
          return;
        }
        this.clipPath = container.maybeAppendByClassName(CLASS_NAMES6.clipPath, "rect").styles({
          width: pageWidth,
          height: pageHeight
        });
        this.contentGroup.attr("clipPath", this.clipPath.node());
      };
      Navigator2.prototype.setVisiblePages = function(pages) {
        this.playWindow.children.forEach(function(page, index2) {
          if (pages.includes(index2))
            show(page);
          else
            hide(page);
        });
      };
      Navigator2.prototype.adjustControllerLayout = function() {
        var _a2 = this, prevBtn = _a2.prevBtnGroup, nextBtn = _a2.nextBtnGroup, pageNum = _a2.pageInfoGroup;
        var _b = this.attributes, orientation5 = _b.orientation, padding = _b.controllerPadding;
        var _c = pageNum.getBBox(), pW = _c.width, pH = _c.height;
        var _d = __read(orientation5 === "horizontal" ? [-180, 0] : [-90, 90], 2), r1 = _d[0], r2 = _d[1];
        prevBtn.setLocalEulerAngles(r1);
        nextBtn.setLocalEulerAngles(r2);
        var _e = prevBtn.getBBox(), bpW = _e.width, bpH = _e.height;
        var _f = nextBtn.getBBox(), bnW = _f.width, bnH = _f.height;
        var maxWidth = Math.max(bpW, pW, bnW);
        var _g = orientation5 === "horizontal" ? {
          offset: [
            [0, 0],
            [bpW / 2 + padding, 0],
            [bpW + pW + padding * 2, 0]
          ],
          textAlign: "start"
        } : {
          offset: [
            [maxWidth / 2, -bpH - padding],
            [maxWidth / 2, 0],
            [maxWidth / 2, bnH + padding]
          ],
          textAlign: "center"
        }, _h = __read(_g.offset, 3), _j = __read(_h[0], 2), o1x = _j[0], o1y = _j[1], _k = __read(_h[1], 2), o2x = _k[0], o2y = _k[1], _l = __read(_h[2], 2), o3x = _l[0], o3y = _l[1], textAlign = _g.textAlign;
        var pageNumText = pageNum.querySelector("text");
        pageNumText && (pageNumText.style.textAlign = textAlign);
        prevBtn.setLocalPosition(o1x, o1y);
        pageNum.setLocalPosition(o2x, o2y);
        nextBtn.setLocalPosition(o3x, o3y);
      };
      Navigator2.prototype.updatePageInfo = function() {
        var _a2;
        var _b = this, currPage = _b.currPage, pageViews = _b.pageViews, formatter2 = _b.attributes.formatter;
        if (pageViews.length < 2)
          return;
        (_a2 = this.pageInfoGroup.querySelector(CLASS_NAMES6.pageInfo.class)) === null || _a2 === void 0 ? void 0 : _a2.attr("text", formatter2(currPage + 1, pageViews.length));
        this.adjustControllerLayout();
      };
      Navigator2.prototype.getFollowingPageDiff = function(pageNum) {
        var currPage = this.currPage;
        if (currPage === pageNum)
          return [0, 0];
        var orientation5 = this.attributes.orientation;
        var _a2 = this.pageShape, pageWidth = _a2.pageWidth, pageHeight = _a2.pageHeight;
        var sign = pageNum < currPage ? -1 : 1;
        return orientation5 === "horizontal" ? [sign * pageWidth, 0] : [0, sign * pageHeight];
      };
      Navigator2.prototype.prepareFollowingPage = function(pageNum) {
        var _a2 = this, currPage = _a2.currPage, pageViews = _a2.pageViews;
        this.setVisiblePages([pageNum, currPage]);
        if (pageNum !== currPage) {
          var _b = __read(this.getFollowingPageDiff(pageNum), 2), dx = _b[0], dy = _b[1];
          pageViews[pageNum].setLocalPosition(dx, dy);
        }
      };
      Navigator2.prototype.renderController = function(container) {
        var _this2 = this;
        var spacing = this.attributes.controllerSpacing;
        var _a2 = this.pageShape, pageWidth = _a2.pageWidth, pageHeight = _a2.pageHeight;
        var visible = this.pageViews.length >= 2;
        var group2 = container.maybeAppendByClassName(CLASS_NAMES6.controller, "g");
        visibility(group2.node(), visible);
        if (!visible)
          return;
        var style = subStyleProps2(this.attributes, "button");
        var textStyle = subStyleProps2(this.attributes, "pageNum");
        var _b = __read(splitStyle(style), 2), _c = _b[0], groupStyle = _b[1], size2 = _c.size, pathStyle = __rest(_c, ["size"]);
        var whetherToAddEventListener = !group2.select(CLASS_NAMES6.prevBtnGroup.class).node();
        var prevBtnGroup = group2.maybeAppendByClassName(CLASS_NAMES6.prevBtnGroup, "g").styles(groupStyle);
        this.prevBtnGroup = prevBtnGroup.node();
        var prevBtn = prevBtnGroup.maybeAppendByClassName(CLASS_NAMES6.prevBtn, "path");
        var nextBtnGroup = group2.maybeAppendByClassName(CLASS_NAMES6.nextBtnGroup, "g").styles(groupStyle);
        this.nextBtnGroup = nextBtnGroup.node();
        var nextBtn = nextBtnGroup.maybeAppendByClassName(CLASS_NAMES6.nextBtn, "path");
        [prevBtn, nextBtn].forEach(function(btn) {
          btn.styles(__assign(__assign({}, pathStyle), { transformOrigin: "center" }));
          scaleToPixel(btn.node(), size2, true);
        });
        var pageInfoGroup = group2.maybeAppendByClassName(CLASS_NAMES6.pageInfoGroup, "g");
        this.pageInfoGroup = pageInfoGroup.node();
        pageInfoGroup.maybeAppendByClassName(CLASS_NAMES6.pageInfo, "text").styles(textStyle);
        this.updatePageInfo();
        group2.node().setLocalPosition(pageWidth + spacing, pageHeight / 2);
        if (whetherToAddEventListener) {
          this.prevBtnGroup.addEventListener("click", function() {
            _this2.prev();
          });
          this.nextBtnGroup.addEventListener("click", function() {
            _this2.next();
          });
        }
      };
      Navigator2.prototype.render = function(attributes, container) {
        var _a2 = attributes.x, x3 = _a2 === void 0 ? 0 : _a2, _b = attributes.y, y3 = _b === void 0 ? 0 : _b;
        this.attr("transform", "translate(".concat(x3, ", ").concat(y3, ")"));
        var containerSelection = select(container);
        this.renderClipPath(containerSelection);
        this.renderController(containerSelection);
        this.setVisiblePages([this.defaultPage]);
        this.goTo(this.defaultPage);
      };
      Navigator2.prototype.bindEvents = function() {
        var _this2 = this;
        var render = (0, import_util170.debounce)(function() {
          return _this2.render(_this2.attributes, _this2);
        }, 50);
        this.playWindow.addEventListener(ElementEvent.INSERTED, render);
        this.playWindow.addEventListener(ElementEvent.REMOVED, render);
      };
      return Navigator2;
    })(Component)
  );

  // node_modules/@antv/component/esm/ui/legend/utils.js
  function hiddenHandle(x3, y3, r) {
    var ratio = 1.4;
    var diffY = ratio * r;
    return [["M", x3 - r, y3 - diffY], ["L", x3 + r, y3 - diffY], ["L", x3 + r, y3 + diffY], ["L", x3 - r, y3 + diffY], ["Z"]];
  }
  var HANDLE_HEIGHT_RATIO = 1.4;
  var HANDLE_TRIANGLE_RATIO = 0.4;
  function verticalHandle(x3, y3, r) {
    var width2 = r;
    var height = width2 * HANDLE_HEIGHT_RATIO;
    var halfWidth = width2 / 2;
    var oneSixthWidth = width2 / 6;
    var triangleX = x3 + height * HANDLE_TRIANGLE_RATIO;
    return [
      ["M", x3, y3],
      ["L", triangleX, y3 + halfWidth],
      ["L", x3 + height, y3 + halfWidth],
      ["L", x3 + height, y3 - halfWidth],
      ["L", triangleX, y3 - halfWidth],
      ["Z"],
      // 绘制两条横线
      ["M", triangleX, y3 + oneSixthWidth],
      ["L", x3 + height - 2, y3 + oneSixthWidth],
      ["M", triangleX, y3 - oneSixthWidth],
      ["L", x3 + height - 2, y3 - oneSixthWidth]
    ];
  }
  function horizontalHandle(x3, y3, r) {
    var width2 = r;
    var height = width2 * HANDLE_HEIGHT_RATIO;
    var halfWidth = width2 / 2;
    var oneSixthWidth = width2 / 6;
    var triangleY = y3 + height * HANDLE_TRIANGLE_RATIO;
    return [
      ["M", x3, y3],
      ["L", x3 - halfWidth, triangleY],
      ["L", x3 - halfWidth, y3 + height],
      ["L", x3 + halfWidth, y3 + height],
      ["L", x3 + halfWidth, triangleY],
      ["Z"],
      // 绘制两条竖线
      ["M", x3 - oneSixthWidth, triangleY],
      ["L", x3 - oneSixthWidth, y3 + height - 2],
      ["M", x3 + oneSixthWidth, triangleY],
      ["L", x3 + oneSixthWidth, y3 + height - 2]
    ];
  }
  Marker.registerSymbol("hiddenHandle", hiddenHandle);
  Marker.registerSymbol("verticalHandle", verticalHandle);
  Marker.registerSymbol("horizontalHandle", horizontalHandle);
  function ifHorizontal(orientation5, a2, b) {
    if (orientation5 === void 0) {
      orientation5 = "horizontal";
    }
    return orientation5 === "horizontal" ? a2 : b;
  }

  // node_modules/@antv/component/esm/ui/legend/category/item.js
  init_tslib_es6();
  var import_util174 = __toESM(require_lib());

  // node_modules/@antv/component/esm/ui/poptip/index.js
  init_tslib_es6();
  var import_util172 = __toESM(require_lib());

  // node_modules/@antv/component/esm/ui/poptip/constant.js
  var _a;
  var POPTIP_ID = "component-poptip";
  var CLASS_NAME = {
    CONTAINER: "component-poptip",
    ARROW: "component-poptip-arrow",
    TEXT: "component-poptip-text"
  };
  var POPTIP_STYLE = (_a = {}, // 容器 默认 style
  _a[".".concat(CLASS_NAME.CONTAINER)] = {
    visibility: "visible",
    position: "absolute",
    "background-color": "rgba(0, 0, 0)",
    "box-shadow": "0px 0px 10px #aeaeae",
    "border-radius": "3px",
    color: "#fff",
    opacity: 0.8,
    "font-size": "12px",
    padding: "4px 6px",
    display: "flex",
    "justify-content": "center",
    "align-items": "center",
    "z-index": 8,
    transition: "visibility 50ms"
  }, // 文本内容 默认 style
  _a[".".concat(CLASS_NAME.TEXT)] = {
    "text-align": "center"
  }, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top']")] = {
    transform: "translate(-50%, -100%)"
  }, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left']")] = {
    transform: "translate(-100%, -50%)"
  }, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right']")] = {
    transform: "translate(0, -50%)"
  }, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom']")] = {
    transform: "translate(-50%, 0)"
  }, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top-left']")] = {
    transform: "translate(0,-100%)"
  }, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top-right']")] = {
    transform: "translate(-100%,-100%)"
  }, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left-top']")] = {
    transform: "translate(-100%, 0)"
  }, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left-bottom']")] = {
    transform: "translate(-100%, -100%)"
  }, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right-top']")] = {
    transform: "translate(0, 0)"
  }, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right-bottom']")] = {
    transform: "translate(0, -100%)"
  }, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom-left']")] = {
    transform: "translate(0, 0)"
  }, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom-right']")] = {
    transform: "translate(-100%, 0)"
  }, _a[".".concat(CLASS_NAME.ARROW)] = {
    width: "4px",
    height: "4px",
    transform: "rotate(45deg)",
    "background-color": "rgba(0, 0, 0)",
    position: "absolute",
    "z-index": -1
  }, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top']")] = {
    transform: "translate(-50%, calc(-100% - 5px))"
  }, _a["[data-position='top'] .".concat(CLASS_NAME.ARROW)] = {
    bottom: "-2px"
  }, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left']")] = {
    transform: "translate(calc(-100% - 5px), -50%)"
  }, _a["[data-position='left'] .".concat(CLASS_NAME.ARROW)] = {
    right: "-2px"
  }, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right']")] = {
    transform: "translate(5px, -50%)"
  }, _a["[data-position='right'] .".concat(CLASS_NAME.ARROW)] = {
    left: "-2px"
  }, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom']")] = {
    transform: "translate(-50%, 5px)"
  }, _a["[data-position='bottom'] .".concat(CLASS_NAME.ARROW)] = {
    top: "-2px"
  }, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top-left']")] = {
    transform: "translate(0, calc(-100% - 5px))"
  }, _a["[data-position='top-left'] .".concat(CLASS_NAME.ARROW)] = {
    left: "10px",
    bottom: "-2px"
  }, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='top-right']")] = {
    transform: "translate(-100%, calc(-100% - 5px))"
  }, _a["[data-position='top-right'] .".concat(CLASS_NAME.ARROW)] = {
    right: "10px",
    bottom: "-2px"
  }, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left-top']")] = {
    transform: "translate(calc(-100% - 5px), 0)"
  }, _a["[data-position='left-top'] .".concat(CLASS_NAME.ARROW)] = {
    right: "-2px",
    top: "8px"
  }, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='left-bottom']")] = {
    transform: "translate(calc(-100% - 5px), -100%)"
  }, _a["[data-position='left-bottom'] .".concat(CLASS_NAME.ARROW)] = {
    right: "-2px",
    bottom: "8px"
  }, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right-top']")] = {
    transform: "translate(5px, 0)"
  }, _a["[data-position='right-top'] .".concat(CLASS_NAME.ARROW)] = {
    left: "-2px",
    top: "8px"
  }, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='right-bottom']")] = {
    transform: "translate(5px, -100%)"
  }, _a["[data-position='right-bottom'] .".concat(CLASS_NAME.ARROW)] = {
    left: "-2px",
    bottom: "8px"
  }, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom-left']")] = {
    transform: "translate(0, 5px)"
  }, _a["[data-position='bottom-left'] .".concat(CLASS_NAME.ARROW)] = {
    top: "-2px",
    left: "8px"
  }, _a[".".concat(CLASS_NAME.CONTAINER, "[data-position='bottom-right']")] = {
    transform: "translate(-100%, 5px)"
  }, _a["[data-position='bottom-right'] .".concat(CLASS_NAME.ARROW)] = {
    top: "-2px",
    right: "8px"
  }, _a);

  // node_modules/@antv/component/esm/ui/poptip/utils.js
  var _this = void 0;
  function getPositionXY(clientX, clientY, target, position2, arrowPointAtCenter, follow) {
    if (arrowPointAtCenter === void 0) {
      arrowPointAtCenter = false;
    }
    if (follow === void 0) {
      follow = false;
    }
    if (follow)
      return [clientX, clientY];
    var _a2 = target.getBoundingClientRect(), x3 = _a2.x, y3 = _a2.y, width2 = _a2.width, height = _a2.height;
    switch (position2) {
      case "top":
        return arrowPointAtCenter ? [x3 + width2 / 2, y3] : [clientX, y3];
      case "left":
        return arrowPointAtCenter ? [x3, y3 + height / 2] : [x3, clientY];
      case "bottom":
        return arrowPointAtCenter ? [x3 + width2 / 2, y3 + height] : [clientX, y3 + height];
      case "right":
        return arrowPointAtCenter ? [x3 + width2, y3 + height / 2] : [x3 + width2, clientY];
      case "top-right":
      case "right-top":
        return [x3 + width2, y3];
      case "left-bottom":
      case "bottom-left":
        return [x3, y3 + height];
      case "right-bottom":
      case "bottom-right":
        return [x3 + width2, y3 + height];
      case "top-left":
      case "left-top":
      default:
        return [x3, y3];
    }
  }
  var getSingleTon = function(fn) {
    var instance;
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (!instance)
        instance = fn.apply(_this, args);
      return instance;
    };
  };
  function createElement(id3) {
    var div = id3 && document.getElementById(id3);
    if (!div) {
      div = document.createElement("div");
      div.setAttribute("id", id3);
      document.body.appendChild(div);
    }
    return div;
  }
  function getSingleTonElement(id3) {
    var element = getSingleTon(createElement)(id3);
    return element;
  }

  // node_modules/@antv/component/esm/ui/poptip/index.js
  var Poptip = (
    /** @class */
    (function(_super) {
      __extends(Poptip2, _super);
      function Poptip2(options) {
        var _this2 = _super.call(this, (0, import_util172.deepMix)({ style: { id: POPTIP_ID } }, Poptip2.defaultOptions, options)) || this;
        _this2.visibility = "visible";
        _this2.map = /* @__PURE__ */ new Map();
        _this2.domStyles = "";
        _this2.initShape();
        _this2.render(_this2.attributes, _this2);
        return _this2;
      }
      Object.defineProperty(Poptip2.prototype, "visible", {
        get: function() {
          return this.visibility === "visible";
        },
        enumerable: false,
        configurable: true
      });
      Poptip2.prototype.render = function(attributes, container) {
        this.visibility = this.style.visibility;
        this.updatePoptipElement();
      };
      Poptip2.prototype.update = function(cfg) {
        this.attr((0, import_util172.deepMix)({}, this.style, cfg));
        this.render(this.attributes, this);
      };
      Poptip2.prototype.bind = function(element, callback) {
        var _this2 = this;
        if (!element)
          return;
        var defaultText = this.style.text;
        var onmousemove = function(e) {
          var target = element;
          var options = _this2.style;
          var text = defaultText;
          if (callback) {
            var _a2 = typeof callback === "function" ? callback.call(null, e) : callback, html = _a2.html, ele = _a2.target, restOptions = __rest(_a2, ["html", "target"]);
            options = (0, import_util172.assign)({}, _this2.style, restOptions);
            if (ele || ele === false)
              target = ele;
            if (typeof html === "string")
              text = html;
          }
          var position2 = options.position, arrowPointAtCenter = options.arrowPointAtCenter, follow = options.follow, offset = options.offset;
          if (target) {
            var _b = e, clientX = _b.clientX, clientY = _b.clientY;
            var _c = __read(getPositionXY(clientX, clientY, target, position2, arrowPointAtCenter, follow), 2), x3 = _c[0], y3 = _c[1];
            _this2.showTip(x3, y3, { text, position: position2, offset });
          } else {
            _this2.hideTip();
          }
        };
        var onmouseleave = function() {
          _this2.hideTip();
        };
        element.addEventListener("mousemove", onmousemove);
        element.addEventListener("mouseleave", onmouseleave);
        this.map.set(element, [onmousemove, onmouseleave]);
      };
      Poptip2.prototype.unbind = function(element) {
        if (this.map.has(element)) {
          var _a2 = __read(this.map.get(element) || [], 2), listener1 = _a2[0], listener2 = _a2[1];
          listener1 && element.removeEventListener("mousemove", listener1);
          listener2 && element.removeEventListener("mouseleave", listener2);
          this.map.delete(element);
        }
      };
      Poptip2.prototype.clear = function() {
        this.container.innerHTML = "";
      };
      Poptip2.prototype.destroy = function() {
        var _this2 = this;
        var _a2;
        __spreadArray([], __read(this.map.keys()), false).forEach(function(ele) {
          return _this2.unbind(ele);
        });
        (_a2 = this.container) === null || _a2 === void 0 ? void 0 : _a2.remove();
        _super.prototype.destroy.call(this);
      };
      Poptip2.prototype.showTip = function(x3, y3, options) {
        var text = (0, import_util172.get)(options, "text");
        if (text && typeof text !== "string")
          return;
        this.applyStyles();
        if (x3 && y3 && options) {
          var offset = options.offset, position2 = options.position;
          position2 && this.container.setAttribute("data-position", position2);
          this.setOffsetPosition(x3, y3, offset);
          if (typeof text === "string") {
            var textElement = this.container.querySelector(".".concat(CLASS_NAME.TEXT));
            if (textElement) {
              textElement.innerHTML = text;
            }
          }
          this.visibility = "visible";
          this.container.style.visibility = "visible";
        }
      };
      Poptip2.prototype.hideTip = function() {
        this.visibility = "hidden";
        this.container.style.visibility = "hidden";
      };
      Poptip2.prototype.getContainer = function() {
        return this.container;
      };
      Poptip2.prototype.getClassName = function() {
        var containerClassName = this.style.containerClassName;
        return "".concat(CLASS_NAME.CONTAINER).concat(containerClassName ? " ".concat(containerClassName) : "");
      };
      Poptip2.prototype.initShape = function() {
        var _this2 = this;
        var id3 = this.style.id;
        this.container = getSingleTonElement(id3);
        this.container.className = this.getClassName();
        this.container.addEventListener("mousemove", function() {
          return _this2.showTip();
        });
        this.container.addEventListener("mouseleave", function() {
          return _this2.hideTip();
        });
      };
      Poptip2.prototype.updatePoptipElement = function() {
        var container = this.container;
        this.clear();
        var _a2 = this.style, id3 = _a2.id, template = _a2.template, text = _a2.text;
        this.container.setAttribute("id", id3);
        this.container.className = this.getClassName();
        var arrowNode = '<span class="'.concat(CLASS_NAME.ARROW, '"></span>');
        container.innerHTML = arrowNode;
        if ((0, import_util172.isString)(template)) {
          container.innerHTML += template;
        } else if (template && (0, import_util172.isElement)(template)) {
          container.appendChild(template);
        }
        if (text) {
          container.getElementsByClassName(CLASS_NAME.TEXT)[0].textContent = text;
        }
        this.applyStyles();
        this.container.style.visibility = this.visibility;
      };
      Poptip2.prototype.applyStyles = function() {
        var styles = deepAssign({}, POPTIP_STYLE, this.style.domStyles);
        var styleStr = Object.entries(styles).reduce(function(r, _a2) {
          var _b = __read(_a2, 2), key = _b[0], value = _b[1];
          var styleStr2 = Object.entries(value).reduce(function(r2, _a3) {
            var _b2 = __read(_a3, 2), k = _b2[0], v = _b2[1];
            return "".concat(r2).concat(k, ": ").concat(v, ";");
          }, "");
          return "".concat(r).concat(key, "{").concat(styleStr2, "}");
        }, "");
        if (this.domStyles !== styleStr) {
          this.domStyles = styleStr;
          var styleDOM = this.container.querySelector("style");
          if (styleDOM)
            this.container.removeChild(styleDOM);
          styleDOM = document.createElement("style");
          styleDOM.innerHTML = styleStr;
          this.container.appendChild(styleDOM);
        }
      };
      Poptip2.prototype.setOffsetPosition = function(x3, y3, offset) {
        if (offset === void 0) {
          offset = this.style.offset;
        }
        var _a2 = __read(offset, 2), _b = _a2[0], offsetX = _b === void 0 ? 0 : _b, _c = _a2[1], offsetY = _c === void 0 ? 0 : _c;
        this.container.style.left = "".concat(x3 + offsetX, "px");
        this.container.style.top = "".concat(y3 + offsetY, "px");
      };
      Poptip2.tag = "poptip";
      Poptip2.defaultOptions = {
        style: {
          x: 0,
          y: 0,
          width: 0,
          height: 0,
          target: null,
          visibility: "hidden",
          text: "",
          position: "top",
          follow: false,
          offset: [0, 0],
          domStyles: POPTIP_STYLE,
          template: '<div class="'.concat(CLASS_NAME.TEXT, '"></div>')
        }
      };
      return Poptip2;
    })(Component)
  );

  // node_modules/@antv/component/esm/ui/legend/category/item.js
  var CLASS_NAMES7 = classNames({
    layout: "flex",
    markerGroup: "marker-group",
    marker: "marker",
    labelGroup: "label-group",
    label: "label",
    valueGroup: "value-group",
    focusGroup: "focus-group",
    focus: "focus",
    value: "value",
    backgroundGroup: "background-group",
    background: "background"
  }, "legend-category-item");
  var DEFAULT_POPTIP_PROPS = {
    offset: [0, 20],
    domStyles: {
      ".component-poptip": {
        opacity: "1",
        padding: "8px 12px",
        background: "#fff",
        boxShadow: "0 2px 8px rgba(0, 0, 0, 0.15)"
      },
      ".component-poptip-arrow": {
        display: "none"
      },
      ".component-poptip-text": {
        color: "#000",
        lineHeight: "20px"
      }
    }
  };
  function styleOfMarker(group2) {
    var marker = group2.querySelector(CLASS_NAMES7.marker.class);
    if (marker)
      return marker.style;
    return {};
  }
  var CategoryItem = (
    /** @class */
    (function(_super) {
      __extends(CategoryItem2, _super);
      function CategoryItem2(options) {
        return _super.call(this, options, {
          span: [1, 1],
          marker: function() {
            return new Circle({ style: { r: 6 } });
          },
          markerSize: 10,
          labelFill: "#646464",
          valueFill: "#646464",
          labelFontSize: 12,
          valueFontSize: 12,
          labelTextBaseline: "middle",
          valueTextBaseline: "middle"
        }) || this;
      }
      Object.defineProperty(CategoryItem2.prototype, "showValue", {
        get: function() {
          var valueText = this.attributes.valueText;
          if (!valueText)
            return false;
          if (typeof valueText === "string" || typeof valueText === "number")
            return valueText !== "";
          if (typeof valueText === "function")
            return true;
          return valueText.attr("text") !== "";
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CategoryItem2.prototype, "actualSpace", {
        get: function() {
          var label = this.labelGroup;
          var value = this.valueGroup;
          var _a2 = this.attributes, markerSize = _a2.markerSize, focus2 = _a2.focus, focusMarkerSize = _a2.focusMarkerSize;
          var _b = label.node().getBBox(), labelWidth = _b.width, labelHeight = _b.height;
          var _c = value.node().getBBox(), valueWidth = _c.width, valueHeight = _c.height;
          var focusWidth = focus2 ? focusMarkerSize !== null && focusMarkerSize !== void 0 ? focusMarkerSize : 12 : 0;
          return {
            markerWidth: markerSize,
            labelWidth,
            valueWidth,
            focusWidth,
            height: Math.max(markerSize, labelHeight, valueHeight)
          };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CategoryItem2.prototype, "span", {
        get: function() {
          var span = this.attributes.span;
          if (!span)
            return [1, 1];
          var _a2 = __read(parseSeriesAttr(span), 2), span1 = _a2[0], innerSpan = _a2[1];
          var span2 = this.showValue ? innerSpan : 0;
          var basis = span1 + span2;
          return [span1 / basis, span2 / basis];
        },
        enumerable: false,
        configurable: true
      });
      CategoryItem2.prototype.setAttribute = function(n, v) {
        _super.prototype.setAttribute.call(this, n, v);
      };
      Object.defineProperty(CategoryItem2.prototype, "shape", {
        get: function() {
          var _a2;
          var _b = this.attributes, markerSize = _b.markerSize, fullWidth = _b.width;
          var actualSpace = this.actualSpace;
          var markerWidth = actualSpace.markerWidth, focusWidth = actualSpace.focusWidth, height = actualSpace.height;
          var _c = this.actualSpace, labelWidth = _c.labelWidth, valueWidth = _c.valueWidth;
          var _d = __read(this.spacing, 3), spacing1 = _d[0], spacing2 = _d[1], spacing3 = _d[2];
          if (fullWidth) {
            var width_1 = fullWidth - markerSize - spacing1 - spacing2 - focusWidth - spacing3;
            var _e = __read(this.span, 2), span1 = _e[0], span2 = _e[1];
            _a2 = __read([span1 * width_1, span2 * width_1], 2), labelWidth = _a2[0], valueWidth = _a2[1];
          }
          var width2 = markerWidth + labelWidth + valueWidth + spacing1 + spacing2 + focusWidth + spacing3;
          return { width: width2, height, markerWidth, labelWidth, valueWidth, focusWidth };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CategoryItem2.prototype, "spacing", {
        get: function() {
          var _a2 = this.attributes, spacing = _a2.spacing, focus2 = _a2.focus;
          if (!spacing)
            return [0, 0, 0];
          var _b = __read(parseSeriesAttr(spacing), 3), spacing1 = _b[0], spacing2 = _b[1], spacing3 = _b[2];
          return [spacing1, this.showValue ? spacing2 : 0, focus2 ? spacing3 : 0];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CategoryItem2.prototype, "layout", {
        get: function() {
          var _a2 = this.shape, markerWidth = _a2.markerWidth, labelWidth = _a2.labelWidth, valueWidth = _a2.valueWidth, focusWidth = _a2.focusWidth, width2 = _a2.width, height = _a2.height;
          var _b = __read(this.spacing, 3), spacing1 = _b[0], spacing2 = _b[1], spacing3 = _b[2];
          return {
            height,
            width: width2,
            markerWidth,
            labelWidth,
            valueWidth,
            focusWidth,
            position: [
              markerWidth / 2,
              markerWidth + spacing1,
              markerWidth + labelWidth + spacing1 + spacing2,
              markerWidth + labelWidth + valueWidth + spacing1 + spacing2 + spacing3 + focusWidth / 2
            ]
          };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CategoryItem2.prototype, "scaleSize", {
        get: function() {
          var markerShapeStyle = styleOfMarker(this.markerGroup.node());
          var _a2 = this.attributes, markerSize = _a2.markerSize, _b = _a2.markerStrokeWidth, markerStrokeWidth = _b === void 0 ? markerShapeStyle.strokeWidth : _b, _c = _a2.markerLineWidth, markerLineWidth = _c === void 0 ? markerShapeStyle.lineWidth : _c, _d = _a2.markerStroke, markerStroke = _d === void 0 ? markerShapeStyle.stroke : _d;
          var strokeWidth = +(markerStrokeWidth || markerLineWidth || (markerStroke ? 1 : 0)) * Math.sqrt(2);
          var _e = this.markerGroup.node().getBBox(), width2 = _e.width, height = _e.height;
          return (1 - strokeWidth / Math.max(width2, height)) * markerSize;
        },
        enumerable: false,
        configurable: true
      });
      CategoryItem2.prototype.renderMarker = function(container) {
        var _this2 = this;
        var marker = this.attributes.marker;
        var style = subStyleProps2(this.attributes, "marker");
        this.markerGroup = container.maybeAppendByClassName(CLASS_NAMES7.markerGroup, "g").style("zIndex", 0);
        ifShow(!!marker, this.markerGroup, function() {
          var _a2;
          var parent = _this2.markerGroup.node();
          var oldMarker = (_a2 = parent.childNodes) === null || _a2 === void 0 ? void 0 : _a2[0];
          var newMarker = typeof marker === "string" ? new Marker({ style: { symbol: marker }, className: CLASS_NAMES7.marker.name }) : marker();
          if (!oldMarker) {
            if (!(newMarker instanceof Marker))
              select(newMarker).attr("className", CLASS_NAMES7.marker.name).styles(style);
            parent.appendChild(newMarker);
          } else if (newMarker.nodeName === oldMarker.nodeName) {
            if (oldMarker instanceof Marker)
              oldMarker.update(__assign(__assign({}, style), { symbol: marker }));
            else {
              copyAttributes(oldMarker, newMarker);
              select(oldMarker).styles(style);
            }
          } else {
            oldMarker.remove();
            select(newMarker).attr("className", CLASS_NAMES7.marker.name).styles(style);
            parent.appendChild(newMarker);
          }
          _this2.markerGroup.node().scale(1 / _this2.markerGroup.node().getScale()[0]);
          var scale4 = scaleToPixel(_this2.markerGroup.node(), _this2.scaleSize, true);
          _this2.markerGroup.node().style._transform = "scale(".concat(scale4, ")");
        });
      };
      CategoryItem2.prototype.renderLabel = function(container) {
        var _a2 = subStyleProps2(this.attributes, "label"), label = _a2.text, style = __rest(_a2, ["text"]);
        this.labelGroup = container.maybeAppendByClassName(CLASS_NAMES7.labelGroup, "g").style("zIndex", 0);
        this.labelGroup.maybeAppendByClassName(CLASS_NAMES7.label, function() {
          return renderExtDo(label);
        }).styles(style);
      };
      CategoryItem2.prototype.renderValue = function(container) {
        var _this2 = this;
        var _a2 = subStyleProps2(this.attributes, "value"), value = _a2.text, style = __rest(_a2, ["text"]);
        this.valueGroup = container.maybeAppendByClassName(CLASS_NAMES7.valueGroup, "g").style("zIndex", 0);
        ifShow(this.showValue, this.valueGroup, function() {
          _this2.valueGroup.maybeAppendByClassName(CLASS_NAMES7.value, function() {
            return renderExtDo(value);
          }).styles(style);
        });
      };
      CategoryItem2.prototype.createPoptip = function() {
        var poptip = this.attributes.poptip;
        var _a2 = poptip || {}, render = _a2.render, poptipStyle = __rest(_a2, ["render"]);
        var poptipGroup = new Poptip({ style: deepAssign(DEFAULT_POPTIP_PROPS, poptipStyle) });
        this.poptipGroup = poptipGroup;
        return poptipGroup;
      };
      CategoryItem2.prototype.bindPoptip = function(node) {
        var _this2 = this;
        var poptip = this.attributes.poptip;
        if (!poptip)
          return;
        var poptipGroup = this.poptipGroup || this.createPoptip();
        poptipGroup.bind(node, function() {
          var _a2 = _this2.attributes, labelText = _a2.labelText, valueText = _a2.valueText, markerFill = _a2.markerFill;
          var label = typeof labelText === "string" ? labelText : labelText === null || labelText === void 0 ? void 0 : labelText.attr("text");
          var value = typeof valueText === "string" ? valueText : valueText === null || valueText === void 0 ? void 0 : valueText.attr("text");
          if (typeof poptip.render === "function") {
            return { html: poptip.render({ label, value, color: markerFill }) };
          }
          var html = "";
          if (typeof label === "string" || typeof label === "number") {
            html += '<div class="component-poptip-label">'.concat(label, "</div>");
          }
          if (typeof value === "string" || typeof value === "number") {
            html += '<div class="component-poptip-value">'.concat(value, "</div>");
          }
          return { html };
        });
      };
      CategoryItem2.prototype.renderFocus = function(ctn) {
        var _this2 = this;
        var _a2 = this.attributes, focus2 = _a2.focus, focusMarkerSize = _a2.focusMarkerSize;
        var defaultOptions4 = {
          x: 0,
          y: 0,
          size: focusMarkerSize,
          opacity: 0.6,
          symbol: "focus",
          stroke: "#aaaaaa",
          lineWidth: 1
        };
        if ((0, import_util174.isUndefined)(focus2))
          return;
        this.focusGroup = ctn.maybeAppendByClassName(CLASS_NAMES7.focusGroup, "g").style("zIndex", 0);
        ifShow(focus2, this.focusGroup, function() {
          var marker = new Marker({
            style: __assign(__assign({}, defaultOptions4), { symbol: "focus" })
          });
          var interactiveCircle = new Circle({
            style: {
              r: defaultOptions4.size / 2,
              fill: "transparent"
            }
          });
          var container = _this2.focusGroup.node();
          container.appendChild(interactiveCircle);
          container.appendChild(marker);
          marker.update({ opacity: 0 });
          ctn.node().addEventListener("pointerenter", function() {
            marker.update({ opacity: 1 });
          });
          ctn.node().addEventListener("pointerleave", function() {
            marker.update({ opacity: 0 });
          });
        });
      };
      CategoryItem2.prototype.renderPoptip = function(ctn) {
        var _this2 = this;
        var poptip = this.attributes.poptip;
        if (!poptip)
          return;
        var valueNode = ctn.maybeAppendByClassName(CLASS_NAMES7.value, "g").node();
        var labelNode = ctn.maybeAppendByClassName(CLASS_NAMES7.label, "g").node();
        [valueNode, labelNode].forEach(function(node) {
          if (node) {
            _this2.bindPoptip(node);
          }
        });
      };
      CategoryItem2.prototype.renderBackground = function(container) {
        var _a2 = this.shape, width2 = _a2.width, height = _a2.height;
        var style = subStyleProps2(this.attributes, "background");
        this.background = container.maybeAppendByClassName(CLASS_NAMES7.backgroundGroup, "g").style("zIndex", -1);
        this.background.maybeAppendByClassName(CLASS_NAMES7.background, "rect").styles(__assign({ width: width2, height }, style));
      };
      CategoryItem2.prototype.adjustLayout = function() {
        var _a2 = this.layout, labelWidth = _a2.labelWidth, valueWidth = _a2.valueWidth, height = _a2.height, _b = __read(_a2.position, 4), markerX = _b[0], labelX = _b[1], valueX = _b[2], focusX = _b[3];
        var halfHeight = height / 2;
        this.markerGroup.styles({
          transform: "translate(".concat(markerX, ", ").concat(halfHeight, ")").concat(this.markerGroup.node().style._transform)
        });
        this.labelGroup.styles({ transform: "translate(".concat(labelX, ", ").concat(halfHeight, ")") });
        if (this.focusGroup)
          this.focusGroup.styles({ transform: "translate(".concat(focusX, ", ").concat(halfHeight, ")") });
        ellipsisIt(this.labelGroup.select(CLASS_NAMES7.label.class).node(), Math.ceil(labelWidth));
        if (this.showValue) {
          this.valueGroup.styles({ transform: "translate(".concat(valueX, ", ").concat(halfHeight, ")") });
          ellipsisIt(this.valueGroup.select(CLASS_NAMES7.value.class).node(), Math.ceil(valueWidth));
        }
      };
      CategoryItem2.prototype.render = function(attributes, container) {
        var ctn = select(container);
        var _a2 = attributes.x, x3 = _a2 === void 0 ? 0 : _a2, _b = attributes.y, y3 = _b === void 0 ? 0 : _b;
        ctn.styles({ transform: "translate(".concat(x3, ", ").concat(y3, ")") });
        this.renderMarker(ctn);
        this.renderLabel(ctn);
        this.renderValue(ctn);
        this.renderBackground(ctn);
        this.renderPoptip(ctn);
        this.renderFocus(ctn);
        this.adjustLayout();
      };
      return CategoryItem2;
    })(Component)
  );

  // node_modules/@antv/component/esm/ui/legend/category/items.js
  var CLASS_NAMES8 = classNames({
    page: "item-page",
    navigator: "navigator",
    item: "item"
  }, "items");
  var ifSatisfied = function(value, rule, defaultValue) {
    if (defaultValue === void 0) {
      defaultValue = true;
    }
    if (value) {
      return rule(value);
    }
    return defaultValue;
  };
  var CategoryItems = (
    /** @class */
    (function(_super) {
      __extends(CategoryItems2, _super);
      function CategoryItems2(options) {
        var _this2 = _super.call(this, options, {
          data: [],
          gridRow: Infinity,
          gridCol: void 0,
          padding: 0,
          width: 1e3,
          height: 100,
          rowPadding: 0,
          colPadding: 0,
          layout: "flex",
          orientation: "horizontal",
          click: import_util176.noop,
          mouseenter: import_util176.noop,
          mouseleave: import_util176.noop
        }) || this;
        _this2.navigatorShape = [0, 0];
        return _this2;
      }
      Object.defineProperty(CategoryItems2.prototype, "pageViews", {
        get: function() {
          return this.navigator.getContainer();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CategoryItems2.prototype, "grid", {
        get: function() {
          var _a2 = this.attributes, gridRow = _a2.gridRow, gridCol = _a2.gridCol, data2 = _a2.data;
          if (!gridRow && !gridCol)
            throw new Error("gridRow and gridCol can not be set null at the same time");
          if (!!gridRow && !!gridCol)
            return [gridRow, gridCol];
          if (gridRow)
            return [gridRow, data2.length];
          return [data2.length, gridCol];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CategoryItems2.prototype, "renderData", {
        get: function() {
          var _a2 = this.attributes, data2 = _a2.data, layout2 = _a2.layout, poptip = _a2.poptip, focus2 = _a2.focus, focusMarkerSize = _a2.focusMarkerSize;
          var style = subStyleProps2(this.attributes, "item");
          var d2 = data2.map(function(datum, index2) {
            var _a3 = datum.id, id3 = _a3 === void 0 ? index2 : _a3, labelText = datum.label, valueText = datum.value;
            return {
              id: "".concat(id3),
              index: index2,
              style: __assign({ layout: layout2, labelText, valueText, poptip, focus: focus2, focusMarkerSize }, Object.fromEntries(Object.entries(style).map(function(_a4) {
                var _b = __read(_a4, 2), key = _b[0], val = _b[1];
                return [key, getCallbackValue(val, [datum, index2, data2])];
              })))
            };
          });
          return d2;
        },
        enumerable: false,
        configurable: true
      });
      CategoryItems2.prototype.getGridLayout = function() {
        var _this2 = this;
        var _a2 = this.attributes, orientation5 = _a2.orientation, width2 = _a2.width, rowPadding = _a2.rowPadding, colPadding = _a2.colPadding;
        var _b = __read(this.navigatorShape, 1), navWidth = _b[0];
        var _c = __read(this.grid, 2), gridRow = _c[0], gridCol = _c[1];
        var pageSize = gridCol * gridRow;
        var prevOffset = 0;
        return this.pageViews.children.map(function(item, index2) {
          var _a3, _b2;
          var page = Math.floor(index2 / pageSize);
          var pageIndex = index2 % pageSize;
          var dir = _this2.ifHorizontal(gridCol, gridRow);
          var pos = [Math.floor(pageIndex / dir), pageIndex % dir];
          if (orientation5 === "vertical")
            pos.reverse();
          var _c2 = __read(pos, 2), row2 = _c2[0], col = _c2[1];
          var colWidth = (width2 - navWidth - (gridCol - 1) * colPadding) / gridCol;
          var rowHeight = item.getBBox().height;
          var _d = __read([0, 0], 2), x3 = _d[0], y3 = _d[1];
          if (orientation5 === "horizontal") {
            _a3 = __read([prevOffset, row2 * (rowHeight + rowPadding)], 2), x3 = _a3[0], y3 = _a3[1];
            prevOffset = col === gridCol - 1 ? 0 : prevOffset + colWidth + colPadding;
          } else {
            _b2 = __read([col * (colWidth + colPadding), prevOffset], 2), x3 = _b2[0], y3 = _b2[1];
            prevOffset = row2 === gridRow - 1 ? 0 : prevOffset + rowHeight + rowPadding;
          }
          return { page, index: index2, row: row2, col, pageIndex, width: colWidth, height: rowHeight, x: x3, y: y3 };
        });
      };
      CategoryItems2.prototype.getFlexLayout = function() {
        var _a2 = this.attributes, maxWidth = _a2.width, maxHeight = _a2.height, rowPadding = _a2.rowPadding, cP = _a2.colPadding;
        var _b = __read(this.navigatorShape, 1), navWidth = _b[0];
        var _c = __read(this.grid, 2), gridRow = _c[0], gridCol = _c[1];
        var _d = __read([maxWidth - navWidth, maxHeight], 2), limitWidth = _d[0], limitHeight = _d[1];
        var _e = __read([0, 0, 0, 0, 0, 0, 0, 0], 8), x3 = _e[0], y3 = _e[1], page = _e[2], pageIndex = _e[3], col = _e[4], row2 = _e[5], prevWidth = _e[6], prevHeight = _e[7];
        return this.pageViews.children.map(function(item, index2) {
          var _a3, _b2, _c2, _d2;
          var _e2 = item.getBBox(), width2 = _e2.width, height = _e2.height;
          var colPadding = prevWidth === 0 ? 0 : cP;
          var nextWidth = prevWidth + colPadding + width2;
          if (nextWidth <= limitWidth && ifSatisfied(col, function(c2) {
            return c2 < gridCol;
          })) {
            _a3 = __read([prevWidth + colPadding, prevHeight, nextWidth], 3), x3 = _a3[0], y3 = _a3[1], prevWidth = _a3[2];
            return { width: width2, height, x: x3, y: y3, page, index: index2, pageIndex: pageIndex++, row: row2, col: col++ };
          }
          _b2 = __read([row2 + 1, 0, 0, prevHeight + height + rowPadding], 4), row2 = _b2[0], col = _b2[1], prevWidth = _b2[2], prevHeight = _b2[3];
          var nextHeight = prevHeight + height;
          if (nextHeight <= limitHeight && ifSatisfied(row2, function(r) {
            return r < gridRow;
          })) {
            _c2 = __read([prevWidth, prevHeight, width2], 3), x3 = _c2[0], y3 = _c2[1], prevWidth = _c2[2];
            return { width: width2, height, x: x3, y: y3, page, index: index2, pageIndex: pageIndex++, row: row2, col: col++ };
          }
          _d2 = __read([0, 0, width2, 0, page + 1, 0, 0, 0], 8), x3 = _d2[0], y3 = _d2[1], prevWidth = _d2[2], prevHeight = _d2[3], page = _d2[4], pageIndex = _d2[5], row2 = _d2[6], col = _d2[7];
          return { width: width2, height, x: x3, y: y3, page, index: index2, pageIndex: pageIndex++, row: row2, col: col++ };
        });
      };
      Object.defineProperty(CategoryItems2.prototype, "itemsLayout", {
        get: function() {
          this.navigatorShape = [0, 0];
          var cb = this.attributes.layout === "grid" ? this.getGridLayout : this.getFlexLayout;
          var layout2 = cb.call(this);
          if (layout2.slice(-1)[0].page > 0) {
            this.navigatorShape = [55, 0];
            return cb.call(this);
          }
          return layout2;
        },
        enumerable: false,
        configurable: true
      });
      CategoryItems2.prototype.ifHorizontal = function(a2, b) {
        var orientation5 = this.attributes.orientation;
        return ifHorizontal(orientation5, a2, b);
      };
      CategoryItems2.prototype.flattenPage = function(container) {
        container.querySelectorAll(CLASS_NAMES8.item.class).forEach(function(item) {
          container.appendChild(item);
        });
        container.querySelectorAll(CLASS_NAMES8.page.class).forEach(function(page) {
          var removedPage = container.removeChild(page);
          removedPage.destroy();
        });
      };
      CategoryItems2.prototype.renderItems = function(container) {
        var _a2 = this.attributes, click = _a2.click, mouseenter = _a2.mouseenter, mouseleave = _a2.mouseleave;
        this.flattenPage(container);
        var dispatchCustomEvent = this.dispatchCustomEvent.bind(this);
        select(container).selectAll(CLASS_NAMES8.item.class).data(this.renderData, function(d2) {
          return d2.id;
        }).join(function(enter) {
          return enter.append(function(_a3) {
            var style = _a3.style;
            return new CategoryItem({ style });
          }).attr("className", CLASS_NAMES8.item.name).on("click", function() {
            click === null || click === void 0 ? void 0 : click(this);
            dispatchCustomEvent("itemClick", { item: this });
          }).on("pointerenter", function() {
            mouseenter === null || mouseenter === void 0 ? void 0 : mouseenter(this);
            dispatchCustomEvent("itemMouseenter", { item: this });
          }).on("pointerleave", function() {
            mouseleave === null || mouseleave === void 0 ? void 0 : mouseleave(this);
            dispatchCustomEvent("itemMouseleave", { item: this });
          });
        }, function(update) {
          return update.each(function(_a3) {
            var style = _a3.style;
            this.update(style);
          });
        }, function(exit) {
          return exit.remove();
        });
      };
      CategoryItems2.prototype.relayoutNavigator = function() {
        var _a2;
        var _b = this.attributes, layout2 = _b.layout, width2 = _b.width;
        var height = ((_a2 = this.pageViews.children[0]) === null || _a2 === void 0 ? void 0 : _a2.getBBox().height) || 0;
        var _c = __read(this.navigatorShape, 2), navWidth = _c[0], navHeight = _c[1];
        this.navigator.update(layout2 === "grid" ? { pageWidth: width2 - navWidth, pageHeight: height - navHeight } : {});
      };
      CategoryItems2.prototype.adjustLayout = function() {
        var _this2 = this;
        var itemsLayouts = Object.entries(groupBy4(this.itemsLayout, "page")).map(function(_a2) {
          var _b = __read(_a2, 2), page = _b[0], layouts2 = _b[1];
          return {
            page,
            layouts: layouts2
          };
        });
        var categoryItems = __spreadArray([], __read(this.navigator.getContainer().children), false);
        itemsLayouts.forEach(function(_a2) {
          var layouts2 = _a2.layouts;
          var page = _this2.pageViews.appendChild(new Group({ className: CLASS_NAMES8.page.name }));
          layouts2.forEach(function(layout2) {
            var x3 = layout2.x, y3 = layout2.y, index2 = layout2.index, width2 = layout2.width, height = layout2.height;
            var item = categoryItems[index2];
            page.appendChild(item);
            (0, import_util176.set)(item, "__layout__", layout2);
            item.update({ x: x3, y: y3, width: width2, height });
          });
        });
        this.relayoutNavigator();
      };
      CategoryItems2.prototype.renderNavigator = function(container) {
        var orientation5 = this.attributes.orientation;
        var navStyle = subStyleProps2(this.attributes, "nav");
        var style = deepAssign({ orientation: orientation5 }, navStyle);
        var that = this;
        container.selectAll(CLASS_NAMES8.navigator.class).data(["nav"]).join(function(enter) {
          return enter.append(function() {
            return new Navigator({ style });
          }).attr("className", CLASS_NAMES8.navigator.name).each(function() {
            that.navigator = this;
          });
        }, function(update) {
          return update.each(function() {
            this.update(style);
          });
        }, function(exit) {
          return exit.remove();
        });
        return this.navigator;
      };
      CategoryItems2.prototype.getBBox = function() {
        return this.navigator.getBBox();
      };
      CategoryItems2.prototype.render = function(attributes, container) {
        var data2 = this.attributes.data;
        if (!data2 || data2.length === 0)
          return;
        var navigator = this.renderNavigator(select(container));
        this.renderItems(navigator.getContainer());
        this.adjustLayout();
      };
      CategoryItems2.prototype.dispatchCustomEvent = function(type, payload) {
        var evt = new CustomEvent(type, {
          detail: payload
        });
        this.dispatchEvent(evt);
      };
      return CategoryItems2;
    })(Component)
  );

  // node_modules/@antv/component/esm/ui/legend/continuous/handle.js
  init_tslib_es6();
  var CLASS_NAMES9 = classNames({
    markerGroup: "marker-group",
    marker: "marker",
    labelGroup: "label-group",
    label: "label"
  }, "handle");
  var DEFAULT_HANDLE_CFG = {
    showLabel: true,
    formatter: function(val) {
      return val.toString();
    },
    markerSize: 25,
    markerStroke: "#c5c5c5",
    markerFill: "#fff",
    markerLineWidth: 1,
    labelFontSize: 12,
    labelFill: "#c5c5c5",
    labelText: "",
    orientation: "vertical",
    spacing: 0
  };
  var Handle2 = (
    /** @class */
    (function(_super) {
      __extends(Handle3, _super);
      function Handle3(options) {
        return _super.call(this, options, DEFAULT_HANDLE_CFG) || this;
      }
      Handle3.prototype.render = function(attributes, container) {
        var markerGroup = select(container).maybeAppendByClassName(CLASS_NAMES9.markerGroup, "g");
        this.renderMarker(markerGroup);
        var labelGroup = select(container).maybeAppendByClassName(CLASS_NAMES9.labelGroup, "g");
        this.renderLabel(labelGroup);
      };
      Handle3.prototype.renderMarker = function(container) {
        var _this2 = this;
        var _a2 = this.attributes, orientation5 = _a2.orientation, _b = _a2.markerSymbol, markerSymbol = _b === void 0 ? ifHorizontal(orientation5, "horizontalHandle", "verticalHandle") : _b;
        ifShow(!!markerSymbol, container, function(group2) {
          var handleStyle = subStyleProps2(_this2.attributes, "marker");
          var markerStyle = __assign({ symbol: markerSymbol }, handleStyle);
          _this2.marker = group2.maybeAppendByClassName(CLASS_NAMES9.marker, function() {
            return new Marker({ style: markerStyle });
          }).update(markerStyle);
        });
      };
      Handle3.prototype.renderLabel = function(container) {
        var _this2 = this;
        var _a2 = this.attributes, showLabel = _a2.showLabel, orientation5 = _a2.orientation, _b = _a2.spacing, spacing = _b === void 0 ? 0 : _b, formatter2 = _a2.formatter;
        ifShow(showLabel, container, function(group2) {
          var _a3;
          var _b2 = subStyleProps2(_this2.attributes, "label"), text = _b2.text, labelStyle = __rest(_b2, ["text"]);
          var _c = ((_a3 = group2.select(CLASS_NAMES9.marker.class)) === null || _a3 === void 0 ? void 0 : _a3.node().getBBox()) || {}, _d = _c.width, width2 = _d === void 0 ? 0 : _d, _e = _c.height, height = _e === void 0 ? 0 : _e;
          var _f = __read(ifHorizontal(orientation5, [0, height + spacing, "center", "top"], [width2 + spacing, 0, "start", "middle"]), 4), x3 = _f[0], y3 = _f[1], textAlign = _f[2], textBaseline = _f[3];
          group2.maybeAppendByClassName(CLASS_NAMES9.label, "text").styles(__assign(__assign({}, labelStyle), { x: x3, y: y3, text: formatter2(text).toString(), textAlign, textBaseline }));
        });
      };
      return Handle3;
    })(Component)
  );

  // node_modules/@antv/component/esm/ui/legend/constant.js
  var LEGEND_BASE_DEFAULT_OPTIONS = {
    showTitle: true,
    padding: 0,
    orientation: "horizontal",
    backgroundFill: "transparent",
    titleText: "",
    titleSpacing: 4,
    titlePosition: "top-left",
    titleFill: "#2C3542",
    titleFontWeight: "bold",
    titleFontFamily: "sans-serif",
    titleFontSize: 12
  };
  var CATEGORY_DEFAULT_OPTIONS = deepAssign({}, LEGEND_BASE_DEFAULT_OPTIONS, {});
  var CONTINUOUS_DEFAULT_OPTIONS = deepAssign({}, LEGEND_BASE_DEFAULT_OPTIONS, superStyleProps(DEFAULT_HANDLE_CFG, "handle"), {
    color: [
      "#d0e3fa",
      "#acc7f6",
      "#8daaf2",
      "#6d8eea",
      "#4d73cd",
      "#325bb1",
      "#5a3e75",
      "#8c3c79",
      "#e23455",
      "#e7655b"
    ],
    indicatorBackgroundFill: "#262626",
    indicatorLabelFill: "white",
    indicatorLabelFontSize: 12,
    indicatorVisibility: "hidden",
    labelAlign: "value",
    labelDirection: "positive",
    labelSpacing: 5,
    showHandle: true,
    showIndicator: true,
    showLabel: true,
    slidable: true,
    titleText: "",
    type: "continuous"
  });
  var CLASS_NAMES10 = classNames({
    title: "title",
    titleGroup: "title-group",
    items: "items",
    itemsGroup: "items-group",
    contentGroup: "content-group",
    ribbonGroup: "ribbon-group",
    ribbon: "ribbon",
    handlesGroup: "handles-group",
    handle: "handle",
    startHandle: "start-handle",
    endHandle: "end-handle",
    labelGroup: "label-group",
    label: "label",
    indicator: "indicator"
  }, "legend");

  // node_modules/@antv/component/esm/ui/legend/category.js
  var Category = (
    /** @class */
    (function(_super) {
      __extends(Category2, _super);
      function Category2(options) {
        return _super.call(this, options, CATEGORY_DEFAULT_OPTIONS) || this;
      }
      Category2.prototype.renderTitle = function(container, width2, height) {
        var _a2 = this.attributes, showTitle = _a2.showTitle, titleText = _a2.titleText;
        var style = subStyleProps2(this.attributes, "title");
        var _b = __read(splitStyle(style), 2), titleStyle = _b[0], groupStyle = _b[1];
        this.titleGroup = container.maybeAppendByClassName(CLASS_NAMES10.titleGroup, "g").styles(groupStyle);
        var finalTitleStyle = __assign(__assign({ width: width2, height }, titleStyle), { text: showTitle ? titleText : "" });
        this.title = this.titleGroup.maybeAppendByClassName(CLASS_NAMES10.title, function() {
          return new Title({ style: finalTitleStyle });
        }).update(finalTitleStyle);
      };
      Category2.prototype.renderItems = function(container, bbox) {
        var x3 = bbox.x, y3 = bbox.y, width2 = bbox.width, height = bbox.height;
        var style = subStyleProps2(this.attributes, "title", true);
        var _a2 = __read(splitStyle(style), 2), partialItemStyle = _a2[0], groupStyle = _a2[1];
        var itemStyle = __assign(__assign({}, partialItemStyle), { width: width2, height, x: 0, y: 0 });
        this.itemsGroup = container.maybeAppendByClassName(CLASS_NAMES10.itemsGroup, "g").styles(__assign(__assign({}, groupStyle), { transform: "translate(".concat(x3, ", ").concat(y3, ")") }));
        var that = this;
        this.itemsGroup.selectAll(CLASS_NAMES10.items.class).data(["items"]).join(function(enter) {
          return enter.append(function() {
            return new CategoryItems({ style: itemStyle });
          }).attr("className", CLASS_NAMES10.items.name).each(function() {
            that.items = select(this);
          });
        }, function(update) {
          return update.update(itemStyle);
        }, function(exit) {
          return exit.remove();
        });
      };
      Category2.prototype.adjustLayout = function() {
        var showTitle = this.attributes.showTitle;
        if (showTitle) {
          var _a2 = this.title.node().getAvailableSpace(), x3 = _a2.x, y3 = _a2.y;
          this.itemsGroup.node().style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
        }
      };
      Object.defineProperty(Category2.prototype, "availableSpace", {
        get: function() {
          var _a2 = this.attributes, showTitle = _a2.showTitle, width2 = _a2.width, height = _a2.height;
          if (!showTitle)
            return new BBox(0, 0, width2, height);
          return this.title.node().getAvailableSpace();
        },
        enumerable: false,
        configurable: true
      });
      Category2.prototype.getBBox = function() {
        var _a2, _b;
        var title = (_a2 = this.title) === null || _a2 === void 0 ? void 0 : _a2.node();
        var items = (_b = this.items) === null || _b === void 0 ? void 0 : _b.node();
        if (!title || !items)
          return _super.prototype.getBBox.call(this);
        return getBBox(title, items);
      };
      Category2.prototype.render = function(attributes, container) {
        var _a2 = this.attributes, width2 = _a2.width, height = _a2.height, _b = _a2.x, x3 = _b === void 0 ? 0 : _b, _c = _a2.y, y3 = _c === void 0 ? 0 : _c;
        var ctn = select(container);
        container.style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
        this.renderTitle(ctn, width2, height);
        this.renderItems(ctn, this.availableSpace);
        this.adjustLayout();
      };
      return Category2;
    })(Component)
  );

  // node_modules/@antv/component/esm/ui/indicator/indicator.js
  init_tslib_es6();

  // node_modules/@antv/component/esm/ui/indicator/constant.js
  var DEFAULT_INDICATOR_STYLE_PROPS = {
    backgroundFill: "#262626",
    backgroundLineCap: "round",
    backgroundLineWidth: 1,
    backgroundStroke: "#333",
    backgroundZIndex: -1,
    formatter: function(val) {
      return val.toString();
    },
    labelFill: "#fff",
    labelFontSize: 12,
    labelTextBaseline: "middle",
    padding: [2, 4],
    position: "right",
    radius: 0,
    zIndex: 999
  };

  // node_modules/@antv/component/esm/ui/indicator/indicator.js
  var CLASS_NAMES11 = classNames({
    background: "background",
    labelGroup: "label-group",
    label: "label"
  }, "indicator");
  var Indicator = (
    /** @class */
    (function(_super) {
      __extends(Indicator2, _super);
      function Indicator2(options) {
        var _this2 = _super.call(this, options, DEFAULT_INDICATOR_STYLE_PROPS) || this;
        _this2.point = [0, 0];
        _this2.group = _this2.appendChild(new Group({}));
        _this2.isMutationObserved = true;
        return _this2;
      }
      Indicator2.prototype.renderBackground = function() {
        if (!this.label)
          return;
        var _a2 = this.attributes, position2 = _a2.position, padding = _a2.padding;
        var _b = __read(parseSeriesAttr(padding), 4), t = _b[0], r = _b[1], b = _b[2], l = _b[3];
        var _c = this.label.node().getLocalBounds(), min4 = _c.min, max4 = _c.max;
        var bbox = new BBox(min4[0] - l, min4[1] - t, max4[0] + r - min4[0] + l, max4[1] + b - min4[1] + t);
        var path = this.getPath(position2, bbox);
        var style = subStyleProps2(this.attributes, "background");
        this.background = select(this.group).maybeAppendByClassName(CLASS_NAMES11.background, "path").styles(__assign(__assign({}, style), { d: path }));
        this.group.appendChild(this.label.node());
      };
      Indicator2.prototype.renderLabel = function() {
        var _a2 = this.attributes, formatter2 = _a2.formatter, labelText = _a2.labelText;
        var style = subStyleProps2(this.attributes, "label");
        var _b = __read(splitStyle(style), 2), _c = _b[0], groupStyle = _b[1], rawText = _c.text, textStyle = __rest(_c, ["text"]);
        this.label = select(this.group).maybeAppendByClassName(CLASS_NAMES11.labelGroup, "g").styles(groupStyle);
        if (!labelText)
          return;
        var text = this.label.maybeAppendByClassName(CLASS_NAMES11.label, function() {
          return renderExtDo(formatter2(labelText));
        }).style("text", formatter2(labelText).toString());
        text.selectAll("text").styles(textStyle);
      };
      Indicator2.prototype.adjustLayout = function() {
        var _a2 = __read(this.point, 2), dx = _a2[0], dy = _a2[1];
        var _b = this.attributes, x3 = _b.x, y3 = _b.y;
        this.group.attr("transform", "translate(".concat(x3 - dx, ", ").concat(y3 - dy, ")"));
      };
      Indicator2.prototype.getPath = function(position2, bbox) {
        var r = this.attributes.radius;
        var x3 = bbox.x, y3 = bbox.y, width2 = bbox.width, height = bbox.height;
        var pathArray = [
          // 0 开始路径
          ["M", x3 + r, y3],
          // 1 上边线
          ["L", x3 + width2 - r, y3],
          // 2 右上角圆弧
          ["A", r, r, 0, 0, 1, x3 + width2, y3 + r],
          // 3 右边线
          ["L", x3 + width2, y3 + height - r],
          // 4 右下角圆弧
          ["A", r, r, 0, 0, 1, x3 + width2 - r, y3 + height],
          // 5 下边线
          ["L", x3 + r, y3 + height],
          // 6 左下角圆弧
          ["A", r, r, 0, 0, 1, x3, y3 + height - r],
          // 7 左边线
          ["L", x3, y3 + r],
          // 8 左上角圆弧
          ["A", r, r, 0, 0, 1, x3 + r, y3],
          // 9 关闭路径
          ["Z"]
        ];
        var revertPositionMap = { top: 4, right: 6, bottom: 0, left: 2 };
        var index2 = revertPositionMap[position2];
        var newPath = this.createCorner([pathArray[index2].slice(-2), pathArray[index2 + 1].slice(-2)]);
        pathArray.splice.apply(pathArray, __spreadArray([index2 + 1, 1], __read(newPath), false));
        pathArray[0][0] = "M";
        return pathArray;
      };
      Indicator2.prototype.createCorner = function(edge, size2) {
        if (size2 === void 0) {
          size2 = 10;
        }
        var cornerScale = 0.8;
        var isH = isHorizontal2.apply(void 0, __spreadArray([], __read(edge), false));
        var _a2 = __read(edge, 2), _b = __read(_a2[0], 2), x0 = _b[0], y0 = _b[1], _c = __read(_a2[1], 2), x1 = _c[0], y1 = _c[1];
        var _d = __read(isH ? [x1 - x0, [x0, x1]] : [y1 - y0, [y0, y1]], 2), len = _d[0], _e = __read(_d[1], 2), b0 = _e[0], b1 = _e[1];
        var hL = len / 2;
        var sign = len / Math.abs(len);
        var cL = size2 * sign;
        var hCL = cL / 2;
        var cS = cL * Math.sqrt(3) / 2 * cornerScale;
        var _f = __read([b0, b0 + hL - hCL, b0 + hL, b0 + hL + hCL, b1], 5), a0 = _f[0], a1 = _f[1], a2 = _f[2], a3 = _f[3], a4 = _f[4];
        if (isH) {
          this.point = [a2, y0 - cS];
          return [
            ["L", a0, y0],
            ["L", a1, y0],
            ["L", a2, y0 - cS],
            ["L", a3, y0],
            ["L", a4, y0]
          ];
        }
        this.point = [x0 + cS, a2];
        return [
          ["L", x0, a0],
          ["L", x0, a1],
          ["L", x0 + cS, a2],
          ["L", x0, a3],
          ["L", x0, a4]
        ];
      };
      Indicator2.prototype.applyVisibility = function() {
        var visibility2 = this.attributes.visibility;
        if (visibility2 === "hidden")
          hide(this);
        else
          show(this);
      };
      Indicator2.prototype.bindEvents = function() {
        this.label.on(ElementEvent.BOUNDS_CHANGED, this.renderBackground);
      };
      Indicator2.prototype.render = function() {
        this.renderLabel();
        this.renderBackground();
        this.adjustLayout();
        this.applyVisibility();
      };
      return Indicator2;
    })(Component)
  );

  // node_modules/@antv/component/esm/ui/tooltip/index.js
  init_tslib_es6();
  var import_util182 = __toESM(require_lib());

  // node_modules/@antv/component/esm/ui/tooltip/constant.js
  init_tslib_es6();
  function getClassNames(prefixCls) {
    if (prefixCls === void 0) {
      prefixCls = "";
    }
    return {
      CONTAINER: "".concat(prefixCls, "tooltip"),
      TITLE: "".concat(prefixCls, "tooltip-title"),
      LIST: "".concat(prefixCls, "tooltip-list"),
      LIST_ITEM: "".concat(prefixCls, "tooltip-list-item"),
      NAME: "".concat(prefixCls, "tooltip-list-item-name"),
      MARKER: "".concat(prefixCls, "tooltip-list-item-marker"),
      NAME_LABEL: "".concat(prefixCls, "tooltip-list-item-name-label"),
      VALUE: "".concat(prefixCls, "tooltip-list-item-value"),
      CROSSHAIR_X: "".concat(prefixCls, "tooltip-crosshair-x"),
      CROSSHAIR_Y: "".concat(prefixCls, "tooltip-crosshair-y")
    };
  }
  var TEXT_OVERFLOW_STYLE = {
    overflow: "hidden",
    "white-space": "nowrap",
    "text-overflow": "ellipsis"
  };
  function getDefaultTooltipStyle(prefixCls) {
    var _a2;
    if (prefixCls === void 0) {
      prefixCls = "";
    }
    var CLASS_NAME2 = getClassNames(prefixCls);
    return _a2 = {}, _a2[".".concat(CLASS_NAME2.CONTAINER)] = {
      position: "absolute",
      visibility: "visible",
      // 'white-space': 'nowrap',
      "z-index": 8,
      transition: "visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)",
      "background-color": "rgba(255, 255, 255, 0.96)",
      "box-shadow": "0 6px 12px 0 rgba(0, 0, 0, 0.12)",
      "border-radius": "4px",
      color: "rgba(0, 0, 0, 0.65)",
      "font-size": "12px",
      // 'font-family': ,
      "line-height": "20px",
      padding: "12px",
      "min-width": "120px",
      "max-width": "360px",
      "font-family": "Roboto-Regular"
    }, _a2[".".concat(CLASS_NAME2.TITLE)] = {
      color: "rgba(0, 0, 0, 0.45)"
    }, _a2[".".concat(CLASS_NAME2.LIST)] = {
      margin: "0px",
      "list-style-type": "none",
      padding: "0px"
    }, _a2[".".concat(CLASS_NAME2.LIST_ITEM)] = {
      "list-style-type": "none",
      display: "flex",
      "line-height": "2em",
      "align-items": "center",
      "justify-content": "space-between",
      "white-space": "nowrap"
    }, _a2[".".concat(CLASS_NAME2.MARKER)] = {
      width: "8px",
      height: "8px",
      "border-radius": "50%",
      display: "inline-block",
      "margin-right": "4px"
    }, _a2[".".concat(CLASS_NAME2.NAME)] = {
      display: "flex",
      "align-items": "center",
      "max-width": "216px"
    }, _a2[".".concat(CLASS_NAME2.NAME_LABEL)] = __assign({ flex: 1 }, TEXT_OVERFLOW_STYLE), _a2[".".concat(CLASS_NAME2.VALUE)] = __assign({ display: "inline-block", float: "right", flex: 1, "text-align": "right", "min-width": "28px", "margin-left": "30px", color: "rgba(0, 0, 0, 0.85)" }, TEXT_OVERFLOW_STYLE), _a2[".".concat(CLASS_NAME2.CROSSHAIR_X)] = {
      position: "absolute",
      width: "1px",
      "background-color": "rgba(0, 0, 0, 0.25)"
    }, _a2[".".concat(CLASS_NAME2.CROSSHAIR_Y)] = {
      position: "absolute",
      height: "1px",
      "background-color": "rgba(0, 0, 0, 0.25)"
    }, _a2;
  }

  // node_modules/@antv/component/esm/ui/tooltip/index.js
  var Tooltip = (
    /** @class */
    (function(_super) {
      __extends(Tooltip3, _super);
      function Tooltip3(options) {
        var _this2 = this;
        var _a2, _b;
        var prefixCls = (_b = (_a2 = options.style) === null || _a2 === void 0 ? void 0 : _a2.template) === null || _b === void 0 ? void 0 : _b.prefixCls;
        var CLASS_NAME2 = getClassNames(prefixCls);
        _this2 = _super.call(this, options, {
          data: [],
          x: 0,
          y: 0,
          visibility: "visible",
          title: "",
          position: "bottom-right",
          offset: [5, 5],
          enterable: false,
          container: {
            x: 0,
            y: 0
          },
          bounding: null,
          template: {
            prefixCls: "",
            container: '<div class="'.concat(CLASS_NAME2.CONTAINER, '"></div>'),
            title: '<div class="'.concat(CLASS_NAME2.TITLE, '"></div>'),
            item: '<li class="'.concat(CLASS_NAME2.LIST_ITEM, '" data-index={index}>\n        <span class="').concat(CLASS_NAME2.NAME, '">\n          <span class="').concat(CLASS_NAME2.MARKER, '" style="background:{color}"></span>\n          <span class="').concat(CLASS_NAME2.NAME_LABEL, '" title="{name}">{name}</span>\n        </span>\n        <span class="').concat(CLASS_NAME2.VALUE, '" title="{value}">{value}</span>\n      </li>')
          },
          style: getDefaultTooltipStyle(prefixCls)
        }) || this;
        _this2.timestamp = -1;
        _this2.prevCustomContentKey = _this2.attributes.contentKey;
        _this2.initShape();
        _this2.render(_this2.attributes, _this2);
        return _this2;
      }
      Object.defineProperty(Tooltip3.prototype, "HTMLTooltipElement", {
        get: function() {
          return this.element;
        },
        enumerable: false,
        configurable: true
      });
      Tooltip3.prototype.getContainer = function() {
        return this.element;
      };
      Object.defineProperty(Tooltip3.prototype, "elementSize", {
        get: function() {
          var width2 = this.element.offsetWidth;
          var height = this.element.offsetHeight;
          return { width: width2, height };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Tooltip3.prototype, "HTMLTooltipItemsElements", {
        get: function() {
          var _a2 = this.attributes, data2 = _a2.data, template = _a2.template;
          return data2.map(function(_a3, idx) {
            var _b = _a3.name, name = _b === void 0 ? "" : _b, _c = _a3.color, color2 = _c === void 0 ? "black" : _c, index2 = _a3.index, rest = __rest(_a3, ["name", "color", "index"]);
            var datum = __assign({ name, color: color2, index: index2 !== null && index2 !== void 0 ? index2 : idx }, rest);
            return (0, import_util182.createDOM)((0, import_util182.substitute)(template.item, datum));
          });
        },
        enumerable: false,
        configurable: true
      });
      Tooltip3.prototype.render = function(attributes, container) {
        this.renderHTMLTooltipElement();
        this.updatePosition();
      };
      Tooltip3.prototype.destroy = function() {
        var _a2;
        (_a2 = this.element) === null || _a2 === void 0 ? void 0 : _a2.remove();
        _super.prototype.destroy.call(this);
      };
      Tooltip3.prototype.show = function(x3, y3) {
        var _this2 = this;
        if (x3 !== void 0 && y3 !== void 0) {
          var isToggle = this.element.style.visibility === "hidden";
          var setPosition = function() {
            _this2.attributes.x = x3 !== null && x3 !== void 0 ? x3 : _this2.attributes.x;
            _this2.attributes.y = y3 !== null && y3 !== void 0 ? y3 : _this2.attributes.y;
            _this2.updatePosition();
          };
          isToggle ? this.closeTransition(setPosition) : setPosition();
        }
        this.element.style.visibility = "visible";
      };
      Tooltip3.prototype.hide = function(x3, y3) {
        if (x3 === void 0) {
          x3 = 0;
        }
        if (y3 === void 0) {
          y3 = 0;
        }
        var enterable = this.attributes.enterable;
        if (enterable && this.isCursorEntered(x3, y3))
          return;
        this.element.style.visibility = "hidden";
      };
      Tooltip3.prototype.initShape = function() {
        var template = this.attributes.template;
        this.element = (0, import_util182.createDOM)(template.container);
        if (this.id)
          this.element.setAttribute("id", this.id);
      };
      Tooltip3.prototype.renderCustomContent = function() {
        if (this.prevCustomContentKey !== void 0 && this.prevCustomContentKey === this.attributes.contentKey)
          return;
        this.prevCustomContentKey = this.attributes.contentKey;
        var content = this.attributes.content;
        if (!content)
          return;
        if (typeof content === "string")
          this.element.innerHTML = content;
        else
          replaceChildren(this.element, content);
      };
      Tooltip3.prototype.renderHTMLTooltipElement = function() {
        var _a2, _b;
        var _c = this.attributes, template = _c.template, title = _c.title, enterable = _c.enterable, style = _c.style, content = _c.content;
        var CLASS_NAME2 = getClassNames(template.prefixCls);
        var container = this.element;
        this.element.style.pointerEvents = enterable ? "auto" : "none";
        if (content)
          this.renderCustomContent();
        else {
          if (title) {
            container.innerHTML = template.title;
            container.getElementsByClassName(CLASS_NAME2.TITLE)[0].innerHTML = title;
          } else
            (_b = (_a2 = container.getElementsByClassName(CLASS_NAME2.TITLE)) === null || _a2 === void 0 ? void 0 : _a2[0]) === null || _b === void 0 ? void 0 : _b.remove();
          var itemsElements = this.HTMLTooltipItemsElements;
          var ul = document.createElement("ul");
          ul.className = CLASS_NAME2.LIST;
          replaceChildren(ul, itemsElements);
          var list = this.element.querySelector(".".concat(CLASS_NAME2.LIST));
          if (list)
            list.replaceWith(ul);
          else
            container.appendChild(ul);
        }
        applyStyleSheet(container, style);
      };
      Tooltip3.prototype.getRelativeOffsetFromCursor = function(assignPosition) {
        var _a2 = this.attributes, position2 = _a2.position, offset = _a2.offset;
        var interPosition = assignPosition || position2;
        var finalPosition = interPosition.split("-");
        var positionScore = { left: [-1, 0], right: [1, 0], top: [0, -1], bottom: [0, 1] };
        var _b = this.elementSize, width2 = _b.width, height = _b.height;
        var absolutelyOffset = [-width2 / 2, -height / 2];
        finalPosition.forEach(function(pos) {
          var _a3 = __read(absolutelyOffset, 2), abs1 = _a3[0], abs2 = _a3[1];
          var _b2 = __read(positionScore[pos], 2), pos1 = _b2[0], pos2 = _b2[1];
          absolutelyOffset = [abs1 + (width2 / 2 + offset[0]) * pos1, abs2 + (height / 2 + offset[1]) * pos2];
        });
        return absolutelyOffset;
      };
      Tooltip3.prototype.setOffsetPosition = function(_a2) {
        var _b = __read(_a2, 2), offsetX = _b[0], offsetY = _b[1];
        var _c = this.attributes, _d = _c.x, x3 = _d === void 0 ? 0 : _d, _e = _c.y, y3 = _e === void 0 ? 0 : _e, _f = _c.container, cx = _f.x, cy = _f.y;
        this.element.style.left = "".concat(+x3 + cx + offsetX, "px");
        this.element.style.top = "".concat(+y3 + cy + offsetY, "px");
      };
      Tooltip3.prototype.updatePosition = function() {
        var _a2 = this.attributes.showDelay, showDelay = _a2 === void 0 ? 60 : _a2;
        var currentTimestamp = Date.now();
        if (this.timestamp > 0 && currentTimestamp - this.timestamp < showDelay)
          return;
        this.timestamp = currentTimestamp;
        this.setOffsetPosition(this.autoPosition(this.getRelativeOffsetFromCursor()));
      };
      Tooltip3.prototype.autoPosition = function(_a2) {
        var _b = __read(_a2, 2), offsetX = _b[0], offsetY = _b[1];
        var _c = this.attributes, cursorX = _c.x, cursorY = _c.y, bounding = _c.bounding, position2 = _c.position;
        if (!bounding)
          return [offsetX, offsetY];
        var _d = this.element, offsetWidth = _d.offsetWidth, offsetHeight = _d.offsetHeight;
        var _e = __read([+cursorX + offsetX, +cursorY + offsetY], 2), expectLeft = _e[0], expectTop = _e[1];
        var inversion = {
          left: "right",
          right: "left",
          top: "bottom",
          bottom: "top"
        };
        var boundingX = bounding.x, boundingY = bounding.y, boundingWidth = bounding.width, boundingHeight = bounding.height;
        var edgeCompare = {
          left: expectLeft < boundingX,
          right: expectLeft + offsetWidth > boundingX + boundingWidth,
          top: expectTop < boundingY,
          bottom: expectTop + offsetHeight > boundingY + boundingHeight
        };
        var correctivePosition = [];
        position2.split("-").forEach(function(pos) {
          if (edgeCompare[pos])
            correctivePosition.push(inversion[pos]);
          else
            correctivePosition.push(pos);
        });
        var correctedPositionString = correctivePosition.join("-");
        return this.getRelativeOffsetFromCursor(correctedPositionString);
      };
      Tooltip3.prototype.isCursorEntered = function(clientX, clientY) {
        if (this.element) {
          var _a2 = this.element.getBoundingClientRect(), x3 = _a2.x, y3 = _a2.y, width2 = _a2.width, height = _a2.height;
          return new BBox(x3, y3, width2, height).isPointIn(clientX, clientY);
        }
        return false;
      };
      Tooltip3.prototype.closeTransition = function(callback) {
        var _this2 = this;
        var transition2 = this.element.style.transition;
        this.element.style.transition = "none";
        callback();
        setTimeout(function() {
          _this2.element.style.transition = transition2;
        }, 10);
      };
      Tooltip3.tag = "tooltip";
      return Tooltip3;
    })(Component)
  );

  // node_modules/@antv/component/esm/ui/select/select.js
  init_tslib_es6();

  // node_modules/@antv/component/esm/ui/select/option.js
  init_tslib_es6();
  var Option = (
    /** @class */
    (function(_super) {
      __extends(Option2, _super);
      function Option2(options) {
        var _this2 = _super.call(this, deepAssign({}, Option2.defaultOptions, options)) || this;
        _this2.hoverColor = "#f5f5f5";
        _this2.selectedColor = "#e6f7ff";
        _this2.background = _this2.appendChild(new Rect({}));
        _this2.label = _this2.background.appendChild(new Group({}));
        return _this2;
      }
      Object.defineProperty(Option2.prototype, "padding", {
        get: function() {
          return parseSeriesAttr(this.style.padding);
        },
        enumerable: false,
        configurable: true
      });
      Option2.prototype.renderLabel = function() {
        var _a2 = this.style, label = _a2.label, value = _a2.value;
        var labelStyle = subStyleProps2(this.attributes, "label");
        select(this.label).maybeAppend(".label", function() {
          return renderExtDo(label);
        }).attr("className", "label").styles(labelStyle);
        this.label.attr("__data__", value);
      };
      Option2.prototype.renderBackground = function() {
        var labelBBox = this.label.getBBox();
        var _a2 = __read(this.padding, 4), top = _a2[0], right = _a2[1], bottom = _a2[2], left = _a2[3];
        var labelWidth = labelBBox.width, labelHeight = labelBBox.height;
        var backgroundWidth = labelWidth + left + right;
        var backgroundHeight = labelHeight + top + bottom;
        var backgroundStyle = subStyleProps2(this.attributes, "background");
        var _b = this.style, _c = _b.width, styleWidth = _c === void 0 ? 0 : _c, _d = _b.height, styleHeight = _d === void 0 ? 0 : _d, selected = _b.selected;
        this.background.attr(__assign(__assign({}, backgroundStyle), { width: Math.max(backgroundWidth, styleWidth), height: Math.max(backgroundHeight, styleHeight), fill: selected ? this.selectedColor : "#fff" }));
        this.label.attr({ transform: "translate(".concat(left, ", ").concat((backgroundHeight - labelHeight) / 2, ")") });
      };
      Option2.prototype.render = function() {
        this.renderLabel();
        this.renderBackground();
      };
      Option2.prototype.bindEvents = function() {
        var _this2 = this;
        this.addEventListener("pointerenter", function() {
          if (_this2.style.selected)
            return;
          _this2.background.attr("fill", _this2.hoverColor);
        });
        this.addEventListener("pointerleave", function() {
          if (_this2.style.selected)
            return;
          _this2.background.attr("fill", _this2.style.backgroundFill);
        });
        var item = this;
        this.addEventListener("click", function() {
          var _a2 = _this2.style, label = _a2.label, value = _a2.value, onClick = _a2.onClick;
          onClick === null || onClick === void 0 ? void 0 : onClick(value, { label, value }, item);
        });
      };
      Option2.defaultOptions = {
        style: {
          value: "",
          label: "",
          cursor: "pointer"
        }
      };
      return Option2;
    })(Component)
  );

  // node_modules/@antv/component/esm/ui/select/select.js
  var Select = (
    /** @class */
    (function(_super) {
      __extends(Select2, _super);
      function Select2(options) {
        var _a2, _b;
        var _this2 = _super.call(this, deepAssign({}, Select2.defaultOptions, options)) || this;
        _this2.currentValue = (_a2 = Select2.defaultOptions.style) === null || _a2 === void 0 ? void 0 : _a2.defaultValue;
        _this2.isPointerInSelect = false;
        _this2.select = _this2.appendChild(new Rect({
          className: "select",
          style: {
            cursor: "pointer",
            width: 0,
            height: 0
          }
        }));
        _this2.dropdown = _this2.appendChild(new Rect({
          className: "dropdown"
        }));
        var defaultValue = _this2.style.defaultValue;
        if (defaultValue && ((_b = _this2.style.options) === null || _b === void 0 ? void 0 : _b.some(function(option) {
          return option.value === defaultValue;
        }))) {
          _this2.currentValue = defaultValue;
        }
        return _this2;
      }
      Select2.prototype.setValue = function(value) {
        this.currentValue = value;
        this.render();
      };
      Select2.prototype.getValue = function() {
        return this.currentValue;
      };
      Object.defineProperty(Select2.prototype, "dropdownPadding", {
        get: function() {
          return parseSeriesAttr(this.style.dropdownPadding);
        },
        enumerable: false,
        configurable: true
      });
      Select2.prototype.renderSelect = function() {
        var _this2 = this;
        var _a2;
        var _b = this.style, x3 = _b.x, y3 = _b.y, width2 = _b.width, height = _b.height, bordered = _b.bordered, showDropdownIcon = _b.showDropdownIcon;
        var selectStyle = subStyleProps2(this.attributes, "select");
        var placeholderStyle = subStyleProps2(this.attributes, "placeholder");
        this.select.attr(__assign(__assign({ x: x3, y: y3, width: width2, height }, selectStyle), { fill: "#fff", strokeWidth: bordered ? 1 : 0 }));
        var padding = this.dropdownPadding;
        var iconSize = 10;
        if (showDropdownIcon) {
          select(this.select).maybeAppend(".dropdown-icon", "path").style("d", "M-5,-3.5 L0,3.5 L5,-3.5").style("transform", "translate(".concat(x3 + width2 - iconSize - padding[1] - padding[3], ", ").concat(y3 + height / 2, ")")).style("lineWidth", 1).style("stroke", this.select.style.stroke);
        }
        var currentOption = (_a2 = this.style.options) === null || _a2 === void 0 ? void 0 : _a2.find(function(option) {
          return option.value === _this2.currentValue;
        });
        var finalPlaceholderStyle = __assign({ x: x3 + padding[3] }, placeholderStyle);
        select(this.select).selectAll(".placeholder").data(!currentOption ? [1] : []).join(function(enter) {
          return enter.append("text").attr("className", "placeholder").styles(finalPlaceholderStyle).style("y", function() {
            var bbox = this.getBBox();
            return y3 + (height - bbox.height) / 2;
          });
        }, function(update) {
          return update.styles(finalPlaceholderStyle);
        }, function(exit) {
          return exit.remove();
        });
        var labelStyle = subStyleProps2(this.attributes, "optionLabel");
        var finalValueStyle = __assign({ x: x3 + padding[3] }, labelStyle);
        select(this.select).selectAll(".value").data(currentOption ? [currentOption] : []).join(function(enter) {
          return enter.append(function(datum) {
            return renderExtDo(datum.label);
          }).attr("className", "value").styles(finalValueStyle).style("y", function() {
            var bbox = this.getBBox();
            return y3 + (height - bbox.height) / 2;
          });
        }, function(update) {
          return update.styles(finalValueStyle);
        }, function(exit) {
          return exit.remove();
        });
      };
      Select2.prototype.renderDropdown = function() {
        var _this2 = this;
        var _a2, _b;
        var _c = this.style, x3 = _c.x, y3 = _c.y, width2 = _c.width, height = _c.height, options = _c.options, onSelect = _c.onSelect, open = _c.open;
        var dropdownStyle = subStyleProps2(this.attributes, "dropdown");
        var optionStyle = subStyleProps2(this.attributes, "option");
        var padding = this.dropdownPadding;
        select(this.dropdown).maybeAppend(".dropdown-container", "g").attr("className", "dropdown-container").selectAll(".dropdown-item").data(options, function(datum) {
          return datum.value;
        }).join(function(enter) {
          return enter.append(function(datum) {
            return new Option({
              className: "dropdown-item",
              style: __assign(__assign(__assign({}, datum), optionStyle), { width: width2 - padding[1] - padding[3], selected: datum.value === _this2.currentValue, onClick: function(value, option, item) {
                _this2.setValue(value);
                onSelect === null || onSelect === void 0 ? void 0 : onSelect(value, option, item);
                _this2.dispatchEvent(new CustomEvent("change", { detail: { value, option, item } }));
                hide(_this2.dropdown);
              } })
            });
          }).each(function(datum, i) {
            var _a3;
            var nodes = (_a3 = this.parentNode) === null || _a3 === void 0 ? void 0 : _a3.children;
            var accHeight = nodes.reduce(function(acc, curr, index2) {
              if (index2 < i) {
                acc += curr.getBBox().height;
              }
              return acc;
            }, 0);
            this.attr("transform", "translate(".concat(padding[3], ", ").concat(padding[0] + accHeight, ")"));
          });
        }, function(update) {
          return update.update(function(datum) {
            return { selected: datum.value === _this2.currentValue };
          });
        }, function(exit) {
          return exit.remove();
        });
        var bbox = (_b = (_a2 = this.dropdown.getElementsByClassName("dropdown-container")) === null || _a2 === void 0 ? void 0 : _a2[0]) === null || _b === void 0 ? void 0 : _b.getBBox();
        var spacing = dropdownStyle.spacing;
        this.dropdown.attr(__assign({ transform: "translate(".concat(x3, ", ").concat(y3 + height + spacing, ")"), width: bbox.width + padding[1] + padding[3], height: bbox.height + padding[0] + padding[2] }, dropdownStyle));
        !open && hide(this.dropdown);
      };
      Select2.prototype.render = function() {
        this.renderSelect();
        this.renderDropdown();
      };
      Select2.prototype.bindEvents = function() {
        var _this2 = this;
        this.addEventListener("click", function(e) {
          e.stopPropagation();
        });
        this.select.addEventListener("click", function() {
          if (_this2.dropdown.style.visibility === "visible")
            hide(_this2.dropdown);
          else {
            show(_this2.dropdown);
          }
        });
        this.addEventListener("pointerenter", function() {
          _this2.isPointerInSelect = true;
        });
        this.addEventListener("pointerleave", function() {
          _this2.isPointerInSelect = false;
        });
        document === null || document === void 0 ? void 0 : document.addEventListener("click", function() {
          if (!_this2.isPointerInSelect) {
            hide(_this2.dropdown);
          }
        });
      };
      Select2.defaultOptions = {
        style: {
          x: 0,
          y: 0,
          width: 140,
          height: 32,
          options: [],
          bordered: true,
          defaultValue: "",
          selectRadius: 8,
          selectStroke: "#d9d9d9",
          showDropdownIcon: true,
          placeholderText: "\u8BF7\u9009\u62E9",
          placeholderFontSize: 12,
          placeholderTextBaseline: "top",
          placeholderFill: "#c2c2c2",
          dropdownFill: "#fff",
          dropdownStroke: "#d9d9d9",
          dropdownRadius: 8,
          dropdownShadowBlur: 4,
          dropdownShadowColor: "rgba(0, 0, 0, 0.08)",
          dropdownPadding: 8,
          dropdownSpacing: 10,
          optionPadding: [8, 12],
          optionFontSize: 12,
          optionTextBaseline: "top",
          optionBackgroundFill: "#fff",
          optionBackgroundRadius: 4,
          optionLabelFontSize: 12,
          optionLabelTextBaseline: "top"
        }
      };
      return Select2;
    })(Component)
  );

  // node_modules/@antv/component/esm/ui/timebar/timebar.js
  init_tslib_es6();
  var import_util190 = __toESM(require_lib());

  // node_modules/@antv/component/esm/ui/timebar/controller.js
  init_tslib_es6();

  // node_modules/@antv/component/esm/ui/timebar/icons.js
  init_tslib_es6();
  var import_util186 = __toESM(require_lib());
  var IconBase = (
    /** @class */
    (function(_super) {
      __extends(IconBase2, _super);
      function IconBase2(options) {
        var _this2 = _super.call(this, deepAssign({}, { style: { backgroundOpacity: IconBase2.backgroundOpacities.default } }, IconBase2.defaultOptions, options)) || this;
        _this2.showBackground = true;
        _this2.background = _this2.appendChild(new Rect({}));
        _this2.icon = _this2.appendChild(new Group({}));
        return _this2;
      }
      Object.defineProperty(IconBase2.prototype, "label", {
        get: function() {
          return "BaseIcon";
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(IconBase2.prototype, "lineWidth", {
        get: function() {
          return Math.log10(this.attributes.size);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(IconBase2.prototype, "padding", {
        get: function() {
          return parseSeriesAttr(this.attributes.size / 5);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(IconBase2.prototype, "iconSize", {
        get: function() {
          var size2 = this.attributes.size;
          var _a2 = __read(this.padding, 4), top = _a2[0], right = _a2[1], bottom = _a2[2], left = _a2[3];
          return Math.max(size2 - Math.max(left + right, top + bottom), this.lineWidth * 2 + 1);
        },
        enumerable: false,
        configurable: true
      });
      IconBase2.prototype.renderBackground = function() {
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, size2 = _a2.size;
        var halfSize = size2 / 2;
        var backgroundStyle = subStyleProps2(this.attributes, "background");
        this.background.attr(__assign({ x: x3 - halfSize, y: y3 - halfSize, width: size2, height: size2 }, backgroundStyle));
      };
      IconBase2.prototype.showIndicator = function() {
        if (!this.label)
          return;
        var size2 = this.attributes.size;
        var _a2 = this.background.getBBox(), x3 = _a2.x, y3 = _a2.y;
        this.indicator.update({ x: x3 + size2 / 2, y: y3 - 5, labelText: this.label, visibility: "visible" });
      };
      IconBase2.prototype.hideIndicator = function() {
        this.indicator.update({ visibility: "hidden" });
      };
      IconBase2.prototype.connectedCallback = function() {
        var _a2;
        _super.prototype.connectedCallback.call(this);
        var size2 = this.attributes.size;
        var _b = this.background.getBBox(), x3 = _b.x, y3 = _b.y;
        var canvas2 = (_a2 = this.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView;
        if (canvas2) {
          this.indicator = canvas2.appendChild(new Indicator({
            style: {
              x: x3 + size2 / 2,
              y: y3 - size2 / 2,
              visibility: "hidden",
              position: "top",
              radius: 3,
              zIndex: 100
            }
          }));
        }
      };
      IconBase2.prototype.disconnectedCallback = function() {
        this.indicator.destroy();
      };
      IconBase2.prototype.render = function() {
        this.renderIcon();
        if (this.showBackground)
          this.renderBackground();
      };
      IconBase2.prototype.bindEvents = function() {
        var _this2 = this;
        var onClick = this.attributes.onClick;
        this.addEventListener("click", function() {
          onClick === null || onClick === void 0 ? void 0 : onClick(_this2);
        });
        if (this.showBackground) {
          var resetBackground_1 = function() {
            return _this2.background.attr({ opacity: IconBase2.backgroundOpacities.default });
          };
          var hoverBackground_1 = function() {
            return _this2.background.attr({ opacity: IconBase2.backgroundOpacities.hover });
          };
          var activeBackground_1 = function() {
            return _this2.background.attr({ opacity: IconBase2.backgroundOpacities.active });
          };
          this.addEventListener("pointerenter", function() {
            hoverBackground_1();
            _this2.showIndicator();
          });
          this.addEventListener("pointerleave", function() {
            resetBackground_1();
            _this2.hideIndicator();
          });
          this.addEventListener("pointerdown", function() {
            activeBackground_1();
          });
          this.addEventListener("pointerup", function() {
            resetBackground_1();
          });
        }
      };
      IconBase2.tag = "IconBase";
      IconBase2.defaultOptions = {
        style: {
          x: 0,
          y: 0,
          size: 10,
          color: "#565758",
          backgroundRadius: 4,
          backgroundFill: "#e2e2e2"
        }
      };
      IconBase2.backgroundOpacities = {
        default: 0,
        hover: 0.8,
        active: 1
      };
      return IconBase2;
    })(Component)
  );
  var arrow = function(size2, color2) {
    if (color2 === void 0) {
      color2 = "#565758";
    }
    return new Path({
      style: {
        fill: color2,
        d: "M ".concat(size2, ",").concat(size2, " L -").concat(size2, ",0 L ").concat(size2, ",-").concat(size2, " Z"),
        transformOrigin: "center"
      }
    });
  };
  var Reset = (
    /** @class */
    (function(_super) {
      __extends(Reset2, _super);
      function Reset2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Reset2.prototype.arcPath = function(cx, cy, radius) {
        var _a2 = __read([radius, radius], 2), rx = _a2[0], ry = _a2[1];
        var getPosByAngle = function(angle2) {
          return [cx + radius * Math.cos(angle2), cy + radius * Math.sin(angle2)];
        };
        var _b = __read(getPosByAngle(-5 / 4 * Math.PI), 2), x1 = _b[0], y1 = _b[1];
        var _c = __read(getPosByAngle(1 / 4 * Math.PI), 2), x22 = _c[0], y22 = _c[1];
        return "M".concat(x1, ",").concat(y1, ",A").concat(rx, ",").concat(ry, ",0,1,1,").concat(x22, ",").concat(y22);
      };
      Object.defineProperty(Reset2.prototype, "label", {
        get: function() {
          return "\u91CD\u7F6E";
        },
        enumerable: false,
        configurable: true
      });
      Reset2.prototype.renderIcon = function() {
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color2 = _a2.color;
        var size2 = this.iconSize;
        var lineWidth = this.lineWidth;
        var arrowSize = lineWidth + 0.5;
        select(this.icon).maybeAppend(".reset", "path").styles({
          stroke: color2,
          lineWidth,
          d: this.arcPath(x3, y3, size2 / 2 - lineWidth),
          markerStart: arrow(arrowSize, color2)
        });
      };
      return Reset2;
    })(IconBase)
  );
  var Backward = (
    /** @class */
    (function(_super) {
      __extends(Backward2, _super);
      function Backward2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Object.defineProperty(Backward2.prototype, "label", {
        get: function() {
          return "\u5FEB\u9000";
        },
        enumerable: false,
        configurable: true
      });
      Backward2.prototype.renderIcon = function() {
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color2 = _a2.color;
        var size2 = this.iconSize;
        var deltaX = size2 / 2;
        var deltaY = size2 / 2 / Math.pow(3, 0.5);
        var points = [
          [x3, y3],
          [x3, y3 - deltaY],
          [x3 - deltaX, y3],
          [x3, y3 + deltaY],
          [x3, y3],
          [x3 + deltaX, y3 - deltaY],
          [x3 + deltaX, y3 + deltaY],
          [x3, y3]
        ];
        select(this.icon).maybeAppend(".backward", "polygon").styles({
          points,
          fill: color2
        });
      };
      return Backward2;
    })(IconBase)
  );
  var Forward = (
    /** @class */
    (function(_super) {
      __extends(Forward2, _super);
      function Forward2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Object.defineProperty(Forward2.prototype, "label", {
        get: function() {
          return "\u5FEB\u8FDB";
        },
        enumerable: false,
        configurable: true
      });
      Forward2.prototype.renderIcon = function() {
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color2 = _a2.color;
        var size2 = this.iconSize;
        var deltaX = size2 / 2;
        var deltaY = size2 / 2 / Math.pow(3, 0.5);
        var points = [
          [x3, y3],
          [x3, y3 - deltaY],
          [x3 + deltaX, y3],
          [x3, y3 + deltaY],
          [x3, y3],
          [x3 - deltaX, y3 - deltaY],
          [x3 - deltaX, y3 + deltaY],
          [x3, y3]
        ];
        select(this.icon).maybeAppend(".forward", "polygon").styles({
          points,
          fill: color2
        });
      };
      return Forward2;
    })(IconBase)
  );
  var Play = (
    /** @class */
    (function(_super) {
      __extends(Play2, _super);
      function Play2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Object.defineProperty(Play2.prototype, "label", {
        get: function() {
          return "\u64AD\u653E";
        },
        enumerable: false,
        configurable: true
      });
      Play2.prototype.renderIcon = function() {
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color2 = _a2.color;
        var size2 = this.iconSize;
        var deltaX = size2 / 3 * Math.pow(3, 0.5) * 0.8;
        var points = [
          [x3 + deltaX, y3],
          [x3 - deltaX / 2, y3 - size2 / 2 * 0.8],
          [x3 - deltaX / 2, y3 + size2 / 2 * 0.8],
          [x3 + deltaX, y3]
        ];
        select(this.icon).maybeAppend(".play", "polygon").styles({
          points,
          fill: color2
        });
      };
      return Play2;
    })(IconBase)
  );
  var Pause = (
    /** @class */
    (function(_super) {
      __extends(Pause2, _super);
      function Pause2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Object.defineProperty(Pause2.prototype, "label", {
        get: function() {
          return "\u6682\u505C";
        },
        enumerable: false,
        configurable: true
      });
      Pause2.prototype.renderIcon = function() {
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color2 = _a2.color;
        var size2 = this.iconSize;
        var deltaX = size2 / 3;
        var points = [
          [x3 - deltaX, y3 - size2 / 2],
          [x3 - deltaX, y3 + size2 / 2],
          [x3 - deltaX / 2, y3 + size2 / 2],
          [x3 - deltaX / 2, y3 - size2 / 2],
          [x3 - deltaX, y3 - size2 / 2],
          [x3 + deltaX / 2, y3 - size2 / 2],
          [x3 + deltaX / 2, y3 + size2 / 2],
          [x3 + deltaX, y3 + size2 / 2],
          [x3 + deltaX, y3 - size2 / 2]
        ];
        select(this.icon).maybeAppend(".pause", "polygon").styles({
          points,
          fill: color2
        });
      };
      return Pause2;
    })(IconBase)
  );
  var Range = (
    /** @class */
    (function(_super) {
      __extends(Range2, _super);
      function Range2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Object.defineProperty(Range2.prototype, "label", {
        get: function() {
          return "\u8303\u56F4\u65F6\u95F4";
        },
        enumerable: false,
        configurable: true
      });
      Range2.prototype.renderIcon = function() {
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color2 = _a2.color;
        var _b = this, size2 = _b.iconSize, lineWidth = _b.lineWidth;
        var gap = lineWidth;
        select(this.icon).maybeAppend(".left-line", "line").styles({
          x1: x3 - size2 / 2,
          y1: y3 - size2 / 2,
          x2: x3 - size2 / 2,
          y2: y3 + size2 / 2,
          stroke: color2,
          lineWidth
        });
        select(this.icon).maybeAppend(".right-line", "line").styles({
          x1: x3 + size2 / 2,
          y1: y3 - size2 / 2,
          x2: x3 + size2 / 2,
          y2: y3 + size2 / 2,
          stroke: color2,
          lineWidth
        });
        select(this.icon).maybeAppend(".left-arrow", "line").styles({
          x1: x3,
          y1: y3,
          x2: x3 - size2 / 2 + gap * 2,
          y2: y3,
          stroke: color2,
          lineWidth,
          markerEnd: arrow(lineWidth * 2, color2)
        });
        select(this.icon).maybeAppend(".right-arrow", "line").styles({
          x1: x3,
          y1: y3,
          x2: x3 + size2 / 2 - gap * 2,
          y2: y3,
          stroke: color2,
          lineWidth,
          markerEnd: arrow(lineWidth * 2, color2)
        });
      };
      return Range2;
    })(IconBase)
  );
  var Value = (
    /** @class */
    (function(_super) {
      __extends(Value2, _super);
      function Value2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Object.defineProperty(Value2.prototype, "label", {
        get: function() {
          return "\u5355\u4E00\u65F6\u95F4";
        },
        enumerable: false,
        configurable: true
      });
      Value2.prototype.renderIcon = function() {
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color2 = _a2.color;
        var _b = this, size2 = _b.iconSize, lineWidth = _b.lineWidth;
        select(this.icon).maybeAppend(".line", "line").styles({
          x1: x3,
          y1: y3 - size2 / 2,
          x2: x3,
          y2: y3 + size2 / 2,
          stroke: color2,
          lineWidth
        });
        var gap = lineWidth;
        select(this.icon).maybeAppend(".left-arrow", "line").styles({
          x1: x3 - size2 / 2 - gap * 2,
          y1: y3,
          x2: x3 - gap * 2,
          y2: y3,
          stroke: color2,
          lineWidth,
          markerEnd: arrow(lineWidth * 2, color2)
        });
        select(this.icon).maybeAppend(".right-arrow", "line").styles({
          x1: x3 + size2 / 2 + gap * 2,
          y1: y3,
          x2: x3 + gap * 2,
          y2: y3,
          stroke: color2,
          lineWidth,
          markerEnd: arrow(lineWidth * 2, color2)
        });
      };
      return Value2;
    })(IconBase)
  );
  var getCoordinatePoints = function(size2) {
    return [
      [-size2 / 2, -size2 / 2],
      [-size2 / 2, size2 / 2],
      [size2 / 2, size2 / 2]
    ];
  };
  var LineChart = (
    /** @class */
    (function(_super) {
      __extends(LineChart2, _super);
      function LineChart2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Object.defineProperty(LineChart2.prototype, "label", {
        get: function() {
          return "\u6298\u7EBF\u56FE";
        },
        enumerable: false,
        configurable: true
      });
      LineChart2.prototype.renderIcon = function() {
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color2 = _a2.color;
        var _b = this, size2 = _b.iconSize, lineWidth = _b.lineWidth;
        var gap = lineWidth;
        var deltaX = (size2 - gap * 2 - lineWidth) / 4;
        var deltaY = (size2 - gap * 2 - lineWidth) / 2;
        var _c = __read([x3 - size2 / 2 + gap, y3 + size2 / 2 - gap * 2], 2), ox = _c[0], oy = _c[1];
        select(this.icon).maybeAppend(".coordinate", "polyline").styles({
          points: getCoordinatePoints(size2).map(function(_a3) {
            var _b2 = __read(_a3, 2), px = _b2[0], py = _b2[1];
            return [px + x3, py + y3];
          }),
          stroke: color2,
          lineWidth
        });
        select(this.icon).maybeAppend(".line", "polyline").styles({
          points: [
            [ox, oy],
            [ox + deltaX, oy - deltaY],
            [ox + deltaX * 2, oy],
            [ox + deltaX * 4, oy - deltaY * 2]
          ],
          stroke: color2,
          lineWidth
        });
      };
      return LineChart2;
    })(IconBase)
  );
  var BarChart = (
    /** @class */
    (function(_super) {
      __extends(BarChart2, _super);
      function BarChart2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Object.defineProperty(BarChart2.prototype, "label", {
        get: function() {
          return "\u6761\u5F62\u56FE";
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BarChart2.prototype, "data", {
        get: function() {
          return [1, 4, 2, 4, 3];
        },
        enumerable: false,
        configurable: true
      });
      BarChart2.prototype.renderIcon = function() {
        var data2 = this.data;
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color2 = _a2.color;
        var _b = this, size2 = _b.iconSize, lineWidth = _b.lineWidth;
        var gap = lineWidth;
        var deltaX = (size2 - gap) / data2.length;
        var deltaY = (size2 - gap * 2) / 4;
        var _c = __read([x3 - size2 / 2 + gap * 2, y3 + size2 / 2 - gap], 2), ox = _c[0], oy = _c[1];
        select(this.icon).maybeAppend(".coordinate", "polyline").styles({
          points: getCoordinatePoints(size2).map(function(_a3) {
            var _b2 = __read(_a3, 2), px = _b2[0], py = _b2[1];
            return [px + x3, py + y3];
          }),
          stroke: color2,
          lineWidth
        });
        select(this.icon).maybeAppend(".bars", "g").selectAll(".column").data(this.data.map(function(value, index2) {
          return { value, index: index2 };
        })).join(function(enter) {
          return enter.append("line").attr("className", "column").style("x1", function(_a3) {
            var index2 = _a3.index;
            return ox + deltaX * index2;
          }).style("y1", oy).style("x2", function(_a3) {
            var index2 = _a3.index;
            return ox + deltaX * index2;
          }).style("y2", function(_a3) {
            var value = _a3.value;
            return oy - deltaY * value;
          }).styles({
            y1: oy,
            stroke: color2,
            lineWidth
          });
        });
      };
      return BarChart2;
    })(IconBase)
  );
  var Split = (
    /** @class */
    (function(_super) {
      __extends(Split2, _super);
      function Split2(options) {
        var _this2 = _super.call(this, deepAssign({}, { style: { color: "#d8d9d9" } }, options)) || this;
        _this2.showBackground = false;
        return _this2;
      }
      Split2.prototype.renderIcon = function() {
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, color2 = _a2.color;
        var _b = this, size2 = _b.iconSize, lineWidth = _b.lineWidth;
        select(this.icon).maybeAppend(".split", "line").styles({
          x1: x3,
          y1: y3 - size2 / 2,
          x2: x3,
          y2: y3 + size2 / 2,
          stroke: color2,
          lineWidth
        });
      };
      return Split2;
    })(IconBase)
  );
  var SpeedSelect = (
    /** @class */
    (function(_super) {
      __extends(SpeedSelect2, _super);
      function SpeedSelect2() {
        var _this2 = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
        _this2.showBackground = false;
        return _this2;
      }
      Object.defineProperty(SpeedSelect2.prototype, "padding", {
        get: function() {
          return parseSeriesAttr(0);
        },
        enumerable: false,
        configurable: true
      });
      SpeedSelect2.prototype.renderIcon = function() {
        var iconSize = this.iconSize;
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, _b = _a2.speed, speed = _b === void 0 ? 1 : _b;
        var inheritStyle = (0, import_util186.omit)(this.attributes, [
          "x",
          "y",
          "transform",
          "transformOrigin",
          "width",
          "height",
          "size",
          "color",
          "speed"
        ]);
        var width2 = (0, import_util186.clamp)(iconSize, 20, Infinity);
        var height = 20;
        var style = __assign(__assign({}, inheritStyle), { x: x3 - width2 / 2, y: y3 - height / 2, width: width2, height, defaultValue: speed, bordered: false, showDropdownIcon: false, selectRadius: 2, dropdownPadding: this.padding, dropdownRadius: 2, dropdownSpacing: iconSize / 5, placeholderFontSize: iconSize / 2, optionPadding: 0, optionLabelFontSize: iconSize / 2, optionBackgroundRadius: 1, options: [
          { label: "1x", value: 1 },
          { label: "1.5x", value: 1.5 },
          { label: "2x", value: 2 }
        ] });
        select(this.icon).maybeAppend(".speed", function() {
          return new Select({ style });
        }).attr("className", "speed").each(function() {
          this.update(style);
        });
      };
      SpeedSelect2.tag = "SpeedSelect";
      return SpeedSelect2;
    })(IconBase)
  );
  var ToggleIcon = (
    /** @class */
    (function(_super) {
      __extends(ToggleIcon2, _super);
      function ToggleIcon2(options) {
        var _this2 = _super.call(this, options) || this;
        _this2.icon = _this2.appendChild(new Group({}));
        _this2.currentType = _this2.attributes.type;
        return _this2;
      }
      ToggleIcon2.prototype.getType = function() {
        return this.currentType;
      };
      ToggleIcon2.prototype.render = function() {
        var _this2 = this;
        var _a2 = this.attributes, onChange = _a2.onChange, restStyles = __rest(_a2, ["onChange"]);
        select(this.icon).selectAll(".icon").data([this.currentType]).join(function(enter) {
          return enter.append(function(type) {
            var _a3;
            var Ctor = (_a3 = _this2.toggles.find(function(_a4) {
              var _b = __read(_a4, 1), key = _b[0];
              return key === type;
            })) === null || _a3 === void 0 ? void 0 : _a3[1];
            if (!Ctor)
              throw new Error("Invalid type: ".concat(type));
            return new Ctor({});
          }).attr("className", "icon").styles(restStyles, false).update({});
        }, function(update) {
          return update.styles({ restStyles }).update({});
        }, function(exit) {
          return exit.remove();
        });
      };
      ToggleIcon2.prototype.bindEvents = function() {
        var _this2 = this;
        var onChange = this.attributes.onChange;
        this.addEventListener("click", function(e) {
          e.preventDefault();
          e.stopPropagation();
          var nextIndex = (_this2.toggles.findIndex(function(_a2) {
            var _b = __read(_a2, 1), key = _b[0];
            return key === _this2.currentType;
          }) + 1) % _this2.toggles.length;
          var nextType = _this2.toggles[nextIndex][0];
          onChange === null || onChange === void 0 ? void 0 : onChange(_this2.currentType);
          _this2.currentType = nextType;
          _this2.render();
        });
      };
      ToggleIcon2.tag = "ToggleIcon";
      return ToggleIcon2;
    })(Component)
  );
  var PlayPause = (
    /** @class */
    (function(_super) {
      __extends(PlayPause2, _super);
      function PlayPause2(options) {
        var _this2 = _super.call(this, deepAssign({}, { style: { type: "play" } }, options)) || this;
        _this2.toggles = [
          ["play", Play],
          ["pause", Pause]
        ];
        return _this2;
      }
      return PlayPause2;
    })(ToggleIcon)
  );
  var SelectionType = (
    /** @class */
    (function(_super) {
      __extends(SelectionType2, _super);
      function SelectionType2(options) {
        var _this2 = _super.call(this, deepAssign({}, { style: { type: "range" } }, options)) || this;
        _this2.toggles = [
          ["range", Range],
          ["value", Value]
        ];
        return _this2;
      }
      return SelectionType2;
    })(ToggleIcon)
  );
  var ChartType = (
    /** @class */
    (function(_super) {
      __extends(ChartType2, _super);
      function ChartType2(options) {
        var _this2 = _super.call(this, deepAssign({}, { style: { type: "column" } }, options)) || this;
        _this2.toggles = [
          ["line", LineChart],
          ["column", BarChart]
        ];
        return _this2;
      }
      return ChartType2;
    })(ToggleIcon)
  );

  // node_modules/@antv/component/esm/ui/timebar/controller.js
  var componentsMap = {
    reset: Reset,
    speed: SpeedSelect,
    backward: Backward,
    playPause: PlayPause,
    forward: Forward,
    selectionType: SelectionType,
    chartType: ChartType,
    split: Split
  };
  var Controller = (
    /** @class */
    (function(_super) {
      __extends(Controller2, _super);
      function Controller2(options) {
        var _this2 = _super.call(this, deepAssign({}, Controller2.defaultOptions, options)) || this;
        _this2.background = _this2.appendChild(new Rect({}));
        _this2.functions = _this2.appendChild(new Group({}));
        return _this2;
      }
      Object.defineProperty(Controller2.prototype, "padding", {
        get: function() {
          return parseSeriesAttr(this.attributes.padding);
        },
        enumerable: false,
        configurable: true
      });
      Controller2.prototype.renderBackground = function() {
        var _a2 = this.style, x3 = _a2.x, y3 = _a2.y, width2 = _a2.width, height = _a2.height;
        var backgroundStyle = subStyleProps2(this.attributes, "background");
        this.background.attr(__assign({ x: x3, y: y3, width: width2, height }, backgroundStyle));
      };
      Controller2.prototype.renderFunctions = function() {
        var _this2 = this;
        var _a2;
        var _b = this.attributes, functions = _b.functions, iconSize = _b.iconSize, iconSpacing = _b.iconSpacing, x3 = _b.x, y3 = _b.y, width2 = _b.width, height = _b.height, align = _b.align;
        var _c = __read(this.padding, 4), right = _c[1], left = _c[3];
        var components = functions.reduce(function(prev, curr) {
          if (prev.length && curr.length) {
            return prev.concat.apply(prev, __spreadArray(["split"], __read(curr), false));
          }
          return prev.concat.apply(prev, __spreadArray([], __read(curr), false));
        }, []);
        var componentsWidth = components.length * (iconSize + iconSpacing) - iconSpacing;
        var xOffset = {
          left: left + iconSize / 2,
          center: (width2 - componentsWidth) / 2 + iconSize / 2,
          right: width2 - componentsWidth - left - right + iconSize / 2
        }[align] || 0;
        (_a2 = this.speedSelect) === null || _a2 === void 0 ? void 0 : _a2.destroy();
        this.functions.removeChildren();
        components.forEach(function(name, index2) {
          var _a3;
          var Ctor = componentsMap[name];
          var style = {
            x: x3 + index2 * (iconSize + iconSpacing) + xOffset,
            y: y3 + height / 2,
            size: iconSize
          };
          if (Ctor === SpeedSelect) {
            style.speed = _this2.attributes.speed;
            style.onSelect = function(value) {
              return _this2.handleFunctionChange(name, { value });
            };
          } else if ([PlayPause, SelectionType, ChartType].includes(Ctor)) {
            style.onChange = function(value) {
              return _this2.handleFunctionChange(name, { value });
            };
            if (Ctor === PlayPause)
              style.type = _this2.attributes.state === "play" ? "pause" : "play";
            if (Ctor === SelectionType)
              style.type = _this2.attributes.selectionType === "range" ? "value" : "range";
            if (Ctor === ChartType)
              style.type = _this2.attributes.chartType === "line" ? "column" : "line";
          } else {
            style.onClick = function() {
              return _this2.handleFunctionChange(name, { value: name });
            };
          }
          if (Ctor === SpeedSelect) {
            var canvas2 = (_a3 = _this2.ownerDocument) === null || _a3 === void 0 ? void 0 : _a3.defaultView;
            if (canvas2) {
              _this2.speedSelect = new Ctor({ style: __assign(__assign({}, style), { zIndex: 100 }) });
              canvas2.appendChild(_this2.speedSelect);
            }
          } else {
            _this2.functions.appendChild(new Ctor({ style }));
          }
        });
      };
      Controller2.prototype.disconnectedCallback = function() {
        var _a2;
        _super.prototype.disconnectedCallback.call(this);
        (_a2 = this.speedSelect) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      };
      Controller2.prototype.render = function() {
        this.renderBackground();
        this.renderFunctions();
      };
      Controller2.prototype.handleFunctionChange = function(name, value) {
        var onChange = this.attributes.onChange;
        onChange === null || onChange === void 0 ? void 0 : onChange(name, value);
      };
      Controller2.defaultOptions = {
        style: {
          x: 0,
          y: 0,
          width: 300,
          height: 40,
          padding: 0,
          align: "center",
          iconSize: 25,
          iconSpacing: 0,
          speed: 1,
          state: "pause",
          chartType: "line",
          selectionType: "range",
          backgroundFill: "#fbfdff",
          backgroundStroke: "#ebedf0",
          functions: [
            ["reset", "speed"],
            ["backward", "playPause", "forward"],
            ["selectionType", "chartType"]
          ]
        }
      };
      return Controller2;
    })(Component)
  );

  // node_modules/@antv/component/esm/ui/timebar/handle.js
  init_tslib_es6();
  var TimeModeHandle = (
    /** @class */
    (function(_super) {
      __extends(TimeModeHandle2, _super);
      function TimeModeHandle2(options) {
        var _this2 = _super.call(this, deepAssign({}, TimeModeHandle2.defaultOptions, options)) || this;
        _this2.bindEvents();
        return _this2;
      }
      TimeModeHandle2.prototype.bindEvents = function() {
        var _this2 = this;
        this.addEventListener("mouseenter", function() {
          _this2.attr("lineWidth", Math.ceil(+(_this2.style.r || 0) / 2));
        });
        this.addEventListener("mouseleave", function() {
          _this2.attr("lineWidth", 0);
        });
      };
      TimeModeHandle2.defaultOptions = {
        style: {
          r: 5,
          fill: "#3f7cf7",
          lineWidth: 0,
          stroke: "#3f7cf7",
          strokeOpacity: 0.5,
          cursor: "pointer"
        }
      };
      return TimeModeHandle2;
    })(Circle)
  );
  var ChartModeHandle = (
    /** @class */
    (function(_super) {
      __extends(ChartModeHandle2, _super);
      function ChartModeHandle2(options) {
        return _super.call(this, deepAssign({}, ChartModeHandle2.defaultOptions, options)) || this;
      }
      ChartModeHandle2.prototype.renderBackground = function() {
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, width2 = _a2.width, height = _a2.height;
        var style = subStyleProps2(this.attributes, "background");
        select(this).maybeAppend("background", "rect").attr("className", "background").styles(__assign({ x: x3 - width2 / 2, y: y3 - height / 2, width: width2, height }, style));
      };
      ChartModeHandle2.prototype.renderIcon = function() {
        var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, iconSize = _a2.iconSize;
        var style = subStyleProps2(this.attributes, "icon");
        var diffX = 1;
        var diffY = iconSize / 2;
        select(this).maybeAppend("icon-left-line", "line").attr("className", "icon-left-line").styles(__assign({ x1: x3 - diffX, y1: y3 - diffY, x2: x3 - diffX, y2: y3 + diffY }, style));
        select(this).maybeAppend("icon-right-line", "line").attr("className", "icon-right-line").styles(__assign({ x1: x3 + diffX, y1: y3 - diffY, x2: x3 + diffX, y2: y3 + diffY }, style));
      };
      ChartModeHandle2.prototype.renderBorder = function() {
        var _a2 = this.attributes, xx = _a2.x, y3 = _a2.y, width2 = _a2.width, height = _a2.height, type = _a2.type;
        var style = subStyleProps2(this.attributes, "border");
        var x3 = type === "start" ? +width2 / 2 : -width2 / 2;
        select(this).maybeAppend("border", "line").attr("className", "border").styles(__assign({ x1: x3 + xx, y1: y3 - height / 2, x2: x3 + xx, y2: y3 + height / 2 }, style));
      };
      ChartModeHandle2.prototype.render = function() {
        this.renderBackground();
        this.renderIcon();
        this.renderBorder();
      };
      ChartModeHandle2.defaultOptions = {
        style: {
          x: 0,
          y: 0,
          width: 10,
          height: 50,
          iconSize: 10,
          type: "start",
          backgroundFill: "#fff",
          backgroundFillOpacity: 0.5,
          iconStroke: "#9a9a9a",
          iconLineWidth: 1,
          borderStroke: "#e8e8e8",
          borderLineWidth: 1
        }
      };
      return ChartModeHandle2;
    })(Component)
  );

  // node_modules/@antv/component/esm/ui/timebar/utils.js
  function labelFormatter(time, interval2) {
    if (typeof time === "number") {
      return parseBySeries(time);
    }
    return parseByTime(time, interval2);
  }
  function parseByTime(time, interval2) {
    var date = new Date(time);
    switch (interval2) {
      case "half-hour":
      case "hour":
      case "four-hour":
        if ([0, 6, 12, 18].includes(date.getHours()) && date.getMinutes() === 0) {
          return formatTime(date, "HH:mm\nYYYY-MM-DD");
        }
        return formatTime(date, "HH:mm");
      case "half-day":
        if (date.getHours() < 12) {
          return "AM\n".concat(formatTime(date, "YYYY-MM-DD"));
        }
        return "PM";
      case "day":
        if ([1, 10, 20].includes(date.getDate())) {
          return formatTime(date, "DD\nYYYY-MM");
        }
        return formatTime(date, "DD");
      case "week":
        if (date.getDate() <= 7) {
          return formatTime(date, "DD\nYYYY-MM");
        }
        return formatTime(date, "DD");
      case "month":
        if ([0, 6].includes(date.getMonth())) {
          return formatTime(date, "MM\u6708\nYYYY");
        }
        return formatTime(date, "MM\u6708");
      case "season":
        if ([0].includes(date.getMonth())) {
          return formatTime(date, "MM\u6708\nYYYY");
        }
        return formatTime(date, "MM\u6708");
      case "year":
        return formatTime(date, "YYYY");
      default:
        return formatTime(date, "YYYY-MM-DD HH:mm");
    }
  }
  function parseBySeries(time) {
    var hours = String(Math.floor(time / 3600)).padStart(2, "0");
    var minutes = String(Math.floor(time % 3600 / 60)).padStart(2, "0");
    var seconds = String(Math.floor(time % 60)).padStart(2, "0");
    if (time < 3600) {
      return "".concat(minutes, ":").concat(seconds);
    }
    return "".concat(hours, ":").concat(minutes, ":").concat(seconds);
  }

  // node_modules/@antv/component/esm/ui/timebar/timebar.js
  var Timebar = (
    /** @class */
    (function(_super) {
      __extends(Timebar3, _super);
      function Timebar3(options) {
        var _this2 = _super.call(this, deepAssign({}, Timebar3.defaultOptions, options)) || this;
        _this2.axis = _this2.appendChild(new Axis({
          style: { type: "linear", startPos: [0, 0], endPos: [0, 0], data: [], showArrow: false, animate: false }
        }));
        _this2.timeline = _this2.appendChild(new Slider({
          style: {
            onChange: function(values3) {
              _this2.handleSliderChange(values3);
            }
          }
        }));
        _this2.controller = _this2.appendChild(new Controller({}));
        _this2.states = {};
        _this2.handleSliderChange = function(values3) {
          var prevValues = (function() {
            var val = _this2.states.values;
            if (Array.isArray(val))
              return __spreadArray([], __read(val), false);
            return val;
          })();
          _this2.setBySliderValues(values3);
          _this2.dispatchOnChange(prevValues);
        };
        var _a2 = _this2.attributes, selectionType = _a2.selectionType, chartType = _a2.chartType, speed = _a2.speed, state = _a2.state, playMode = _a2.playMode, values2 = _a2.values;
        _this2.states = { chartType, playMode, selectionType, speed, state };
        _this2.setByTimebarValues(values2);
        return _this2;
      }
      Object.defineProperty(Timebar3.prototype, "data", {
        get: function() {
          var data2 = this.attributes.data;
          var compareFn = function(a2, b) {
            if (a2.time < b.time)
              return -1;
            if (a2.time > b.time)
              return 1;
            return 0;
          };
          return data2.sort(compareFn);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Timebar3.prototype, "space", {
        /** 计算空间分配 */
        get: function() {
          var _a2 = this.attributes, x3 = _a2.x, y3 = _a2.y, width2 = _a2.width, height = _a2.height, type = _a2.type, controllerHeight = _a2.controllerHeight;
          var availableTimelineHeight = (0, import_util190.clamp)(+height - controllerHeight, 0, +height);
          var controllerBBox = new BBox(x3, y3 + +height - controllerHeight, +width2, controllerHeight);
          var axisBBox;
          var axisHeight = 0;
          if (type === "chart") {
            axisHeight = 35;
            axisBBox = new BBox(x3, y3 + availableTimelineHeight - axisHeight, +width2, axisHeight);
          } else
            axisBBox = new BBox();
          var timelineHeight = type === "time" ? 10 : availableTimelineHeight;
          var timelineBBox = new BBox(x3, y3 + (type === "time" ? availableTimelineHeight : availableTimelineHeight - timelineHeight), +width2, timelineHeight - axisHeight);
          return { axisBBox, controllerBBox, timelineBBox };
        },
        enumerable: false,
        configurable: true
      });
      Timebar3.prototype.setBySliderValues = function(val) {
        var _a2, _b;
        var data2 = this.data;
        var _c = __read(Array.isArray(val) ? val : [0, val], 2), startRatio = _c[0], endRatio = _c[1];
        var length = data2.length;
        var startDatum = data2[Math.floor(startRatio * length)];
        var endDatum = data2[Math.ceil(endRatio * length) - (Array.isArray(val) ? 0 : 1)];
        this.states.values = [(_a2 = startDatum === null || startDatum === void 0 ? void 0 : startDatum.time) !== null && _a2 !== void 0 ? _a2 : data2[0].time, (_b = endDatum === null || endDatum === void 0 ? void 0 : endDatum.time) !== null && _b !== void 0 ? _b : Infinity];
      };
      Timebar3.prototype.setByTimebarValues = function(val) {
        var _a2, _b, _c;
        var data2 = this.data;
        var _d = __read(Array.isArray(val) ? val : [void 0, val], 2), start = _d[0], end = _d[1];
        var startDatum = data2.find(function(_a3) {
          var time = _a3.time;
          return time === start;
        });
        var endDatum = data2.find(function(_a3) {
          var time = _a3.time;
          return time === end;
        });
        this.states.values = [(_a2 = startDatum === null || startDatum === void 0 ? void 0 : startDatum.time) !== null && _a2 !== void 0 ? _a2 : (_b = data2[0]) === null || _b === void 0 ? void 0 : _b.time, (_c = endDatum === null || endDatum === void 0 ? void 0 : endDatum.time) !== null && _c !== void 0 ? _c : Infinity];
      };
      Timebar3.prototype.setByIndex = function(index2) {
        var _a2, _b, _c, _d;
        var data2 = this.data;
        var _e = __read(index2, 2), startIndex = _e[0], endIndex = _e[1];
        this.states.values = [(_b = (_a2 = data2[startIndex]) === null || _a2 === void 0 ? void 0 : _a2.time) !== null && _b !== void 0 ? _b : data2[0].time, (_d = (_c = this.data[endIndex]) === null || _c === void 0 ? void 0 : _c.time) !== null && _d !== void 0 ? _d : Infinity];
      };
      Object.defineProperty(Timebar3.prototype, "sliderValues", {
        /**
         * 获取 timebar 的 values
         */
        get: function() {
          var _a2 = this.states, values2 = _a2.values, selectionType = _a2.selectionType;
          var _b = __read(Array.isArray(values2) ? values2 : [void 0, values2], 2), start = _b[0], end = _b[1];
          var data2 = this.data;
          var length = data2.length;
          var isValue = selectionType === "value";
          var getStartValue = function() {
            var startDatumIndex = data2.findIndex(function(_a3) {
              var time = _a3.time;
              return time === start;
            });
            if (isValue)
              return 0;
            if (startDatumIndex > -1)
              return startDatumIndex / length;
            return 0;
          };
          var getEndValue = function() {
            if (end === Infinity)
              return 1;
            var endDatumIndex = data2.findIndex(function(_a3) {
              var time = _a3.time;
              return time === end;
            });
            if (endDatumIndex > -1)
              return endDatumIndex / length;
            if (isValue)
              return 0.5;
            return 1;
          };
          return [getStartValue(), getEndValue()];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Timebar3.prototype, "values", {
        get: function() {
          var _a2 = this.states, values2 = _a2.values, selectionType = _a2.selectionType;
          var _b = __read(Array.isArray(values2) ? values2 : [this.data[0].time, values2], 2), start = _b[0], end = _b[1];
          if (selectionType === "value")
            return end;
          return [start, end];
        },
        enumerable: false,
        configurable: true
      });
      Timebar3.prototype.getDatumByRatio = function(ratio) {
        var data2 = this.data;
        var length = data2.length;
        var index2 = Math.floor(ratio * (length - 1));
        return data2[index2];
      };
      Object.defineProperty(Timebar3.prototype, "chartHandleIconShape", {
        get: function() {
          var selectionType = this.states.selectionType;
          var height = this.space.timelineBBox.height;
          if (selectionType === "range")
            return function(type) {
              return new ChartModeHandle({ style: { type, height, iconSize: height / 6 } });
            };
          return function() {
            return new Line({ style: { x1: 0, y1: -height / 2, x2: 0, y2: height / 2, lineWidth: 2, stroke: "#c8c8c8" } });
          };
        },
        enumerable: false,
        configurable: true
      });
      Timebar3.prototype.getChartStyle = function(bbox) {
        var _this2 = this;
        var x3 = bbox.x, y3 = bbox.y, width2 = bbox.width, height = bbox.height;
        var _a2 = this.states, selectionType = _a2.selectionType, chartType = _a2.chartType;
        var data2 = this.data;
        var _b = this.attributes, type = _b.type, userDefinedLabelFormatter = _b.labelFormatter;
        var _c = subStyleProps2(this.attributes, "chart"), ignoreType = _c.type, userDefinedChartStyle = __rest(_c, ["type"]);
        var isRange = selectionType === "range";
        if (type === "time") {
          return __assign({
            handleIconShape: function() {
              return new TimeModeHandle({});
            },
            selectionFill: "#2e7ff8",
            selectionFillOpacity: 1,
            showLabelOnInteraction: true,
            handleLabelDy: isRange ? -15 : 0,
            autoFitLabel: isRange,
            handleSpacing: isRange ? -15 : 0,
            trackFill: "#edeeef",
            trackLength: width2,
            trackOpacity: 0.5,
            trackRadius: height / 2,
            trackSize: height / 2,
            type: selectionType,
            values: this.sliderValues,
            formatter: function(value) {
              if (userDefinedLabelFormatter)
                return userDefinedLabelFormatter(value);
              var time = _this2.getDatumByRatio(value).time;
              if (typeof time === "number")
                return parseBySeries(time);
              return formatTime(time, "YYYY-MM-DD HH:mm:ss");
            },
            transform: "translate(".concat(x3, ", ").concat(y3, ")"),
            // x,
            // y,
            zIndex: 1
          }, userDefinedChartStyle);
        }
        var handleIconOffset = selectionType === "range" ? 5 : 0;
        var sparklineData = data2.map(function(_a3) {
          var value = _a3.value;
          return value;
        });
        return __assign({
          handleIconOffset,
          handleIconShape: this.chartHandleIconShape,
          selectionFill: "#fff",
          selectionFillOpacity: 0.5,
          selectionType: "invert",
          sparklineSpacing: 0.1,
          sparklineColumnLineWidth: 0,
          sparklineColor: "#d4e5fd",
          sparklineAreaOpacity: 1,
          sparklineAreaLineWidth: 0,
          sparklineData,
          sparklineType: chartType,
          sparklineScale: 0.8,
          trackLength: width2,
          trackSize: height,
          type: selectionType,
          values: this.sliderValues,
          // x,
          // y,
          transform: "translate(".concat(x3, ", ").concat(y3, ")"),
          zIndex: 1
        }, userDefinedChartStyle);
      };
      Timebar3.prototype.renderChart = function(bbox) {
        if (bbox === void 0) {
          bbox = this.space.timelineBBox;
        }
        this.timeline.update(this.getChartStyle(bbox));
      };
      Timebar3.prototype.updateSelection = function() {
        this.timeline.setValues(this.sliderValues, true);
        this.handleSliderChange(this.sliderValues);
      };
      Timebar3.prototype.getAxisStyle = function(bbox) {
        var data2 = this.data;
        var _a2 = this.attributes, interval2 = _a2.interval, userDefinedLabelFormatter = _a2.labelFormatter;
        var userDefinedAxisStyle = subStyleProps2(this.attributes, "axis");
        var x3 = bbox.x, y3 = bbox.y, width2 = bbox.width;
        var axisData = __spreadArray(__spreadArray([], __read(data2), false), [{ time: 0 }], false).map(function(_a3, index2, arr) {
          var time = _a3.time;
          return {
            label: "".concat(time),
            value: index2 / (arr.length - 1),
            time
          };
        });
        var style = __assign({
          startPos: [x3, y3],
          endPos: [x3 + width2, y3],
          data: axisData,
          // hide last label
          labelFilter: function(_datum, index2) {
            return index2 < axisData.length - 1;
          },
          labelFormatter: function(_a3) {
            var time = _a3.time;
            return userDefinedLabelFormatter ? userDefinedLabelFormatter(time) : labelFormatter(time, interval2);
          }
        }, userDefinedAxisStyle);
        return style;
      };
      Timebar3.prototype.renderAxis = function(bbox) {
        if (bbox === void 0) {
          bbox = this.space.axisBBox;
        }
        var type = this.attributes.type;
        if (type !== "chart")
          return;
        this.axis.update(this.getAxisStyle(bbox));
      };
      Timebar3.prototype.renderController = function(bbox) {
        if (bbox === void 0) {
          bbox = this.space.controllerBBox;
        }
        var type = this.attributes.type;
        var _a2 = this.states, state = _a2.state, speed = _a2.speed, selectionType = _a2.selectionType, chartType = _a2.chartType;
        var userDefinedControllerStyle = subStyleProps2(this.attributes, "controller");
        var that = this;
        var style = __assign(__assign(__assign({}, bbox), { iconSize: 20, speed, state, selectionType, chartType, onChange: function(type2, _a3) {
          var value = _a3.value;
          switch (type2) {
            case "reset":
              that.internalReset();
              break;
            case "speed":
              that.handleSpeedChange(value);
              break;
            case "backward":
              that.internalBackward();
              break;
            case "playPause":
              if (value === "play")
                that.internalPlay();
              else
                that.internalPause();
              break;
            case "forward":
              that.internalForward();
              break;
            case "selectionType":
              that.handleSelectionTypeChange(value);
              break;
            case "chartType":
              that.handleChartTypeChange(value);
              break;
            default:
              break;
          }
        } }), userDefinedControllerStyle);
        if (type === "time") {
          style.functions = [["reset", "speed"], ["backward", "playPause", "forward"], ["selectionType"]];
        }
        this.controller.update(style);
      };
      Timebar3.prototype.dispatchOnChange = function(prevValues) {
        var data2 = this.data;
        var onChange = this.attributes.onChange;
        var _a2 = this.states, values2 = _a2.values, selectionType = _a2.selectionType;
        var _b = __read(values2, 2), start = _b[0], end = _b[1];
        var endTime = end === Infinity ? data2.at(-1).time : end;
        var newValues = selectionType === "range" ? [start, endTime] : endTime;
        var isEqual15 = function(val1, val2) {
          if (Array.isArray(val1)) {
            if (!Array.isArray(val2))
              return false;
            if (val1[0] === val2[0]) {
              if (val1[1] === val2[1])
                return true;
              if (val1[1] === Infinity || val2[1] === Infinity)
                return true;
            }
            return false;
          }
          if (Array.isArray(val2))
            return false;
          return val1 === val2;
        };
        if (!prevValues || !isEqual15(prevValues, newValues)) {
          onChange === null || onChange === void 0 ? void 0 : onChange(selectionType === "range" ? [start, endTime] : endTime);
        }
      };
      Timebar3.prototype.internalReset = function(preventEvent) {
        var _a2, _b;
        var selectionType = this.states.selectionType;
        this.internalPause();
        this.setBySliderValues(selectionType === "range" ? [0, 1] : [0, 0]);
        this.renderController();
        this.updateSelection();
        if (!preventEvent) {
          (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onReset) === null || _b === void 0 ? void 0 : _b.call(_a2);
          this.dispatchOnChange();
        }
      };
      Timebar3.prototype.reset = function() {
        this.internalReset();
      };
      Timebar3.prototype.moveSelection = function(direction2, preventEvent) {
        var data2 = this.data;
        var length = data2.length;
        var _a2 = this.states, values2 = _a2.values, selectionType = _a2.selectionType, playMode = _a2.playMode;
        var _b = __read(values2, 2), startTime = _b[0], endTime = _b[1];
        var startIndex = data2.findIndex(function(_a3) {
          var time = _a3.time;
          return time === startTime;
        });
        var endIndex = data2.findIndex(function(_a3) {
          var time = _a3.time;
          return time === endTime;
        });
        if (endIndex === -1)
          endIndex = length;
        var diff = direction2 === "backward" ? -1 : 1;
        var currentIndexes;
        if (selectionType === "range") {
          if (playMode === "acc") {
            currentIndexes = [startIndex, endIndex + diff];
            if (diff === -1 && startIndex === endIndex) {
              currentIndexes = [startIndex, length];
            }
          } else
            currentIndexes = [startIndex + diff, endIndex + diff];
        } else
          currentIndexes = [startIndex, endIndex + diff];
        var normalizeIndexes = function(indexes) {
          var _a3 = __read(indexes.sort(function(a2, b) {
            return a2 - b;
          }), 2), start = _a3[0], end = _a3[1];
          var clampIndex = function(index2) {
            return (0, import_util190.clamp)(index2, 0, length);
          };
          if (end > length) {
            if (selectionType === "value")
              return [0, 0];
            if (playMode === "acc")
              return [clampIndex(start), clampIndex(start)];
            return [0, clampIndex(end - start)];
          }
          if (start < 0) {
            if (playMode === "acc")
              return [0, clampIndex(end)];
            return [clampIndex(start + length - end), length];
          }
          return [clampIndex(start), clampIndex(end)];
        };
        var normalizedIndexes = normalizeIndexes(currentIndexes);
        this.setByIndex(normalizedIndexes);
        this.updateSelection();
        return normalizedIndexes;
      };
      Timebar3.prototype.internalBackward = function(preventEvent) {
        var _a2, _b;
        var indexes = this.moveSelection("backward", preventEvent);
        if (!preventEvent) {
          (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onBackward) === null || _b === void 0 ? void 0 : _b.call(_a2);
          this.dispatchOnChange();
        }
        return indexes;
      };
      Timebar3.prototype.backward = function() {
        this.internalBackward();
      };
      Timebar3.prototype.internalPlay = function(preventEvent) {
        var _this2 = this;
        var _a2, _b;
        var data2 = this.data;
        var loop = this.attributes.loop;
        var _c = this.states.speed, speed = _c === void 0 ? 1 : _c;
        this.playInterval = window.setInterval(function() {
          var indexes = _this2.internalForward();
          if (indexes[1] === data2.length && !loop) {
            _this2.internalPause();
            _this2.renderController();
          }
        }, 1e3 / speed);
        this.states.state = "play";
        !preventEvent && ((_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onPlay) === null || _b === void 0 ? void 0 : _b.call(_a2));
      };
      Timebar3.prototype.play = function() {
        this.internalPlay();
      };
      Timebar3.prototype.internalPause = function(preventEvent) {
        var _a2, _b;
        clearInterval(this.playInterval);
        this.states.state = "pause";
        !preventEvent && ((_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onPause) === null || _b === void 0 ? void 0 : _b.call(_a2));
      };
      Timebar3.prototype.pause = function() {
        this.internalPause();
      };
      Timebar3.prototype.internalForward = function(preventEvent) {
        var _a2, _b;
        var indexes = this.moveSelection("forward", preventEvent);
        if (!preventEvent) {
          (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onForward) === null || _b === void 0 ? void 0 : _b.call(_a2);
          this.dispatchOnChange();
        }
        return indexes;
      };
      Timebar3.prototype.forward = function() {
        this.internalForward();
      };
      Timebar3.prototype.handleSpeedChange = function(value) {
        var _a2, _b;
        this.states.speed = value;
        var state = this.states.state;
        if (state === "play") {
          this.internalPause(true);
          this.internalPlay(true);
        }
        (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onSpeedChange) === null || _b === void 0 ? void 0 : _b.call(_a2, value);
      };
      Timebar3.prototype.handleSelectionTypeChange = function(type) {
        var _a2, _b;
        this.states.selectionType = type;
        this.renderChart();
        (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onSelectionTypeChange) === null || _b === void 0 ? void 0 : _b.call(_a2, type);
      };
      Timebar3.prototype.handleChartTypeChange = function(type) {
        var _a2, _b;
        this.states.chartType = type;
        this.renderChart();
        (_b = (_a2 = this.attributes) === null || _a2 === void 0 ? void 0 : _a2.onChartTypeChange) === null || _b === void 0 ? void 0 : _b.call(_a2, type);
      };
      Timebar3.prototype.render = function() {
        var _a2 = this.space, axisBBox = _a2.axisBBox, controllerBBox = _a2.controllerBBox, timelineBBox = _a2.timelineBBox;
        this.renderController(controllerBBox);
        this.renderAxis(axisBBox);
        this.renderChart(timelineBBox);
        if (this.states.state === "play")
          this.internalPlay();
      };
      Timebar3.prototype.destroy = function() {
        _super.prototype.destroy.call(this);
        this.internalPause(true);
      };
      Timebar3.defaultOptions = {
        style: {
          x: 0,
          y: 0,
          axisLabelFill: "#6e6e6e",
          axisLabelTextAlign: "left",
          axisLabelTextBaseline: "top",
          axisLabelTransform: "translate(5, -12)",
          axisLineLineWidth: 1,
          axisLineStroke: "#cacdd1",
          axisTickLength: 15,
          axisTickLineWidth: 1,
          axisTickStroke: "#cacdd1",
          chartShowLabel: false,
          chartType: "line",
          controllerAlign: "center",
          controllerHeight: 40,
          data: [],
          interval: "day",
          loop: false,
          playMode: "acc",
          selectionType: "range",
          type: "time"
        }
      };
      return Timebar3;
    })(Component)
  );

  // node_modules/@antv/g6/esm/plugins/legend.js
  var import_util192 = __toESM(require_lib());

  // node_modules/@antv/g6/esm/plugins/utils/canvas.js
  function createPluginCanvas(options) {
    const { width: width2, height, renderer } = options;
    const $container = getContainer(options);
    const canvas2 = new Canvas({
      width: width2,
      height,
      container: $container,
      renderer: renderer || new Renderer()
    });
    return [$container, canvas2];
  }
  function getContainer(options) {
    var _a2;
    const { container, className, graphCanvas } = options;
    if (container) {
      return typeof container === "string" ? document.getElementById(container) : container;
    }
    const $container = createPluginContainer(className, false);
    const { width: width2, height, containerStyle } = options;
    const [x3, y3] = computePosition(options);
    Object.assign($container.style, Object.assign({ position: "absolute", left: x3 + "px", top: y3 + "px", width: width2 + "px", height: height + "px" }, containerStyle));
    (_a2 = graphCanvas.getContainer()) === null || _a2 === void 0 ? void 0 : _a2.appendChild($container);
    return $container;
  }
  function computePosition(options) {
    const { width: width2, height, placement, graphCanvas } = options;
    const [W2, H] = graphCanvas.getSize();
    const [xRatio, yRatio] = parsePlacement(placement);
    return [xRatio * (W2 - width2), yRatio * (H - height)];
  }

  // node_modules/@antv/g6/esm/plugins/legend.js
  var __rest16 = function(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  var Legend = class _Legend extends BasePlugin {
    constructor(context, options) {
      super(context, Object.assign({}, _Legend.defaultOptions, options));
      this.typePrefix = "__data__";
      this.draw = false;
      this.fieldMap = {
        node: /* @__PURE__ */ new Map(),
        edge: /* @__PURE__ */ new Map(),
        combo: /* @__PURE__ */ new Map()
      };
      this.selectedItems = [];
      this.bindEvents = () => {
        const { graph } = this.context;
        graph.on(GraphEvent.AFTER_DRAW, this.createElement);
      };
      this.changeState = (el, state) => {
        const { graph } = this.context;
        const { typePrefix } = this;
        const composeId = (0, import_util192.get)(el, [typePrefix, "id"]);
        const category = (0, import_util192.get)(el, [typePrefix, "style", "labelText"]);
        const [type] = composeId.split("__");
        const ids = this.fieldMap[type].get(category) || [];
        graph.setElementState(Object.fromEntries(ids === null || ids === void 0 ? void 0 : ids.map((id3) => [id3, state])));
      };
      this.click = (event) => {
        if (this.options.trigger === "hover")
          return;
        const composeId = (0, import_util192.get)(event, [this.typePrefix, "id"]);
        if (!this.selectedItems.includes(composeId)) {
          this.selectedItems.push(composeId);
          this.changeState(event, "selected");
        } else {
          this.selectedItems = this.selectedItems.filter((item) => item !== composeId);
          this.changeState(event, []);
        }
      };
      this.mouseleave = (event) => {
        if (this.options.trigger === "click")
          return;
        this.selectedItems = [];
        this.changeState(event, []);
      };
      this.mouseenter = (event) => {
        if (this.options.trigger === "click")
          return;
        const composeId = (0, import_util192.get)(event, [this.typePrefix, "id"]);
        if (!this.selectedItems.includes(composeId)) {
          this.selectedItems.push(composeId);
          this.changeState(event, "active");
        } else {
          this.selectedItems = this.selectedItems.filter((item) => item !== composeId);
        }
      };
      this.setFieldMap = (field, id3, type) => {
        if (!field)
          return;
        const map = this.fieldMap[type];
        if (!map)
          return;
        if (!map.has(field)) {
          map.set(field, [id3]);
        } else {
          const ids = map.get(field);
          if (ids) {
            ids.push(id3);
            map.set(field, ids);
          }
        }
      };
      this.getEvents = () => {
        return {
          mouseenter: this.mouseenter,
          mouseleave: this.mouseleave,
          click: this.click
        };
      };
      this.getMarkerData = (field, elementType) => {
        if (!field)
          return [];
        const { model, element } = this.context;
        const { nodes, edges, combos } = model.getData();
        const items = {};
        const getField = (item) => {
          if ((0, import_util192.isFunction)(field))
            return field(item);
          return field;
        };
        const defaultType = {
          node: "circle",
          edge: "line",
          combo: "rect"
        };
        const markerMapping = {
          circle: "circle",
          ellipse: "circle",
          // 待 components 支持 ellipse
          image: "bowtie",
          rect: "square",
          star: "cross",
          triangle: "triangle",
          diamond: "diamond",
          cubic: "dot",
          line: "hyphen",
          polyline: "hyphen",
          quadratic: "hv",
          "cubic-horizontal": "hyphen",
          "cubic-vertical": "line"
        };
        const getElementStyle = (type, datum) => {
          const style = element === null || element === void 0 ? void 0 : element.getElementComputedStyle(type, datum);
          return style;
        };
        const getElementModel = (data2, type) => {
          data2.forEach((item) => {
            const { id: id3 } = item;
            const value = (0, import_util192.get)(item, ["data", getField(item)]);
            const marker = (element === null || element === void 0 ? void 0 : element.getElementType(type, item)) || "circle";
            const style = getElementStyle(type, item);
            const color2 = (type === "edge" ? style === null || style === void 0 ? void 0 : style.stroke : style === null || style === void 0 ? void 0 : style.fill) || "#1783ff";
            if (id3 && value && value.replace(/\s+/g, "")) {
              this.setFieldMap(value, id3, type);
              if (!items[value]) {
                items[value] = {
                  id: `${type}__${id3}`,
                  label: value,
                  marker: markerMapping[marker] || defaultType[type],
                  elementType: type,
                  lineWidth: 1,
                  stroke: color2,
                  fill: color2
                };
              }
            }
          });
        };
        switch (elementType) {
          case "node":
            getElementModel(nodes, "node");
            break;
          case "edge":
            getElementModel(edges, "edge");
            break;
          case "combo":
            getElementModel(combos, "combo");
            break;
          default:
            return [];
        }
        return Object.values(items);
      };
      this.createElement = () => {
        if (this.draw) {
          this.updateElement();
          return;
        }
        const _a2 = this.options, { width: width2, height, nodeField, edgeField, comboField, trigger, position: position2, container, containerStyle, className } = _a2, rest = __rest16(_a2, ["width", "height", "nodeField", "edgeField", "comboField", "trigger", "position", "container", "containerStyle", "className"]);
        const nodeItems = this.getMarkerData(nodeField, "node");
        const edgeItems = this.getMarkerData(edgeField, "edge");
        const comboItems = this.getMarkerData(comboField, "combo");
        const items = [...nodeItems, ...comboItems, ...edgeItems];
        const categoryStyle = Object.assign({
          width: width2,
          height,
          data: items,
          itemMarkerLineWidth: ({ lineWidth }) => lineWidth,
          itemMarker: ({ marker }) => marker,
          itemMarkerStroke: ({ stroke }) => stroke,
          itemMarkerFill: ({ fill }) => fill,
          gridCol: nodeItems.length
        }, rest, this.getEvents());
        const category = new Category({
          className: "legend",
          style: categoryStyle
        });
        this.category = category;
        const canvas2 = this.upsertCanvas();
        canvas2.appendChild(category);
        this.draw = true;
      };
      this.bindEvents();
    }
    /**
     * <zh/> 更新图例配置
     *
     * <en/> Update the legend configuration
     * @param options - <zh/> 图例配置项 | <en/> Legend options
     * @internal
     */
    update(options) {
      super.update(options);
      this.clear();
      this.createElement();
    }
    clear() {
      var _a2, _b;
      (_a2 = this.canvas) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      (_b = this.container) === null || _b === void 0 ? void 0 : _b.remove();
      this.canvas = void 0;
      this.container = void 0;
      this.draw = false;
    }
    /**
     * <zh/> 刷新图例元素状态
     *
     * <en/> Refresh the status of the legend element
     */
    updateElement() {
      if (!this.category)
        return;
      this.category.update({
        itemMarkerOpacity: ({ id: id3 }) => {
          if (!this.selectedItems.length || this.selectedItems.includes(id3))
            return 1;
          return 0.5;
        },
        itemLabelOpacity: ({ id: id3 }) => {
          if (!this.selectedItems.length || this.selectedItems.includes(id3))
            return 1;
          return 0.5;
        }
      });
    }
    upsertCanvas() {
      if (this.canvas)
        return this.canvas;
      const graphCanvas = this.context.canvas;
      const [canvasWidth, canvasHeight] = graphCanvas.getSize();
      const { width: width2 = canvasWidth, height = canvasHeight, position: position2, container, containerStyle, className } = this.options;
      const [$container, canvas2] = createPluginCanvas({
        width: width2,
        height,
        graphCanvas,
        container,
        containerStyle,
        placement: position2,
        className: "legend"
      });
      this.container = $container;
      if (className)
        $container.classList.add(className);
      this.canvas = canvas2;
      return this.canvas;
    }
    /**
     * <zh/>销毁图例
     *
     * <en/> Destroy the legend
     * @internal
     */
    destroy() {
      this.clear();
      this.context.graph.off(GraphEvent.AFTER_DRAW, this.createElement);
      super.destroy();
    }
  };
  Legend.defaultOptions = {
    position: "bottom",
    trigger: "hover",
    orientation: "horizontal",
    layout: "flex",
    itemSpacing: 4,
    rowPadding: 10,
    colPadding: 10,
    itemMarkerSize: 16,
    itemLabelFontSize: 16,
    width: 240,
    height: 160
  };

  // node_modules/@antv/g6/esm/plugins/minimap/index.js
  var import_util193 = __toESM(require_lib());
  var Minimap = class _Minimap extends BasePlugin {
    constructor(context, options) {
      super(context, Object.assign({}, _Minimap.defaultOptions, options));
      this.onDraw = (event) => {
        var _a2;
        if ((_a2 = event === null || event === void 0 ? void 0 : event.data) === null || _a2 === void 0 ? void 0 : _a2.render)
          return;
        this.onRender();
      };
      this.landmarkMap = /* @__PURE__ */ new Map();
      this.mask = null;
      this.isMaskDragging = false;
      this.onMaskDragStart = (event) => {
        if (!this.mask)
          return;
        this.isMaskDragging = true;
        this.mask.setPointerCapture(event.pointerId);
        this.mask.addEventListener("pointermove", this.onMaskDrag);
        this.mask.addEventListener("pointerup", this.onMaskDragEnd);
        this.mask.addEventListener("pointercancel", this.onMaskDragEnd);
      };
      this.onMaskDrag = (event) => {
        if (!this.mask || !this.isMaskDragging)
          return;
        const { size: [minimapWidth, minimapHeight] } = this.options;
        const { movementX, movementY } = event;
        const { left, top, width: w, height: h } = this.mask.style;
        const [, , fullWidth, fullHeight] = this.maskBBox;
        let x3 = parseInt(left) + movementX;
        let y3 = parseInt(top) + movementY;
        let width2 = parseInt(w);
        let height = parseInt(h);
        if (x3 < 0)
          x3 = 0;
        if (y3 < 0)
          y3 = 0;
        if (x3 + width2 > minimapWidth)
          x3 = lower(minimapWidth - width2, 0);
        if (y3 + height > minimapHeight)
          y3 = lower(minimapHeight - height, 0);
        if (width2 < fullWidth) {
          if (movementX > 0) {
            x3 = lower(x3 - movementX, 0);
            width2 = upper(width2 + movementX, minimapWidth);
          } else if (movementX < 0)
            width2 = upper(width2 - movementX, minimapWidth);
        }
        if (height < fullHeight) {
          if (movementY > 0) {
            y3 = lower(y3 - movementY, 0);
            height = upper(height + movementY, minimapHeight);
          } else if (movementY < 0)
            height = upper(height - movementY, minimapHeight);
        }
        Object.assign(this.mask.style, {
          left: x3 + "px",
          top: y3 + "px",
          width: width2 + "px",
          height: height + "px"
        });
        const deltaX = parseInt(left) - x3;
        const deltaY = parseInt(top) - y3;
        if (deltaX === 0 && deltaY === 0)
          return;
        const zoom1 = this.context.canvas.getCamera().getZoom();
        const zoom2 = this.canvas.getCamera().getZoom();
        const ratio = zoom1 / zoom2;
        this.context.graph.translateBy([deltaX * ratio, deltaY * ratio], false);
      };
      this.onMaskDragEnd = (event) => {
        if (!this.mask)
          return;
        this.isMaskDragging = false;
        this.mask.releasePointerCapture(event.pointerId);
        this.mask.removeEventListener("pointermove", this.onMaskDrag);
        this.mask.removeEventListener("pointerup", this.onMaskDragEnd);
        this.mask.removeEventListener("pointercancel", this.onMaskDragEnd);
      };
      this.onTransform = (0, import_util193.throttle)(() => {
        if (this.isMaskDragging)
          return;
        this.updateMask();
        this.setCamera();
      }, 32, { leading: true });
      this.setOnRender();
      this.bindEvents();
    }
    update(options) {
      this.unbindEvents();
      super.update(options);
      if ("delay" in options)
        this.setOnRender();
      this.bindEvents();
    }
    setOnRender() {
      this.onRender = (0, import_util193.debounce)(() => {
        this.renderMinimap();
        this.renderMask();
      }, this.options.delay);
    }
    bindEvents() {
      const { graph } = this.context;
      graph.on(GraphEvent.AFTER_DRAW, this.onDraw);
      graph.on(GraphEvent.AFTER_RENDER, this.onRender);
      graph.on(GraphEvent.AFTER_ANIMATE, this.onRender);
      graph.on(GraphEvent.AFTER_TRANSFORM, this.onTransform);
    }
    unbindEvents() {
      const { graph } = this.context;
      graph.off(GraphEvent.AFTER_DRAW, this.onDraw);
      graph.off(GraphEvent.AFTER_RENDER, this.onRender);
      graph.off(GraphEvent.AFTER_ANIMATE, this.onRender);
      graph.off(GraphEvent.AFTER_TRANSFORM, this.onTransform);
    }
    /**
     * <zh/> 创建或更新缩略图
     *
     * <en/> Create or update the minimap
     */
    renderMinimap() {
      const data2 = this.getElements();
      const canvas2 = this.initCanvas();
      this.setShapes(canvas2, data2);
    }
    getElements() {
      const { filter } = this.options;
      const { model, element } = this.context;
      const originData = model.getData();
      const data2 = {
        nodes: originData.nodes.filter((node) => element === null || element === void 0 ? void 0 : element.getElement(idOf(node))),
        edges: originData.edges.filter((edge) => {
          const edgeElement = element === null || element === void 0 ? void 0 : element.getElement(idOf(edge));
          return edgeElement && isVisible(edgeElement);
        }),
        combos: originData.combos.filter((combo) => element === null || element === void 0 ? void 0 : element.getElement(idOf(combo)))
      };
      if (!filter)
        return data2;
      const { nodes, edges, combos } = data2;
      return {
        nodes: nodes.filter((node) => filter(idOf(node), "node")),
        edges: edges.filter((edge) => filter(idOf(edge), "edge")),
        combos: combos.filter((combo) => filter(idOf(combo), "combo"))
      };
    }
    setShapes(canvas2, data2) {
      const { nodes, edges, combos } = data2;
      const { shape } = this.options;
      const { element } = this.context;
      const iterate = (datum, elType) => {
        const id3 = idOf(datum);
        const target = element === null || element === void 0 ? void 0 : element.getElement(id3);
        if (!target)
          return;
        const keyShape = target.getShape("key");
        let cloneShape;
        if (typeof shape === "string") {
          const shapeName = shape;
          const miniShape = target.getShape(shapeName);
          cloneShape = miniShape.cloneNode();
        } else {
          const miniShape = shape(id3, elType, target);
          if (miniShape === target) {
            cloneShape = miniShape.cloneNode(true);
          } else {
            cloneShape = miniShape;
          }
        }
        cloneShape.setPosition(keyShape.getPosition());
        if (target.style.zIndex)
          cloneShape.style.zIndex = target.style.zIndex;
        cloneShape.id = target.id;
        canvas2.appendChild(cloneShape);
      };
      canvas2.removeChildren();
      edges.forEach((datum) => iterate(datum, "edge"));
      combos.forEach((datum) => iterate(datum, "combo"));
      nodes.forEach((datum) => iterate(datum, "node"));
    }
    initCanvas() {
      const { renderer, size: [width2, height] } = this.options;
      if (this.canvas) {
        const { width: w, height: h } = this.canvas.getConfig();
        if (width2 !== w || height !== h)
          this.canvas.resize(width2, height);
        if (renderer)
          this.canvas.setRenderer(renderer);
      } else {
        const { className, position: position2, container, containerStyle } = this.options;
        const [$container, canvas2] = createPluginCanvas({
          renderer,
          width: width2,
          height,
          placement: position2,
          className: "minimap",
          container,
          containerStyle,
          graphCanvas: this.context.canvas
        });
        if (className)
          $container.classList.add(className);
        this.container = $container;
        this.canvas = canvas2;
      }
      this.setCamera();
      return this.canvas;
    }
    createLandmark(position2, focalPoint, zoom) {
      const key = `${position2.join(",")}-${focalPoint.join(",")}-${zoom}`;
      if (this.landmarkMap.has(key))
        return this.landmarkMap.get(key);
      const camera = this.canvas.getCamera();
      const landmark = camera.createLandmark(key, {
        position: position2,
        focalPoint,
        zoom
      });
      this.landmarkMap.set(key, landmark);
      return landmark;
    }
    setCamera() {
      var _a2;
      const { canvas: canvas2 } = this.context;
      const camera = (_a2 = this.canvas) === null || _a2 === void 0 ? void 0 : _a2.getCamera();
      if (!camera)
        return;
      const { size: [minimapWidth, minimapHeight], padding } = this.options;
      const [top, right, bottom, left] = parsePadding(padding);
      const { min: boundsMin, max: boundsMax, center } = canvas2.getBounds("elements");
      const boundsWidth = boundsMax[0] - boundsMin[0];
      const boundsHeight = boundsMax[1] - boundsMin[1];
      const availableWidth = minimapWidth - left - right;
      const availableHeight = minimapHeight - top - bottom;
      const scaleX2 = availableWidth / boundsWidth;
      const scaleY2 = availableHeight / boundsHeight;
      const scale4 = Math.min(scaleX2, scaleY2);
      const landmark = this.createLandmark(center, center, scale4);
      camera.gotoLandmark(landmark, 0);
    }
    get maskBBox() {
      const { canvas: graphCanvas } = this.context;
      const canvasSize = graphCanvas.getSize();
      const canvasMin = graphCanvas.getCanvasByViewport([0, 0]);
      const canvasMax = graphCanvas.getCanvasByViewport(canvasSize);
      const maskMin = this.canvas.canvas2Viewport(toPointObject(canvasMin));
      const maskMax = this.canvas.canvas2Viewport(toPointObject(canvasMax));
      const width2 = maskMax.x - maskMin.x;
      const height = maskMax.y - maskMin.y;
      return [maskMin.x, maskMin.y, width2, height];
    }
    /**
     * <zh/> 计算遮罩包围盒
     *
     * <en/> Calculate the bounding box of the mask
     * @returns <zh/> 遮罩包围盒 | <en/> Mask bounding box
     */
    calculateMaskBBox() {
      const { size: [minimapWidth, minimapHeight] } = this.options;
      let [x3, y3, width2, height] = this.maskBBox;
      if (x3 < 0) {
        width2 = upper(width2 + x3, minimapWidth);
        x3 = 0;
      }
      if (y3 < 0) {
        height = upper(height + y3, minimapHeight);
        y3 = 0;
      }
      if (x3 + width2 > minimapWidth)
        width2 = lower(minimapWidth - x3, 0);
      if (y3 + height > minimapHeight)
        height = lower(minimapHeight - y3, 0);
      return [upper(x3, minimapWidth), upper(y3, minimapHeight), lower(width2, 0), lower(height, 0)];
    }
    /**
     * <zh/> 创建或更新遮罩
     *
     * <en/> Create or update the mask
     */
    renderMask() {
      const { maskStyle } = this.options;
      if (!this.mask) {
        this.mask = document.createElement("div");
        this.mask.addEventListener("pointerdown", this.onMaskDragStart);
        this.mask.draggable = true;
        this.mask.addEventListener("dragstart", (event) => event.preventDefault && event.preventDefault());
      }
      this.container.appendChild(this.mask);
      Object.assign(this.mask.style, Object.assign(Object.assign({}, maskStyle), { cursor: "move", position: "absolute", pointerEvents: "auto" }));
      this.updateMask();
    }
    updateMask() {
      if (!this.mask)
        return;
      const [x3, y3, width2, height] = this.calculateMaskBBox();
      Object.assign(this.mask.style, {
        top: y3 + "px",
        left: x3 + "px",
        width: width2 + "px",
        height: height + "px"
      });
    }
    destroy() {
      var _a2, _b, _c;
      this.unbindEvents();
      (_a2 = this.canvas) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      (_b = this.mask) === null || _b === void 0 ? void 0 : _b.remove();
      (_c = this.container) === null || _c === void 0 ? void 0 : _c.remove();
      super.destroy();
    }
  };
  Minimap.defaultOptions = {
    size: [240, 160],
    shape: "key",
    padding: 10,
    position: "right-bottom",
    maskStyle: {
      border: "1px solid #ddd",
      background: "rgba(0, 0, 0, 0.1)"
    },
    containerStyle: {
      border: "1px solid #ddd",
      background: "#fff"
    },
    delay: 128
  };
  var upper = (value, max4) => Math.min(value, max4);
  var lower = (value, min4) => Math.max(value, min4);

  // node_modules/@antv/g6/esm/plugins/snapline/index.js
  var import_util194 = __toESM(require_lib());
  var __awaiter17 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var defaultLineStyle = { x1: 0, y1: 0, x2: 0, y2: 0, visibility: "hidden" };
  var Snapline = class _Snapline extends BasePlugin {
    constructor(context, options) {
      super(context, Object.assign({}, _Snapline.defaultOptions, options));
      this.initSnapline = () => {
        const canvas2 = this.context.canvas.getLayer("transient");
        if (!this.horizontalLine) {
          this.horizontalLine = canvas2.appendChild(new Line({ style: Object.assign(Object.assign({}, defaultLineStyle), this.options.horizontalLineStyle) }));
        }
        if (!this.verticalLine) {
          this.verticalLine = canvas2.appendChild(new Line({ style: Object.assign(Object.assign({}, defaultLineStyle), this.options.verticalLineStyle) }));
        }
      };
      this.isHorizontalSticking = false;
      this.isVerticalSticking = false;
      this.enableStick = true;
      this.autoSnapToLine = (nodeId, bbox, metadata) => __awaiter17(this, void 0, void 0, function* () {
        const { verticalX, horizontalY } = metadata;
        const { tolerance: tolerance2 } = this.options;
        const { min: [nodeMinX, nodeMinY], max: [nodeMaxX, nodeMaxY], center: [nodeCenterX, nodeCenterY] } = bbox;
        let dx = 0;
        let dy = 0;
        if (verticalX !== null) {
          if (distance5(nodeMaxX, verticalX) < tolerance2)
            dx = verticalX - nodeMaxX;
          if (distance5(nodeMinX, verticalX) < tolerance2)
            dx = verticalX - nodeMinX;
          if (distance5(nodeCenterX, verticalX) < tolerance2)
            dx = verticalX - nodeCenterX;
          if (dx !== 0)
            this.isVerticalSticking = true;
        }
        if (horizontalY !== null) {
          if (distance5(nodeMaxY, horizontalY) < tolerance2)
            dy = horizontalY - nodeMaxY;
          if (distance5(nodeMinY, horizontalY) < tolerance2)
            dy = horizontalY - nodeMinY;
          if (distance5(nodeCenterY, horizontalY) < tolerance2)
            dy = horizontalY - nodeCenterY;
          if (dy !== 0)
            this.isHorizontalSticking = true;
        }
        if (dx !== 0 || dy !== 0) {
          yield this.context.graph.translateElementBy({ [nodeId]: [dx, dy] }, false);
        }
      });
      this.enableSnap = (event) => {
        const { target } = event;
        const threshold = 0.5;
        if (this.isHorizontalSticking || this.isVerticalSticking) {
          const [dx, dy] = this.getDelta(event);
          if (this.isHorizontalSticking && this.isVerticalSticking && Math.abs(dx) <= threshold && Math.abs(dy) <= threshold) {
            this.context.graph.translateElementBy({ [target.id]: [-dx, -dy] }, false);
            return false;
          } else if (this.isHorizontalSticking && Math.abs(dy) <= threshold) {
            this.context.graph.translateElementBy({ [target.id]: [0, -dy] }, false);
            return false;
          } else if (this.isVerticalSticking && Math.abs(dx) <= threshold) {
            this.context.graph.translateElementBy({ [target.id]: [-dx, 0] }, false);
            return false;
          } else {
            this.isHorizontalSticking = false;
            this.isVerticalSticking = false;
            this.enableStick = false;
            setTimeout(() => {
              this.enableStick = true;
            }, 200);
          }
        }
        return this.enableStick;
      };
      this.calcSnaplineMetadata = (target, nodeBBox) => {
        const { tolerance: tolerance2, shape } = this.options;
        const { min: [nodeMinX, nodeMinY], max: [nodeMaxX, nodeMaxY], center: [nodeCenterX, nodeCenterY] } = nodeBBox;
        let verticalX = null;
        let verticalMinY = null;
        let verticalMaxY = null;
        let horizontalY = null;
        let horizontalMinX = null;
        let horizontalMaxX = null;
        this.getNodes().some((snapNode) => {
          if ((0, import_util194.isEqual)(target.id, snapNode.id))
            return false;
          const snapBBox = getShape(snapNode, shape).getRenderBounds();
          const { min: [snapMinX, snapMinY], max: [snapMaxX, snapMaxY], center: [snapCenterX, snapCenterY] } = snapBBox;
          if (verticalX === null) {
            if (distance5(snapCenterX, nodeCenterX) < tolerance2) {
              verticalX = snapCenterX;
            } else if (distance5(snapMinX, nodeMinX) < tolerance2) {
              verticalX = snapMinX;
            } else if (distance5(snapMinX, nodeMaxX) < tolerance2) {
              verticalX = snapMinX;
            } else if (distance5(snapMaxX, nodeMaxX) < tolerance2) {
              verticalX = snapMaxX;
            } else if (distance5(snapMaxX, nodeMinX) < tolerance2) {
              verticalX = snapMaxX;
            }
            if (verticalX !== null) {
              verticalMinY = Math.min(snapMinY, nodeMinY);
              verticalMaxY = Math.max(snapMaxY, nodeMaxY);
            }
          }
          if (horizontalY === null) {
            if (distance5(snapCenterY, nodeCenterY) < tolerance2) {
              horizontalY = snapCenterY;
            } else if (distance5(snapMinY, nodeMinY) < tolerance2) {
              horizontalY = snapMinY;
            } else if (distance5(snapMinY, nodeMaxY) < tolerance2) {
              horizontalY = snapMinY;
            } else if (distance5(snapMaxY, nodeMaxY) < tolerance2) {
              horizontalY = snapMaxY;
            } else if (distance5(snapMaxY, nodeMinY) < tolerance2) {
              horizontalY = snapMaxY;
            }
            if (horizontalY !== null) {
              horizontalMinX = Math.min(snapMinX, nodeMinX);
              horizontalMaxX = Math.max(snapMaxX, nodeMaxX);
            }
          }
          return verticalX !== null && horizontalY !== null;
        });
        return { verticalX, verticalMinY, verticalMaxY, horizontalY, horizontalMinX, horizontalMaxX };
      };
      this.onDragStart = () => {
        this.initSnapline();
      };
      this.onDrag = (event) => __awaiter17(this, void 0, void 0, function* () {
        const { target } = event;
        if (this.options.autoSnap) {
          const enable = this.enableSnap(event);
          if (!enable)
            return;
        }
        const nodeBBox = getShape(target, this.options.shape).getRenderBounds();
        const metadata = this.calcSnaplineMetadata(target, nodeBBox);
        this.hideSnapline();
        if (metadata.verticalX !== null || metadata.horizontalY !== null) {
          this.updateSnapline(metadata);
        }
        if (this.options.autoSnap) {
          yield this.autoSnapToLine(target.id, nodeBBox, metadata);
        }
      });
      this.onDragEnd = () => {
        this.hideSnapline();
      };
      this.bindEvents();
    }
    getNodes() {
      var _a2;
      const { filter } = this.options;
      const allNodes = ((_a2 = this.context.element) === null || _a2 === void 0 ? void 0 : _a2.getNodes()) || [];
      const nodes = allNodes.filter((node) => {
        var _a3;
        return isVisible(node) && ((_a3 = this.context.viewport) === null || _a3 === void 0 ? void 0 : _a3.isInViewport(node.getRenderBounds()));
      });
      if (!filter)
        return nodes;
      return nodes.filter((node) => filter(node));
    }
    hideSnapline() {
      this.horizontalLine.style.visibility = "hidden";
      this.verticalLine.style.visibility = "hidden";
    }
    getLineWidth(direction2) {
      const { lineWidth } = this.options[`${direction2}LineStyle`];
      return +(lineWidth || defaultLineStyle.lineWidth || 1) / this.context.graph.getZoom();
    }
    updateSnapline(metadata) {
      const { verticalX, verticalMinY, verticalMaxY, horizontalY, horizontalMinX, horizontalMaxX } = metadata;
      const [canvasWidth, canvasHeight] = this.context.canvas.getSize();
      const { offset } = this.options;
      if (horizontalY !== null) {
        Object.assign(this.horizontalLine.style, {
          x1: offset === Infinity ? 0 : horizontalMinX - offset,
          y1: horizontalY,
          x2: offset === Infinity ? canvasWidth : horizontalMaxX + offset,
          y2: horizontalY,
          visibility: "visible",
          lineWidth: this.getLineWidth("horizontal")
        });
      } else {
        this.horizontalLine.style.visibility = "hidden";
      }
      if (verticalX !== null) {
        Object.assign(this.verticalLine.style, {
          x1: verticalX,
          y1: offset === Infinity ? 0 : verticalMinY - offset,
          x2: verticalX,
          y2: offset === Infinity ? canvasHeight : verticalMaxY + offset,
          visibility: "visible",
          lineWidth: this.getLineWidth("vertical")
        });
      } else {
        this.verticalLine.style.visibility = "hidden";
      }
    }
    /**
     * Get the delta of the drag
     * @param event - drag event object
     * @returns delta
     * @internal
     */
    getDelta(event) {
      const zoom = this.context.graph.getZoom();
      return divide([event.dx, event.dy], zoom);
    }
    bindEvents() {
      return __awaiter17(this, void 0, void 0, function* () {
        const { graph } = this.context;
        graph.on(NodeEvent.DRAG_START, this.onDragStart);
        graph.on(NodeEvent.DRAG, this.onDrag);
        graph.on(NodeEvent.DRAG_END, this.onDragEnd);
      });
    }
    unbindEvents() {
      const { graph } = this.context;
      graph.off(NodeEvent.DRAG_START, this.onDragStart);
      graph.off(NodeEvent.DRAG, this.onDrag);
      graph.off(NodeEvent.DRAG_END, this.onDragEnd);
    }
    destroyElements() {
      var _a2, _b;
      (_a2 = this.horizontalLine) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      (_b = this.verticalLine) === null || _b === void 0 ? void 0 : _b.destroy();
    }
    destroy() {
      this.destroyElements();
      this.unbindEvents();
      super.destroy();
    }
  };
  Snapline.defaultOptions = {
    tolerance: 5,
    offset: 20,
    autoSnap: true,
    shape: "key",
    verticalLineStyle: { stroke: "#1783FF" },
    horizontalLineStyle: { stroke: "#1783FF" },
    filter: () => true
  };
  var distance5 = (a2, b) => Math.abs(a2 - b);
  var getShape = (node, shapeFilter) => {
    return typeof shapeFilter === "function" ? shapeFilter(node) : node.getShape(shapeFilter);
  };

  // node_modules/@antv/g6/esm/plugins/timebar.js
  var import_util195 = __toESM(require_lib());
  var __awaiter18 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest17 = function(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  var prospectiveTimeKeys = ["timestamp", "time", "date", "datetime"];
  var Timebar2 = class _Timebar extends BasePlugin {
    get padding() {
      return parsePadding(this.options.padding);
    }
    constructor(context, options) {
      super(context, Object.assign({}, _Timebar.defaultOptions, options));
      this.backup();
      this.upsertTimebar();
    }
    /**
     * <zh/> 播放
     *
     * <en/> Play
     */
    play() {
      var _a2;
      (_a2 = this.timebar) === null || _a2 === void 0 ? void 0 : _a2.play();
    }
    /**
     * <zh/> 暂停
     *
     * <en/> Pause
     */
    pause() {
      var _a2;
      (_a2 = this.timebar) === null || _a2 === void 0 ? void 0 : _a2.pause();
    }
    /**
     * <zh/> 前进
     *
     * <en/> Forward
     */
    forward() {
      var _a2;
      (_a2 = this.timebar) === null || _a2 === void 0 ? void 0 : _a2.forward();
    }
    /**
     * <zh/> 后退
     *
     * <en/> Backward
     */
    backward() {
      var _a2;
      (_a2 = this.timebar) === null || _a2 === void 0 ? void 0 : _a2.backward();
    }
    /**
     * <zh/> 重置
     *
     * <en/> Reset
     */
    reset() {
      var _a2;
      (_a2 = this.timebar) === null || _a2 === void 0 ? void 0 : _a2.reset();
    }
    /**
     * <zh/> 更新时间条配置项
     *
     * <en/> Update timebar configuration options
     * @param options - <zh/> 配置项 | <en/> Options
     * @internal
     */
    update(options) {
      super.update(options);
      this.backup();
      this.upsertTimebar();
    }
    /**
     * <zh/> 备份数据
     *
     * <en/> Backup data
     */
    backup() {
      this.originalData = shallowCopy(this.context.graph.getData());
    }
    upsertTimebar() {
      const { canvas: canvas2 } = this.context;
      const _a2 = this.options, { onChange, timebarType, data: data2, x: x3, y: y3, width: width2, height, mode } = _a2, restOptions = __rest17(_a2, ["onChange", "timebarType", "data", "x", "y", "width", "height", "mode"]);
      const canvasSize = canvas2.getSize();
      const [top] = this.padding;
      this.upsertCanvas().ready.then(() => {
        var _a3;
        const style = Object.assign(Object.assign({ x: canvasSize[0] / 2 - width2 / 2, y: top, onChange: (value) => {
          const range = ((0, import_util195.isArray)(value) ? value : [value, value]).map((time) => (0, import_util195.isDate)(time) ? time.getTime() : time);
          if (this.options.mode === "modify")
            this.filterElements(range);
          else
            this.hiddenElements(range);
          onChange === null || onChange === void 0 ? void 0 : onChange(range);
        } }, restOptions), {
          data: data2.map((datum) => (0, import_util195.isNumber)(datum) ? { time: datum, value: 0 } : datum),
          width: width2,
          height,
          type: timebarType
        });
        if (!this.timebar) {
          this.timebar = new Timebar({ style });
          (_a3 = this.canvas) === null || _a3 === void 0 ? void 0 : _a3.appendChild(this.timebar);
        } else {
          this.timebar.update(style);
        }
      });
    }
    upsertCanvas() {
      if (this.canvas)
        return this.canvas;
      const { className, height, position: position2 } = this.options;
      const graphCanvas = this.context.canvas;
      const [width2] = graphCanvas.getSize();
      const [top, , bottom] = this.padding;
      const [$container, canvas2] = createPluginCanvas({
        width: width2,
        height: height + top + bottom,
        graphCanvas,
        className: "timebar",
        placement: position2
      });
      this.container = $container;
      if (className)
        $container.classList.add(className);
      this.canvas = canvas2;
      return this.canvas;
    }
    filterElements(range) {
      return __awaiter18(this, void 0, void 0, function* () {
        var _a2;
        if (!this.originalData)
          return;
        const { elementTypes, getTime } = this.options;
        const { graph, element } = this.context;
        const newData = shallowCopy(this.originalData);
        elementTypes.forEach((type) => {
          const key = `${type}s`;
          newData[key] = (this.originalData[key] || []).filter((datum) => {
            const time = getTime(datum);
            if (match(time, range))
              return true;
            return false;
          });
        });
        const nodeLikeIds = [...newData.nodes, ...newData.combos].map((datum) => idOf(datum));
        newData.edges = newData.edges.filter((edge) => {
          const source = edge.source;
          const target = edge.target;
          return nodeLikeIds.includes(source) && nodeLikeIds.includes(target);
        });
        graph.setData(newData);
        yield (_a2 = element.draw({ animation: false, silence: true })) === null || _a2 === void 0 ? void 0 : _a2.finished;
      });
    }
    hiddenElements(range) {
      const { graph } = this.context;
      const { elementTypes, getTime } = this.options;
      const hideElementId = [];
      const showElementId = [];
      elementTypes.forEach((elementType) => {
        var _a2;
        const key = `${elementType}s`;
        const elementData = ((_a2 = this.originalData) === null || _a2 === void 0 ? void 0 : _a2[key]) || [];
        elementData.forEach((elementDatum) => {
          const id3 = idOf(elementDatum);
          const time = getTime(elementDatum);
          if (match(time, range))
            showElementId.push(id3);
          else
            hideElementId.push(id3);
        });
      });
      graph.hideElement(hideElementId, false);
      graph.showElement(showElementId, false);
    }
    /**
     * <zh/> 销毁时间条
     *
     * <en/> Destroy the timebar
     * @internal
     */
    destroy() {
      var _a2, _b, _c;
      const { graph } = this.context;
      this.originalData && graph.setData(Object.assign({}, this.originalData));
      (_a2 = this.timebar) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      (_b = this.canvas) === null || _b === void 0 ? void 0 : _b.destroy();
      (_c = this.container) === null || _c === void 0 ? void 0 : _c.remove();
      this.originalData = void 0;
      this.container = void 0;
      this.timebar = void 0;
      this.canvas = void 0;
      super.destroy();
    }
  };
  Timebar2.defaultOptions = {
    position: "bottom",
    enable: true,
    timebarType: "time",
    className: "g6-timebar",
    width: 450,
    height: 60,
    zIndex: 3,
    elementTypes: ["node"],
    padding: 10,
    mode: "modify",
    getTime: (datum) => inferTime(datum, prospectiveTimeKeys, void 0),
    loop: false
  };
  var shallowCopy = (data2) => {
    const { nodes = [], edges = [], combos = [] } = data2;
    return {
      nodes: [...nodes],
      edges: [...edges],
      combos: [...combos]
    };
  };
  var match = (time, range) => {
    if ((0, import_util195.isNumber)(range))
      return time === range;
    const [start, end] = range;
    return time >= start && time <= end;
  };
  var inferTime = (datum, optionsKeys, defaultValue) => {
    var _a2;
    for (let i = 0; i < optionsKeys.length; i++) {
      const key = optionsKeys[i];
      const val = (_a2 = datum.data) === null || _a2 === void 0 ? void 0 : _a2[key];
      if (val)
        return val;
    }
    return defaultValue;
  };

  // node_modules/@antv/g6/esm/plugins/title/index.js
  var __rest18 = function(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  var commonStyle = {
    fill: "#1D2129",
    wordWrap: true,
    // 自动换行
    maxLines: 1,
    // 最大行数
    textOverflow: "ellipsis",
    // 溢出隐藏省略号
    textBaseline: "top",
    /**
     * textAlign 需要和 x 结合使用
     * 举例: 前提条件: 画布 width = 600
     * - textAlign: 'start' | 'left
     *    需要设 x = 0
     * - textAlign: 'end' | 'right'
     *    需要设 x = 600 (即画布的宽度)
     * - textAlign: 'center'
     *    需要设 x = 300 (即画布的宽度 / 2)
     */
    textAlign: "start",
    x: 0
  };
  var defaultTitleStyle = Object.assign(Object.assign({}, commonStyle), { fillOpacity: 0.9, fontSize: 16, fontWeight: "bold" });
  var defaultSubTitleStyle = Object.assign(Object.assign({}, commonStyle), { fillOpacity: 0.65, fontSize: 12, fontWeight: "normal" });
  var defaultOptions3 = {
    align: "left",
    spacing: 8,
    size: 44,
    padding: [16, 24, 0, 24]
  };
  var titleKey = "title";
  var subtitleKey = "subtitle";
  var Title2 = class extends BasePlugin {
    get padding() {
      return parsePadding(this.options.padding);
    }
    constructor(context, options) {
      const combineOption = Object.assign({}, defaultOptions3, options);
      super(context, combineOption);
      this.onRender = () => {
        const canvas2 = this.updateCanvas();
        this.renderTitle(canvas2);
      };
      this.bindEvents();
    }
    bindEvents() {
      const { graph } = this.context;
      graph.on(GraphEvent.AFTER_RENDER, this.onRender);
      graph.on(GraphEvent.AFTER_ANIMATE, this.onRender);
    }
    unbindEvents() {
      const { graph } = this.context;
      graph.off(GraphEvent.AFTER_RENDER, this.onRender);
      graph.off(GraphEvent.AFTER_ANIMATE, this.onRender);
    }
    destroy() {
      var _a2, _b;
      this.unbindEvents();
      (_a2 = this.canvas) === null || _a2 === void 0 ? void 0 : _a2.destroy();
      (_b = this.container) === null || _b === void 0 ? void 0 : _b.remove();
      super.destroy();
    }
    updateCanvas() {
      const { size: size2, className, align } = this.options;
      const [width2] = this.context.canvas.getSize();
      const [pt = 0, , pb = 0] = this.padding;
      const height = size2 + pt + pb;
      if (this.canvas) {
        const { width: w, height: h } = this.canvas.getConfig();
        if (width2 !== w || height !== h)
          this.canvas.resize(width2, height);
      } else {
        const positions = {
          left: "left-top",
          center: "top",
          right: "right-top"
        };
        const [$container, canvas2] = createPluginCanvas({
          width: width2,
          height,
          placement: positions[align] || positions.left,
          className: "title-canvas",
          graphCanvas: this.context.canvas
        });
        if (className)
          $container.classList.add(className);
        this.container = $container;
        this.canvas = canvas2;
      }
      return this.canvas;
    }
    renderTitle(canvas2) {
      const titles = new TitleComponent({
        options: this.options,
        ctx: this.context
      });
      canvas2.removeChildren();
      titles.getTitle().forEach((label) => {
        if (label)
          canvas2.appendChild(label);
      });
    }
  };
  var TitleComponent = class {
    get padding() {
      return parsePadding(this.options.padding);
    }
    constructor(props) {
      const { options, ctx: ctx3 } = props;
      this.options = options;
      this.context = ctx3;
    }
    getTitle() {
      const _a2 = this.options, _b = titleKey, propsTitle = _a2[_b], _c = subtitleKey, propsSubtitle = _a2[_c], { spacing = 44, padding, align } = _a2, style = __rest18(_a2, [typeof _b === "symbol" ? _b : _b + "", typeof _c === "symbol" ? _c : _c + "", "spacing", "padding", "align"]);
      const titleText = propsTitle;
      const subTitleText = propsSubtitle;
      const titleStyle = subStyleProps(style, titleKey);
      const subtitleStyle = subStyleProps(style, subtitleKey);
      const [topGraphWidth] = this.context.graph.getSize();
      const [pt = 0, pr = 0, , pl = 0] = this.padding;
      const canvasWidth = topGraphWidth;
      const textWidth = canvasWidth - pl - pr;
      let subTitle = null;
      let alignX = pl;
      let textAlign = "left";
      switch (align) {
        case "left":
          alignX = pl;
          textAlign = "left";
          break;
        case "center":
          alignX = canvasWidth / 2;
          textAlign = "center";
          break;
        case "right":
          alignX = canvasWidth - pr;
          textAlign = "right";
          break;
        default:
          alignX = pl;
          textAlign = "left";
      }
      const title = new Label({
        className: titleKey,
        style: Object.assign(Object.assign(Object.assign(Object.assign({}, defaultTitleStyle), { wordWrapWidth: textWidth - 5, x: alignX, y: pt, textAlign }), titleStyle), { text: titleText })
      });
      const titleBBox = title.getBBox();
      if (subTitleText) {
        subTitle = new Label({
          className: "subTitle",
          style: Object.assign(Object.assign(Object.assign(Object.assign({}, defaultSubTitleStyle), { wordWrapWidth: textWidth - 5, x: alignX, y: titleBBox.height + spacing + pt, textAlign }), subtitleStyle), { text: subTitleText })
        });
      }
      return [title, subTitle];
    }
  };

  // node_modules/@antv/g6/esm/plugins/toolbar/util.js
  function parsePositionToStyle(position2) {
    const style = {
      top: "unset",
      right: "unset",
      bottom: "unset",
      left: "unset"
    };
    const directions2 = position2.split("-");
    directions2.forEach((d2) => {
      style[d2] = "8px";
    });
    style.flexDirection = position2.startsWith("top") || position2.startsWith("bottom") ? "row" : "column";
    return style;
  }
  var TOOLBAR_CSS = `
  .g6-toolbar {
    position: absolute;
    z-index: 100;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    box-shadow: 0px 0px 8px rgba(0, 0, 0, 0.1);
    opacity: 0.65;
  }
  .g6-toolbar .g6-toolbar-item {
    display: inline-block;
    width: 16px;
    height: 16px;
    padding: 4px;
    cursor: pointer;
    box-sizing: content-box;
  }

  .g6-toolbar .g6-toolbar-item:hover {
    background-color: #f0f0f0;
  }

  .g6-toolbar .g6-toolbar-item svg {
    display: inline-block;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }
`;
  var BUILD_IN_SVG_ICON = `
  <svg>
    <symbol id="zoom-in" viewBox="64 64 896 896">
      <path d="M637 443H519V309c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v134H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h118v134c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V519h118c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z"></path>
    </symbol>
    <symbol id="zoom-out" viewBox="64 64 896 896">
      <path d="M637 443H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h312c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z"></path>
    </symbol>
    <symbol id="edit" viewBox="64 64 896 896">
      <path d="M257.7 752c2 0 4-.2 6-.5L431.9 722c2-.4 3.9-1.3 5.3-2.8l423.9-423.9a9.96 9.96 0 000-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2a33.5 33.5 0 009.4 29.8c6.6 6.4 14.9 9.9 23.8 9.9zm67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z"></path>
    </symbol>
    <symbol id="delete" viewBox="64 64 896 896">
      <path d="M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z"></path>
    </symbol>
    <symbol id="redo" viewBox="64 64 896 896">
      <path d="M758.2 839.1C851.8 765.9 912 651.9 912 523.9 912 303 733.5 124.3 512.6 124 291.4 123.7 112 302.8 112 523.9c0 125.2 57.5 236.9 147.6 310.2 3.5 2.8 8.6 2.2 11.4-1.3l39.4-50.5c2.7-3.4 2.1-8.3-1.2-11.1-8.1-6.6-15.9-13.7-23.4-21.2a318.64 318.64 0 01-68.6-101.7C200.4 609 192 567.1 192 523.9s8.4-85.1 25.1-124.5c16.1-38.1 39.2-72.3 68.6-101.7 29.4-29.4 63.6-52.5 101.7-68.6C426.9 212.4 468.8 204 512 204s85.1 8.4 124.5 25.1c38.1 16.1 72.3 39.2 101.7 68.6 29.4 29.4 52.5 63.6 68.6 101.7 16.7 39.4 25.1 81.3 25.1 124.5s-8.4 85.1-25.1 124.5a318.64 318.64 0 01-68.6 101.7c-9.3 9.3-19.1 18-29.3 26L668.2 724a8 8 0 00-14.1 3l-39.6 162.2c-1.2 5 2.6 9.9 7.7 9.9l167 .8c6.7 0 10.5-7.7 6.3-12.9l-37.3-47.9z"></path>
    </symbol>
    <symbol id="undo" viewBox="64 64 896 896">
      <path d="M511.4 124C290.5 124.3 112 303 112 523.9c0 128 60.2 242 153.8 315.2l-37.5 48c-4.1 5.3-.3 13 6.3 12.9l167-.8c5.2 0 9-4.9 7.7-9.9L369.8 727a8 8 0 00-14.1-3L315 776.1c-10.2-8-20-16.7-29.3-26a318.64 318.64 0 01-68.6-101.7C200.4 609 192 567.1 192 523.9s8.4-85.1 25.1-124.5c16.1-38.1 39.2-72.3 68.6-101.7 29.4-29.4 63.6-52.5 101.7-68.6C426.9 212.4 468.8 204 512 204s85.1 8.4 124.5 25.1c38.1 16.1 72.3 39.2 101.7 68.6 29.4 29.4 52.5 63.6 68.6 101.7 16.7 39.4 25.1 81.3 25.1 124.5s-8.4 85.1-25.1 124.5a318.64 318.64 0 01-68.6 101.7c-7.5 7.5-15.3 14.5-23.4 21.2a7.93 7.93 0 00-1.2 11.1l39.4 50.5c2.8 3.5 7.9 4.1 11.4 1.3C854.5 760.8 912 649.1 912 523.9c0-221.1-179.4-400.2-400.6-399.9z"></path>
    </symbol>
    <symbol id="export" viewBox="64 64 896 896">
      <path d="M880 912H144c-17.7 0-32-14.3-32-32V144c0-17.7 14.3-32 32-32h360c4.4 0 8 3.6 8 8v56c0 4.4-3.6 8-8 8H184v656h656V520c0-4.4 3.6-8 8-8h56c4.4 0 8 3.6 8 8v360c0 17.7-14.3 32-32 32zM770.87 199.13l-52.2-52.2a8.01 8.01 0 014.7-13.6l179.4-21c5.1-.6 9.5 3.7 8.9 8.9l-21 179.4c-.8 6.6-8.9 9.4-13.6 4.7l-52.4-52.4-256.2 256.2a8.03 8.03 0 01-11.3 0l-42.4-42.4a8.03 8.03 0 010-11.3l256.1-256.3z"></path>
    </symbol>
    <symbol id="auto-fit" viewBox="64 64 896 896">
      <path d="M952 474H829.8C812.5 327.6 696.4 211.5 550 194.2V72c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v122.2C327.6 211.5 211.5 327.6 194.2 474H72c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h122.2C211.5 696.4 327.6 812.5 474 829.8V952c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V829.8C696.4 812.5 812.5 696.4 829.8 550H952c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zM512 756c-134.8 0-244-109.2-244-244s109.2-244 244-244 244 109.2 244 244-109.2 244-244 244z"></path>
      <path d="M512 392c-32.1 0-62.1 12.4-84.8 35.2-22.7 22.7-35.2 52.7-35.2 84.8s12.5 62.1 35.2 84.8C449.9 619.4 480 632 512 632s62.1-12.5 84.8-35.2C619.4 574.1 632 544 632 512s-12.5-62.1-35.2-84.8A118.57 118.57 0 00512 392z"></path>
    </symbol>
    <symbol id="reset" viewBox="64 64 896 896">
      <path d="M909.1 209.3l-56.4 44.1C775.8 155.1 656.2 92 521.9 92 290 92 102.3 279.5 102 511.5 101.7 743.7 289.8 932 521.9 932c181.3 0 335.8-115 394.6-276.1 1.5-4.2-.7-8.9-4.9-10.3l-56.7-19.5a8 8 0 00-10.1 4.8c-1.8 5-3.8 10-5.9 14.9-17.3 41-42.1 77.8-73.7 109.4A344.77 344.77 0 01655.9 829c-42.3 17.9-87.4 27-133.8 27-46.5 0-91.5-9.1-133.8-27A341.5 341.5 0 01279 755.2a342.16 342.16 0 01-73.7-109.4c-17.9-42.4-27-87.4-27-133.9s9.1-91.5 27-133.9c17.3-41 42.1-77.8 73.7-109.4 31.6-31.6 68.4-56.4 109.3-73.8 42.3-17.9 87.4-27 133.8-27 46.5 0 91.5 9.1 133.8 27a341.5 341.5 0 01109.3 73.8c9.9 9.9 19.2 20.4 27.8 31.4l-60.2 47a8 8 0 003 14.1l175.6 43c5 1.2 9.9-2.6 9.9-7.7l.8-180.9c-.1-6.6-7.8-10.3-13-6.2z"></path>
    </symbol>
    <symbol id="exit-fullscreen" viewBox="0 0 1024 1024">
      <path d="M418.13333333 361.43786666c0 0.2048-0.13653333 0.4096-0.13653334 0.68266667C417.99679999 362.32533333 418.13333333 362.53013333 418.13333333 362.73493333 418.13333333 371.54133333 414.44693333 379.392 408.78079999 385.39946666 408.43946666 385.7408 408.30293333 386.21866666 408.02986666 386.49173333c-1.09226667 1.09226667-2.59413333 1.77493333-3.82293333 2.73066667C398.40426666 393.65973333 391.64586666 396.8 383.93173333 396.8 383.72693333 396.8 383.59039999 396.73173333 383.38559999 396.73173333S382.97599999 396.8 382.77119999 396.8L112.29866666 396.8C92.50133333 396.8 76.79999999 381.50826666 76.79999999 362.66666666 76.66346666 343.89333333 92.63786666 328.53333333 112.16213333 328.53333333l189.44 0L87.44959999 114.51733333C73.59146666 100.59093333 73.25013333 78.5408 86.63039999 65.29706666c13.17546667-13.44853333 35.36213333-12.97066667 49.152 0.88746667l214.08426667 214.08426667L349.86666666 90.89706666C349.79839999 71.23626666 365.22666666 55.46666666 383.99999999 55.46666666 402.77333333 55.33013333 418.13333333 71.30453333 418.13333333 90.8288L418.13333333 361.43786666zM928.90453333 328.53333333l-189.44 0 214.15253333-214.08426667c13.85813333-13.9264 14.19946667-35.90826667 0.88746667-49.22026666-13.17546667-13.44853333-35.36213333-12.97066667-49.152 0.88746666l-214.08426667 214.08426667L691.26826666 90.89706666C691.26826666 71.23626666 675.83999999 55.46666666 657.06666666 55.46666666 638.29333333 55.33013333 622.93333333 71.30453333 622.93333333 90.8288l0 270.60906666c0 0.2048 0.13653333 0.4096 0.13653333 0.68266667C623.06986666 362.32533333 622.93333333 362.53013333 622.93333333 362.73493333 622.93333333 371.54133333 626.61973333 379.392 632.28586666 385.39946666c0.34133333 0.34133333 0.47786667 0.8192 0.8192 1.09226667 1.09226667 1.09226667 2.59413333 1.77493333 3.8912 2.73066667C642.66239999 393.65973333 649.42079999 396.8 657.13493333 396.8c0.2048 0 0.34133333-0.06826667 0.54613333-0.06826667S658.09066666 396.8 658.29546666 396.8l270.5408 0C948.56533333 396.8 964.26666666 381.50826666 964.26666666 362.66666666 964.40319999 343.89333333 948.42879999 328.53333333 928.90453333 328.53333333zM418.13333333 635.73333333c0-8.8064-3.6864-16.5888-9.35253334-22.66453333C408.43946666 612.72746666 408.30293333 612.2496 408.02986666 611.90826666 406.86933333 610.88426666 405.43573333 610.2016 404.20693333 609.24586666 398.47253333 604.80853333 391.64586666 601.6 383.93173333 601.6 383.72693333 601.6 383.59039999 601.73653333 383.38559999 601.73653333S382.97599999 601.6 382.77119999 601.6L112.29866666 601.6C92.50133333 601.6 76.79999999 616.96 76.79999999 635.73333333 76.66346666 654.50666666 92.63786666 669.86666666 112.16213333 669.86666666l189.44 0-214.15253334 214.15253334c-13.85813333 13.85813333-14.19946667 35.84-0.88746666 49.22026666 13.17546667 13.44853333 35.36213333 12.9024 49.152-0.95573333l214.08426666-214.08426667 0 189.37173334c0 19.59253333 15.42826667 35.49866667 34.2016 35.36213333C402.77333333 943.2064 418.13333333 927.232 418.13333333 907.5712L418.13333333 637.09866666c0-0.27306667-0.13653333-0.47786667-0.13653334-0.68266666C417.99679999 636.14293333 418.13333333 635.93813333 418.13333333 635.73333333zM739.46453333 669.86666666l189.44 0c19.456 0 35.49866667-15.36 35.36213333-34.13333333C964.26666666 616.96 948.56533333 601.6 928.76799999 601.6L658.29546666 601.6C658.09066666 601.6 657.88586666 601.73653333 657.68106666 601.73653333S657.33973333 601.6 657.13493333 601.6C649.42079999 601.6 642.59413333 604.80853333 636.85973333 609.24586666 635.63093333 610.2016 634.19733333 610.88426666 633.03679999 611.90826666 632.76373333 612.2496 632.62719999 612.72746666 632.28586666 613.0688 626.61973333 619.14453333 622.93333333 626.92693333 622.93333333 635.73333333c0 0.2048 0.13653333 0.4096 0.13653333 0.68266667C623.06986666 636.6208 622.93333333 636.8256 622.93333333 637.09866666l0 270.5408C622.93333333 927.232 638.29333333 943.2064 657.06666666 942.93333333c18.77333333 0.13653333 34.2016-15.70133333 34.2016-35.36213333l0-189.37173334 214.08426667 214.08426667c13.78986667 13.85813333 35.90826667 14.40426667 49.152 0.95573333 13.312-13.312 12.97066667-35.36213333-0.88746667-49.22026666L739.46453333 669.86666666z"  ></path></symbol>
    <symbol id="request-fullscreen" viewBox="0 0 1024 1024">
      <path d="M69.818182 87.598545v273.128728a34.909091 34.909091 0 0 0 69.818182 0V163.653818l221.928727 222.021818a33.512727 33.512727 0 0 0 47.383273-47.383272L186.926545 116.363636h197.073455a34.909091 34.909091 0 0 0 0-69.818181H110.871273C85.364364 46.545455 69.818182 59.671273 69.818182 87.598545zM938.542545 46.545455H665.413818a34.909091 34.909091 0 0 0 0 69.818181h197.073455L640.465455 338.292364a33.512727 33.512727 0 0 0 47.383272 47.383272l221.928728-222.021818v197.073455a34.909091 34.909091 0 0 0 69.818181 0V87.598545c0-27.927273-15.453091-41.053091-40.96-41.05309z m-827.671272 907.636363h273.128727a34.909091 34.909091 0 0 0 0-69.818182H186.926545l222.021819-221.928727a33.512727 33.512727 0 0 0-47.383273-47.383273L139.636364 837.073455V640a34.909091 34.909091 0 0 0-69.818182 0v273.128727c0 27.927273 15.546182 41.053091 41.053091 41.053091z m868.724363-41.053091V640a34.909091 34.909091 0 0 0-69.818181 0v197.073455L687.941818 615.051636a33.512727 33.512727 0 0 0-47.383273 47.383273L862.487273 884.363636H665.413818a34.909091 34.909091 0 0 0 0 69.818182h273.128727c25.6 0 41.053091-13.125818 41.053091-41.053091z"  ></path></symbol>
  </svg>
`;

  // node_modules/@antv/g6/esm/plugins/toolbar/index.js
  var __awaiter19 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var Toolbar = class _Toolbar extends BasePlugin {
    constructor(context, options) {
      super(context, Object.assign({}, _Toolbar.defaultOptions, options));
      this.$element = createPluginContainer("toolbar", false);
      this.onToolbarItemClick = (e) => {
        const { onClick } = this.options;
        if (e.target instanceof Element) {
          if (e.target.className.includes("g6-toolbar-item")) {
            const v = e.target.getAttribute("value");
            onClick === null || onClick === void 0 ? void 0 : onClick(v, e.target);
          }
        }
      };
      const $container = this.context.canvas.getContainer();
      this.$element.style.display = "flex";
      $container.appendChild(this.$element);
      insertDOM("g6-toolbar-css", "style", {}, TOOLBAR_CSS, document.head);
      insertDOM("g6-toolbar-svgicon", "div", { display: "none" }, BUILD_IN_SVG_ICON);
      this.$element.addEventListener("click", this.onToolbarItemClick);
      this.update(options);
    }
    /**
     * <zh/> 更新工具栏的配置项
     *
     * <en/> Update the configuration of the toolbar
     * @param options - <zh/> 工具栏的配置项 | <en/> The options of the toolbar
     * @internal
     */
    update(options) {
      const _super = Object.create(null, {
        update: { get: () => super.update }
      });
      return __awaiter19(this, void 0, void 0, function* () {
        _super.update.call(this, options);
        const { className, position: position2, style } = this.options;
        this.$element.className = `g6-toolbar ${className || ""}`;
        Object.assign(this.$element.style, style, parsePositionToStyle(position2));
        this.$element.innerHTML = yield this.getDOMContent();
      });
    }
    /**
     * <zh/> 销毁工具栏
     *
     * <en/> Destroy the toolbar
     * @internal
     */
    destroy() {
      this.$element.removeEventListener("click", this.onToolbarItemClick);
      this.$element.remove();
      super.destroy();
    }
    getDOMContent() {
      return __awaiter19(this, void 0, void 0, function* () {
        const items = yield this.options.getItems();
        return items.map((item) => {
          var _a2;
          return `
          <div class="g6-toolbar-item" value="${item.value}" title="${(_a2 = item.title) !== null && _a2 !== void 0 ? _a2 : ""}">
            <svg aria-hidden="true" focusable="false">
              <use xlink:href="#${item.id}"></use>
            </svg>
          </div>`;
        }).join("");
      });
    }
  };
  Toolbar.defaultOptions = {
    position: "top-left"
  };

  // node_modules/@antv/g6/esm/plugins/tooltip.js
  var import_util197 = __toESM(require_lib());
  var __awaiter20 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var Tooltip2 = class _Tooltip extends BasePlugin {
    constructor(context, options) {
      super(context, Object.assign({}, _Tooltip.defaultOptions, options));
      this.currentTarget = null;
      this.tooltipElement = null;
      this.container = null;
      this.isEnable = (event, items) => {
        const { enable } = this.options;
        if (typeof enable === "function") {
          return enable(event, items);
        }
        return enable;
      };
      this.onClick = (event) => {
        const { target: { id: id3 } } = event;
        if (this.currentTarget === id3) {
          this.hide(event);
        } else {
          this.show(event);
        }
      };
      this.onPointerMove = (event) => {
        const { target } = event;
        if (!this.currentTarget || target.id === this.currentTarget) {
          return;
        }
        this.show(event);
      };
      this.onPointerLeave = (event) => {
        this.hide(event);
      };
      this.onCanvasMove = (event) => {
        this.hide(event);
      };
      this.onPointerOver = (event) => {
        this.show(event);
      };
      this.showById = (id3) => __awaiter20(this, void 0, void 0, function* () {
        const event = {
          target: { id: id3 }
        };
        yield this.show(event);
      });
      this.getElementData = (id3, targetType) => {
        const { model } = this.context;
        switch (targetType) {
          case "node":
            return model.getNodeData([id3]);
          case "edge":
            return model.getEdgeData([id3]);
          case "combo":
            return model.getComboData([id3]);
          default:
            return [];
        }
      };
      this.show = (event) => __awaiter20(this, void 0, void 0, function* () {
        var _a2, _b;
        const { client, target: { id: id3 } } = event;
        if (isToBeDestroyed(event.target))
          return;
        const targetType = this.context.graph.getElementType(id3);
        const { getContent, title } = this.options;
        const items = this.getElementData(id3, targetType);
        if (!this.tooltipElement || !this.isEnable(event, items))
          return;
        let tooltipContent = {};
        if (getContent) {
          tooltipContent.content = yield getContent(event, items);
          if (!tooltipContent.content)
            return;
        } else {
          const style = this.context.graph.getElementRenderStyle(id3);
          const color2 = targetType === "node" ? style.fill : style.stroke;
          tooltipContent = {
            title: title || targetType,
            data: items.map((item) => {
              return {
                name: "ID",
                value: item.id || `${item.source} -> ${item.target}`,
                color: color2
              };
            })
          };
        }
        this.currentTarget = id3;
        let x3;
        let y3;
        if (client) {
          x3 = client.x;
          y3 = client.y;
        } else {
          const style = (0, import_util197.get)(items, "0.style", { x: 0, y: 0 });
          x3 = style.x;
          y3 = style.y;
        }
        (_b = (_a2 = this.options).onOpenChange) === null || _b === void 0 ? void 0 : _b.call(_a2, true);
        this.tooltipElement.update(Object.assign(Object.assign(Object.assign({}, this.tooltipStyleProps), {
          x: x3,
          y: y3,
          style: {
            ".tooltip": {
              visibility: "visible"
            }
          }
        }), tooltipContent));
      });
      this.hide = (event) => {
        var _a2, _b, _c, _d, _e;
        if (!event) {
          (_b = (_a2 = this.options).onOpenChange) === null || _b === void 0 ? void 0 : _b.call(_a2, false);
          (_c = this.tooltipElement) === null || _c === void 0 ? void 0 : _c.hide();
          this.currentTarget = null;
          return;
        }
        if (!this.tooltipElement)
          return;
        if (!this.currentTarget)
          return;
        const { client: { x: x3, y: y3 } } = event;
        (_e = (_d = this.options).onOpenChange) === null || _e === void 0 ? void 0 : _e.call(_d, false);
        this.tooltipElement.hide(x3, y3);
        this.currentTarget = null;
      };
      this.initTooltip = () => {
        var _a2;
        const tooltipElement = new Tooltip({
          className: "tooltip",
          style: this.tooltipStyleProps
        });
        (_a2 = this.container) === null || _a2 === void 0 ? void 0 : _a2.appendChild(tooltipElement.HTMLTooltipElement);
        return tooltipElement;
      };
      this.render();
      this.bindEvents();
    }
    /**
     * <zh/> 获取事件及处理事件的方法
     *
     * <en/> Get event and handle event methods
     * @returns <zh/> 事件及处理事件的方法 | <en/> Event and handling event methods
     */
    getEvents() {
      if (this.options.trigger === "click") {
        return {
          "node:click": this.onClick,
          "edge:click": this.onClick,
          "combo:click": this.onClick,
          "canvas:click": this.onPointerLeave,
          contextmenu: this.onPointerLeave,
          drag: this.onPointerLeave
        };
      }
      return {
        "node:pointerover": this.onPointerOver,
        "node:pointermove": this.onPointerMove,
        "canvas:pointermove": this.onCanvasMove,
        "edge:pointerover": this.onPointerOver,
        "edge:pointermove": this.onPointerMove,
        "combo:pointerover": this.onPointerOver,
        "combo:pointermove": this.onPointerMove,
        contextmenu: this.onPointerLeave,
        "node:drag": this.onPointerLeave
      };
    }
    /**
     * <zh/> 更新tooltip配置
     *
     * <en/> Update the tooltip configuration
     * @param options - <zh/> 配置项 | <en/> options
     * @internal
     */
    update(options) {
      var _a2;
      this.unbindEvents();
      super.update(options);
      if (this.tooltipElement) {
        (_a2 = this.container) === null || _a2 === void 0 ? void 0 : _a2.removeChild(this.tooltipElement.HTMLTooltipElement);
      }
      this.tooltipElement = this.initTooltip();
      this.bindEvents();
    }
    render() {
      const { canvas: canvas2 } = this.context;
      const $container = canvas2.getContainer();
      if (!$container)
        return;
      this.container = $container;
      this.tooltipElement = this.initTooltip();
    }
    unbindEvents() {
      const { graph } = this.context;
      const events = this.getEvents();
      Object.keys(events).forEach((eventName) => {
        graph.off(eventName, events[eventName]);
      });
    }
    bindEvents() {
      const { graph } = this.context;
      const events = this.getEvents();
      Object.keys(events).forEach((eventName) => {
        graph.on(eventName, events[eventName]);
      });
    }
    get tooltipStyleProps() {
      const { canvas: canvas2 } = this.context;
      const { center } = canvas2.getBounds();
      const $container = canvas2.getContainer();
      const { top, left } = $container.getBoundingClientRect();
      const { style, position: position2, enterable, container = { x: -left, y: -top }, title, offset } = this.options;
      const [x3, y3] = center;
      const [width2, height] = canvas2.getSize();
      return {
        x: x3,
        y: y3,
        container,
        title,
        bounding: { x: 0, y: 0, width: width2, height },
        position: position2,
        enterable,
        offset,
        style
      };
    }
    /**
     * <zh/> 销毁tooltip
     *
     * <en/> Destroy tooltip
     * @internal
     */
    destroy() {
      var _a2;
      this.unbindEvents();
      if (this.tooltipElement) {
        (_a2 = this.container) === null || _a2 === void 0 ? void 0 : _a2.removeChild(this.tooltipElement.HTMLTooltipElement);
      }
      super.destroy();
    }
  };
  Tooltip2.defaultOptions = {
    trigger: "hover",
    position: "top-right",
    enterable: false,
    enable: true,
    offset: [10, 10],
    style: {
      ".tooltip": {
        visibility: "hidden"
      }
    }
  };

  // node_modules/@antv/g6/esm/plugins/watermark/util.js
  var __awaiter21 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var canvas;
  function createCanvas(width2, height) {
    if (!canvas) {
      canvas = document.createElement("canvas");
    }
    canvas.width = width2;
    canvas.height = height;
    const ctx3 = canvas.getContext("2d");
    ctx3.clearRect(0, 0, width2, height);
    return canvas;
  }
  function getTextWatermark(width2, height, text, style) {
    return __awaiter21(this, void 0, void 0, function* () {
      const canvas2 = createCanvas(width2, height);
      const ctx3 = canvas2.getContext("2d");
      const { rotate: rotate3, opacity, textFill, textFontSize, textFontFamily, textFontVariant, textFontWeight, textAlign, textBaseline } = style;
      ctx3.textAlign = textAlign;
      ctx3.textBaseline = textBaseline;
      ctx3.translate(width2 / 2, height / 2);
      ctx3.font = `${textFontSize}px ${textFontFamily} ${textFontVariant} ${textFontWeight}`;
      rotate3 && ctx3.rotate(rotate3);
      opacity && (ctx3.globalAlpha = opacity);
      if (textFill) {
        ctx3.fillStyle = textFill;
        ctx3.fillText(`${text}`, 0, 0);
      }
      return canvas2.toDataURL();
    });
  }
  function getImageWatermark(width2, height, imageURL, style) {
    return __awaiter21(this, void 0, void 0, function* () {
      const canvas2 = createCanvas(width2, height);
      const ctx3 = canvas2.getContext("2d");
      const { rotate: rotate3, opacity } = style;
      rotate3 && ctx3.rotate(rotate3);
      opacity && (ctx3.globalAlpha = opacity);
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.src = imageURL;
      return new Promise((resolve) => {
        img.onload = function() {
          const sepX = width2 > img.width ? (width2 - img.width) / 2 : 0;
          const sepY = height > img.height ? (height - img.height) / 2 : 0;
          ctx3.drawImage(img, 0, 0, img.width, img.height, sepX, sepY, width2 - sepX * 2, height - sepY * 2);
          resolve(canvas2.toDataURL());
        };
      });
    });
  }

  // node_modules/@antv/g6/esm/plugins/watermark/index.js
  var __awaiter22 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest19 = function(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  var Watermark = class _Watermark extends BasePlugin {
    constructor(context, options) {
      super(context, Object.assign({}, _Watermark.defaultOptions, options));
      this.$element = createPluginContainer("watermark");
      const $container = this.context.canvas.getContainer();
      $container.appendChild(this.$element);
      this.update(options);
    }
    /**
     * <zh/> 更新水印配置
     *
     * <en/> Update the watermark configuration
     * @param options - <zh/> 配置项 | <en/> Options
     * @internal
     */
    update(options) {
      const _super = Object.create(null, {
        update: { get: () => super.update }
      });
      return __awaiter22(this, void 0, void 0, function* () {
        _super.update.call(this, options);
        const _a2 = this.options, { width: width2, height, text, imageURL } = _a2, rest = __rest19(_a2, ["width", "height", "text", "imageURL"]);
        Object.keys(rest).forEach((key) => {
          if (key.startsWith("background")) {
            this.$element.style[key] = options[key];
          }
        });
        const base64 = imageURL ? yield getImageWatermark(width2, height, imageURL, rest) : yield getTextWatermark(width2, height, text, rest);
        this.$element.style.backgroundImage = `url(${base64})`;
      });
    }
    /**
     * <zh/> 销毁水印
     *
     * <en/> Destroy the watermark
     * @internal
     */
    destroy() {
      super.destroy();
      this.$element.remove();
    }
  };
  Watermark.defaultOptions = {
    width: 200,
    height: 100,
    opacity: 0.2,
    rotate: Math.PI / 12,
    text: "",
    textFill: "#000",
    textFontSize: 16,
    textAlign: "center",
    textBaseline: "middle",
    backgroundRepeat: "repeat"
  };

  // node_modules/@antv/g6/esm/themes/base.js
  var BADGE_PALETTE = ["#7E92B5", "#F4664A", "#FFBE3A"];
  var NODE_PALETTE_OPTIONS = {
    type: "group",
    color: ["#1783FF", "#00C9C9", "#F08F56", "#D580FF", "#7863FF", "#DB9D0D", "#60C42D", "#FF80CA", "#2491B3", "#17C76F"]
  };
  var EDGE_PALETTE_OPTIONS = {
    type: "group",
    color: [
      "#99ADD1",
      "#1783FF",
      "#00C9C9",
      "#F08F56",
      "#D580FF",
      "#7863FF",
      "#DB9D0D",
      "#60C42D",
      "#FF80CA",
      "#2491B3",
      "#17C76F"
    ]
  };
  function create(tokens3) {
    const { bgColor, textColor, nodeColor, nodeColorDisabled, nodeStroke, nodeHaloStrokeOpacityActive = 0.15, nodeHaloStrokeOpacitySelected = 0.25, nodeOpacityDisabled = 0.06, nodeIconOpacityInactive = 0.85, nodeOpacityInactive = 0.25, nodeBadgePalette = BADGE_PALETTE, nodePaletteOptions = NODE_PALETTE_OPTIONS, edgeColor, edgeColorDisabled, edgePaletteOptions = EDGE_PALETTE_OPTIONS, comboColor, comboColorDisabled, comboStroke, comboStrokeDisabled, edgeColorInactive } = tokens3;
    return {
      background: bgColor,
      node: {
        palette: nodePaletteOptions,
        style: {
          donutOpacity: 1,
          badgeBackgroundOpacity: 1,
          badgeFill: "#fff",
          badgeFontSize: 8,
          badgePadding: [0, 4],
          badgePalette: nodeBadgePalette,
          fill: nodeColor,
          fillOpacity: 1,
          halo: false,
          iconFill: "#fff",
          iconOpacity: 1,
          labelBackground: false,
          labelBackgroundFill: bgColor,
          labelBackgroundLineWidth: 0,
          labelBackgroundOpacity: 0.75,
          labelFill: textColor,
          labelFillOpacity: 0.85,
          labelLineHeight: 16,
          labelPadding: [0, 2],
          labelFontSize: 12,
          labelFontWeight: 400,
          labelOpacity: 1,
          labelOffsetY: 2,
          lineWidth: 0,
          portFill: nodeColor,
          portLineWidth: 1,
          portStroke: nodeStroke,
          portStrokeOpacity: 0.65,
          size: 32,
          stroke: nodeStroke,
          strokeOpacity: 1,
          zIndex: 2
        },
        state: {
          selected: {
            halo: true,
            haloLineWidth: 24,
            haloStrokeOpacity: nodeHaloStrokeOpacitySelected,
            labelFontSize: 12,
            labelFontWeight: "bold",
            lineWidth: 4,
            stroke: nodeStroke
          },
          active: {
            halo: true,
            haloLineWidth: 12,
            haloStrokeOpacity: nodeHaloStrokeOpacityActive
          },
          highlight: {
            labelFontWeight: "bold",
            lineWidth: 4,
            stroke: nodeStroke,
            strokeOpacity: 0.85
          },
          inactive: {
            badgeBackgroundOpacity: nodeOpacityInactive,
            donutOpacity: nodeOpacityInactive,
            fillOpacity: nodeOpacityInactive,
            iconOpacity: nodeIconOpacityInactive,
            labelFill: textColor,
            labelFillOpacity: nodeOpacityInactive,
            strokeOpacity: nodeOpacityInactive
          },
          disabled: {
            badgeBackgroundOpacity: 0.25,
            donutOpacity: nodeOpacityDisabled,
            fill: nodeColorDisabled,
            fillOpacity: nodeOpacityDisabled,
            iconFill: nodeColorDisabled,
            iconOpacity: 0.25,
            labelFill: textColor,
            labelFillOpacity: 0.25,
            strokeOpacity: nodeOpacityDisabled
          }
        },
        animation: {
          enter: "fade",
          exit: "fade",
          show: "fade",
          hide: "fade",
          expand: "node-expand",
          collapse: "node-collapse",
          update: [{ fields: ["x", "y", "fill", "stroke"] }],
          translate: [{ fields: ["x", "y"] }]
        }
      },
      edge: {
        palette: edgePaletteOptions,
        style: {
          badgeBackgroundFill: edgeColor,
          badgeFill: "#fff",
          badgeFontSize: 8,
          badgeOffsetX: 10,
          badgeBackgroundOpacity: 1,
          fillOpacity: 1,
          halo: false,
          haloLineWidth: 12,
          haloStrokeOpacity: 1,
          increasedLineWidthForHitTesting: 2,
          labelBackground: false,
          labelBackgroundFill: bgColor,
          labelBackgroundLineWidth: 0,
          labelBackgroundOpacity: 0.75,
          labelBackgroundPadding: [4, 4, 4, 4],
          labelFill: textColor,
          labelFontSize: 12,
          labelFontWeight: 400,
          labelOpacity: 1,
          labelPlacement: "center",
          labelTextBaseline: "middle",
          lineWidth: 1,
          stroke: edgeColor,
          strokeOpacity: 1,
          zIndex: 1
        },
        state: {
          selected: {
            halo: true,
            haloStrokeOpacity: 0.25,
            labelFontSize: 14,
            labelFontWeight: "bold",
            lineWidth: 3
          },
          active: {
            halo: true,
            haloStrokeOpacity: 0.15
          },
          highlight: {
            labelFontWeight: "bold",
            lineWidth: 3
          },
          inactive: {
            stroke: edgeColorInactive,
            fillOpacity: 0.08,
            labelOpacity: 0.25,
            strokeOpacity: 0.08,
            badgeBackgroundOpacity: 0.25
          },
          disabled: {
            stroke: edgeColorDisabled,
            fillOpacity: 0.45,
            strokeOpacity: 0.45,
            labelOpacity: 0.25,
            badgeBackgroundOpacity: 0.45
          }
        },
        animation: {
          enter: "fade",
          exit: "fade",
          expand: "path-in",
          collapse: "path-out",
          show: "fade",
          hide: "fade",
          update: [{ fields: ["sourceNode", "targetNode"] }, { fields: ["stroke"], shape: "key" }],
          translate: [{ fields: ["sourceNode", "targetNode"] }]
        }
      },
      combo: {
        style: {
          collapsedMarkerFill: bgColor,
          collapsedMarkerFontSize: 12,
          collapsedMarkerFillOpacity: 1,
          collapsedSize: 32,
          collapsedFillOpacity: 1,
          fill: comboColor,
          halo: false,
          haloLineWidth: 12,
          haloStroke: comboStroke,
          haloStrokeOpacity: 0.25,
          labelBackground: false,
          labelBackgroundFill: bgColor,
          labelBackgroundLineWidth: 0,
          labelBackgroundOpacity: 0.75,
          labelBackgroundPadding: [2, 4, 2, 4],
          labelFill: textColor,
          labelFontSize: 12,
          labelFontWeight: 400,
          labelOpacity: 1,
          lineDash: 0,
          lineWidth: 1,
          fillOpacity: 0.04,
          strokeOpacity: 1,
          padding: 10,
          stroke: comboStroke
        },
        state: {
          selected: {
            halo: true,
            labelFontSize: 14,
            labelFontWeight: 700,
            lineWidth: 4
          },
          active: {
            halo: true
          },
          highlight: {
            labelFontWeight: 700,
            lineWidth: 4
          },
          inactive: {
            fillOpacity: 0.65,
            labelOpacity: 0.25,
            strokeOpacity: 0.65
          },
          disabled: {
            fill: comboColorDisabled,
            fillOpacity: 0.25,
            labelOpacity: 0.25,
            stroke: comboStrokeDisabled,
            strokeOpacity: 0.25
          }
        },
        animation: {
          enter: "fade",
          exit: "fade",
          show: "fade",
          hide: "fade",
          expand: "combo-expand",
          collapse: "combo-collapse",
          update: [{ fields: ["x", "y"] }, { fields: ["fill", "stroke", "lineWidth"], shape: "key" }],
          translate: [{ fields: ["x", "y"] }]
        }
      }
    };
  }

  // node_modules/@antv/g6/esm/themes/dark.js
  var EDGE_PALETTE_OPTIONS2 = {
    type: "group",
    color: [
      "#637088",
      "#0F55A6",
      "#008383",
      "#9C5D38",
      "#8B53A6",
      "#4E40A6",
      "#8F6608",
      "#3E801D",
      "#A65383",
      "#175E75",
      "#0F8248"
    ]
  };
  var tokens = {
    bgColor: "#000000",
    comboColor: "#fdfdfd",
    comboColorDisabled: "#d0e4ff",
    comboStroke: "#99add1",
    comboStrokeDisabled: "#969696",
    edgeColor: "#637088",
    edgeColorDisabled: "#637088",
    edgeColorInactive: "#D0E4FF",
    edgePaletteOptions: EDGE_PALETTE_OPTIONS2,
    nodeColor: "#1783ff",
    nodeColorDisabled: "#D0E4FF",
    nodeHaloStrokeOpacityActive: 0.25,
    nodeHaloStrokeOpacitySelected: 0.45,
    nodeIconOpacityInactive: 0.45,
    nodeOpacityDisabled: 0.25,
    nodeOpacityInactive: 0.45,
    nodeStroke: "#d0e4ff",
    textColor: "#ffffff"
  };
  var dark = create(tokens);

  // node_modules/@antv/g6/esm/themes/light.js
  var tokens2 = {
    bgColor: "#ffffff",
    comboColor: "#99ADD1",
    comboColorDisabled: "#f0f0f0",
    comboStroke: "#99add1",
    comboStrokeDisabled: "#d9d9d9",
    edgeColor: "#99add1",
    edgeColorDisabled: "#d9d9d9",
    edgeColorInactive: "#1B324F",
    nodeColor: "#1783ff",
    nodeColorDisabled: "#1B324F",
    nodeHaloStrokeOpacityActive: 0.15,
    nodeHaloStrokeOpacitySelected: 0.25,
    nodeIconOpacityInactive: 0.85,
    nodeOpacityDisabled: 0.06,
    nodeOpacityInactive: 0.25,
    nodeStroke: "#000000",
    textColor: "#000000"
  };
  var light = create(tokens2);

  // node_modules/@antv/g6/esm/transforms/base-transform.js
  var BaseTransform = class extends BaseExtension {
    beforeDraw(data2, context) {
      return data2;
    }
    afterLayout(type, data2) {
    }
  };

  // node_modules/@antv/g6/esm/transforms/arrange-draw-order.js
  var ArrangeDrawOrder = class extends BaseTransform {
    beforeDraw(input) {
      const { model } = this.context;
      const combosToAdd = input.add.combos;
      const arrangeCombo = (combos) => {
        const order2 = [];
        combos.forEach((combo, id3) => {
          const ancestors = model.getAncestorsData(id3, "combo");
          const path = ancestors.map((ancestor) => idOf(ancestor)).reverse();
          order2.push([id3, combo, path.length]);
        });
        return new Map(order2.sort(([, , zIndex1], [, , zIndex2]) => zIndex2 - zIndex1).map(([id3, datum]) => [id3, datum]));
      };
      input.add.combos = arrangeCombo(combosToAdd);
      input.update.combos = arrangeCombo(input.update.combos);
      return input;
    }
  };

  // node_modules/@antv/g6/esm/transforms/utils.js
  function reassignTo(input, type, elementType, datum, overwrite) {
    const id3 = idOf(datum);
    const typeName = `${elementType}s`;
    const exitsDatum = overwrite ? datum : input.add[typeName].get(id3) || input.update[typeName].get(id3) || input.remove[typeName].get(id3) || datum;
    Object.entries(input).forEach(([_type, value]) => {
      if (type === _type)
        value[typeName].set(id3, exitsDatum);
      else
        value[typeName].delete(id3);
    });
  }
  function isStyleEqual(style, originalStyle) {
    return Object.keys(style).every((key) => style[key] === originalStyle[key]);
  }

  // node_modules/@antv/g6/esm/transforms/collapse-expand-combo.js
  var CollapseExpandCombo = class extends BaseTransform {
    beforeDraw(input, context) {
      if (context.stage === "visibility")
        return input;
      if (!this.context.model.model.hasTreeStructure(COMBO_KEY))
        return input;
      const { model } = this.context;
      const { add: add5, update } = input;
      const combos = [...input.update.combos.entries(), ...input.add.combos.entries()];
      while (combos.length) {
        const [id3, combo] = combos.pop();
        if (isCollapsed(combo)) {
          const descendants = model.getDescendantsData(id3);
          const descendantIds = descendants.map(idOf);
          const { internal, external } = getSubgraphRelatedEdges(descendantIds, (id4) => model.getRelatedEdgesData(id4));
          descendants.forEach((descendant) => {
            const descendantId = idOf(descendant);
            const comboIndex = combos.findIndex(([id4]) => id4 === descendantId);
            if (comboIndex !== -1)
              combos.splice(comboIndex, 1);
            const elementType = model.getElementType(descendantId);
            reassignTo(input, "remove", elementType, descendant);
          });
          internal.forEach((edge) => reassignTo(input, "remove", "edge", edge));
          external.forEach((edge) => {
            var _a2;
            const id4 = idOf(edge);
            const edgeElement = (_a2 = this.context.element) === null || _a2 === void 0 ? void 0 : _a2.getElement(id4);
            if (edgeElement)
              update.edges.set(id4, edge);
            else
              add5.edges.set(id4, edge);
          });
        } else {
          const children = model.getChildrenData(id3);
          const childrenIds = children.map(idOf);
          const { edges } = getSubgraphRelatedEdges(childrenIds, (id4) => model.getRelatedEdgesData(id4));
          [...children, ...edges].forEach((descendant) => {
            var _a2;
            const id4 = idOf(descendant);
            const elementType = model.getElementType(id4);
            const element = (_a2 = this.context.element) === null || _a2 === void 0 ? void 0 : _a2.getElement(id4);
            if (element)
              reassignTo(input, "update", elementType, descendant);
            else
              reassignTo(input, "add", elementType, descendant);
            if (elementType === "combo")
              combos.push([id4, descendant]);
          });
        }
      }
      return input;
    }
  };

  // node_modules/@antv/g6/esm/transforms/collapse-expand-node.js
  var weakAssignTo = (input, type, elementType, datum) => {
    const typeName = `${elementType}s`;
    const id3 = idOf(datum);
    if (!input.add[typeName].has(id3) && !input.update[typeName].has(id3)) {
      input[type][typeName].set(idOf(datum), datum);
    }
  };
  var CollapseExpandNode = class extends BaseTransform {
    getElement(id3) {
      return this.context.element.getElement(id3);
    }
    handleExpand(node, input) {
      weakAssignTo(input, "add", "node", node);
      if (isCollapsed(node))
        return;
      const id3 = idOf(node);
      weakAssignTo(input, "add", "node", node);
      const relatedEdges = this.context.model.getRelatedEdgesData(id3);
      relatedEdges.forEach((edge) => {
        reassignTo(input, "add", "edge", edge);
      });
      const children = this.context.model.getChildrenData(id3);
      children.forEach((child) => {
        this.handleExpand(child, input);
      });
    }
    beforeDraw(input) {
      const { graph, model } = this.context;
      if (!model.model.hasTreeStructure(TREE_KEY))
        return input;
      const { add: { nodes: nodesToAdd, edges: edgesToAdd }, update: { nodes: nodesToUpdate } } = input;
      const nodesToCollapse = /* @__PURE__ */ new Map();
      const nodesToExpand = /* @__PURE__ */ new Map();
      nodesToAdd.forEach((node, id3) => {
        if (isCollapsed(node))
          nodesToCollapse.set(id3, node);
      });
      edgesToAdd.forEach((edge) => {
        if (graph.getElementType(edge.source) !== "node")
          return;
        const source = graph.getNodeData(edge.source);
        if (isCollapsed(source))
          nodesToCollapse.set(edge.source, source);
      });
      nodesToUpdate.forEach((node, id3) => {
        const nodeElement = this.getElement(id3);
        if (!nodeElement)
          return;
        const isCurrentCollapsed = nodeElement.attributes.collapsed;
        if (isCollapsed(node)) {
          if (!isCurrentCollapsed)
            nodesToCollapse.set(id3, node);
        } else {
          if (isCurrentCollapsed)
            nodesToExpand.set(id3, node);
        }
      });
      const handledNodes = /* @__PURE__ */ new Set();
      nodesToCollapse.forEach((node, id3) => {
        const descendants = model.getDescendantsData(id3);
        descendants.forEach((descendant) => {
          const id4 = idOf(descendant);
          if (handledNodes.has(id4))
            return;
          reassignTo(input, "remove", "node", descendant);
          const relatedEdges = model.getRelatedEdgesData(id4);
          relatedEdges.forEach((edge) => {
            reassignTo(input, "remove", "edge", edge);
          });
          handledNodes.add(id4);
        });
      });
      nodesToExpand.forEach((node, id3) => {
        const ancestors = model.getAncestorsData(id3, TREE_KEY);
        if (ancestors.some(isCollapsed)) {
          reassignTo(input, "remove", "node", node);
          return;
        }
        this.handleExpand(node, input);
      });
      return input;
    }
  };

  // node_modules/@antv/g6/esm/registry/register.js
  function register(category, type, Ctor) {
    const ext = EXTENSION_REGISTRY[category][type];
    if (ext) {
      print.warn(`The extension ${type} of ${category} has been registered before, and will be overridden.`);
    }
    Object.assign(EXTENSION_REGISTRY[category], { [type]: Ctor });
  }

  // node_modules/@antv/g-plugin-dragndrop/dist/index.esm.js
  var import_util199 = __toESM(require_lib());
  var DragndropPlugin = /* @__PURE__ */ (function() {
    function DragndropPlugin2(dragndropPluginOptions) {
      _classCallCheck(this, DragndropPlugin2);
      this.dragndropPluginOptions = dragndropPluginOptions;
    }
    return _createClass(DragndropPlugin2, [{
      key: "apply",
      value: function apply3(context) {
        var _this2 = this;
        var renderingService = context.renderingService, renderingContext = context.renderingContext;
        var document2 = renderingContext.root.ownerDocument;
        var canvas2 = document2.defaultView;
        var handlePointerdown = function handlePointerdown2(event) {
          var target = event.target;
          var isDocument = target === document2;
          var draggableEventTarget = isDocument && _this2.dragndropPluginOptions.isDocumentDraggable ? document2 : target.closest && target.closest("[draggable=true]");
          if (draggableEventTarget) {
            var dragstartTriggered = false;
            var dragstartTimeStamp = event.timeStamp;
            var dragstartClientCoordinates = [event.clientX, event.clientY];
            var currentDroppable = null;
            var lastDragClientCoordinates = [event.clientX, event.clientY];
            var handlePointermove = /* @__PURE__ */ (function() {
              var _ref = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(event2) {
                var timeElapsed, distanceMoved, point4, elementsBelow, elementBelow, droppableBelow;
                return _regeneratorRuntime().wrap(function(_context) {
                  while (1) switch (_context.prev = _context.next) {
                    case 0:
                      if (dragstartTriggered) {
                        _context.next = 2;
                        break;
                      }
                      timeElapsed = event2.timeStamp - dragstartTimeStamp;
                      distanceMoved = (0, import_util199.distanceSquareRoot)([event2.clientX, event2.clientY], dragstartClientCoordinates);
                      if (!(timeElapsed <= _this2.dragndropPluginOptions.dragstartTimeThreshold || distanceMoved <= _this2.dragndropPluginOptions.dragstartDistanceThreshold)) {
                        _context.next = 1;
                        break;
                      }
                      return _context.abrupt("return");
                    case 1:
                      event2.type = "dragstart";
                      draggableEventTarget.dispatchEvent(event2);
                      dragstartTriggered = true;
                    case 2:
                      event2.type = "drag";
                      event2.dx = event2.clientX - lastDragClientCoordinates[0];
                      event2.dy = event2.clientY - lastDragClientCoordinates[1];
                      draggableEventTarget.dispatchEvent(event2);
                      lastDragClientCoordinates = [event2.clientX, event2.clientY];
                      if (isDocument) {
                        _context.next = 4;
                        break;
                      }
                      point4 = _this2.dragndropPluginOptions.overlap === "pointer" ? [event2.canvasX, event2.canvasY] : target.getBounds().center;
                      _context.next = 3;
                      return document2.elementsFromPoint(point4[0], point4[1]);
                    case 3:
                      elementsBelow = _context.sent;
                      elementBelow = elementsBelow[elementsBelow.indexOf(target) + 1];
                      droppableBelow = (elementBelow === null || elementBelow === void 0 ? void 0 : elementBelow.closest("[droppable=true]")) || (_this2.dragndropPluginOptions.isDocumentDroppable ? document2 : null);
                      if (currentDroppable !== droppableBelow) {
                        if (currentDroppable) {
                          event2.type = "dragleave";
                          event2.target = currentDroppable;
                          currentDroppable.dispatchEvent(event2);
                        }
                        if (droppableBelow) {
                          event2.type = "dragenter";
                          event2.target = droppableBelow;
                          droppableBelow.dispatchEvent(event2);
                        }
                        currentDroppable = droppableBelow;
                        if (currentDroppable) {
                          event2.type = "dragover";
                          event2.target = currentDroppable;
                          currentDroppable.dispatchEvent(event2);
                        }
                      }
                    case 4:
                    case "end":
                      return _context.stop();
                  }
                }, _callee);
              }));
              return function handlePointermove2(_x) {
                return _ref.apply(this, arguments);
              };
            })();
            canvas2.addEventListener("pointermove", handlePointermove);
            var stopDragging = function stopDragging2(originalPointerUpEvent) {
              if (dragstartTriggered) {
                originalPointerUpEvent.detail = {
                  preventClick: true
                };
                var _event = originalPointerUpEvent.clone();
                if (currentDroppable) {
                  _event.type = "drop";
                  _event.target = currentDroppable;
                  currentDroppable.dispatchEvent(_event);
                }
                _event.type = "dragend";
                draggableEventTarget.dispatchEvent(_event);
                dragstartTriggered = false;
              }
              canvas2.removeEventListener("pointermove", handlePointermove);
            };
            target.addEventListener("pointerup", stopDragging, {
              once: true
            });
            target.addEventListener("pointerupoutside", stopDragging, {
              once: true
            });
          }
        };
        renderingService.hooks.init.tap(DragndropPlugin2.tag, function() {
          canvas2.addEventListener("pointerdown", handlePointerdown);
        });
        renderingService.hooks.destroy.tap(DragndropPlugin2.tag, function() {
          canvas2.removeEventListener("pointerdown", handlePointerdown);
        });
      }
    }]);
  })();
  DragndropPlugin.tag = "Dragndrop";
  var Plugin7 = /* @__PURE__ */ (function(_AbstractRendererPlug) {
    function Plugin8() {
      var _this2;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, Plugin8);
      _this2 = _callSuper(this, Plugin8);
      _this2.name = "dragndrop";
      _this2.options = options;
      return _this2;
    }
    _inherits(Plugin8, _AbstractRendererPlug);
    return _createClass(Plugin8, [{
      key: "init",
      value: function init() {
        this.addRenderingPlugin(new DragndropPlugin(_objectSpread2({
          overlap: "pointer",
          isDocumentDraggable: false,
          isDocumentDroppable: false,
          dragstartDistanceThreshold: 0,
          dragstartTimeThreshold: 0
        }, this.options)));
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.removeAllRenderingPlugins();
      }
    }, {
      key: "setOptions",
      value: function setOptions(options) {
        Object.assign(this.plugins[0].dragndropPluginOptions, options);
      }
    }]);
  })(AbstractRendererPlugin);

  // node_modules/@antv/g6/esm/runtime/canvas.js
  var import_util200 = __toESM(require_lib());
  var __awaiter23 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest20 = function(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  var SINGLE_LAYER_NAME = ["main"];
  var MULTI_LAYER_NAME = ["background", "main", "label", "transient"];
  function getMainLayerOf(layers) {
    return layers.main;
  }
  var Canvas2 = class {
    getConfig() {
      return this.config;
    }
    getLayer(layer = "main") {
      return this.extends.layers[layer] || getMainLayerOf(this.getLayers());
    }
    /**
     * <zh/> 获取所有图层
     *
     * <en/> Get all layers
     * @returns <zh/> 图层 <en/> Layer
     */
    getLayers() {
      return this.extends.layers;
    }
    /**
     * <zh/> 获取渲染器
     *
     * <en/> Get renderer
     * @param layer - <zh/> 图层 <en/> Layer
     * @returns <zh/> 渲染器 <en/> Renderer
     */
    getRenderer(layer) {
      return this.extends.renderers[layer];
    }
    /**
     * <zh/> 获取相机
     *
     * <en/> Get camera
     * @param layer - <zh/> 图层 <en/> Layer
     * @returns <zh/> 相机 <en/> Camera
     */
    getCamera(layer = "main") {
      return this.getLayer(layer).getCamera();
    }
    getRoot(layer = "main") {
      return this.getLayer(layer).getRoot();
    }
    getContextService(layer = "main") {
      return this.getLayer(layer).getContextService();
    }
    setCursor(cursor) {
      this.config.cursor = cursor;
      this.getLayer().setCursor(cursor);
    }
    get document() {
      return this.getLayer().document;
    }
    get context() {
      return this.getLayer().context;
    }
    constructor(config) {
      this.config = {
        enableMultiLayer: true
      };
      Object.assign(this.config, config);
      const _a2 = this.config, { renderer, background, cursor, enableMultiLayer } = _a2, restConfig = __rest20(_a2, ["renderer", "background", "cursor", "enableMultiLayer"]);
      const layersName = enableMultiLayer ? MULTI_LAYER_NAME : SINGLE_LAYER_NAME;
      const renderers = createRenderers(renderer, layersName);
      const layers = Object.fromEntries(layersName.map((layer) => {
        const canvas2 = new Canvas(Object.assign(Object.assign({}, restConfig), { supportsMutipleCanvasesInOneContainer: enableMultiLayer, renderer: renderers[layer], background: enableMultiLayer ? layer === "background" ? background : void 0 : background }));
        return [layer, canvas2];
      }));
      configCanvasDom(layers);
      this.extends = {
        config: this.config,
        renderer,
        renderers,
        layers
      };
    }
    get ready() {
      return Promise.all(Object.entries(this.getLayers()).map(([, canvas2]) => canvas2.ready));
    }
    resize(width2, height) {
      Object.assign(this.extends.config, { width: width2, height });
      Object.values(this.getLayers()).forEach((canvas2) => {
        const camera = canvas2.getCamera();
        const position2 = camera.getPosition();
        const focalPoint = camera.getFocalPoint();
        canvas2.resize(width2, height);
        camera.setPosition(position2);
        camera.setFocalPoint(focalPoint);
      });
    }
    /**
     * <zh/> 获取画布边界
     *
     * <en/> Get canvas boundary
     * @param group
     * <zh/> 元素分组
     * - undefined: 获取整个画布边界
     * - 'elements': 仅获取元素边界
     * - 'plugins': 仅获取插件边界
     *
     * <en/> Element group
     * - undefined: Get the entire canvas boundary
     * - 'elements': Get only the element boundary
     * - 'plugins': Get only the plugin boundary
     * @returns <zh/> 边界 <en/> Boundary
     */
    getBounds(group2) {
      return getCombinedBBox(Object.values(this.getLayers()).map((canvas2) => {
        const g = group2 ? canvas2.getRoot().childNodes.find((node) => node.classList.includes(group2)) : canvas2.getRoot();
        return g;
      }).filter((el) => (el === null || el === void 0 ? void 0 : el.childNodes.length) > 0).map((el) => el.getBounds()));
    }
    getContainer() {
      const container = this.extends.config.container;
      return typeof container === "string" ? document.getElementById(container) : container;
    }
    getSize() {
      return [this.extends.config.width || 0, this.extends.config.height || 0];
    }
    appendChild(child, index2) {
      var _a2;
      const layer = ((_a2 = child.style) === null || _a2 === void 0 ? void 0 : _a2.$layer) || "main";
      return this.getLayer(layer).appendChild(child, index2);
    }
    setRenderer(renderer) {
      if (renderer === this.extends.renderer)
        return;
      const renderers = createRenderers(renderer, this.config.enableMultiLayer ? MULTI_LAYER_NAME : SINGLE_LAYER_NAME);
      this.extends.renderers = renderers;
      Object.entries(renderers).forEach(([layer, instance]) => this.getLayer(layer).setRenderer(instance));
      configCanvasDom(this.getLayers());
    }
    getCanvasByViewport(point4) {
      return parsePoint(this.getLayer().viewport2Canvas(toPointObject(point4)));
    }
    getViewportByCanvas(point4) {
      return parsePoint(this.getLayer().canvas2Viewport(toPointObject(point4)));
    }
    getViewportByClient(point4) {
      return parsePoint(this.getLayer().client2Viewport(toPointObject(point4)));
    }
    getClientByViewport(point4) {
      return parsePoint(this.getLayer().viewport2Client(toPointObject(point4)));
    }
    getClientByCanvas(point4) {
      return this.getClientByViewport(this.getViewportByCanvas(point4));
    }
    getCanvasByClient(point4) {
      const main = this.getLayer();
      const viewportPoint = main.client2Viewport(toPointObject(point4));
      return parsePoint(main.viewport2Canvas(viewportPoint));
    }
    toDataURL() {
      return __awaiter23(this, arguments, void 0, function* (options = {}) {
        const devicePixelRatio = globalThis.devicePixelRatio || 1;
        const { mode = "viewport" } = options, restOptions = __rest20(options, ["mode"]);
        let [startX, startY, width2, height] = [0, 0, 0, 0];
        if (mode === "viewport") {
          [width2, height] = this.getSize();
        } else if (mode === "overall") {
          const bounds = this.getBounds();
          const size2 = getBBoxSize(bounds);
          [startX, startY] = bounds.min;
          [width2, height] = size2;
        }
        const container = (0, import_util200.createDOM)('<div id="virtual-image"></div>');
        const offscreenCanvas = new Canvas({
          width: width2,
          height,
          renderer: new Renderer(),
          devicePixelRatio,
          container,
          background: this.extends.config.background
        });
        yield offscreenCanvas.ready;
        offscreenCanvas.appendChild(this.getLayer("background").getRoot().cloneNode(true));
        offscreenCanvas.appendChild(this.getRoot().cloneNode(true));
        const label = this.getLayer("label").getRoot().cloneNode(true);
        const originCanvasPosition = offscreenCanvas.viewport2Canvas({ x: 0, y: 0 });
        const currentCanvasPosition = this.getCanvasByViewport([0, 0]);
        label.translate([
          currentCanvasPosition[0] - originCanvasPosition.x,
          currentCanvasPosition[1] - originCanvasPosition.y
        ]);
        label.scale(1 / this.getCamera().getZoom());
        offscreenCanvas.appendChild(label);
        offscreenCanvas.appendChild(this.getLayer("transient").getRoot().cloneNode(true));
        const camera = this.getCamera();
        const offscreenCamera = offscreenCanvas.getCamera();
        if (mode === "viewport") {
          offscreenCamera.setZoom(camera.getZoom());
          offscreenCamera.setPosition(camera.getPosition());
          offscreenCamera.setFocalPoint(camera.getFocalPoint());
        } else if (mode === "overall") {
          const [x3, y3, z] = offscreenCamera.getPosition();
          const [fx, fy, fz] = offscreenCamera.getFocalPoint();
          offscreenCamera.setPosition([x3 + startX, y3 + startY, z]);
          offscreenCamera.setFocalPoint([fx + startX, fy + startY, fz]);
        }
        const contextService = offscreenCanvas.getContextService();
        return new Promise((resolve) => {
          offscreenCanvas.addEventListener(CanvasEvent.RERENDER, () => __awaiter23(this, void 0, void 0, function* () {
            yield new Promise((r) => setTimeout(r, 300));
            const url = yield contextService.toDataURL(restOptions);
            resolve(url);
          }));
        });
      });
    }
    destroy() {
      Object.values(this.getLayers()).forEach((canvas2) => {
        const camera = canvas2.getCamera();
        camera.cancelLandmarkAnimation();
        canvas2.destroy();
      });
    }
  };
  function createRenderers(renderer, layersName) {
    return Object.fromEntries(layersName.map((layer) => {
      const instance = (renderer === null || renderer === void 0 ? void 0 : renderer(layer)) || new Renderer();
      if (instance instanceof Renderer) {
        instance.setConfig({ enableDirtyRectangleRendering: false });
      }
      if (layer === "main") {
        instance.registerPlugin(new Plugin7({
          isDocumentDraggable: true,
          isDocumentDroppable: true,
          dragstartDistanceThreshold: 10,
          dragstartTimeThreshold: 100
        }));
      } else {
        instance.unregisterPlugin(instance.getPlugin("dom-interaction"));
      }
      return [layer, instance];
    }));
  }
  function configCanvasDom(layers) {
    Object.entries(layers).forEach(([layer, canvas2]) => {
      const domElement = canvas2.getContextService().getDomElement();
      if (domElement === null || domElement === void 0 ? void 0 : domElement.style) {
        domElement.style.gridArea = "1 / 1 / 2 / 2";
        domElement.style.outline = "none";
        domElement.tabIndex = 1;
        if (layer !== "main")
          domElement.style.pointerEvents = "none";
      }
      if (domElement === null || domElement === void 0 ? void 0 : domElement.parentElement) {
        domElement.parentElement.style.display = "grid";
        domElement.parentElement.style.isolation = "isolate";
      }
    });
  }

  // node_modules/@antv/g6/esm/runtime/graph.js
  var import_util207 = __toESM(require_lib());

  // node_modules/@antv/g6/esm/utils/dom.js
  var import_util201 = __toESM(require_lib());
  var parseInt10 = (d2) => d2 ? parseInt(d2) : 0;
  function getContainerSize(container) {
    const style = getComputedStyle(container);
    const wrapperWidth = container.clientWidth || parseInt10(style.width);
    const wrapperHeight = container.clientHeight || parseInt10(style.height);
    const widthPadding = parseInt10(style.paddingLeft) + parseInt10(style.paddingRight);
    const heightPadding = parseInt10(style.paddingTop) + parseInt10(style.paddingBottom);
    return [wrapperWidth - widthPadding, wrapperHeight - heightPadding];
  }
  function sizeOf(container) {
    if (!container)
      return [0, 0];
    let effectiveWidth = 640;
    let effectiveHeight = 480;
    const [containerWidth, containerHeight] = getContainerSize(container);
    effectiveWidth = containerWidth || effectiveWidth;
    effectiveHeight = containerHeight || effectiveHeight;
    const MIN_CHART_WIDTH = 1;
    const MIN_CHART_HEIGHT = 1;
    return [
      Math.max((0, import_util201.isNumber)(effectiveWidth) ? effectiveWidth : MIN_CHART_WIDTH, MIN_CHART_WIDTH),
      Math.max((0, import_util201.isNumber)(effectiveHeight) ? effectiveHeight : MIN_CHART_HEIGHT, MIN_CHART_HEIGHT)
    ];
  }

  // node_modules/@antv/g6/esm/utils/event/events.js
  var BaseEvent = class {
    constructor(type) {
      this.type = type;
    }
  };
  var GraphLifeCycleEvent = class extends BaseEvent {
    constructor(type, data2) {
      super(type);
      this.data = data2;
    }
  };
  var AnimateEvent = class extends BaseEvent {
    constructor(type, animationType, animation, data2) {
      super(type);
      this.animationType = animationType;
      this.animation = animation;
      this.data = data2;
    }
  };
  var ElementLifeCycleEvent = class extends BaseEvent {
    constructor(type, elementType, data2) {
      super(type);
      this.elementType = elementType;
      this.data = data2;
    }
  };
  var ViewportEvent = class extends BaseEvent {
    constructor(type, data2) {
      super(type);
      this.data = data2;
    }
  };

  // node_modules/@antv/g6/esm/utils/event/index.js
  function emit(emitter, event) {
    emitter.emit(event.type, event);
  }
  function eventTargetOf(shape) {
    if (!shape)
      return null;
    if (shape instanceof Document2) {
      return { type: "canvas", element: shape };
    }
    let element = shape;
    while (element) {
      if (isNode(element))
        return { type: "node", element };
      if (isEdge(element))
        return { type: "edge", element };
      if (isCombo(element))
        return { type: "combo", element };
      element = element.parentElement;
    }
    return null;
  }

  // node_modules/@antv/g6/esm/utils/z-index.js
  function getZIndexOf(datum) {
    var _a2;
    return ((_a2 = datum === null || datum === void 0 ? void 0 : datum.style) === null || _a2 === void 0 ? void 0 : _a2.zIndex) || 0;
  }

  // node_modules/@antv/g6/esm/utils/cache.js
  var import_util202 = __toESM(require_lib());
  var CacheTargetKey = "cachedStyle";
  var getStyleCacheKey = (name) => `__${name}__`;
  function cacheStyle(element, name) {
    const names = Array.isArray(name) ? name : [name];
    if (!(0, import_util202.get)(element, CacheTargetKey))
      (0, import_util202.set)(element, CacheTargetKey, {});
    names.forEach((n) => {
      (0, import_util202.set)((0, import_util202.get)(element, CacheTargetKey), getStyleCacheKey(n), element.attributes[n]);
    });
  }
  function getCachedStyle(element, name) {
    return (0, import_util202.get)(element, [CacheTargetKey, getStyleCacheKey(name)]);
  }
  function hasCachedStyle(element, name) {
    return getStyleCacheKey(name) in ((0, import_util202.get)(element, CacheTargetKey) || {});
  }

  // node_modules/@antv/g6/esm/runtime/animation.js
  var Animation2 = class {
    constructor(context) {
      this.tasks = [];
      this.animations = /* @__PURE__ */ new Set();
      this.context = context;
    }
    getTasks() {
      const tasks2 = [...this.tasks];
      this.tasks = [];
      return tasks2;
    }
    add(context, callbacks) {
      this.tasks.push([context, callbacks]);
    }
    animate(localAnimation, callbacks, extendOptions) {
      var _a2, _b, _c;
      (_a2 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.before) === null || _a2 === void 0 ? void 0 : _a2.call(callbacks);
      const animations = this.getTasks().map(([context, cb]) => {
        var _a3, _b2, _c2;
        const { element, elementType, stage } = context;
        const options = getElementAnimationOptions(this.context.options, elementType, stage, localAnimation);
        (_a3 = cb === null || cb === void 0 ? void 0 : cb.before) === null || _a3 === void 0 ? void 0 : _a3.call(cb);
        const animation2 = options.length ? executor(element, this.inferStyle(context, extendOptions), options) : null;
        if (animation2) {
          (_b2 = cb === null || cb === void 0 ? void 0 : cb.beforeAnimate) === null || _b2 === void 0 ? void 0 : _b2.call(cb, animation2);
          animation2.finished.then(() => {
            var _a4, _b3;
            (_a4 = cb === null || cb === void 0 ? void 0 : cb.afterAnimate) === null || _a4 === void 0 ? void 0 : _a4.call(cb, animation2);
            (_b3 = cb === null || cb === void 0 ? void 0 : cb.after) === null || _b3 === void 0 ? void 0 : _b3.call(cb);
            this.animations.delete(animation2);
          });
        } else
          (_c2 = cb === null || cb === void 0 ? void 0 : cb.after) === null || _c2 === void 0 ? void 0 : _c2.call(cb);
        return animation2;
      }).filter(Boolean);
      animations.forEach((animation2) => this.animations.add(animation2));
      const animation = createAnimationsProxy(animations);
      if (animation) {
        (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.beforeAnimate) === null || _b === void 0 ? void 0 : _b.call(callbacks, animation);
        animation.finished.then(() => {
          var _a3, _b2;
          (_a3 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.afterAnimate) === null || _a3 === void 0 ? void 0 : _a3.call(callbacks, animation);
          (_b2 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.after) === null || _b2 === void 0 ? void 0 : _b2.call(callbacks);
          this.release();
        });
      } else
        (_c = callbacks === null || callbacks === void 0 ? void 0 : callbacks.after) === null || _c === void 0 ? void 0 : _c.call(callbacks);
      return animation;
    }
    /**
     * <zh/> 推断额外的动画样式
     *
     * <en/> Infer additional animation styles
     * @param context - <zh/> 动画上下文 | <en/> Animation context
     * @param options - <zh/> 扩展选项 | <en/> Extend options
     * @returns <zh/> 始态样式与终态样式 | <en/> Initial style and final style
     */
    inferStyle(context, options) {
      var _a2, _b;
      const { element, elementType, stage, originalStyle, updatedStyle = {} } = context;
      if (!context.modifiedStyle)
        context.modifiedStyle = Object.assign(Object.assign({}, originalStyle), updatedStyle);
      const { modifiedStyle } = context;
      const fromStyle = {};
      const toStyle = {};
      if (stage === "enter") {
        Object.assign(fromStyle, { opacity: 0 });
      } else if (stage === "exit") {
        Object.assign(toStyle, { opacity: 0 });
      } else if (stage === "show") {
        Object.assign(fromStyle, { opacity: 0 });
        Object.assign(toStyle, { opacity: (_a2 = getCachedStyle(element, "opacity")) !== null && _a2 !== void 0 ? _a2 : inferDefaultValue("opacity") });
      } else if (stage === "hide") {
        Object.assign(fromStyle, { opacity: (_b = getCachedStyle(element, "opacity")) !== null && _b !== void 0 ? _b : inferDefaultValue("opacity") });
        Object.assign(toStyle, { opacity: 0 });
      } else if (stage === "collapse") {
        const { collapse } = options || {};
        const { target, descendants, position: position2 } = collapse;
        if (elementType === "node") {
          if (descendants.includes(element.id)) {
            const [x3, y3, z] = position2;
            Object.assign(toStyle, { x: x3, y: y3, z });
          }
        } else if (elementType === "combo") {
          if (element.id === target || descendants.includes(element.id)) {
            const [x3, y3] = position2;
            Object.assign(toStyle, { x: x3, y: y3, childrenNode: originalStyle.childrenNode });
          }
        } else if (elementType === "edge") {
          Object.assign(toStyle, { sourceNode: modifiedStyle.sourceNode, targetNode: modifiedStyle.targetNode });
        }
      } else if (stage === "expand") {
        const { expand } = options || {};
        const { target, descendants, position: position2 } = expand;
        if (elementType === "node") {
          if (element.id === target || descendants.includes(element.id)) {
            const [x3, y3, z] = position2;
            Object.assign(fromStyle, { x: x3, y: y3, z });
          }
        } else if (elementType === "combo") {
          if (element.id === target || descendants.includes(element.id)) {
            const [x3, y3, z] = position2;
            Object.assign(fromStyle, { x: x3, y: y3, z, childrenNode: modifiedStyle.childrenNode });
          }
        } else if (elementType === "edge") {
          Object.assign(fromStyle, { sourceNode: modifiedStyle.sourceNode, targetNode: modifiedStyle.targetNode });
        }
      }
      return [
        Object.keys(fromStyle).length > 0 ? Object.assign({}, originalStyle, fromStyle) : originalStyle,
        Object.keys(toStyle).length > 0 ? Object.assign({}, modifiedStyle, toStyle) : modifiedStyle
      ];
    }
    stop() {
      this.animations.forEach((animation) => animation.cancel());
    }
    clear() {
      this.tasks = [];
    }
    /**
     * <zh/> 释放存量动画对象
     *
     * <en/> Release stock animation objects
     * @description see: https://github.com/antvis/G/issues/1731
     */
    release() {
      var _a2, _b;
      const { canvas: canvas2 } = this.context;
      const animationsWithPromises = (_b = (_a2 = canvas2.document) === null || _a2 === void 0 ? void 0 : _a2.timeline) === null || _b === void 0 ? void 0 : _b.animationsWithPromises;
      if (animationsWithPromises) {
        canvas2.document.timeline.animationsWithPromises = animationsWithPromises.filter((animation) => animation.playState !== "finished");
      }
    }
    destroy() {
      this.stop();
      this.animations.clear();
      this.tasks = [];
    }
  };

  // node_modules/@antv/g6/esm/runtime/batch.js
  var BatchController = class {
    constructor(context) {
      this.batchCount = 0;
      this.context = context;
    }
    emit(event) {
      const { graph } = this.context;
      graph.emit(event.type, event);
    }
    startBatch(initiate = true) {
      this.batchCount++;
      if (this.batchCount === 1)
        this.emit(new GraphLifeCycleEvent(GraphEvent.BATCH_START, { initiate }));
    }
    endBatch() {
      this.batchCount--;
      if (this.batchCount === 0)
        this.emit(new GraphLifeCycleEvent(GraphEvent.BATCH_END));
    }
    get isBatching() {
      return this.batchCount > 0;
    }
    destroy() {
      this.context = null;
    }
  };

  // node_modules/@antv/g6/esm/runtime/behavior.js
  var BehaviorController = class extends ExtensionController {
    constructor(context) {
      super(context);
      this.currentTarget = null;
      this.currentTargetType = null;
      this.category = "behavior";
      this.forwardCanvasEvents = (event) => {
        const { target: originalTarget } = event;
        const target = eventTargetOf(originalTarget);
        if (!target)
          return;
        const { graph, canvas: canvas2 } = this.context;
        const { type: targetType, element: targetElement } = target;
        if ("destroyed" in targetElement && (isToBeDestroyed(targetElement) || targetElement.destroyed))
          return;
        const { type, detail, button: button2 } = event;
        const stdEvent = Object.assign(Object.assign({}, event), { target: targetElement, targetType, originalTarget });
        if (type === CommonEvent.POINTER_MOVE) {
          if (this.currentTarget !== targetElement) {
            if (this.currentTarget) {
              graph.emit(`${this.currentTargetType}:${CommonEvent.POINTER_LEAVE}`, Object.assign(Object.assign({}, stdEvent), { type: CommonEvent.POINTER_LEAVE, target: this.currentTarget, targetType: this.currentTargetType }));
            }
            if (targetElement) {
              Object.assign(stdEvent, { type: CommonEvent.POINTER_ENTER });
              graph.emit(`${targetType}:${CommonEvent.POINTER_ENTER}`, stdEvent);
            }
          }
          this.currentTarget = targetElement;
          this.currentTargetType = targetType;
        }
        if (!(type === CommonEvent.CLICK && button2 === 2)) {
          graph.emit(`${targetType}:${type}`, stdEvent);
          graph.emit(type, stdEvent);
        }
        if (type === CommonEvent.CLICK && detail === 2) {
          Object.assign(stdEvent, { type: CommonEvent.DBLCLICK });
          graph.emit(`${targetType}:${CommonEvent.DBLCLICK}`, stdEvent);
          graph.emit(CommonEvent.DBLCLICK, stdEvent);
        }
        if (type === CommonEvent.POINTER_DOWN && button2 === 2) {
          Object.assign(stdEvent, {
            type: CommonEvent.CONTEXT_MENU,
            preventDefault: () => {
              var _a2;
              (_a2 = canvas2.getContainer()) === null || _a2 === void 0 ? void 0 : _a2.addEventListener(CommonEvent.CONTEXT_MENU, (e) => e.preventDefault(), {
                once: true
              });
            }
          });
          graph.emit(`${targetType}:${CommonEvent.CONTEXT_MENU}`, stdEvent);
          graph.emit(CommonEvent.CONTEXT_MENU, stdEvent);
        }
      };
      this.forwardContainerEvents = (event) => {
        this.context.graph.emit(event.type, event);
      };
      this.forwardEvents();
      this.setBehaviors(this.context.options.behaviors || []);
    }
    setBehaviors(behaviors) {
      this.setExtensions(behaviors);
    }
    forwardEvents() {
      const container = this.context.canvas.getContainer();
      if (container) {
        [ContainerEvent.KEY_DOWN, ContainerEvent.KEY_UP].forEach((name) => {
          container.addEventListener(name, this.forwardContainerEvents);
        });
      }
      const canvas2 = this.context.canvas.document;
      if (canvas2) {
        [
          CommonEvent.CLICK,
          CommonEvent.DBLCLICK,
          CommonEvent.POINTER_OVER,
          CommonEvent.POINTER_LEAVE,
          CommonEvent.POINTER_ENTER,
          CommonEvent.POINTER_MOVE,
          CommonEvent.POINTER_OUT,
          CommonEvent.POINTER_DOWN,
          CommonEvent.POINTER_UP,
          CommonEvent.CONTEXT_MENU,
          CommonEvent.DRAG_START,
          CommonEvent.DRAG,
          CommonEvent.DRAG_END,
          CommonEvent.DRAG_ENTER,
          CommonEvent.DRAG_OVER,
          CommonEvent.DRAG_LEAVE,
          CommonEvent.DROP,
          CommonEvent.WHEEL
        ].forEach((name) => {
          canvas2.addEventListener(name, this.forwardCanvasEvents);
        });
      }
    }
    destroy() {
      const container = this.context.canvas.getContainer();
      if (container) {
        [ContainerEvent.KEY_DOWN, ContainerEvent.KEY_UP].forEach((name) => {
          container.removeEventListener(name, this.forwardContainerEvents);
        });
      }
      this.context.canvas.document.removeAllEventListeners();
      super.destroy();
    }
  };

  // node_modules/@antv/g6/esm/runtime/data.js
  var import_util203 = __toESM(require_lib());

  // node_modules/@antv/g6/esm/utils/data.js
  var __rest21 = function(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  function mergeElementsData(original, modified) {
    const { data: originalData, style: originalStyle } = original, originalAttrs = __rest21(original, ["data", "style"]);
    const { data: modifiedData, style: modifiedStyle } = modified, modifiedAttrs = __rest21(modified, ["data", "style"]);
    const result = Object.assign(Object.assign({}, originalAttrs), modifiedAttrs);
    if (originalData || modifiedData) {
      Object.assign(result, { data: Object.assign(Object.assign({}, originalData), modifiedData) });
    }
    if (originalStyle || modifiedStyle) {
      Object.assign(result, { style: Object.assign(Object.assign({}, originalStyle), modifiedStyle) });
    }
    return result;
  }
  function cloneElementData(data2) {
    const { data: customData, style } = data2, restAttrs = __rest21(data2, ["data", "style"]);
    const clonedData = restAttrs;
    if (customData)
      clonedData.data = Object.assign({}, customData);
    if (style)
      clonedData.style = Object.assign({}, style);
    return clonedData;
  }
  function isElementDataEqual(original = {}, modified = {}) {
    const { states: originalStates = [], data: originalData = {}, style: originalStyle = {}, children: originalChildren = [] } = original, originalAttrs = __rest21(original, ["states", "data", "style", "children"]);
    const { states: modifiedStates = [], data: modifiedData = {}, style: modifiedStyle = {}, children: modifiedChildren = [] } = modified, modifiedAttrs = __rest21(modified, ["states", "data", "style", "children"]);
    const isArrayEqual = (arr1, arr2) => {
      if (arr1.length !== arr2.length)
        return false;
      return arr1.every((item, index2) => item === arr2[index2]);
    };
    const isObjectEqual = (obj1, obj2) => {
      const keys1 = Object.keys(obj1);
      const keys2 = Object.keys(obj2);
      if (keys1.length !== keys2.length)
        return false;
      return keys1.every((key) => obj1[key] === obj2[key]);
    };
    if (!isObjectEqual(originalAttrs, modifiedAttrs))
      return false;
    if (!isArrayEqual(originalChildren, modifiedChildren))
      return false;
    if (!isArrayEqual(originalStates, modifiedStates))
      return false;
    if (!isObjectEqual(originalData, modifiedData))
      return false;
    if (!isObjectEqual(originalStyle, modifiedStyle))
      return false;
    return true;
  }

  // node_modules/@antv/g6/esm/utils/graphlib.js
  var __rest22 = function(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  function toGraphlibData(data2) {
    const { id: id3 = idOf(data2), style, data: customData } = data2, rest = __rest22(data2, ["id", "style", "data"]);
    const _data = Object.assign(Object.assign({}, data2), { style: Object.assign({}, style), data: Object.assign({}, customData) });
    if (isEdgeData(data2))
      return Object.assign({ id: id3, data: _data }, rest);
    return { id: id3, data: _data };
  }
  function toG6Data(data2) {
    return data2.data;
  }
  function createTreeStructure(model) {
    if (model.hasTreeStructure(TREE_KEY))
      return;
    model.attachTreeStructure(TREE_KEY);
    const edges = model.getAllEdges();
    for (const edge of edges) {
      const { source, target } = edge;
      model.setParent(target, source, TREE_KEY);
    }
  }

  // node_modules/@antv/g6/esm/runtime/data.js
  var DataController = class {
    constructor() {
      this.latestRemovedComboIds = /* @__PURE__ */ new Set();
      this.comboIds = /* @__PURE__ */ new Set();
      this.changes = [];
      this.batchCount = 0;
      this.isTraceless = false;
      this.enableUpdateNodeLikeHierarchy = true;
      this.model = new Graph2();
    }
    pushChange(change) {
      if (this.isTraceless)
        return;
      const { type } = change;
      if (type === ChangeType.NodeUpdated || type === ChangeType.EdgeUpdated || type === ChangeType.ComboUpdated) {
        const { value, original } = change;
        this.changes.push({ value: cloneElementData(value), original: cloneElementData(original), type });
      } else {
        this.changes.push({ value: cloneElementData(change.value), type });
      }
    }
    getChanges() {
      return this.changes;
    }
    clearChanges() {
      this.changes = [];
    }
    batch(callback) {
      this.batchCount++;
      this.model.batch(callback);
      this.batchCount--;
    }
    isBatching() {
      return this.batchCount > 0;
    }
    /**
     * <zh/> 执行操作而不会留下记录
     *
     * <en/> Perform operations without leaving records
     * @param callback - <zh/> 回调函数 | <en/> callback function
     * @remarks
     * <zh/> 通常用于运行时调整元素并同步数据，避免触发数据变更导致重绘
     *
     * <en/> Usually used to adjust elements at runtime and synchronize data to avoid triggering data changes and causing redraws
     */
    silence(callback) {
      this.isTraceless = true;
      callback();
      this.isTraceless = false;
    }
    isCombo(id3) {
      return this.comboIds.has(id3) || this.latestRemovedComboIds.has(id3);
    }
    getData() {
      return {
        nodes: this.getNodeData(),
        edges: this.getEdgeData(),
        combos: this.getComboData()
      };
    }
    getNodeData(ids) {
      return this.model.getAllNodes().reduce((acc, node) => {
        const data2 = toG6Data(node);
        if (this.isCombo(idOf(data2)))
          return acc;
        if (ids === void 0)
          acc.push(data2);
        else
          ids.includes(idOf(data2)) && acc.push(data2);
        return acc;
      }, []);
    }
    getEdgeDatum(id3) {
      return toG6Data(this.model.getEdge(id3));
    }
    getEdgeData(ids) {
      return this.model.getAllEdges().reduce((acc, edge) => {
        const data2 = toG6Data(edge);
        if (ids === void 0)
          acc.push(data2);
        else
          ids.includes(idOf(data2)) && acc.push(data2);
        return acc;
      }, []);
    }
    getComboData(ids) {
      return this.model.getAllNodes().reduce((acc, combo) => {
        const data2 = toG6Data(combo);
        if (!this.isCombo(idOf(data2)))
          return acc;
        if (ids === void 0)
          acc.push(data2);
        else
          ids.includes(idOf(data2)) && acc.push(data2);
        return acc;
      }, []);
    }
    getRootsData(hierarchyKey = TREE_KEY) {
      return this.model.getRoots(hierarchyKey).map(toG6Data);
    }
    getAncestorsData(id3, hierarchyKey) {
      const { model } = this;
      if (!model.hasNode(id3) || !model.hasTreeStructure(hierarchyKey))
        return [];
      return model.getAncestors(id3, hierarchyKey).map(toG6Data);
    }
    getDescendantsData(id3) {
      const root2 = this.getElementDataById(id3);
      const data2 = [];
      dfs(root2, (node) => {
        if (node !== root2)
          data2.push(node);
      }, (node) => this.getChildrenData(idOf(node)), "TB");
      return data2;
    }
    getParentData(id3, hierarchyKey) {
      const { model } = this;
      if (!hierarchyKey) {
        print.warn("The hierarchy structure key is not specified");
        return void 0;
      }
      if (!model.hasNode(id3) || !model.hasTreeStructure(hierarchyKey))
        return void 0;
      const parent = model.getParent(id3, hierarchyKey);
      return parent ? toG6Data(parent) : void 0;
    }
    getChildrenData(id3) {
      const structureKey = this.getElementType(id3) === "node" ? TREE_KEY : COMBO_KEY;
      const { model } = this;
      if (!model.hasNode(id3) || !model.hasTreeStructure(structureKey))
        return [];
      return model.getChildren(id3, structureKey).map(toG6Data);
    }
    /**
     * <zh/> 获取指定类型元素的数据
     *
     * <en/> Get the data of the specified type of element
     * @param elementType - <zh/> 元素类型 | <en/> element type
     * @returns <zh/> 元素数据 | <en/> element data
     */
    getElementsDataByType(elementType) {
      if (elementType === "node")
        return this.getNodeData();
      if (elementType === "edge")
        return this.getEdgeData();
      if (elementType === "combo")
        return this.getComboData();
      return [];
    }
    /**
     * <zh/> 根据 ID 获取元素的数据，不用关心元素的类型
     *
     * <en/> Get the data of the element by ID, no need to care about the type of the element
     * @param id - <zh/> 元素 ID 数组 | <en/> element ID array
     * @returns <zh/> 元素数据 | <en/> data of the element
     */
    getElementDataById(id3) {
      const type = this.getElementType(id3);
      if (type === "edge")
        return this.getEdgeDatum(id3);
      return this.getNodeLikeDatum(id3);
    }
    /**
     * <zh/> 获取节点的数据
     *
     * <en/> Get node data
     * @param id - <zh/> 节点 ID | <en/> node ID
     * @returns <zh/> 节点数据 | <en/> node data
     */
    getNodeLikeDatum(id3) {
      const data2 = this.model.getNode(id3);
      return toG6Data(data2);
    }
    /**
     * <zh/> 获取所有节点和 combo 的数据
     *
     * <en/> Get all node and combo data
     * @param ids - <zh/> 节点和 combo ID 数组 | <en/> node and combo ID array
     * @returns <zh/> 节点和 combo 的数据 | <en/> node and combo data
     */
    getNodeLikeData(ids) {
      return this.model.getAllNodes().reduce((acc, node) => {
        const data2 = toG6Data(node);
        if (ids)
          ids.includes(idOf(data2)) && acc.push(data2);
        else
          acc.push(data2);
        return acc;
      }, []);
    }
    getElementDataByState(elementType, state) {
      const elementData = this.getElementsDataByType(elementType);
      return elementData.filter((datum) => {
        var _a2;
        return (_a2 = datum.states) === null || _a2 === void 0 ? void 0 : _a2.includes(state);
      });
    }
    getElementState(id3) {
      var _a2;
      return ((_a2 = this.getElementDataById(id3)) === null || _a2 === void 0 ? void 0 : _a2.states) || [];
    }
    hasNode(id3) {
      return this.model.hasNode(id3) && !this.isCombo(id3);
    }
    hasEdge(id3) {
      return this.model.hasEdge(id3);
    }
    hasCombo(id3) {
      return this.model.hasNode(id3) && this.isCombo(id3);
    }
    getRelatedEdgesData(id3, direction2 = "both") {
      return this.model.getRelatedEdges(id3, direction2).map(toG6Data);
    }
    getNeighborNodesData(id3) {
      return this.model.getNeighbors(id3).map(toG6Data);
    }
    setData(data2) {
      const { nodes: modifiedNodes = [], edges: modifiedEdges = [], combos: modifiedCombos = [] } = data2;
      const { nodes: originalNodes, edges: originalEdges, combos: originalCombos } = this.getData();
      const nodeDiff = arrayDiff(originalNodes, modifiedNodes, (node) => idOf(node), isElementDataEqual);
      const edgeDiff = arrayDiff(originalEdges, modifiedEdges, (edge) => idOf(edge), isElementDataEqual);
      const comboDiff = arrayDiff(originalCombos, modifiedCombos, (combo) => idOf(combo), isElementDataEqual);
      this.batch(() => {
        const dataToAdd = {
          nodes: nodeDiff.enter,
          edges: edgeDiff.enter,
          combos: comboDiff.enter
        };
        this.addData(dataToAdd);
        this.computeZIndex(dataToAdd, "add", true);
        const dataToUpdate = {
          nodes: nodeDiff.update,
          edges: edgeDiff.update,
          combos: comboDiff.update
        };
        this.updateData(dataToUpdate);
        this.computeZIndex(dataToUpdate, "update", true);
        const dataToRemove = {
          nodes: nodeDiff.exit.map(idOf),
          edges: edgeDiff.exit.map(idOf),
          combos: comboDiff.exit.map(idOf)
        };
        this.removeData(dataToRemove);
      });
    }
    addData(data2) {
      const { nodes, edges, combos } = data2;
      this.batch(() => {
        this.addComboData(combos);
        this.addNodeData(nodes);
        this.addEdgeData(edges);
      });
      this.computeZIndex(data2, "add");
    }
    addNodeData(nodes = []) {
      if (!nodes.length)
        return;
      this.model.addNodes(nodes.map((node) => {
        this.pushChange({ value: node, type: ChangeType.NodeAdded });
        return toGraphlibData(node);
      }));
      this.updateNodeLikeHierarchy(nodes);
      this.computeZIndex({ nodes }, "add");
    }
    addEdgeData(edges = []) {
      if (!edges.length)
        return;
      this.model.addEdges(edges.map((edge) => {
        this.pushChange({ value: edge, type: ChangeType.EdgeAdded });
        return toGraphlibData(edge);
      }));
      this.computeZIndex({ edges }, "add");
    }
    addComboData(combos = []) {
      if (!combos.length)
        return;
      const { model } = this;
      if (!model.hasTreeStructure(COMBO_KEY)) {
        model.attachTreeStructure(COMBO_KEY);
      }
      model.addNodes(combos.map((combo) => {
        this.comboIds.add(idOf(combo));
        this.pushChange({ value: combo, type: ChangeType.ComboAdded });
        return toGraphlibData(combo);
      }));
      this.updateNodeLikeHierarchy(combos);
      this.computeZIndex({ combos }, "add");
    }
    addChildrenData(parentId, childrenData) {
      const parentData = this.getNodeLikeDatum(parentId);
      const childrenId = childrenData.map(idOf);
      this.addNodeData(childrenData);
      this.updateNodeData([{ id: parentId, children: [...parentData.children || [], ...childrenId] }]);
      this.addEdgeData(childrenId.map((childId) => ({ source: parentId, target: childId })));
    }
    /**
     * <zh/> 计算 zIndex
     *
     * <en/> Calculate zIndex
     * @param data - <zh/> 新增的数据 | <en/> newly added data
     * @param type - <zh/> 操作类型 | <en/> operation type
     * @param force - <zh/> 忽略批处理 | <en/> ignore batch processing
     * @remarks
     * <zh/> 调用该函数的情况：
     * - 新增元素
     * - 更新节点/组合的 combo
     * - 更新节点的 children
     *
     * <en/> The situation of calling this function:
     * - Add element
     * - Update the combo of the node/combo
     * - Update the children of the node
     */
    computeZIndex(data2, type, force = false) {
      if (!force && this.isBatching())
        return;
      this.batch(() => {
        const { nodes = [], edges = [], combos = [] } = data2;
        combos.forEach((combo) => {
          var _a2, _b, _c;
          const id3 = idOf(combo);
          if (type === "add" && (0, import_util203.isNumber)((_a2 = combo.style) === null || _a2 === void 0 ? void 0 : _a2.zIndex))
            return;
          if (type === "update" && !("combo" in combo))
            return;
          const parent = this.getParentData(id3, COMBO_KEY);
          const zIndex = parent ? ((_c = (_b = parent.style) === null || _b === void 0 ? void 0 : _b.zIndex) !== null && _c !== void 0 ? _c : 0) + 1 : 0;
          this.preventUpdateNodeLikeHierarchy(() => {
            this.updateComboData([{ id: id3, style: { zIndex } }]);
          });
        });
        nodes.forEach((node) => {
          var _a2, _b, _c;
          const id3 = idOf(node);
          if (type === "add" && (0, import_util203.isNumber)((_a2 = node.style) === null || _a2 === void 0 ? void 0 : _a2.zIndex))
            return;
          if (type === "update" && !("combo" in node) && !("children" in node))
            return;
          let zIndex = 0;
          const comboParent = this.getParentData(id3, COMBO_KEY);
          if (comboParent) {
            zIndex = (((_b = comboParent.style) === null || _b === void 0 ? void 0 : _b.zIndex) || 0) + 1;
          } else {
            const nodeParent = this.getParentData(id3, TREE_KEY);
            if (nodeParent)
              zIndex = ((_c = nodeParent === null || nodeParent === void 0 ? void 0 : nodeParent.style) === null || _c === void 0 ? void 0 : _c.zIndex) || 0;
          }
          this.preventUpdateNodeLikeHierarchy(() => {
            this.updateNodeData([{ id: id3, style: { zIndex } }]);
          });
        });
        edges.forEach((edge) => {
          var _a2, _b, _c, _d, _e;
          if ((0, import_util203.isNumber)((_a2 = edge.style) === null || _a2 === void 0 ? void 0 : _a2.zIndex))
            return;
          let { id: id3, source, target } = edge;
          if (!id3)
            id3 = idOf(edge);
          else {
            const datum = this.getEdgeDatum(id3);
            source = datum.source;
            target = datum.target;
          }
          if (!source || !target)
            return;
          const sourceZIndex = ((_c = (_b = this.getNodeLikeDatum(source)) === null || _b === void 0 ? void 0 : _b.style) === null || _c === void 0 ? void 0 : _c.zIndex) || 0;
          const targetZIndex = ((_e = (_d = this.getNodeLikeDatum(target)) === null || _d === void 0 ? void 0 : _d.style) === null || _e === void 0 ? void 0 : _e.zIndex) || 0;
          this.updateEdgeData([{ id: idOf(edge), style: { zIndex: Math.max(sourceZIndex, targetZIndex) - 1 } }]);
        });
      });
    }
    /**
     * <zh/> 计算元素置顶后的 zIndex
     *
     * <en/> Calculate the zIndex after the element is placed on top
     * @param id - <zh/> 元素 ID | <en/> ID of the element
     * @returns <zh/> zIndex | <en/> zIndex
     */
    getFrontZIndex(id3) {
      var _a2;
      const elementType = this.getElementType(id3);
      const elementData = this.getElementDataById(id3);
      const data2 = this.getData();
      Object.assign(data2, {
        [`${elementType}s`]: data2[`${elementType}s`].filter((element) => idOf(element) !== id3)
      });
      if (elementType === "combo") {
        if (!isCollapsed(elementData)) {
          const ancestorIds = new Set(this.getAncestorsData(id3, COMBO_KEY).map(idOf));
          data2.nodes = data2.nodes.filter((element) => !ancestorIds.has(idOf(element)));
          data2.combos = data2.combos.filter((element) => !ancestorIds.has(idOf(element)));
          data2.edges = data2.edges.filter(({ source, target }) => !ancestorIds.has(source) && !ancestorIds.has(target));
        }
      }
      return Math.max(((_a2 = elementData.style) === null || _a2 === void 0 ? void 0 : _a2.zIndex) || 0, 0, ...Object.values(data2).flat().map((datum) => {
        var _a3;
        return (((_a3 = datum === null || datum === void 0 ? void 0 : datum.style) === null || _a3 === void 0 ? void 0 : _a3.zIndex) || 0) + 1;
      }));
    }
    updateNodeLikeHierarchy(data2) {
      if (!this.enableUpdateNodeLikeHierarchy)
        return;
      const { model } = this;
      data2.forEach((datum) => {
        const id3 = idOf(datum);
        const parent = parentIdOf(datum);
        if (parent !== void 0) {
          if (!model.hasTreeStructure(COMBO_KEY))
            model.attachTreeStructure(COMBO_KEY);
          if (parent === null) {
            this.refreshComboData(id3);
          }
          this.setParent(id3, parentIdOf(datum), COMBO_KEY);
        }
        const children = datum.children || [];
        if (children.length) {
          if (!model.hasTreeStructure(TREE_KEY))
            model.attachTreeStructure(TREE_KEY);
          const _children = children.filter((child) => model.hasNode(child));
          _children.forEach((child) => this.setParent(child, id3, TREE_KEY));
          if (_children.length !== children.length) {
            this.updateNodeData([{ id: id3, children: _children }]);
          }
        }
      });
    }
    /**
     * <zh/> 执行变更时不要更新节点层次结构
     *
     * <en/> Do not update the node hierarchy when executing changes
     * @param callback - <zh/> 变更函数 | <en/> change function
     */
    preventUpdateNodeLikeHierarchy(callback) {
      this.enableUpdateNodeLikeHierarchy = false;
      callback();
      this.enableUpdateNodeLikeHierarchy = true;
    }
    updateData(data2) {
      const { nodes, edges, combos } = data2;
      this.batch(() => {
        this.updateNodeData(nodes);
        this.updateComboData(combos);
        this.updateEdgeData(edges);
      });
      this.computeZIndex(data2, "update");
    }
    updateNodeData(nodes = []) {
      if (!nodes.length)
        return;
      const { model } = this;
      this.batch(() => {
        const modifiedNodes = [];
        nodes.forEach((modifiedNode) => {
          const id3 = idOf(modifiedNode);
          const originalNode = toG6Data(model.getNode(id3));
          if (isElementDataEqual(originalNode, modifiedNode))
            return;
          const value = mergeElementsData(originalNode, modifiedNode);
          this.pushChange({ value, original: originalNode, type: ChangeType.NodeUpdated });
          model.mergeNodeData(id3, value);
          modifiedNodes.push(value);
        });
        this.updateNodeLikeHierarchy(modifiedNodes);
      });
      this.computeZIndex({ nodes }, "update");
    }
    /**
     * <zh/> 将所有数据提交到变更记录中以进行重绘
     *
     * <en/> Submit all data to the change record for redrawing
     */
    refreshData() {
      const { nodes, edges, combos } = this.getData();
      nodes.forEach((node) => {
        this.pushChange({ value: node, original: node, type: ChangeType.NodeUpdated });
      });
      edges.forEach((edge) => {
        this.pushChange({ value: edge, original: edge, type: ChangeType.EdgeUpdated });
      });
      combos.forEach((combo) => {
        this.pushChange({ value: combo, original: combo, type: ChangeType.ComboUpdated });
      });
    }
    syncNodeLikeDatum(datum) {
      const { model } = this;
      const id3 = idOf(datum);
      if (!model.hasNode(id3))
        return;
      const original = toG6Data(model.getNode(id3));
      const value = mergeElementsData(original, datum);
      model.mergeNodeData(id3, value);
    }
    syncEdgeDatum(datum) {
      const { model } = this;
      const id3 = idOf(datum);
      if (!model.hasEdge(id3))
        return;
      const original = toG6Data(model.getEdge(id3));
      const value = mergeElementsData(original, datum);
      model.mergeEdgeData(id3, value);
    }
    updateEdgeData(edges = []) {
      if (!edges.length)
        return;
      const { model } = this;
      this.batch(() => {
        edges.forEach((modifiedEdge) => {
          const id3 = idOf(modifiedEdge);
          const originalEdge = toG6Data(model.getEdge(id3));
          if (isElementDataEqual(originalEdge, modifiedEdge))
            return;
          if (modifiedEdge.source && originalEdge.source !== modifiedEdge.source) {
            model.updateEdgeSource(id3, modifiedEdge.source);
          }
          if (modifiedEdge.target && originalEdge.target !== modifiedEdge.target) {
            model.updateEdgeTarget(id3, modifiedEdge.target);
          }
          const updatedData = mergeElementsData(originalEdge, modifiedEdge);
          this.pushChange({ value: updatedData, original: originalEdge, type: ChangeType.EdgeUpdated });
          model.mergeEdgeData(id3, updatedData);
        });
      });
      this.computeZIndex({ edges }, "update");
    }
    updateComboData(combos = []) {
      if (!combos.length)
        return;
      const { model } = this;
      model.batch(() => {
        const modifiedCombos = [];
        combos.forEach((modifiedCombo) => {
          const id3 = idOf(modifiedCombo);
          const originalCombo = toG6Data(model.getNode(id3));
          if (isElementDataEqual(originalCombo, modifiedCombo))
            return;
          const value = mergeElementsData(originalCombo, modifiedCombo);
          this.pushChange({ value, original: originalCombo, type: ChangeType.ComboUpdated });
          model.mergeNodeData(id3, value);
          modifiedCombos.push(value);
        });
        this.updateNodeLikeHierarchy(modifiedCombos);
      });
      this.computeZIndex({ combos }, "update");
    }
    /**
     * <zh/> 设置节点的父节点
     *
     * <en/> Set the parent node of the node
     * @param id - <zh/> 节点 ID | <en/> node ID
     * @param parent - <zh/> 父节点 ID | <en/> parent node ID
     * @param hierarchyKey - <zh/> 层次结构类型 | <en/> hierarchy type
     * @param update - <zh/> 添加新/旧父节点数据更新记录 | <en/> add new/old parent node data update record
     */
    setParent(id3, parent, hierarchyKey, update = true) {
      if (id3 === parent)
        return;
      const elementData = this.getNodeLikeDatum(id3);
      const originalParentId = parentIdOf(elementData);
      if (originalParentId !== parent && hierarchyKey === COMBO_KEY) {
        const modifiedDatum = { id: id3, combo: parent };
        if (this.isCombo(id3))
          this.syncNodeLikeDatum(modifiedDatum);
        else
          this.syncNodeLikeDatum(modifiedDatum);
      }
      this.model.setParent(id3, parent, hierarchyKey);
      if (update && hierarchyKey === COMBO_KEY) {
        (0, import_util203.uniq)([originalParentId, parent]).forEach((pId) => {
          if (pId !== void 0)
            this.refreshComboData(pId);
        });
      }
    }
    /**
     * <zh/> 刷新 combo 数据
     *
     * <en/> Refresh combo data
     * @param id - <zh/> combo ID | <en/> combo ID
     * @remarks
     * <zh/> 不会更改数据，但会触发数据变更事件
     *
     * <en/> Will not change the data, but will trigger data change events
     */
    refreshComboData(id3) {
      const combo = this.getComboData([id3])[0];
      const ancestors = this.getAncestorsData(id3, COMBO_KEY);
      if (combo)
        this.pushChange({ value: combo, original: combo, type: ChangeType.ComboUpdated });
      ancestors.forEach((value) => {
        this.pushChange({ value, original: value, type: ChangeType.ComboUpdated });
      });
    }
    getElementPosition(id3) {
      const datum = this.getElementDataById(id3);
      return positionOf(datum);
    }
    translateNodeLikeBy(id3, offset) {
      if (this.isCombo(id3))
        this.translateComboBy(id3, offset);
      else
        this.translateNodeBy(id3, offset);
    }
    translateNodeLikeTo(id3, position2) {
      if (this.isCombo(id3))
        this.translateComboTo(id3, position2);
      else
        this.translateNodeTo(id3, position2);
    }
    translateNodeBy(id3, offset) {
      const curr = this.getElementPosition(id3);
      const position2 = add(curr, [...offset, 0].slice(0, 3));
      this.translateNodeTo(id3, position2);
    }
    translateNodeTo(id3, position2) {
      const [x3 = 0, y3 = 0, z = 0] = position2;
      this.preventUpdateNodeLikeHierarchy(() => {
        this.updateNodeData([{ id: id3, style: { x: x3, y: y3, z } }]);
      });
    }
    translateComboBy(id3, offset) {
      const [dx = 0, dy = 0, dz = 0] = offset;
      if ([dx, dy, dz].some(isNaN) || [dx, dy, dz].every((o) => o === 0))
        return;
      const combo = this.getComboData([id3])[0];
      if (!combo)
        return;
      const seenNodeLikeIds = /* @__PURE__ */ new Set();
      dfs(combo, (succeed) => {
        const succeedID = idOf(succeed);
        if (seenNodeLikeIds.has(succeedID))
          return;
        seenNodeLikeIds.add(succeedID);
        const [x3, y3, z] = positionOf(succeed);
        const value = mergeElementsData(succeed, {
          style: { x: x3 + dx, y: y3 + dy, z: z + dz }
        });
        this.pushChange({
          value,
          // @ts-ignore
          original: succeed,
          type: this.isCombo(succeedID) ? ChangeType.ComboUpdated : ChangeType.NodeUpdated
        });
        this.model.mergeNodeData(succeedID, value);
      }, (node) => this.getChildrenData(idOf(node)), "BT");
    }
    translateComboTo(id3, position2) {
      var _a2;
      if (position2.some(isNaN))
        return;
      const [tx = 0, ty = 0, tz = 0] = position2;
      const combo = (_a2 = this.getComboData([id3])) === null || _a2 === void 0 ? void 0 : _a2[0];
      if (!combo)
        return;
      const [comboX, comboY, comboZ] = positionOf(combo);
      const dx = tx - comboX;
      const dy = ty - comboY;
      const dz = tz - comboZ;
      dfs(combo, (succeed) => {
        const succeedId = idOf(succeed);
        const [x3, y3, z] = positionOf(succeed);
        const value = mergeElementsData(succeed, {
          style: { x: x3 + dx, y: y3 + dy, z: z + dz }
        });
        this.pushChange({
          value,
          // @ts-ignore
          original: succeed,
          type: this.isCombo(succeedId) ? ChangeType.ComboUpdated : ChangeType.NodeUpdated
        });
        this.model.mergeNodeData(succeedId, value);
      }, (node) => this.getChildrenData(idOf(node)), "BT");
    }
    removeData(data2) {
      const { nodes, edges, combos } = data2;
      this.batch(() => {
        this.removeEdgeData(edges);
        this.removeNodeData(nodes);
        this.removeComboData(combos);
        this.latestRemovedComboIds = new Set(combos);
      });
    }
    removeNodeData(ids = []) {
      if (!ids.length)
        return;
      this.batch(() => {
        ids.forEach((id3) => {
          this.removeEdgeData(this.getRelatedEdgesData(id3).map(idOf));
          this.pushChange({ value: this.getNodeData([id3])[0], type: ChangeType.NodeRemoved });
          this.removeNodeLikeHierarchy(id3);
        });
        this.model.removeNodes(ids);
      });
    }
    removeEdgeData(ids = []) {
      if (!ids.length)
        return;
      ids.forEach((id3) => this.pushChange({ value: this.getEdgeData([id3])[0], type: ChangeType.EdgeRemoved }));
      this.model.removeEdges(ids);
    }
    removeComboData(ids = []) {
      if (!ids.length)
        return;
      this.batch(() => {
        ids.forEach((id3) => {
          this.pushChange({ value: this.getComboData([id3])[0], type: ChangeType.ComboRemoved });
          this.removeNodeLikeHierarchy(id3);
          this.comboIds.delete(id3);
        });
        this.model.removeNodes(ids);
      });
    }
    /**
     * <zh/> 移除节点层次结构，将其子节点移动到父节点的 children 列表中
     *
     * <en/> Remove the node hierarchy and move its child nodes to the parent node's children list
     * @param id - <zh/> 待处理的节点 | <en/> node to be processed
     */
    removeNodeLikeHierarchy(id3) {
      if (this.model.hasTreeStructure(COMBO_KEY)) {
        const grandParent = parentIdOf(this.getNodeLikeDatum(id3));
        this.setParent(id3, void 0, COMBO_KEY, false);
        this.model.getChildren(id3, COMBO_KEY).forEach((child) => {
          const childData = toG6Data(child);
          const childId = idOf(childData);
          this.setParent(idOf(childData), grandParent, COMBO_KEY, false);
          const value = mergeElementsData(childData, {
            id: idOf(childData),
            combo: grandParent
          });
          this.pushChange({
            value,
            original: childData,
            type: this.isCombo(childId) ? ChangeType.ComboUpdated : ChangeType.NodeUpdated
          });
          this.model.mergeNodeData(idOf(childData), value);
        });
        if (!(0, import_util203.isNil)(grandParent))
          this.refreshComboData(grandParent);
      }
    }
    /**
     * <zh/> 获取元素的类型
     *
     * <en/> Get the type of the element
     * @param id - <zh/> 元素 ID | <en/> ID of the element
     * @returns <zh/> 元素类型 | <en/> type of the element
     */
    getElementType(id3) {
      if (this.model.hasNode(id3)) {
        if (this.isCombo(id3))
          return "combo";
        return "node";
      }
      if (this.model.hasEdge(id3))
        return "edge";
      throw new Error(format(`Unknown element type of id: ${id3}`));
    }
    destroy() {
      const { model } = this;
      const nodes = model.getAllNodes();
      const edges = model.getAllEdges();
      model.removeEdges(edges.map((edge) => edge.id));
      model.removeNodes(nodes.map((node) => node.id));
      this.context = {};
    }
  };

  // node_modules/@antv/g6/esm/runtime/element.js
  var import_util204 = __toESM(require_lib());
  var __awaiter24 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var ElementController = class {
    constructor(context) {
      this.elementMap = {};
      this.shapeTypeMap = {};
      this.paletteStyle = {};
      this.defaultStyle = {};
      this.stateStyle = {};
      this.visibilityCache = /* @__PURE__ */ new WeakMap();
      this.context = context;
    }
    init() {
      this.initContainer();
    }
    initContainer() {
      if (!this.container || this.container.destroyed) {
        const { canvas: canvas2 } = this.context;
        this.container = canvas2.appendChild(new Group({ className: "elements" }));
      }
    }
    emit(event, context) {
      if (context.silence)
        return;
      emit(this.context.graph, event);
    }
    forEachElementData(callback) {
      ELEMENT_TYPES.forEach((elementType) => {
        const elementData = this.context.model.getElementsDataByType(elementType);
        callback(elementType, elementData);
      });
    }
    getElementType(elementType, datum) {
      var _a2;
      const { options, graph } = this.context;
      const userDefinedType = ((_a2 = options[elementType]) === null || _a2 === void 0 ? void 0 : _a2.type) || datum.type;
      if (!userDefinedType) {
        if (elementType === "edge")
          return "line";
        else
          return "circle";
      }
      if (typeof userDefinedType === "string")
        return userDefinedType;
      return userDefinedType.call(graph, datum);
    }
    getTheme(elementType) {
      return themeOf(this.context.options)[elementType] || {};
    }
    getThemeStyle(elementType) {
      return this.getTheme(elementType).style || {};
    }
    getThemeStateStyle(elementType, states) {
      const { state = {} } = this.getTheme(elementType);
      return Object.assign({}, ...states.map((name) => state[name] || {}));
    }
    computePaletteStyle() {
      const { options } = this.context;
      this.paletteStyle = {};
      this.forEachElementData((elementType, elementData) => {
        var _a2, _b;
        const palette = Object.assign({}, parsePalette((_a2 = this.getTheme(elementType)) === null || _a2 === void 0 ? void 0 : _a2.palette), parsePalette((_b = options[elementType]) === null || _b === void 0 ? void 0 : _b.palette));
        if (palette === null || palette === void 0 ? void 0 : palette.field) {
          Object.assign(this.paletteStyle, assignColorByPalette(elementData, palette));
        }
      });
    }
    getPaletteStyle(elementType, id3) {
      const color2 = this.paletteStyle[id3];
      if (!color2)
        return {};
      if (elementType === "edge")
        return { stroke: color2 };
      return { fill: color2 };
    }
    /**
     * <zh/> 计算单个元素的默认样式
     *
     * <en/> compute default style of single element
     */
    computeElementDefaultStyle(elementType, context) {
      var _a2;
      const { options } = this.context;
      const defaultStyle = ((_a2 = options[elementType]) === null || _a2 === void 0 ? void 0 : _a2.style) || {};
      if ("transform" in defaultStyle && Array.isArray(defaultStyle.transform)) {
        defaultStyle.transform = [...defaultStyle.transform];
      }
      this.defaultStyle[idOf(context.datum)] = computeElementCallbackStyle(defaultStyle, context);
    }
    computeElementsDefaultStyle(ids) {
      const { graph } = this.context;
      this.forEachElementData((elementType, elementData) => {
        const length = elementData.length;
        for (let i = 0; i < length; i++) {
          const datum = elementData[i];
          if (ids === void 0 || ids.includes(idOf(datum))) {
            this.computeElementDefaultStyle(elementType, { datum, graph });
          }
        }
      });
    }
    getDefaultStyle(id3) {
      return this.defaultStyle[id3] || {};
    }
    getElementState(id3) {
      try {
        const { model } = this.context;
        return model.getElementState(id3);
      } catch (_a2) {
        return [];
      }
    }
    /**
     * <zh/> 获取单个元素的单个状态的样式
     *
     * <en/> get single state style of single element
     */
    getElementStateStyle(elementType, state, context) {
      var _a2, _b;
      const { options } = this.context;
      const stateStyle = ((_b = (_a2 = options[elementType]) === null || _a2 === void 0 ? void 0 : _a2.state) === null || _b === void 0 ? void 0 : _b[state]) || {};
      return computeElementCallbackStyle(stateStyle, context);
    }
    /**
     * <zh/> 计算单个元素的合并状态样式
     *
     * <en/> compute merged state style of single element
     */
    computeElementStatesStyle(elementType, states, context) {
      this.stateStyle[idOf(context.datum)] = Object.assign({}, ...states.map((state) => this.getElementStateStyle(elementType, state, context)));
    }
    /**
     * <zh/> 计算全部元素的状态样式
     *
     * <en/> compute state style of all elements
     * @param ids - <zh/> 计算指定元素的状态样式 | <en/> compute state style of specified elements
     */
    computeElementsStatesStyle(ids) {
      const { graph } = this.context;
      this.forEachElementData((elementType, elementData) => {
        const length = elementData.length;
        for (let i = 0; i < length; i++) {
          const datum = elementData[i];
          if (ids === void 0 || ids.includes(idOf(datum))) {
            const states = this.getElementState(idOf(datum));
            this.computeElementStatesStyle(elementType, states, { datum, graph });
          }
        }
      });
    }
    getStateStyle(id3) {
      return this.stateStyle[id3] || {};
    }
    computeStyle(stage, ids) {
      const skip = ["translate", "zIndex"];
      if (stage && skip.includes(stage))
        return;
      this.computePaletteStyle();
      this.computeElementsDefaultStyle(ids);
      this.computeElementsStatesStyle(ids);
    }
    getElement(id3) {
      return this.elementMap[id3];
    }
    getNodes() {
      return this.context.model.getNodeData().map(({ id: id3 }) => this.elementMap[id3]);
    }
    getEdges() {
      return this.context.model.getEdgeData().map((edge) => this.elementMap[idOf(edge)]);
    }
    getCombos() {
      return this.context.model.getComboData().map(({ id: id3 }) => this.elementMap[id3]);
    }
    getElementComputedStyle(elementType, datum) {
      const id3 = idOf(datum);
      const themeStyle = this.getThemeStyle(elementType);
      const paletteStyle = this.getPaletteStyle(elementType, id3);
      const dataStyle = datum.style || {};
      const defaultStyle = this.getDefaultStyle(id3);
      const themeStateStyle = this.getThemeStateStyle(elementType, this.getElementState(id3));
      const stateStyle = this.getStateStyle(id3);
      const style = Object.assign({}, themeStyle, paletteStyle, dataStyle, defaultStyle, themeStateStyle, stateStyle);
      if (elementType === "combo") {
        const childrenData = this.context.model.getChildrenData(id3);
        const isCollapsed2 = !!style.collapsed;
        const childrenNode = isCollapsed2 ? [] : childrenData.map(idOf).filter((id4) => this.getElement(id4));
        Object.assign(style, { childrenNode, childrenData });
      }
      return style;
    }
    getDrawData(context) {
      this.init();
      const data2 = this.computeChangesAndDrawData(context);
      if (!data2)
        return null;
      const { type = "draw", stage = type } = context;
      this.markDestroyElement(data2.drawData);
      this.computeStyle(stage);
      return { type, stage, data: data2 };
    }
    /**
     * <zh/> 开始绘制流程
     *
     * <en/> start render process
     */
    draw(context = { animation: true }) {
      const drawData = this.getDrawData(context);
      if (!drawData)
        return;
      const { data: { drawData: { add: add5, update, remove } } } = drawData;
      this.destroyElements(remove, context);
      this.createElements(add5, context);
      this.updateElements(update, context);
      return this.setAnimationTask(context, drawData);
    }
    preLayoutDraw() {
      return __awaiter24(this, arguments, void 0, function* (context = { animation: true }) {
        var _a2, _b;
        const preResult = this.getDrawData(context);
        if (!preResult)
          return;
        const { data: { drawData } } = preResult;
        yield (_b = (_a2 = this.context.layout) === null || _a2 === void 0 ? void 0 : _a2.preLayout) === null || _b === void 0 ? void 0 : _b.call(_a2, drawData);
        const { add: add5, update, remove } = drawData;
        this.destroyElements(remove, context);
        this.createElements(add5, context);
        this.updateElements(update, context);
        return this.setAnimationTask(context, preResult);
      });
    }
    setAnimationTask(context, data2) {
      const { animation, silence } = context;
      const { data: { dataChanges, drawData }, stage, type } = data2;
      return this.context.animation.animate(animation, silence ? {} : {
        before: () => this.emit(new GraphLifeCycleEvent(GraphEvent.BEFORE_DRAW, {
          dataChanges,
          animation,
          stage,
          render: type === "render"
        }), context),
        beforeAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.DRAW, animation2, drawData), context),
        afterAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.DRAW, animation2, drawData), context),
        after: () => this.emit(new GraphLifeCycleEvent(GraphEvent.AFTER_DRAW, {
          dataChanges,
          animation,
          stage,
          render: type === "render",
          firstRender: this.context.graph.rendered === false
        }), context)
      });
    }
    computeChangesAndDrawData(context) {
      const { model } = this.context;
      const dataChanges = model.getChanges();
      const tasks2 = reduceDataChanges(dataChanges);
      if (tasks2.length === 0)
        return null;
      const { NodeAdded = [], NodeUpdated = [], NodeRemoved = [], EdgeAdded = [], EdgeUpdated = [], EdgeRemoved = [], ComboAdded = [], ComboUpdated = [], ComboRemoved = [] } = (0, import_util204.groupBy)(tasks2, (change) => change.type);
      const dataOf = (data2) => new Map(data2.map((datum) => {
        const data3 = datum.value;
        return [idOf(data3), data3];
      }));
      const input = {
        add: {
          nodes: dataOf(NodeAdded),
          edges: dataOf(EdgeAdded),
          combos: dataOf(ComboAdded)
        },
        update: {
          nodes: dataOf(NodeUpdated),
          edges: dataOf(EdgeUpdated),
          combos: dataOf(ComboUpdated)
        },
        remove: {
          nodes: dataOf(NodeRemoved),
          edges: dataOf(EdgeRemoved),
          combos: dataOf(ComboRemoved)
        }
      };
      const drawData = this.transformData(input, context);
      model.clearChanges();
      return { dataChanges, drawData };
    }
    transformData(input, context) {
      const transforms = this.context.transform.getTransformInstance();
      return Object.values(transforms).reduce((data2, transform) => transform.beforeDraw(data2, context), input);
    }
    createElement(elementType, datum, context) {
      var _a2;
      const id3 = idOf(datum);
      const currentElement = this.getElement(id3);
      if (currentElement)
        return;
      const type = this.getElementType(elementType, datum);
      const style = this.getElementComputedStyle(elementType, datum);
      const Ctor = getExtension(elementType, type);
      if (!Ctor)
        return print.warn(`The element ${type} of ${elementType} is not registered.`);
      this.emit(new ElementLifeCycleEvent(GraphEvent.BEFORE_ELEMENT_CREATE, elementType, datum), context);
      const element = this.container.appendChild(new Ctor({
        id: id3,
        context: this.context,
        style
      }));
      this.shapeTypeMap[id3] = type;
      this.elementMap[id3] = element;
      const { stage = "enter" } = context;
      (_a2 = this.context.animation) === null || _a2 === void 0 ? void 0 : _a2.add({
        element,
        elementType,
        stage,
        originalStyle: Object.assign({}, element.attributes),
        updatedStyle: style
      }, {
        after: () => {
          var _a3;
          this.emit(new ElementLifeCycleEvent(GraphEvent.AFTER_ELEMENT_CREATE, elementType, datum), context);
          (_a3 = element.onCreate) === null || _a3 === void 0 ? void 0 : _a3.call(element);
        }
      });
    }
    createElements(data2, context) {
      const { nodes, edges, combos } = data2;
      const iteration = [
        ["node", nodes],
        ["combo", combos],
        ["edge", edges]
      ];
      iteration.forEach(([elementType, elementData]) => {
        elementData.forEach((datum) => this.createElement(elementType, datum, context));
      });
    }
    getUpdateStageStyle(elementType, datum, context) {
      const { stage = "update" } = context;
      if (stage === "translate") {
        if (elementType === "node" || elementType === "combo") {
          const { style: { x: x3 = 0, y: y3 = 0, z = 0 } = {} } = datum;
          return { x: x3, y: y3, z };
        } else
          return {};
      }
      return this.getElementComputedStyle(elementType, datum);
    }
    updateElement(elementType, datum, context) {
      var _a2;
      const id3 = idOf(datum);
      const { stage = "update" } = context;
      const element = this.getElement(id3);
      if (!element)
        return () => null;
      this.emit(new ElementLifeCycleEvent(GraphEvent.BEFORE_ELEMENT_UPDATE, elementType, datum), context);
      const type = this.getElementType(elementType, datum);
      const style = this.getUpdateStageStyle(elementType, datum, context);
      if (this.shapeTypeMap[id3] !== type) {
        element.destroy();
        delete this.shapeTypeMap[id3];
        delete this.elementMap[id3];
        this.createElement(elementType, datum, { animation: false, silence: true });
      }
      const exactStage = stage !== "visibility" ? stage : style.visibility === "hidden" ? "hide" : "show";
      if (exactStage === "hide")
        delete style["visibility"];
      (_a2 = this.context.animation) === null || _a2 === void 0 ? void 0 : _a2.add({
        element,
        elementType,
        stage: exactStage,
        originalStyle: Object.assign({}, element.attributes),
        updatedStyle: style
      }, {
        before: () => {
          const element2 = this.elementMap[id3];
          if (stage !== "collapse")
            updateStyle(element2, style);
          if (stage === "visibility") {
            if (!hasCachedStyle(element2, "opacity"))
              cacheStyle(element2, "opacity");
            this.visibilityCache.set(element2, exactStage === "show" ? "visible" : "hidden");
            if (exactStage === "show")
              setVisibility(element2, "visible");
          }
        },
        after: () => {
          var _a3;
          const element2 = this.elementMap[id3];
          if (stage === "collapse")
            updateStyle(element2, style);
          if (exactStage === "hide")
            setVisibility(element2, this.visibilityCache.get(element2));
          this.emit(new ElementLifeCycleEvent(GraphEvent.AFTER_ELEMENT_UPDATE, elementType, datum), context);
          (_a3 = element2.onUpdate) === null || _a3 === void 0 ? void 0 : _a3.call(element2);
        }
      });
    }
    updateElements(data2, context) {
      const { nodes, edges, combos } = data2;
      const iteration = [
        ["node", nodes],
        ["combo", combos],
        ["edge", edges]
      ];
      iteration.forEach(([elementType, elementData]) => {
        elementData.forEach((datum) => this.updateElement(elementType, datum, context));
      });
    }
    /**
     * <zh/> 标记销毁元素
     *
     * <en/> mark destroy element
     * @param data - <zh/> 绘制数据 | <en/> draw data
     */
    markDestroyElement(data2) {
      Object.values(data2.remove).forEach((elementData) => {
        elementData.forEach((datum) => {
          const id3 = idOf(datum);
          const element = this.getElement(id3);
          if (element)
            markToBeDestroyed(element);
        });
      });
    }
    destroyElement(elementType, datum, context) {
      var _a2;
      const { stage = "exit" } = context;
      const id3 = idOf(datum);
      const element = this.elementMap[id3];
      if (!element)
        return () => null;
      this.emit(new ElementLifeCycleEvent(GraphEvent.BEFORE_ELEMENT_DESTROY, elementType, datum), context);
      (_a2 = this.context.animation) === null || _a2 === void 0 ? void 0 : _a2.add({
        element,
        elementType,
        stage,
        originalStyle: Object.assign({}, element.attributes),
        updatedStyle: {}
      }, {
        after: () => {
          var _a3;
          this.clearElement(id3);
          element.destroy();
          (_a3 = element.onDestroy) === null || _a3 === void 0 ? void 0 : _a3.call(element);
          this.emit(new ElementLifeCycleEvent(GraphEvent.AFTER_ELEMENT_DESTROY, elementType, datum), context);
        }
      });
    }
    destroyElements(data2, context) {
      const { nodes, edges, combos } = data2;
      const iteration = [
        ["combo", combos],
        ["edge", edges],
        ["node", nodes]
      ];
      iteration.forEach(([elementType, elementData]) => {
        elementData.forEach((datum) => this.destroyElement(elementType, datum, context));
      });
    }
    clearElement(id3) {
      delete this.paletteStyle[id3];
      delete this.defaultStyle[id3];
      delete this.stateStyle[id3];
      delete this.elementMap[id3];
      delete this.shapeTypeMap[id3];
    }
    /**
     * <zh/> 将布局结果对齐到元素，避免视图偏移。会修改布局结果
     *
     * <en/> Align the layout result to the element to avoid view offset. Will modify the layout result
     * @param layoutResult - <zh/> 布局结果 | <en/> layout result
     * @param id - <zh/> 元素 ID | <en/> element ID
     */
    alignLayoutResultToElement(layoutResult, id3) {
      var _a2, _b;
      const target = (_a2 = layoutResult.nodes) === null || _a2 === void 0 ? void 0 : _a2.find((node) => idOf(node) === id3);
      if (target) {
        const originalPosition = positionOf(this.context.model.getNodeLikeDatum(id3));
        const modifiedPosition = positionOf(target);
        const delta = subtract(originalPosition, modifiedPosition);
        (_b = layoutResult.nodes) === null || _b === void 0 ? void 0 : _b.forEach((node) => {
          var _a3, _b2, _c;
          if ((_a3 = node.style) === null || _a3 === void 0 ? void 0 : _a3.x)
            node.style.x += delta[0];
          if ((_b2 = node.style) === null || _b2 === void 0 ? void 0 : _b2.y)
            node.style.y += delta[1];
          if ((_c = node.style) === null || _c === void 0 ? void 0 : _c.z)
            node.style.z += delta[2] || 0;
        });
      }
    }
    /**
     * <zh/> 收起节点
     *
     * <en/> collapse node
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @param options - <zh/> 选项 | <en/> options
     */
    collapseNode(id3, options) {
      return __awaiter24(this, void 0, void 0, function* () {
        var _a2;
        const { animation } = options;
        const { model } = this.context;
        const data2 = this.computeChangesAndDrawData({ stage: "collapse", animation });
        if (!data2)
          return;
        const { drawData } = data2;
        const { add: add5, remove, update } = drawData;
        this.markDestroyElement(drawData);
        const context = { animation, stage: "collapse", data: drawData };
        this.destroyElements(remove, context);
        this.createElements(add5, context);
        this.updateElements(update, context);
        yield (_a2 = this.context.animation.animate(animation, {
          beforeAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.COLLAPSE, animation2, drawData), context),
          afterAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.COLLAPSE, animation2, drawData), context)
        }, {
          collapse: {
            target: id3,
            descendants: Array.from(remove.nodes).map(([, node]) => idOf(node)),
            position: positionOf(update.nodes.get(id3))
          }
        })) === null || _a2 === void 0 ? void 0 : _a2.finished;
      });
    }
    /**
     * <zh/> 展开节点
     *
     * <en/> expand node
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @param animation - <zh/> 是否使用动画，默认为 true | <en/> Whether to use animation, default is true
     */
    expandNode(id3, options) {
      return __awaiter24(this, void 0, void 0, function* () {
        var _a2;
        const { model, layout: layout2 } = this.context;
        const { animation, align } = options;
        const position2 = positionOf(model.getNodeData([id3])[0]);
        const data2 = this.computeChangesAndDrawData({ stage: "expand", animation });
        this.createElements(data2.drawData.add, { animation: false, stage: "expand", target: id3 });
        this.context.animation.clear();
        this.computeStyle("expand");
        if (!data2)
          return;
        const { drawData } = data2;
        const { update, add: add5 } = drawData;
        const context = { animation, stage: "expand", data: drawData };
        add5.edges.forEach((edge) => update.edges.set(idOf(edge), edge));
        add5.nodes.forEach((node) => update.nodes.set(idOf(node), node));
        this.updateElements(update, context);
        yield (_a2 = this.context.animation.animate(animation, {
          beforeAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.EXPAND, animation2, drawData), context),
          afterAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.EXPAND, animation2, drawData), context)
        }, {
          expand: {
            target: id3,
            descendants: Array.from(add5.nodes).map(([, node]) => idOf(node)),
            position: position2
          }
        })) === null || _a2 === void 0 ? void 0 : _a2.finished;
      });
    }
    collapseCombo(id3, animation) {
      return __awaiter24(this, void 0, void 0, function* () {
        var _a2;
        const { model, element } = this.context;
        if (model.getAncestorsData(id3, COMBO_KEY).some((datum) => isCollapsed(datum)))
          return;
        const combo = element.getElement(id3);
        const position2 = combo.getComboPosition(Object.assign(Object.assign({}, combo.attributes), { collapsed: true }));
        const data2 = this.computeChangesAndDrawData({ stage: "collapse", animation });
        if (!data2)
          return;
        const { dataChanges, drawData } = data2;
        this.markDestroyElement(drawData);
        const { update, remove } = drawData;
        const context = { animation, stage: "collapse", data: drawData };
        this.destroyElements(remove, context);
        this.updateElements(update, context);
        const idsOf2 = (data3) => Array.from(data3).map(([, node]) => idOf(node));
        yield (_a2 = this.context.animation.animate(animation, {
          before: () => this.emit(new GraphLifeCycleEvent(GraphEvent.BEFORE_DRAW, { dataChanges, animation }), context),
          beforeAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.COLLAPSE, animation2, drawData), context),
          afterAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.COLLAPSE, animation2, drawData), context),
          after: () => this.emit(new GraphLifeCycleEvent(GraphEvent.AFTER_DRAW, { dataChanges, animation }), context)
        }, {
          collapse: {
            target: id3,
            descendants: [...idsOf2(remove.nodes), ...idsOf2(remove.combos)],
            position: position2
          }
        })) === null || _a2 === void 0 ? void 0 : _a2.finished;
      });
    }
    expandCombo(id3, animation) {
      return __awaiter24(this, void 0, void 0, function* () {
        var _a2;
        const { model } = this.context;
        const position2 = positionOf(model.getComboData([id3])[0]);
        this.computeStyle("expand");
        const data2 = this.computeChangesAndDrawData({ stage: "expand", animation });
        if (!data2)
          return;
        const { dataChanges, drawData } = data2;
        const { add: add5, update } = drawData;
        const context = { animation, stage: "expand", data: drawData, target: id3 };
        this.createElements(add5, context);
        this.updateElements(update, context);
        const idsOf2 = (data3) => Array.from(data3).map(([, node]) => idOf(node));
        yield (_a2 = this.context.animation.animate(animation, {
          before: () => this.emit(new GraphLifeCycleEvent(GraphEvent.BEFORE_DRAW, { dataChanges, animation }), context),
          beforeAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.EXPAND, animation2, drawData), context),
          afterAnimate: (animation2) => this.emit(new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.EXPAND, animation2, drawData), context),
          after: () => this.emit(new GraphLifeCycleEvent(GraphEvent.AFTER_DRAW, { dataChanges, animation }), context)
        }, {
          expand: {
            target: id3,
            descendants: [...idsOf2(add5.nodes), ...idsOf2(add5.combos)],
            position: position2
          }
        })) === null || _a2 === void 0 ? void 0 : _a2.finished;
      });
    }
    /**
     * <zh/> 清空所有元素
     *
     * <en/> clear all elements
     */
    clear() {
      this.container.destroy();
      this.initContainer();
      this.elementMap = {};
      this.shapeTypeMap = {};
      this.defaultStyle = {};
      this.stateStyle = {};
      this.paletteStyle = {};
    }
    destroy() {
      this.clear();
      this.container.destroy();
      this.context = {};
    }
  };

  // node_modules/@antv/g6/esm/runtime/layout.js
  var import_util205 = __toESM(require_lib());
  var __awaiter25 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest23 = function(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  var LayoutController = class {
    get presetOptions() {
      return {
        animation: !!getAnimationOptions(this.context.options, true)
      };
    }
    get options() {
      const { options } = this.context;
      return options.layout;
    }
    constructor(context) {
      this.instances = [];
      this.context = context;
    }
    getLayoutInstance() {
      return this.instances;
    }
    /**
     * <zh/> 前布局，即在绘制前执行布局
     *
     * <en/> Pre-layout, that is, perform layout before drawing
     * @param data - <zh/> 绘制数据 | <en/> Draw data
     * @remarks
     * <zh/> 前布局应该只在首次绘制前执行，后续更新不会触发
     *
     * <en/> Pre-layout should only be executed before the first drawing, and subsequent updates will not trigger
     */
    preLayout(data2) {
      return __awaiter25(this, void 0, void 0, function* () {
        var _a2, _b, _c, _d;
        const { graph, model } = this.context;
        const { add: add5 } = data2;
        emit(graph, new GraphLifeCycleEvent(GraphEvent.BEFORE_LAYOUT, { type: "pre" }));
        const simulate = yield (_a2 = this.context.layout) === null || _a2 === void 0 ? void 0 : _a2.simulate();
        (_b = simulate === null || simulate === void 0 ? void 0 : simulate.nodes) === null || _b === void 0 ? void 0 : _b.forEach((l) => {
          const id3 = idOf(l);
          const node = add5.nodes.get(id3);
          model.syncNodeLikeDatum(l);
          if (node)
            Object.assign(node.style, l.style);
        });
        (_c = simulate === null || simulate === void 0 ? void 0 : simulate.edges) === null || _c === void 0 ? void 0 : _c.forEach((l) => {
          const id3 = idOf(l);
          const edge = add5.edges.get(id3);
          model.syncEdgeDatum(l);
          if (edge)
            Object.assign(edge.style, l.style);
        });
        (_d = simulate === null || simulate === void 0 ? void 0 : simulate.combos) === null || _d === void 0 ? void 0 : _d.forEach((l) => {
          const id3 = idOf(l);
          const combo = add5.combos.get(id3);
          model.syncNodeLikeDatum(l);
          if (combo)
            Object.assign(combo.style, l.style);
        });
        emit(graph, new GraphLifeCycleEvent(GraphEvent.AFTER_LAYOUT, { type: "pre" }));
        this.transformDataAfterLayout("pre", data2);
      });
    }
    /**
     * <zh/> 后布局，即在完成绘制后执行布局
     *
     * <en/> Post layout, that is, perform layout after drawing
     * @param layoutOptions - <zh/> 布局配置项 | <en/> Layout options
     */
    postLayout() {
      return __awaiter25(this, arguments, void 0, function* (layoutOptions = this.options) {
        if (!layoutOptions)
          return;
        const pipeline = Array.isArray(layoutOptions) ? layoutOptions : [layoutOptions];
        const { graph } = this.context;
        emit(graph, new GraphLifeCycleEvent(GraphEvent.BEFORE_LAYOUT, { type: "post" }));
        for (let index2 = 0; index2 < pipeline.length; index2++) {
          const options = pipeline[index2];
          const data2 = this.getLayoutData(options);
          const opts = Object.assign(Object.assign({}, this.presetOptions), options);
          emit(graph, new GraphLifeCycleEvent(GraphEvent.BEFORE_STAGE_LAYOUT, { options: opts, index: index2 }));
          const result = yield this.stepLayout(data2, opts, index2);
          emit(graph, new GraphLifeCycleEvent(GraphEvent.AFTER_STAGE_LAYOUT, { options: opts, index: index2 }));
          if (!options.animation) {
            this.updateElementPosition(result, false);
          }
        }
        emit(graph, new GraphLifeCycleEvent(GraphEvent.AFTER_LAYOUT, { type: "post" }));
        this.transformDataAfterLayout("post");
      });
    }
    transformDataAfterLayout(type, data2) {
      const transforms = this.context.transform.getTransformInstance();
      Object.values(transforms).forEach((transform) => transform.afterLayout(type, data2));
    }
    /**
     * <zh/> 模拟布局
     *
     * <en/> Simulate layout
     * @returns <zh/> 模拟布局结果 | <en/> Simulated layout result
     */
    simulate() {
      return __awaiter25(this, void 0, void 0, function* () {
        if (!this.options)
          return {};
        const pipeline = Array.isArray(this.options) ? this.options : [this.options];
        let simulation = {};
        for (let index2 = 0; index2 < pipeline.length; index2++) {
          const options = pipeline[index2];
          const data2 = this.getLayoutData(options);
          const result = yield this.stepLayout(data2, Object.assign(Object.assign(Object.assign({}, this.presetOptions), options), { animation: false }), index2);
          simulation = result;
        }
        return simulation;
      });
    }
    stepLayout(data2, options, index2) {
      return __awaiter25(this, void 0, void 0, function* () {
        if (isTreeLayout(options))
          return yield this.treeLayout(data2, options, index2);
        return yield this.graphLayout(data2, options, index2);
      });
    }
    graphLayout(data2, options, index2) {
      return __awaiter25(this, void 0, void 0, function* () {
        const { animation, enableWorker, iterations = 300 } = options;
        const layout2 = this.initGraphLayout(options);
        if (!layout2)
          return {};
        this.instances[index2] = layout2;
        this.instance = layout2;
        if (enableWorker) {
          const rawLayout = layout2;
          this.supervisor = new Supervisor(rawLayout.graphData2LayoutModel(data2), rawLayout.instance, { iterations });
          return layoutMapping2GraphData(yield this.supervisor.execute());
        }
        if (isLayoutWithIterations(layout2)) {
          if (animation) {
            return yield layout2.execute(data2, {
              onTick: (tickData) => {
                this.updateElementPosition(tickData, false);
              }
            });
          }
          layout2.execute(data2);
          layout2.stop();
          return layout2.tick(iterations);
        }
        const layoutResult = yield layout2.execute(data2);
        if (animation) {
          const animationResult = this.updateElementPosition(layoutResult, animation);
          yield animationResult === null || animationResult === void 0 ? void 0 : animationResult.finished;
        }
        return layoutResult;
      });
    }
    treeLayout(data2, options, index2) {
      return __awaiter25(this, void 0, void 0, function* () {
        const { type, animation } = options;
        const layout2 = getExtension("layout", type);
        if (!layout2)
          return {};
        const { nodes = [], edges = [] } = data2;
        const model = new Graph2({
          nodes: nodes.map((node) => ({ id: idOf(node), data: node.data || {} })),
          edges: edges.map((edge) => ({ id: idOf(edge), source: edge.source, target: edge.target, data: edge.data || {} }))
        });
        createTreeStructure(model);
        const layoutPreset = { nodes: [], edges: [] };
        const layoutResult = { nodes: [], edges: [] };
        const roots = model.getRoots(TREE_KEY);
        roots.forEach((root2) => {
          dfs(root2, (node) => {
            node.children = model.getSuccessors(node.id);
          }, (node) => model.getSuccessors(node.id), "TB");
          const result = layout2(root2, options);
          const { x: rx, y: ry, z: rz = 0 } = result;
          dfs(result, (node) => {
            const { id: id3, x: x3, y: y3, z = 0 } = node;
            layoutPreset.nodes.push({ id: id3, style: { x: rx, y: ry, z: rz } });
            layoutResult.nodes.push({ id: id3, style: { x: x3, y: y3, z } });
          }, (node) => node.children, "TB");
        });
        const offset = this.inferTreeLayoutOffset(layoutResult);
        applyTreeLayoutOffset(layoutResult, offset);
        if (animation) {
          applyTreeLayoutOffset(layoutPreset, offset);
          this.updateElementPosition(layoutPreset, false);
          const animationResult = this.updateElementPosition(layoutResult, animation);
          yield animationResult === null || animationResult === void 0 ? void 0 : animationResult.finished;
        }
        return layoutResult;
      });
    }
    inferTreeLayoutOffset(data2) {
      var _a2;
      let [minX, maxX] = [Infinity, -Infinity];
      let [minY, maxY] = [Infinity, -Infinity];
      (_a2 = data2.nodes) === null || _a2 === void 0 ? void 0 : _a2.forEach((node) => {
        const { x: x3 = 0, y: y3 = 0 } = node.style || {};
        minX = Math.min(minX, x3);
        maxX = Math.max(maxX, x3);
        minY = Math.min(minY, y3);
        maxY = Math.max(maxY, y3);
      });
      const { canvas: canvas2 } = this.context;
      const canvasSize = canvas2.getSize();
      const [x1, y1] = canvas2.getCanvasByViewport([0, 0]);
      const [x22, y22] = canvas2.getCanvasByViewport(canvasSize);
      if (minX >= x1 && maxX <= x22 && minY >= y1 && maxY <= y22)
        return [0, 0];
      const cx = (x1 + x22) / 2;
      const cy = (y1 + y22) / 2;
      return [cx - (minX + maxX) / 2, cy - (minY + maxY) / 2];
    }
    stopLayout() {
      if (this.instance && isLayoutWithIterations(this.instance)) {
        this.instance.stop();
        this.instance = void 0;
      }
      if (this.supervisor) {
        this.supervisor.stop();
        this.supervisor = void 0;
      }
      if (this.animationResult) {
        this.animationResult.finish();
        this.animationResult = void 0;
      }
    }
    getLayoutData(options) {
      const { nodeFilter = () => true, comboFilter = () => true, preLayout = false, isLayoutInvisibleNodes = false } = options;
      const { nodes, edges, combos } = this.context.model.getData();
      const { element, model } = this.context;
      const getElement = (id3) => element.getElement(id3);
      const filterFn = preLayout ? (node) => {
        var _a2;
        if (!isLayoutInvisibleNodes) {
          if (((_a2 = node.style) === null || _a2 === void 0 ? void 0 : _a2.visibility) === "hidden")
            return false;
          if (model.getAncestorsData(node.id, TREE_KEY).some(isCollapsed))
            return false;
          if (model.getAncestorsData(node.id, COMBO_KEY).some(isCollapsed))
            return false;
        }
        return nodeFilter(node);
      } : (node) => {
        const id3 = idOf(node);
        const element2 = getElement(id3);
        if (!element2)
          return false;
        if (isToBeDestroyed(element2))
          return false;
        return nodeFilter(node);
      };
      const nodesToLayout = nodes.filter(filterFn);
      const combosToLayout = combos.filter(comboFilter);
      const nodeLikeIdsMap = new Map(nodesToLayout.map((node) => [idOf(node), node]));
      combosToLayout.forEach((combo) => nodeLikeIdsMap.set(idOf(combo), combo));
      const edgesToLayout = edges.filter(({ source, target }) => {
        return nodeLikeIdsMap.has(source) && nodeLikeIdsMap.has(target);
      });
      return {
        nodes: nodesToLayout,
        edges: edgesToLayout,
        combos: combosToLayout
      };
    }
    /**
     * <zh/> 创建布局实例
     *
     * <en/> Create layout instance
     * @param options - <zh/> 布局配置项 | <en/> Layout options
     * @returns <zh/> 布局对象 | <en/> Layout object
     */
    initGraphLayout(options) {
      var _a2;
      const { element, viewport } = this.context;
      const { type, enableWorker, animation, iterations } = options, restOptions = __rest23(options, ["type", "enableWorker", "animation", "iterations"]);
      const [width2, height] = viewport.getCanvasSize();
      const center = [width2 / 2, height / 2];
      const nodeSize = (_a2 = options === null || options === void 0 ? void 0 : options.nodeSize) !== null && _a2 !== void 0 ? _a2 : ((node) => {
        const nodeElement = element === null || element === void 0 ? void 0 : element.getElement(node.id);
        if (nodeElement)
          return nodeElement.attributes.size;
        return element === null || element === void 0 ? void 0 : element.getElementComputedStyle("node", node).size;
      });
      const Ctor = getExtension("layout", type);
      if (!Ctor)
        return print.warn(`The layout of ${type} is not registered.`);
      const STDCtor = Object.getPrototypeOf(Ctor.prototype) === BaseLayout.prototype ? Ctor : layoutAdapter(Ctor, this.context);
      const layout2 = new STDCtor(this.context);
      const config = { nodeSize, width: width2, height, center };
      switch (layout2.id) {
        case "d3-force":
        case "d3-force-3d":
          Object.assign(config, {
            center: { x: width2 / 2, y: height / 2, z: 0 }
          });
          break;
        default:
          break;
      }
      (0, import_util205.deepMix)(layout2.options, config, restOptions);
      return layout2;
    }
    updateElementPosition(layoutResult, animation) {
      const { model, element } = this.context;
      if (!element)
        return null;
      model.updateData(layoutResult);
      return element.draw({ animation, silence: true });
    }
    destroy() {
      var _a2;
      this.stopLayout();
      this.context = {};
      (_a2 = this.supervisor) === null || _a2 === void 0 ? void 0 : _a2.kill();
      this.supervisor = void 0;
      this.instance = void 0;
      this.instances = [];
      this.animationResult = void 0;
    }
  };
  var applyTreeLayoutOffset = (data2, offset) => {
    var _a2;
    const [ox, oy] = offset;
    (_a2 = data2.nodes) === null || _a2 === void 0 ? void 0 : _a2.forEach((node) => {
      if (node.style) {
        const { x: x3 = 0, y: y3 = 0 } = node.style;
        node.style.x = x3 + ox;
        node.style.y = y3 + oy;
      } else {
        node.style = { x: ox, y: oy };
      }
    });
  };

  // node_modules/@antv/g6/esm/runtime/options.js
  function inferOptions(options) {
    const flow = [inferLayoutOptions];
    return flow.reduce((acc, infer) => infer(acc), options);
  }
  function inferLayoutOptions(options) {
    if (!options.layout)
      return options;
    if (Array.isArray(options.layout))
      return options;
    if ("preLayout" in options.layout)
      return options;
    if ([
      "antv-dagre",
      "combo-combined",
      "compact-box",
      "circular",
      "concentric",
      "dagre",
      "fishbone",
      "grid",
      "indented",
      "mds",
      "radial",
      "random",
      "snake",
      // <zh/> 下列布局的标签位置待适配，需要手动配置 preLayout false
      // <en/> The label position of the following layouts needs to be adapted, and preLayout needs to be manually configured as false
      "dendrogram",
      "mindmap"
    ].includes(options.layout.type)) {
      options.layout.preLayout = true;
    }
    return options;
  }

  // node_modules/@antv/g6/esm/runtime/plugin.js
  var PluginController = class extends ExtensionController {
    constructor(context) {
      super(context);
      this.category = "plugin";
      this.setPlugins(this.context.options.plugins || []);
    }
    setPlugins(plugins) {
      this.setExtensions(plugins);
    }
    getPluginInstance(key) {
      const exactly = this.extensionMap[key];
      if (exactly)
        return exactly;
      print.warn(`Cannot find the plugin ${key}, will try to find it by type.`);
      const fussily = this.extensions.find((extension) => extension.type === key);
      if (fussily)
        return this.extensionMap[fussily.key];
    }
  };

  // node_modules/@antv/g6/esm/runtime/transform.js
  var REQUIRED_TRANSFORMS = [
    "update-related-edges",
    "collapse-expand-node",
    "collapse-expand-combo",
    "get-edge-actual-ends",
    "arrange-draw-order"
  ];
  var TransformController = class extends ExtensionController {
    constructor(context) {
      super(context);
      this.category = "transform";
      this.setTransforms(this.context.options.transforms || []);
    }
    getTransforms() {
    }
    setTransforms(transforms) {
      this.setExtensions([
        ...REQUIRED_TRANSFORMS.slice(0, REQUIRED_TRANSFORMS.length - 1),
        ...transforms,
        REQUIRED_TRANSFORMS[REQUIRED_TRANSFORMS.length - 1]
      ]);
    }
    getTransformInstance(key) {
      return key ? this.extensionMap[key] : this.extensionMap;
    }
  };

  // node_modules/@antv/g6/esm/runtime/viewport.js
  var import_util206 = __toESM(require_lib());
  var __awaiter26 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var ViewportController = class {
    get padding() {
      return parsePadding(this.context.options.padding);
    }
    get paddingOffset() {
      const [top, right, bottom, left] = this.padding;
      const [offsetX, offsetY, offsetZ] = [(left - right) / 2, (top - bottom) / 2, 0];
      return [offsetX, offsetY, offsetZ];
    }
    constructor(context) {
      this.landmarkCounter = 0;
      this.context = context;
      const [px, py] = this.paddingOffset;
      const { zoom, rotation, x: x3 = px, y: y3 = py } = context.options;
      this.transform({ mode: "absolute", scale: zoom, translate: [x3, y3], rotate: rotation }, false);
    }
    get camera() {
      const { canvas: canvas2 } = this.context;
      return new Proxy(canvas2.getCamera(), {
        get: (target, prop) => {
          const layers = Object.entries(canvas2.getLayers()).filter(([name]) => !["main"].includes(name));
          const cameras = layers.map(([, layer]) => layer.getCamera());
          const value = target[prop];
          if (typeof value === "function") {
            return (...args) => {
              const result = value.apply(target, args);
              cameras.forEach((camera) => {
                camera[prop].apply(camera, args);
              });
              return result;
            };
          }
        }
      });
    }
    createLandmark(options) {
      return this.camera.createLandmark(`landmark-${this.landmarkCounter++}`, options);
    }
    getAnimation(animation) {
      const finalAnimation = getAnimationOptions(this.context.options, animation);
      if (!finalAnimation)
        return false;
      return (0, import_util206.pick)(Object.assign({}, finalAnimation), ["easing", "duration"]);
    }
    getCanvasSize() {
      const { canvas: canvas2 } = this.context;
      const { width: width2 = 0, height = 0 } = canvas2.getConfig();
      return [width2, height];
    }
    /**
     * <zh/> 获取画布中心坐标
     *
     * <en/> Get the center coordinates of the canvas
     * @returns - <zh/> 画布中心坐标 | <en/> Center coordinates of the canvas
     * @remarks
     * <zh/> 基于画布的宽高计算中心坐标，不受视口变换影响
     *
     * <en/> Calculate the center coordinates based on the width and height of the canvas, not affected by the viewport transformation
     */
    getCanvasCenter() {
      const { canvas: canvas2 } = this.context;
      const { width: width2 = 0, height = 0 } = canvas2.getConfig();
      return [width2 / 2, height / 2, 0];
    }
    /**
     * <zh/> 当前视口中心坐标
     *
     * <en/> Current viewport center coordinates
     * @returns - <zh/> 视口中心坐标 | <en/> Viewport center coordinates
     * @remarks
     * <zh/> 以画布原点为原点，受到视口变换影响
     *
     * <en/> With the origin of the canvas as the origin, affected by the viewport transformation
     */
    getViewportCenter() {
      const [x3, y3] = this.camera.getPosition();
      return [x3, y3, 0];
    }
    getGraphCenter() {
      return this.context.graph.getViewportByCanvas(this.getCanvasCenter());
    }
    getZoom() {
      return this.camera.getZoom();
    }
    getRotation() {
      return this.camera.getRoll();
    }
    getTranslateOptions(options) {
      const { camera } = this;
      const { mode, translate: translate3 = [] } = options;
      const currentZoom = this.getZoom();
      const position2 = camera.getPosition();
      const focalPoint = camera.getFocalPoint();
      const [cx, cy] = this.getCanvasCenter();
      const [x3 = 0, y3 = 0, z = 0] = translate3;
      const delta = divide([-x3, -y3, -z], currentZoom);
      return mode === "relative" ? {
        position: add(position2, delta),
        focalPoint: add(focalPoint, delta)
      } : {
        position: add([cx, cy, position2[2]], delta),
        focalPoint: add([cx, cy, focalPoint[2]], delta)
      };
    }
    getRotateOptions(options) {
      const { mode, rotate: rotate3 = 0 } = options;
      const roll = mode === "relative" ? this.camera.getRoll() + rotate3 : rotate3;
      return { roll };
    }
    getZoomOptions(options) {
      const { zoomRange } = this.context.options;
      const currentZoom = this.camera.getZoom();
      const { mode, scale: scale4 = 1 } = options;
      return (0, import_util206.clamp)(mode === "relative" ? currentZoom * scale4 : scale4, ...zoomRange);
    }
    transform(options, animation) {
      return __awaiter26(this, void 0, void 0, function* () {
        const { graph } = this.context;
        const { translate: translate3, rotate: rotate3, scale: scale4, origin } = options;
        this.cancelAnimation();
        const _animation = this.getAnimation(animation);
        emit(graph, new ViewportEvent(GraphEvent.BEFORE_TRANSFORM, options));
        if (!rotate3 && scale4 && !translate3 && origin && !_animation) {
          this.camera.setZoomByViewportPoint(this.getZoomOptions(options), origin);
          emit(graph, new ViewportEvent(GraphEvent.AFTER_TRANSFORM, options));
          return;
        }
        const landmarkOptions = {};
        if (translate3)
          Object.assign(landmarkOptions, this.getTranslateOptions(options));
        if ((0, import_util206.isNumber)(rotate3))
          Object.assign(landmarkOptions, this.getRotateOptions(options));
        if ((0, import_util206.isNumber)(scale4))
          Object.assign(landmarkOptions, { zoom: this.getZoomOptions(options) });
        if (_animation) {
          emit(graph, new AnimateEvent(GraphEvent.BEFORE_ANIMATE, AnimationType.TRANSFORM, null, options));
          return new Promise((resolve) => {
            this.transformResolver = resolve;
            this.camera.gotoLandmark(this.createLandmark(landmarkOptions), Object.assign(Object.assign({}, _animation), { onfinish: () => {
              emit(graph, new AnimateEvent(GraphEvent.AFTER_ANIMATE, AnimationType.TRANSFORM, null, options));
              emit(graph, new ViewportEvent(GraphEvent.AFTER_TRANSFORM, options));
              this.transformResolver = void 0;
              resolve();
            } }));
          });
        } else {
          this.camera.gotoLandmark(this.createLandmark(landmarkOptions), {
            duration: 0
          });
          emit(graph, new ViewportEvent(GraphEvent.AFTER_TRANSFORM, options));
        }
      });
    }
    fitView(options, animation) {
      return __awaiter26(this, void 0, void 0, function* () {
        const [top, right, bottom, left] = this.padding;
        const { when = "always", direction: direction2 = "both" } = options || {};
        const [width2, height] = this.context.canvas.getSize();
        const innerWidth = width2 - left - right;
        const innerHeight = height - top - bottom;
        const canvasBounds = this.context.canvas.getBounds();
        const bboxInViewPort = this.getBBoxInViewport(canvasBounds);
        const [contentWidth, contentHeight] = getBBoxSize(bboxInViewPort);
        const isOverflow = direction2 === "x" && contentWidth >= innerWidth || direction2 === "y" && contentHeight >= innerHeight || direction2 === "both" && contentWidth >= innerWidth && contentHeight >= innerHeight;
        if (when === "overflow" && !isOverflow)
          return yield this.fitCenter({ animation });
        const scaleX2 = innerWidth / contentWidth;
        const scaleY2 = innerHeight / contentHeight;
        const scale4 = direction2 === "x" ? scaleX2 : direction2 === "y" ? scaleY2 : Math.min(scaleX2, scaleY2);
        const _animation = this.getAnimation(animation);
        if (!Number.isFinite(scale4)) {
          return;
        }
        yield this.transform({
          mode: "relative",
          scale: scale4,
          translate: add(subtract(this.getCanvasCenter(), this.getBBoxInViewport(canvasBounds).center), divide(this.paddingOffset, scale4))
        }, _animation);
      });
    }
    fitCenter(options) {
      return __awaiter26(this, void 0, void 0, function* () {
        const canvasBounds = this.context.canvas.getBounds();
        yield this.focus(canvasBounds, options);
      });
    }
    focusElements(ids_1) {
      return __awaiter26(this, arguments, void 0, function* (ids, options = {}) {
        const { element } = this.context;
        if (!element)
          return;
        const getBoundsOf = (el) => options.shapes ? el.getShape(options.shapes).getRenderBounds() : el.getRenderBounds();
        const elementsBounds = getCombinedBBox(ids.map((id3) => getBoundsOf(element.getElement(id3))));
        yield this.focus(elementsBounds, options);
      });
    }
    focus(bbox, options) {
      return __awaiter26(this, void 0, void 0, function* () {
        const center = this.context.graph.getViewportByCanvas(bbox.center);
        const position2 = options.position || this.getCanvasCenter();
        const delta = subtract(position2, center);
        yield this.transform({ mode: "relative", translate: add(delta, this.paddingOffset) }, options.animation);
      });
    }
    /**
     * <zh/> 获取画布元素在视口中的包围盒
     *
     * <en/> Get the bounding box of the canvas element in the viewport
     * @param bbox - <zh/> 画布元素包围盒 | <en/> Canvas element bounding box
     * @returns - <zh/> 视口中的包围盒 | <en/> Bounding box in the viewport
     */
    getBBoxInViewport(bbox) {
      const { min: min4, max: max4 } = bbox;
      const { graph } = this.context;
      const [x1, y1] = graph.getViewportByCanvas(min4);
      const [x22, y22] = graph.getViewportByCanvas(max4);
      const bboxInViewport = new AABB();
      bboxInViewport.setMinMax([x1, y1, 0], [x22, y22, 0]);
      return bboxInViewport;
    }
    /**
     * <zh/> 判断点或包围盒是否在视口中
     *
     * <en/> Determine whether the point or bounding box is in the viewport
     * @param target - <zh/> 点或包围盒 | <en/> Point or bounding box
     * @param complete - <zh/> 是否完全在视口中 | <en/> Whether it is completely in the viewport
     * @param tolerance - <zh/> 视口外的容差 | <en/> Tolerance outside the viewport
     * @returns - <zh/> 是否在视口中 | <en/> Whether it is in the viewport
     */
    isInViewport(target, complete = false, tolerance2 = 0) {
      const { graph } = this.context;
      const size2 = this.getCanvasSize();
      const [x1, y1] = graph.getCanvasByViewport([0, 0]);
      const [x22, y22] = graph.getCanvasByViewport(size2);
      let viewportBBox = new AABB();
      viewportBBox.setMinMax([x1, y1, 0], [x22, y22, 0]);
      if (tolerance2) {
        viewportBBox = getExpandedBBox(viewportBBox, tolerance2);
      }
      return isPoint(target) ? isPointInBBox(target, viewportBBox) : !complete ? viewportBBox.intersects(target) : isBBoxInside(target, viewportBBox);
    }
    cancelAnimation() {
      var _a2, _b;
      if ((_a2 = this.camera.landmarks) === null || _a2 === void 0 ? void 0 : _a2.length) {
        this.camera.cancelLandmarkAnimation();
      }
      (_b = this.transformResolver) === null || _b === void 0 ? void 0 : _b.call(this);
    }
  };

  // node_modules/@antv/g6/esm/runtime/graph.js
  var __awaiter27 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step2(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step2(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var Graph3 = class _Graph extends esm_default {
    constructor(options) {
      var _a2;
      super();
      this.options = {};
      this.rendered = false;
      this.destroyed = false;
      this.context = {
        model: new DataController()
      };
      this.isCollapsingExpanding = false;
      this.onResize = (0, import_util207.debounce)(() => {
        this.resize();
      }, 300);
      this._setOptions(Object.assign({}, _Graph.defaultOptions, options), true);
      this.context.graph = this;
      this.options.autoResize && ((_a2 = globalThis.addEventListener) === null || _a2 === void 0 ? void 0 : _a2.call(globalThis, "resize", this.onResize));
    }
    /**
     * <zh/> 获取配置项
     *
     * <en/> Get options
     * @returns <zh/> 配置项 | <en/> options
     * @apiCategory option
     */
    getOptions() {
      return this.options;
    }
    /**
     * <zh/> 设置配置项
     *
     * <en/> Set options
     * @param options - <zh/> 配置项 | <en/> options
     * @remarks
     * <zh/> 要更新 devicePixelRatio、container 属性请销毁后重新创建实例
     *
     * <en/> To update devicePixelRatio and container properties, please destroy and recreate the instance
     * @apiCategory option
     */
    setOptions(options) {
      this._setOptions(options, false);
    }
    _setOptions(options, isInit) {
      this.updateCanvas(options);
      Object.assign(this.options, inferOptions(options));
      if (isInit) {
        const { data: data3 } = options;
        if (data3)
          this.addData(data3);
        return;
      }
      const { behaviors, combo, data: data2, edge, layout: layout2, node, plugins, theme, transforms } = options;
      if (behaviors)
        this.setBehaviors(behaviors);
      if (data2)
        this.setData(data2);
      if (node)
        this.setNode(node);
      if (edge)
        this.setEdge(edge);
      if (combo)
        this.setCombo(combo);
      if (layout2)
        this.setLayout(layout2);
      if (theme)
        this.setTheme(theme);
      if (plugins)
        this.setPlugins(plugins);
      if (transforms)
        this.setTransforms(transforms);
    }
    /**
     * <zh/> 获取当前画布容器的尺寸
     *
     * <en/> Get the size of the current canvas container
     * @returns <zh/> 画布尺寸 | <en/> canvas size
     * @apiCategory canvas
     */
    getSize() {
      if (this.context.canvas)
        return this.context.canvas.getSize();
      return [this.options.width || 0, this.options.height || 0];
    }
    /**
     * <zh/> 设置当前画布容器的尺寸
     *
     * <en/> Set the size of the current canvas container
     * @param width - <zh/> 画布宽度 | <en/> canvas width
     * @param height - <zh/> 画布高度 | <en/> canvas height
     * @apiCategory canvas
     */
    setSize(width2, height) {
      if (width2)
        this.options.width = width2;
      if (height)
        this.options.height = height;
      this.resize(width2, height);
    }
    /**
     * <zh/> 设置当前图的缩放区间
     *
     * <en/> Get the zoom range of the current graph
     * @param zoomRange - <zh/> 缩放区间 | <en/> zoom range
     * @apiCategory viewport
     */
    setZoomRange(zoomRange) {
      this.options.zoomRange = zoomRange;
    }
    /**
     * <zh/> 获取当前图的缩放区间
     *
     * <en/> Get the zoom range of the current graph
     * @returns <zh/> 缩放区间 | <en/> zoom range
     * @apiCategory viewport
     */
    getZoomRange() {
      return this.options.zoomRange;
    }
    /**
     * <zh/> 设置节点样式映射
     *
     * <en/> Set node mapper
     * @param node - <zh/> 节点配置 | <en/> node options
     * @remarks
     * <zh/> 即 `options.node` 的值
     *
     * <en/> The value of `options.node`
     * @apiCategory element
     */
    setNode(node) {
      this.options.node = node;
      this.context.model.refreshData();
    }
    /**
     * <zh/> 设置边样式映射
     *
     * <en/> Set edge mapper
     * @param edge - <zh/> 边配置 | <en/> edge options
     * @remarks
     * <zh/> 即 `options.edge` 的值
     *
     * <en/> The value of `options.edge`
     * @apiCategory element
     */
    setEdge(edge) {
      this.options.edge = edge;
      this.context.model.refreshData();
    }
    /**
     * <zh/> 设置组合样式映射
     *
     * <en/> Set combo mapper
     * @param combo - <zh/> 组合配置 | <en/> combo options
     * @remarks
     * <zh/> 即 `options.combo` 的值
     *
     * <en/> The value of `options.combo`
     * @apiCategory element
     */
    setCombo(combo) {
      this.options.combo = combo;
      this.context.model.refreshData();
    }
    /**
     * <zh/> 获取主题
     *
     * <en/> Get theme
     * @returns <zh/> 当前主题 | <en/> current theme
     * @apiCategory theme
     */
    getTheme() {
      return this.options.theme;
    }
    /**
     * <zh/> 设置主题
     *
     * <en/> Set theme
     * @param theme - <zh/> 主题名 | <en/> theme name
     * @example
     * ```ts
     * graph.setTheme('dark');
     * ```
     * @apiCategory theme
     */
    setTheme(theme) {
      this.options.theme = (0, import_util207.isFunction)(theme) ? theme(this.getTheme()) : theme;
    }
    /**
     * <zh/> 设置布局
     *
     * <en/> Set layout
     * @param layout - <zh/> 布局配置 | <en/> layout options
     * @example
     * ```ts
     * graph.setLayout({
     *  type: 'dagre',
     * })
     * ```
     * @apiCategory layout
     */
    setLayout(layout2) {
      this.options.layout = (0, import_util207.isFunction)(layout2) ? layout2(this.getLayout()) : layout2;
    }
    /**
     * <zh/> 获取布局配置
     *
     * <en/> Get layout options
     * @returns <zh/> 布局配置 | <en/> layout options
     * @apiCategory layout
     */
    getLayout() {
      return this.options.layout;
    }
    /**
     * <zh/> 设置交互
     *
     * <en/> Set behaviors
     * @param behaviors - <zh/> 交互配置 | <en/> behavior options
     * @remarks
     * <zh/> 设置的交互会全量替换原有的交互，如果需要新增交互可以使用如下方式：
     *
     * <en/> The set behavior will completely replace the original behavior. If you need to add behavior, you can use the following method:
     *
     * ```ts
     * graph.setBehaviors((behaviors) => [...behaviors, { type: 'zoom-canvas' }])
     * ```
     * @apiCategory behavior
     */
    setBehaviors(behaviors) {
      var _a2;
      this.options.behaviors = (0, import_util207.isFunction)(behaviors) ? behaviors(this.getBehaviors()) : behaviors;
      (_a2 = this.context.behavior) === null || _a2 === void 0 ? void 0 : _a2.setBehaviors(this.options.behaviors);
    }
    /**
     * <zh/> 更新指定的交互配置
     *
     * <en/> Update specified behavior options
     * @param behavior - <zh/> 交互配置 | <en/> behavior options
     * @remarks
     * <zh/> 如果要更新一个交互，那么必须在交互配置中指定 key 字段，例如：
     *
     * <en/> If you want to update a behavior, you must specify the key field in the behavior options, for example:
     * ```ts
     * {
     *   behaviors: [{ type: 'zoom-canvas', key: 'zoom-canvas' }]
     * }
     *
     * graph.updateBehavior({ key: 'zoom-canvas', enable: false })
     * ```
     * @apiCategory behavior
     */
    updateBehavior(behavior) {
      this.setBehaviors((behaviors) => behaviors.map((_behavior) => {
        if (typeof _behavior === "object" && _behavior.key === behavior.key) {
          return Object.assign(Object.assign({}, _behavior), behavior);
        }
        return _behavior;
      }));
    }
    /**
     * <zh/> 获取交互配置
     *
     * <en/> Get behaviors options
     * @returns <zh/> 交互配置 | <en/> behavior options
     * @apiCategory behavior
     */
    getBehaviors() {
      return this.options.behaviors || [];
    }
    /**
     * <zh/> 设置插件配置
     *
     * <en/> Set plugins options
     * @param plugins - <zh/> 插件配置 | <en/> plugin options
     * @remarks
     * <zh/> 设置的插件会全量替换原有的插件配置，如果需要新增插件可以使用如下方式：
     *
     * <en/> The set plugin will completely replace the original plugin configuration. If you need to add a plugin, you can use the following method:
     * ```ts
     * graph.setPlugins((plugins) => [...plugins, { key: 'grid-line' }])
     * ```
     * @apiCategory plugin
     */
    setPlugins(plugins) {
      var _a2;
      this.options.plugins = (0, import_util207.isFunction)(plugins) ? plugins(this.getPlugins()) : plugins;
      (_a2 = this.context.plugin) === null || _a2 === void 0 ? void 0 : _a2.setPlugins(this.options.plugins);
    }
    /**
     * <zh/> 更新插件配置
     *
     * <en/> Update plugin options
     * @param plugin - <zh/> 插件配置 | <en/> plugin options
     * @remarks
     * <zh/> 如果要更新一个插件，那么必须在插件配置中指定 key 字段，例如：
     *
     * <en/> If you want to update a plugin, you must specify the key field in the plugin options, for example:
     * ```ts
     * {
     *   plugins: [{ key: 'grid-line' }]
     * }
     *
     * graph.updatePlugin({ key: 'grid-line', follow: true })
     * ```
     * @apiCategory plugin
     */
    updatePlugin(plugin) {
      this.setPlugins((plugins) => plugins.map((_plugin) => {
        if (typeof _plugin === "object" && _plugin.key === plugin.key) {
          return Object.assign(Object.assign({}, _plugin), plugin);
        }
        return _plugin;
      }));
    }
    /**
     * <zh/> 获取插件配置
     *
     * <en/> Get plugins options
     * @returns <zh/> 插件配置 | <en/> plugin options
     * @apiCategory plugin
     */
    getPlugins() {
      return this.options.plugins || [];
    }
    /**
     * <zh/> 获取插件实例
     *
     * <en/> Get plugin instance
     * @param key - <zh/> 插件 key（在配置 plugin 时需要手动传入指定） | <en/> plugin key(need to be specified manually when configuring plugin)
     * @returns <zh/> 插件实例 | <en/> plugin instance
     * @remarks
     * <zh/> 一些插件提供了 API 方法可供调用，例如全屏插件可以调用 `request` 和 `exit` 方法来请求和退出全屏
     *
     * <en/> Some plugins provide API methods for calling, such as the full-screen plugin can call the `request` and `exit` methods to request and exit full-screen
     * ```ts
     * const fullscreen = graph.getPluginInstance('fullscreen');
     *
     * fullscreen.request();
     *
     * fullscreen.exit();
     * ```
     * @apiCategory plugin
     */
    getPluginInstance(key) {
      return this.context.plugin.getPluginInstance(key);
    }
    /**
     * <zh/> 设置数据转换器
     *
     * <en/> Set data transforms
     * @param transforms - <zh/> 数据转换配置 | <en/> data transform options
     * @remarks
     * <zh/> 数据转换器能够在图渲染过程中执行数据转换，目前支持在渲染前对绘制数据进行转化。
     *
     * <en/> Data transforms can perform data transformation during the rendering process of the graph. Currently, it supports transforming the drawing data before rendering.
     * @apiCategory transform
     */
    setTransforms(transforms) {
      var _a2;
      this.options.transforms = (0, import_util207.isFunction)(transforms) ? transforms(this.getTransforms()) : transforms;
      (_a2 = this.context.transform) === null || _a2 === void 0 ? void 0 : _a2.setTransforms(this.options.transforms);
    }
    /**
     * <zh/> 更新数据转换器
     *
     * <en/> Update data transform
     * @param transform - <zh/> 数据转换器配置 | <en/> data transform options
     * @apiCategory transform
     */
    updateTransform(transform) {
      this.setTransforms((transforms) => transforms.map((_transform) => {
        if (typeof _transform === "object" && _transform.key === transform.key) {
          return Object.assign(Object.assign({}, _transform), transform);
        }
        return _transform;
      }));
      this.context.model.refreshData();
    }
    /**
     * <zh/> 获取数据转换器配置
     *
     * <en/> Get data transforms options
     * @returns <zh/> 数据转换配置 | <en/> data transform options
     * @apiCategory transform
     */
    getTransforms() {
      return this.options.transforms || [];
    }
    /**
     * <zh/> 获取图数据
     *
     * <en/> Get graph data
     * @returns <zh/> 图数据 | <en/> Graph data
     * <zh/> 获取当前图的数据，包括节点、边、组合数据
     *
     * <en/> Get the data of the current graph, including node, edge, and combo data
     * @apiCategory data
     */
    getData() {
      return this.context.model.getData();
    }
    /**
     * <zh/> 判断图中是否存在指定节点
     * <en/> Determine whether a specified node exists in the graph
     * @param {ID} id
     * @returns {boolean}
     * @remarks <zh/> 判断图中是否存在指定节点,避免在不存在的节点上进行操作
     * <en/> Determine whether a specified node exists in the graph and avoid operating on non-existent nodes
     */
    hasNode(id3) {
      return this.context.model.hasNode(id3);
    }
    /**
     * <zh/> 判断图中是否存在指定边
     * <en/> Determine whether a specified edge exists in the graph
     * @param {ID} id
     * @returns  {boolean}
     * @remarks <zh/> 判断图中是否存在指定边,避免在不存在的边上进行操作
     * <en/> Determine whether a specified edge exists in the graph and avoid operating on non-existent edges
     */
    hasEdge(id3) {
      return this.context.model.hasEdge(id3);
    }
    /**
     * <zh/> 判断图中是否存在指定组合
     * <en/> Determine whether a specified combo exists in the graph
     * @param {ID} id
     * @returns  {boolean}
     * @remarks <zh/> 判断图中是否存在指定组合,避免在不存在的组合上进行操作
     * <en/> Determine whether a specified combo exists in the graph and avoid operating on non-existent combos
     */
    hasCombo(id3) {
      return this.context.model.hasCombo(id3);
    }
    getElementData(ids) {
      if (Array.isArray(ids))
        return ids.map((id3) => this.context.model.getElementDataById(id3));
      return this.context.model.getElementDataById(ids);
    }
    getNodeData(id3) {
      if (id3 === void 0)
        return this.context.model.getNodeData();
      if (Array.isArray(id3))
        return this.context.model.getNodeData(id3);
      return this.context.model.getNodeLikeDatum(id3);
    }
    getEdgeData(id3) {
      if (id3 === void 0)
        return this.context.model.getEdgeData();
      if (Array.isArray(id3))
        return this.context.model.getEdgeData(id3);
      return this.context.model.getEdgeDatum(id3);
    }
    getComboData(id3) {
      if (id3 === void 0)
        return this.context.model.getComboData();
      if (Array.isArray(id3))
        return this.context.model.getComboData(id3);
      return this.context.model.getNodeLikeDatum(id3);
    }
    /**
     * <zh/> 设置全量数据
     *
     * <en/> Set full data
     * @param data - <zh/> 数据 | <en/> data
     * @remarks
     * <zh/> 设置全量数据会替换当前图中的所有数据，G6 会自动进行数据差异计算
     *
     * <en/> Setting full data will replace all data in the current graph, and G6 will automatically calculate the data difference
     * @apiCategory data
     */
    setData(data2) {
      this.context.model.setData((0, import_util207.isFunction)(data2) ? data2(this.getData()) : data2);
    }
    /**
     * <zh/> 新增元素数据
     *
     * <en/> Add element data
     * @param data - <zh/> 元素数据 | <en/> element data
     * @example
     * ```ts
     * graph.addData({
     *  nodes: [{ id: 'node-1' }, { id: 'node-2' }],
     *  edges: [{ source: 'node-1', target: 'node-2' }],
     * });
     * ```
     * @apiCategory data
     */
    addData(data2) {
      this.context.model.addData((0, import_util207.isFunction)(data2) ? data2(this.getData()) : data2);
    }
    /**
     * <zh/> 新增节点数据
     *
     * <en/> Add node data
     * @param data - <zh/> 节点数据 | <en/> node data
     * @example
     * ```ts
     * graph.addNodeData([{ id: 'node-1' }, { id: 'node-2' }]);
     * ```
     * @apiCategory data
     */
    addNodeData(data2) {
      this.context.model.addNodeData((0, import_util207.isFunction)(data2) ? data2(this.getNodeData()) : data2);
    }
    /**
     * <zh/> 新增边数据
     *
     * <en/> Add edge data
     * @param data - <zh/> 边数据 | <en/> edge data
     * @example
     * ```ts
     * graph.addEdgeData([{ source: 'node-1', target: 'node-2' }]);
     * ```
     * @apiCategory data
     */
    addEdgeData(data2) {
      this.context.model.addEdgeData((0, import_util207.isFunction)(data2) ? data2(this.getEdgeData()) : data2);
    }
    /**
     * <zh/> 新增组合数据
     *
     * <en/> Add combo data
     * @param data - <zh/> 组合数据 | <en/> combo data
     * @example
     * ```ts
     * graph.addComboData([{ id: 'combo-1' }]);
     * ```
     * @apiCategory data
     */
    addComboData(data2) {
      this.context.model.addComboData((0, import_util207.isFunction)(data2) ? data2(this.getComboData()) : data2);
    }
    /**
     * <zh/> 为树图节点添加子节点数据
     *
     * <en/> Add child node data to the tree node
     * @param parentId - <zh/> 父节点 ID | <en/> parent node ID
     * @param childrenData - <zh/> 子节点数据 | <en/> child node data
     * @remarks
     * <zh/> 为组合添加子节点使用 addNodeData / addComboData 方法
     *
     * <en/> Use addNodeData / addComboData method to add child nodes to the combo
     * @apiCategory data
     */
    addChildrenData(parentId, childrenData) {
      this.context.model.addChildrenData(parentId, childrenData);
    }
    /**
     * <zh/> 更新元素数据
     *
     * <en/> Update element data
     * @param data - <zh/> 元素数据 | <en/> element data
     * @remarks
     * <zh/> 只需要传入需要更新的数据即可，不必传入完整的数据
     *
     * <en/> Just pass in the data that needs to be updated, no need to pass in the complete data
     * @example
     * ```ts
     * graph.updateData({
     *   nodes: [{ id: 'node-1', style: { x: 100, y: 100 } }],
     *   edges: [{ id: 'edge-1', style: { lineWidth: 2 } }]
     * });
     * ```
     * @apiCategory data
     */
    updateData(data2) {
      this.context.model.updateData((0, import_util207.isFunction)(data2) ? data2(this.getData()) : data2);
    }
    /**
     * <zh/> 更新节点数据
     *
     * <en/> Update node data
     * @param data - <zh/> 节点数据 | <en/> node data
     * @remarks
     * <zh/> 只需要传入需要更新的数据即可，不必传入完整的数据
     *
     * <en/> Just pass in the data that needs to be updated, no need to pass in the complete data
     * @example
     * ```ts
     * graph.updateNodeData([{ id: 'node-1', style: { x: 100, y: 100 } }]);
     * ```
     * @apiCategory data
     */
    updateNodeData(data2) {
      this.context.model.updateNodeData((0, import_util207.isFunction)(data2) ? data2(this.getNodeData()) : data2);
    }
    /**
     * <zh/> 更新边数据
     *
     * <en/> Update edge data
     * @param data - <zh/> 边数据 | <en/> edge data
     * @remarks
     * <zh/> 只需要传入需要更新的数据即可，不必传入完整的数据
     *
     * <en/> Just pass in the data that needs to be updated, no need to pass in the complete data
     * @example
     * ```ts
     * graph.updateEdgeData([{ id: 'edge-1', style: { lineWidth: 2 } }]);
     * ```
     * @apiCategory data
     */
    updateEdgeData(data2) {
      this.context.model.updateEdgeData((0, import_util207.isFunction)(data2) ? data2(this.getEdgeData()) : data2);
    }
    /**
     * <zh/> 更新组合数据
     *
     * <en/> Update combo data
     * @param data - <zh/> 组合数据 | <en/> combo data
     * @remarks
     * <zh/> 只需要传入需要更新的数据即可，不必传入完整的数据
     *
     * <en/> Just pass in the data that needs to be updated, no need to pass in the complete data
     * @example
     * ```ts
     * graph.updateComboData([{ id: 'combo-1', style: { x: 100, y: 100 } }]);
     * ```
     * @apiCategory data
     */
    updateComboData(data2) {
      this.context.model.updateComboData((0, import_util207.isFunction)(data2) ? data2(this.getComboData()) : data2);
    }
    /**
     * <zh/> 删除元素数据
     *
     * <en/> Remove element data
     * @param ids - <zh/> 元素 ID 数组 | <en/> element ID array
     * @example
     * ```ts
     * graph.removeData({
     *   nodes: ['node-1', 'node-2'],
     *   edges: ['edge-1'],
     * });
     * ```
     * @apiCategory data
     */
    removeData(ids) {
      this.context.model.removeData((0, import_util207.isFunction)(ids) ? ids(this.getData()) : ids);
    }
    /**
     * <zh/> 删除节点数据
     *
     * <en/> Remove node data
     * @param ids - <zh/> 节点 ID 数组 | <en/> node ID array
     * @example
     * ```ts
     * graph.removeNodeData(['node-1', 'node-2']);
     * ```
     * @apiCategory data
     */
    removeNodeData(ids) {
      this.context.model.removeNodeData((0, import_util207.isFunction)(ids) ? ids(this.getNodeData()) : ids);
    }
    /**
     * <zh/> 删除边数据
     *
     * <en/> Remove edge data
     * @param ids - <zh/> 边 ID 数组 | <en/> edge ID array
     * @remarks
     * <zh/> 如果传入边数据时仅提供了 source 和 target，那么需要通过 `idOf` 方法获取边的实际 ID
     *
     * <en/> If only the source and target are provided when passing in the edge data, you need to get the actual ID of the edge through the `idOf` method
     * @example
     * ```ts
     * graph.removeEdgeData(['edge-1']);
     * ```
     * @apiCategory data
     */
    removeEdgeData(ids) {
      this.context.model.removeEdgeData((0, import_util207.isFunction)(ids) ? ids(this.getEdgeData()) : ids);
    }
    /**
     * <zh/> 删除组合数据
     *
     * <en/> Remove combo data
     * @param ids - <zh/> 组合 ID 数组 | <en/> 组合 ID array
     * @example
     * ```ts
     * graph.removeComboData(['combo-1']);
     * ```
     * @apiCategory data
     */
    removeComboData(ids) {
      this.context.model.removeComboData((0, import_util207.isFunction)(ids) ? ids(this.getComboData()) : ids);
    }
    /**
     * <zh/> 获取元素类型
     *
     * <en/> Get element type
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @returns <zh/> 元素类型 | <en/> element type
     * @apiCategory element
     */
    getElementType(id3) {
      return this.context.model.getElementType(id3);
    }
    /**
     * <zh/> 获取节点或组合关联边的数据
     *
     * <en/> Get edge data related to the node or combo
     * @param id - <zh/> 节点或组合ID | <en/> node or combo ID
     * @param direction - <zh/> 边的方向 | <en/> edge direction
     * @returns <zh/> 边数据 | <en/> edge data
     * @apiCategory data
     */
    getRelatedEdgesData(id3, direction2 = "both") {
      return this.context.model.getRelatedEdgesData(id3, direction2);
    }
    /**
     * <zh/> 获取节点或组合的一跳邻居节点数据
     *
     * <en/> Get the one-hop neighbor node data of the node or combo
     * @param id - <zh/> 节点或组合ID | <en/> node or combo ID
     * @returns <zh/> 邻居节点数据 | <en/> neighbor node data
     * @apiCategory data
     */
    getNeighborNodesData(id3) {
      return this.context.model.getNeighborNodesData(id3);
    }
    /**
     * <zh/> 获取节点或组合的祖先元素数据
     *
     * <en/> Get the ancestor element data of the node or combo
     * @param id - <zh/> 节点或组合ID | <en/> node or combo ID
     * @param hierarchy - <zh/> 指定树图层级关系还是组合层级关系 | <en/> specify tree or combo hierarchy relationship
     * @returns <zh/> 祖先元素数据 | <en/> ancestor element data
     * @remarks
     * <zh/> 数组中的顺序是从父节点到祖先节点
     *
     * <en/> The order in the array is from the parent node to the ancestor node
     * @apiCategory data
     */
    getAncestorsData(id3, hierarchy) {
      return this.context.model.getAncestorsData(id3, hierarchy);
    }
    /**
     * <zh/> 获取节点或组合的父元素数据
     *
     * <en/> Get the parent element data of the node or combo
     * @param id - <zh/> 节点或组合ID | <en/> node or combo ID
     * @param hierarchy - <zh/> 指定树图层级关系还是组合层级关系 | <en/> specify tree or combo hierarchy relationship
     * @returns <zh/> 父元素数据 | <en/> parent element data
     * @apiCategory data
     */
    getParentData(id3, hierarchy) {
      return this.context.model.getParentData(id3, hierarchy);
    }
    /**
     * <zh/> 获取节点或组合的子元素数据
     *
     * <en/> Get the child element data of the node or combo
     * @param id - <zh/> 节点或组合ID | <en/> node or combo ID
     * @returns <zh/> 子元素数据 | <en/> child element data
     * @apiCategory data
     */
    getChildrenData(id3) {
      return this.context.model.getChildrenData(id3);
    }
    /**
     * <zh/> 获取节点或组合的后代元素数据
     *
     * <en/> Get the descendant element data of the node or combo
     * @param id - <zh/> 节点或组合ID | <en/> node or combo ID
     * @returns <zh/> 后代元素数据 | <en/> descendant element data
     * @apiCategory data
     */
    getDescendantsData(id3) {
      return this.context.model.getDescendantsData(id3);
    }
    getElementDataByState(elementType, state) {
      return this.context.model.getElementDataByState(elementType, state);
    }
    initCanvas() {
      return __awaiter27(this, void 0, void 0, function* () {
        var _a2;
        if (this.context.canvas)
          return yield this.context.canvas.ready;
        const { container = "container", width: width2, height, renderer, cursor, background, canvas: canvasOptions, devicePixelRatio = (_a2 = globalThis.devicePixelRatio) !== null && _a2 !== void 0 ? _a2 : 1 } = this.options;
        if (container instanceof Canvas2) {
          this.context.canvas = container;
          if (cursor)
            container.setCursor(cursor);
          if (renderer)
            container.setRenderer(renderer);
          yield container.ready;
        } else {
          const $container = (0, import_util207.isString)(container) ? document.getElementById(container) : container;
          const containerSize = sizeOf($container);
          this.emit(GraphEvent.BEFORE_CANVAS_INIT, { container: $container, width: width2, height });
          const options = Object.assign(Object.assign({}, canvasOptions), {
            container: $container,
            width: width2 || containerSize[0],
            height: height || containerSize[1],
            background,
            renderer,
            cursor,
            devicePixelRatio
          });
          const canvas2 = new Canvas2(options);
          this.context.canvas = canvas2;
          yield canvas2.ready;
          this.emit(GraphEvent.AFTER_CANVAS_INIT, { canvas: canvas2 });
        }
      });
    }
    updateCanvas(options) {
      var _a2, _b;
      const { renderer, cursor, height, width: width2 } = options;
      const canvas2 = this.context.canvas;
      if (!canvas2)
        return;
      if (renderer) {
        this.emit(GraphEvent.BEFORE_RENDERER_CHANGE, { renderer: this.options.renderer });
        canvas2.setRenderer(renderer);
        this.emit(GraphEvent.AFTER_RENDERER_CHANGE, { renderer });
      }
      if (cursor)
        canvas2.setCursor(cursor);
      if ((0, import_util207.isNumber)(width2) || (0, import_util207.isNumber)(height))
        this.setSize((_a2 = width2 !== null && width2 !== void 0 ? width2 : this.options.width) !== null && _a2 !== void 0 ? _a2 : 0, (_b = height !== null && height !== void 0 ? height : this.options.height) !== null && _b !== void 0 ? _b : 0);
    }
    initRuntime() {
      this.context.options = this.options;
      if (!this.context.batch)
        this.context.batch = new BatchController(this.context);
      if (!this.context.plugin)
        this.context.plugin = new PluginController(this.context);
      if (!this.context.viewport)
        this.context.viewport = new ViewportController(this.context);
      if (!this.context.transform)
        this.context.transform = new TransformController(this.context);
      if (!this.context.element)
        this.context.element = new ElementController(this.context);
      if (!this.context.animation)
        this.context.animation = new Animation2(this.context);
      if (!this.context.layout)
        this.context.layout = new LayoutController(this.context);
      if (!this.context.behavior)
        this.context.behavior = new BehaviorController(this.context);
    }
    prepare() {
      return __awaiter27(this, void 0, void 0, function* () {
        yield Promise.resolve();
        if (this.destroyed) {
          console.error(format("The graph instance has been destroyed"));
          return;
        }
        yield this.initCanvas();
        this.initRuntime();
      });
    }
    /**
     * <zh/> 执行渲染
     *
     * <en/> Render
     * @remarks
     * <zh/> 此过程会执行数据更新、绘制元素、执行布局
     *
     * > ⚠️ render 为异步方法，如果需要在 render 后执行一些操作，可以使用 `await graph.render()` 或者监听 GraphEvent.AFTER_RENDER 事件
     *
     * <en/> This process will execute data update, element rendering, and layout execution
     *
     * > ⚠️ render is an asynchronous method. If you need to perform some operations after render, you can use `await graph.render()` or listen to the GraphEvent.AFTER_RENDER event
     * @apiCategory render
     */
    render() {
      return __awaiter27(this, void 0, void 0, function* () {
        yield this.prepare();
        emit(this, new GraphLifeCycleEvent(GraphEvent.BEFORE_RENDER));
        if (!this.options.layout) {
          const animation = this.context.element.draw({ type: "render" });
          yield Promise.all([animation === null || animation === void 0 ? void 0 : animation.finished, this.autoFit()]);
        } else if (!this.rendered && isPreLayout(this.options.layout)) {
          const animation = yield this.context.element.preLayoutDraw({ type: "render" });
          yield Promise.all([animation === null || animation === void 0 ? void 0 : animation.finished, this.autoFit()]);
        } else {
          const animation = this.context.element.draw({ type: "render" });
          yield Promise.all([animation === null || animation === void 0 ? void 0 : animation.finished, this.context.layout.postLayout()]);
          yield this.autoFit();
        }
        this.rendered = true;
        emit(this, new GraphLifeCycleEvent(GraphEvent.AFTER_RENDER));
      });
    }
    /**
     * <zh/> 绘制元素
     *
     * <en/> Draw elements
     * @returns <zh/> 渲染结果 | <en/> draw result
     * @remarks
     * <zh/> 仅执行元素绘制，不会重新布局
     *
     * <zh/> ⚠️ draw 为异步方法，如果需要在 draw 后执行一些操作，可以使用 `await graph.draw()` 或者监听 GraphEvent.AFTER_DRAW 事件
     *
     * <en/> Only execute element drawing, no re-layout
     *
     * <en/> ⚠️ draw is an asynchronous method. If you need to perform some operations after draw, you can use `await graph.draw()` or listen to the GraphEvent.AFTER_DRAW event
     * @apiCategory render
     */
    draw() {
      return __awaiter27(this, void 0, void 0, function* () {
        var _a2;
        yield this.prepare();
        yield (_a2 = this.context.element.draw()) === null || _a2 === void 0 ? void 0 : _a2.finished;
      });
    }
    /**
     * <zh/> 执行布局
     *
     * <en/> Execute layout
     * @param layoutOptions - <zh/> 布局配置项 | <en/> Layout options
     * @apiCategory layout
     */
    layout(layoutOptions) {
      return __awaiter27(this, void 0, void 0, function* () {
        yield this.context.layout.postLayout(layoutOptions);
      });
    }
    /**
     * <zh/> 停止布局
     *
     * <en/> Stop layout
     * @remarks
     * <zh/> 适用于带有迭代动画的布局，目前有 `force` 属于此类布局，即停止力导布局的迭代，一般用于布局迭代时间过长情况下的手动停止迭代动画，例如在点击画布/节点的监听中调用
     *
     * <en/> Suitable for layouts with iterative animations. Currently, `force` belongs to this type of layout, that is, stop the iteration of the force-directed layout. It is generally used to manually stop the iteration animation when the layout iteration time is too long, such as calling in the click canvas/node listener
     * @apiCategory layout
     */
    stopLayout() {
      this.context.layout.stopLayout();
    }
    /**
     * <zh/> 清空画布元素
     *
     * <en/> Clear canvas elements
     * @apiCategory canvas
     */
    clear() {
      return __awaiter27(this, void 0, void 0, function* () {
        const { model, element } = this.context;
        model.setData({});
        model.clearChanges();
        element === null || element === void 0 ? void 0 : element.clear();
      });
    }
    /**
     * <zh/> 销毁当前图实例
     *
     * <en/> Destroy the current graph instance
     * @remarks
     * <zh/> 销毁后无法进行任何操作，如果需要重新使用，需要重新创建一个新的图实例
     *
     * <en/> After destruction, no operations can be performed. If you need to reuse it, you need to create a new graph instance
     * @apiCategory instance
     */
    destroy() {
      var _a2;
      emit(this, new GraphLifeCycleEvent(GraphEvent.BEFORE_DESTROY));
      const { layout: layout2, animation, element, model, canvas: canvas2, behavior, plugin } = this.context;
      plugin === null || plugin === void 0 ? void 0 : plugin.destroy();
      behavior === null || behavior === void 0 ? void 0 : behavior.destroy();
      layout2 === null || layout2 === void 0 ? void 0 : layout2.destroy();
      animation === null || animation === void 0 ? void 0 : animation.destroy();
      element === null || element === void 0 ? void 0 : element.destroy();
      model.destroy();
      canvas2 === null || canvas2 === void 0 ? void 0 : canvas2.destroy();
      this.options = {};
      this.context = {};
      this.off();
      (_a2 = globalThis.removeEventListener) === null || _a2 === void 0 ? void 0 : _a2.call(globalThis, "resize", this.onResize);
      this.destroyed = true;
      emit(this, new GraphLifeCycleEvent(GraphEvent.AFTER_DESTROY));
    }
    /**
     * <zh/> 获取画布实例
     *
     * <en/> Get canvas instance
     * @returns - <zh/> 画布实例 | <en/> canvas instance
     * @apiCategory canvas
     */
    getCanvas() {
      return this.context.canvas;
    }
    resize(width2, height) {
      var _a2;
      const containerSize = sizeOf((_a2 = this.context.canvas) === null || _a2 === void 0 ? void 0 : _a2.getContainer());
      const specificSize = [width2 || containerSize[0], height || containerSize[1]];
      if (!this.context.canvas)
        return;
      const canvasSize = this.context.canvas.getSize();
      if ((0, import_util207.isEqual)(specificSize, canvasSize))
        return;
      emit(this, new GraphLifeCycleEvent(GraphEvent.BEFORE_SIZE_CHANGE, { size: specificSize }));
      this.context.canvas.resize(...specificSize);
      emit(this, new GraphLifeCycleEvent(GraphEvent.AFTER_SIZE_CHANGE, { size: specificSize }));
    }
    /**
     * <zh/> 将图缩放至合适大小并平移至视口中心
     *
     * <en/> Zoom the graph to fit the viewport and move it to the center of the viewport
     * @param options - <zh/> 适配配置 | <en/> fit options
     * @param animation - <zh/> 动画配置 | <en/> animation options
     * @apiCategory viewport
     */
    fitView(options, animation) {
      return __awaiter27(this, void 0, void 0, function* () {
        var _a2;
        yield (_a2 = this.context.viewport) === null || _a2 === void 0 ? void 0 : _a2.fitView(options, animation);
      });
    }
    /**
     * <zh/> 将图平移至视口中心
     *
     * <en/> Move the graph to the center of the viewport
     * @param animation - <zh/> 动画配置 | <en/> animation options
     * @apiCategory viewport
     */
    fitCenter(animation) {
      return __awaiter27(this, void 0, void 0, function* () {
        var _a2;
        yield (_a2 = this.context.viewport) === null || _a2 === void 0 ? void 0 : _a2.fitCenter({ animation });
      });
    }
    autoFit() {
      return __awaiter27(this, void 0, void 0, function* () {
        const { autoFit } = this.context.options;
        if (!autoFit)
          return;
        if ((0, import_util207.isString)(autoFit)) {
          if (autoFit === "view")
            yield this.fitView();
          else if (autoFit === "center")
            yield this.fitCenter();
        } else {
          const { type, animation } = autoFit;
          if (type === "view")
            yield this.fitView(autoFit.options, animation);
          else if (type === "center")
            yield this.fitCenter(animation);
        }
      });
    }
    /**
     * <zh/> 聚焦元素
     *
     * <en/> Focus on element
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @param animation - <zh/> 动画配置 | <en/> animation options
     * @remarks
     * <zh/> 移动图，使得元素对齐到视口中心
     *
     * <en/> Move the graph so that the element is aligned to the center of the viewport
     * @apiCategory viewport
     */
    focusElement(id3, animation) {
      return __awaiter27(this, void 0, void 0, function* () {
        var _a2;
        yield (_a2 = this.context.viewport) === null || _a2 === void 0 ? void 0 : _a2.focusElements(Array.isArray(id3) ? id3 : [id3], { animation });
      });
    }
    /**
     * <zh/> 基于当前缩放比例进行缩放（相对缩放）
     *
     * <en/> Zoom based on the current zoom ratio (relative zoom)
     * @param ratio - <zh/> 缩放比例 | <en/> zoom ratio
     * @param animation - <zh/> 动画配置 | <en/> animation options
     * @param origin - <zh/> 缩放中心(视口坐标) | <en/> zoom center(viewport coordinates)
     * @remarks
     * <zh/>
     * - ratio > 1 放大
     * - ratio < 1 缩小
     *
     * <en/>
     * - ratio > 1 zoom in
     * - ratio < 1 zoom out
     * @apiCategory viewport
     */
    zoomBy(ratio, animation, origin) {
      return __awaiter27(this, void 0, void 0, function* () {
        yield this.context.viewport.transform({ mode: "relative", scale: ratio, origin }, animation);
      });
    }
    /**
     * <zh/> 缩放画布至指定比例（绝对缩放）
     *
     * <en/> Zoom the canvas to the specified ratio (absolute zoom)
     * @param zoom - <zh/> 指定缩放比例 | <en/> specified zoom ratio
     * @param animation - <zh/> 动画配置 | <en/> animation options
     * @param origin - <zh/> 缩放中心(视口坐标) | <en/> zoom center(viewport coordinates)
     * @remarks
     * <zh/>
     * - zoom = 1 默认大小
     * - zoom > 1 放大
     * - zoom < 1 缩小
     *
     * <en/>
     * - zoom = 1 default size
     * - zoom > 1 zoom in
     * - zoom < 1 zoom out
     * @apiCategory viewport
     */
    zoomTo(zoom, animation, origin) {
      return __awaiter27(this, void 0, void 0, function* () {
        yield this.context.viewport.transform({ mode: "absolute", scale: zoom, origin }, animation);
      });
    }
    /**
     * <zh/> 获取当前缩放比例
     *
     * <en/> Get the current zoom ratio
     * @returns <zh/> 缩放比例 | <en/> zoom ratio
     * @apiCategory viewport
     */
    getZoom() {
      return this.context.viewport.getZoom();
    }
    /**
     * <zh/> 基于当前旋转角度进行旋转（相对旋转）
     *
     * <en/> Rotate based on the current rotation angle (relative rotation)
     * @param angle - <zh/> 旋转角度 | <en/> rotation angle
     * @param animation - <zh/> 动画配置 | <en/> animation options
     * @param origin - <zh/> 旋转中心(视口坐标) | <en/> rotation center(viewport coordinates)
     * @apiCategory viewport
     */
    rotateBy(angle2, animation, origin) {
      return __awaiter27(this, void 0, void 0, function* () {
        yield this.context.viewport.transform({ mode: "relative", rotate: angle2, origin }, animation);
      });
    }
    /**
     * <zh/> 旋转画布至指定角度 (绝对旋转)
     *
     * <en/> Rotate the canvas to the specified angle (absolute rotation)
     * @param angle - <zh/> 目标角度 | <en/> target angle
     * @param animation - <zh/> 动画配置 | <en/> animation options
     * @param origin - <zh/> 旋转中心(视口坐标) | <en/> rotation center(viewport coordinates)
     * @apiCategory viewport
     */
    rotateTo(angle2, animation, origin) {
      return __awaiter27(this, void 0, void 0, function* () {
        yield this.context.viewport.transform({ mode: "absolute", rotate: angle2, origin }, animation);
      });
    }
    /**
     * <zh/> 获取当前旋转角度
     *
     * <en/> Get the current rotation angle
     * @returns <zh/> 旋转角度 | <en/> rotation angle
     * @apiCategory viewport
     */
    getRotation() {
      return this.context.viewport.getRotation();
    }
    /**
     * <zh/> 将图平移指定距离 (相对平移)
     *
     * <en/> Translate the graph by the specified distance (relative translation)
     * @param offset - <zh/> 偏移量 | <en/> offset
     * @param animation - <zh/> 动画配置 | <en/> animation options
     * @apiCategory viewport
     */
    translateBy(offset, animation) {
      return __awaiter27(this, void 0, void 0, function* () {
        yield this.context.viewport.transform({ mode: "relative", translate: offset }, animation);
      });
    }
    /**
     * <zh/> 将图平移至指定位置 (绝对平移)
     *
     * <en/> Translate the graph to the specified position (absolute translation)
     * @param position - <zh/> 指定位置 | <en/> specified position
     * @param animation - <zh/> 动画配置 | <en/> animation options
     * @apiCategory viewport
     */
    translateTo(position2, animation) {
      return __awaiter27(this, void 0, void 0, function* () {
        yield this.context.viewport.transform({ mode: "absolute", translate: position2 }, animation);
      });
    }
    /**
     * <zh/> 获取图的位置
     *
     * <en/> Get the position of the graph
     * @returns <zh/> 图的位置 | <en/> position of the graph
     * @remarks
     * <zh/> 即画布原点在视口坐标系下的位置。默认状态下，图的位置为 [0, 0]
     *
     * <en/> That is, the position of the canvas origin in the viewport coordinate system. By default, the position of the graph is [0, 0]
     * @apiCategory viewport
     */
    getPosition() {
      return subtract([0, 0], this.getCanvasByViewport([0, 0]));
    }
    translateElementBy(args1_1, args2_1) {
      return __awaiter27(this, arguments, void 0, function* (args1, args2, args3 = true) {
        var _a2, _b;
        const [config, animation] = (0, import_util207.isObject)(args1) ? [args1, (_a2 = args2) !== null && _a2 !== void 0 ? _a2 : true] : [{ [args1]: args2 }, args3];
        Object.entries(config).forEach(([id3, offset]) => this.context.model.translateNodeLikeBy(id3, offset));
        yield (_b = this.context.element.draw({ animation, stage: "translate" })) === null || _b === void 0 ? void 0 : _b.finished;
      });
    }
    translateElementTo(args1_1, args2_1) {
      return __awaiter27(this, arguments, void 0, function* (args1, args2, args3 = true) {
        var _a2, _b;
        const [config, animation] = (0, import_util207.isObject)(args1) ? [args1, (_a2 = args2) !== null && _a2 !== void 0 ? _a2 : true] : [{ [args1]: args2 }, args3];
        Object.entries(config).forEach(([id3, position2]) => this.context.model.translateNodeLikeTo(id3, position2));
        yield (_b = this.context.element.draw({ animation, stage: "translate" })) === null || _b === void 0 ? void 0 : _b.finished;
      });
    }
    /**
     * <zh/> 获取元素位置
     *
     * <en/> Get element position
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @returns <zh/> 元素位置 | <en/> element position
     * @apiCategory element
     */
    getElementPosition(id3) {
      return this.context.model.getElementPosition(id3);
    }
    /**
     * <zh/> 获取元素渲染样式
     *
     * <en/> Get element rendering style
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @returns <zh/> 元素渲染样式 | <en/> element rendering style
     * @apiCategory element
     */
    getElementRenderStyle(id3) {
      return (0, import_util207.omit)(this.context.element.getElement(id3).attributes, ["context"]);
    }
    setElementVisibility(args1_1, args2_1) {
      return __awaiter27(this, arguments, void 0, function* (args1, args2, args3 = true) {
        var _a2, _b;
        const [config, animation] = (0, import_util207.isObject)(args1) ? [args1, (_a2 = args2) !== null && _a2 !== void 0 ? _a2 : true] : [{ [args1]: args2 }, args3];
        const dataToUpdate = { nodes: [], edges: [], combos: [] };
        Object.entries(config).forEach(([id3, value]) => {
          const elementType = this.getElementType(id3);
          dataToUpdate[`${elementType}s`].push({ id: id3, style: { visibility: value } });
        });
        const { model, element } = this.context;
        model.preventUpdateNodeLikeHierarchy(() => {
          model.updateData(dataToUpdate);
        });
        yield (_b = element.draw({ animation, stage: "visibility" })) === null || _b === void 0 ? void 0 : _b.finished;
      });
    }
    /**
     * <zh/> 显示元素
     *
     * <en/> Show element
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @param animation - <zh/> 是否启用动画 | <en/> whether to enable animation
     * @apiCategory element
     */
    showElement(id3, animation) {
      return __awaiter27(this, void 0, void 0, function* () {
        const ids = Array.isArray(id3) ? id3 : [id3];
        yield this.setElementVisibility(Object.fromEntries(ids.map((_id) => [_id, "visible"])), animation);
      });
    }
    /**
     * <zh/> 隐藏元素
     *
     * <en/> Hide element
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @param animation - <zh/> 是否启用动画 | <en/> whether to enable animation
     * @apiCategory element
     */
    hideElement(id3, animation) {
      return __awaiter27(this, void 0, void 0, function* () {
        const ids = Array.isArray(id3) ? id3 : [id3];
        yield this.setElementVisibility(Object.fromEntries(ids.map((_id) => [_id, "hidden"])), animation);
      });
    }
    /**
     * <zh/> 获取元素可见性
     *
     * <en/> Get element visibility
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @returns <zh/> 元素可见性 | <en/> element visibility
     * @apiCategory element
     */
    getElementVisibility(id3) {
      var _a2, _b;
      const element = this.context.element.getElement(id3);
      return (_b = (_a2 = element === null || element === void 0 ? void 0 : element.style) === null || _a2 === void 0 ? void 0 : _a2.visibility) !== null && _b !== void 0 ? _b : "visible";
    }
    setElementZIndex(args1, args2) {
      return __awaiter27(this, void 0, void 0, function* () {
        var _a2;
        const dataToUpdate = { nodes: [], edges: [], combos: [] };
        const config = (0, import_util207.isObject)(args1) ? args1 : { [args1]: args2 };
        Object.entries(config).forEach(([id3, value]) => {
          const elementType = this.getElementType(id3);
          dataToUpdate[`${elementType}s`].push({ id: id3, style: { zIndex: value } });
        });
        const { model, element } = this.context;
        model.preventUpdateNodeLikeHierarchy(() => model.updateData(dataToUpdate));
        yield (_a2 = element.draw({ animation: false, stage: "zIndex" })) === null || _a2 === void 0 ? void 0 : _a2.finished;
      });
    }
    /**
     * <zh/> 将元素置于最顶层
     *
     * <en/> Bring the element to the front
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @apiCategory element
     */
    frontElement(id3) {
      return __awaiter27(this, void 0, void 0, function* () {
        const ids = Array.isArray(id3) ? id3 : [id3];
        const { model } = this.context;
        const zIndexes = {};
        ids.map((_id) => {
          const zIndex = model.getFrontZIndex(_id);
          const elementType = model.getElementType(_id);
          if (elementType === "combo") {
            const ancestor = model.getAncestorsData(_id, COMBO_KEY).at(-1) || this.getComboData(_id);
            const descendants = [ancestor, ...model.getDescendantsData(idOf(ancestor))];
            const delta = zIndex - getZIndexOf(ancestor);
            descendants.forEach((combo) => {
              zIndexes[idOf(combo)] = this.getElementZIndex(idOf(combo)) + delta;
            });
            const { internal } = getSubgraphRelatedEdges(descendants.map(idOf), (id4) => model.getRelatedEdgesData(id4));
            internal.forEach((edge) => {
              const edgeId = idOf(edge);
              zIndexes[edgeId] = this.getElementZIndex(edgeId) + delta;
            });
          } else
            zIndexes[_id] = zIndex;
        });
        yield this.setElementZIndex(zIndexes);
      });
    }
    /**
     * <zh/> 获取元素层级
     *
     * <en/> Get element z-index
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @returns <zh/> 元素层级 | <en/> element z-index
     * @apiCategory element
     */
    getElementZIndex(id3) {
      return getZIndexOf(this.context.model.getElementDataById(id3));
    }
    setElementState(args1_1, args2_1) {
      return __awaiter27(this, arguments, void 0, function* (args1, args2, args3 = true) {
        var _a2, _b;
        const [config, animation] = (0, import_util207.isObject)(args1) ? [args1, (_a2 = args2) !== null && _a2 !== void 0 ? _a2 : true] : [{ [args1]: args2 }, args3];
        const parseState = (state) => {
          if (!state)
            return [];
          return Array.isArray(state) ? state : [state];
        };
        const dataToUpdate = { nodes: [], edges: [], combos: [] };
        Object.entries(config).forEach(([id3, value]) => {
          const elementType = this.getElementType(id3);
          dataToUpdate[`${elementType}s`].push({ id: id3, states: parseState(value) });
        });
        this.updateData(dataToUpdate);
        yield (_b = this.context.element.draw({ animation, stage: "state" })) === null || _b === void 0 ? void 0 : _b.finished;
      });
    }
    /**
     * <zh/> 获取元素状态
     *
     * <en/> Get element state
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @returns <zh/> 元素状态 | <en/> element state
     * @apiCategory element
     */
    getElementState(id3) {
      return this.context.model.getElementState(id3);
    }
    /**
     * <zh/> 获取元素自身以及子节点在世界坐标系下的渲染包围盒
     *
     * <en/> Get the rendering bounding box of the element itself and its child nodes in the world coordinate system
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @returns <zh/> 渲染包围盒 | <en/> render bounding box
     * @apiCategory element
     */
    getElementRenderBounds(id3) {
      return this.context.element.getElement(id3).getRenderBounds();
    }
    /**
     * <zh/> 收起元素
     *
     * <en/> Collapse element
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @param options - <zh/> 是否启用动画或者配置收起节点的配置项 | <en/> whether to enable animation or the options of collapsing node
     * @apiCategory element
     */
    collapseElement(id_1) {
      return __awaiter27(this, arguments, void 0, function* (id3, options = true) {
        const { model, element } = this.context;
        if (isCollapsed(model.getNodeLikeData([id3])[0]))
          return;
        if (this.isCollapsingExpanding)
          return;
        if (typeof options === "boolean")
          options = { animation: options, align: true };
        const elementType = model.getElementType(id3);
        yield this.frontElement(id3);
        this.isCollapsingExpanding = true;
        model.updateData(elementType === "node" ? {
          nodes: [{ id: id3, style: { collapsed: true } }]
        } : {
          combos: [{ id: id3, style: { collapsed: true } }]
        });
        if (elementType === "node")
          yield element.collapseNode(id3, options);
        else if (elementType === "combo")
          yield element.collapseCombo(id3, !!options.animation);
        this.isCollapsingExpanding = false;
      });
    }
    /**
     * <zh/> 展开元素
     *
     * <en/> Expand Element
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @param animation - <zh/> 是否启用动画或者配置收起节点的配置项 | <en/> whether to enable animation or the options of collapsing node
     * @param options
     * @apiCategory element
     */
    expandElement(id_1) {
      return __awaiter27(this, arguments, void 0, function* (id3, options = true) {
        const { model, element } = this.context;
        if (!isCollapsed(model.getNodeLikeData([id3])[0]))
          return;
        if (this.isCollapsingExpanding)
          return;
        if (typeof options === "boolean")
          options = { animation: options, align: true };
        const elementType = model.getElementType(id3);
        this.isCollapsingExpanding = true;
        model.updateData(elementType === "node" ? {
          nodes: [{ id: id3, style: { collapsed: false } }]
        } : {
          combos: [{ id: id3, style: { collapsed: false } }]
        });
        if (elementType === "node")
          yield element.expandNode(id3, options);
        else if (elementType === "combo")
          yield element.expandCombo(id3, !!options.animation);
        this.isCollapsingExpanding = false;
      });
    }
    setElementCollapsibility(id3, collapsed) {
      const elementType = this.getElementType(id3);
      if (elementType === "node")
        this.updateNodeData([{ id: id3, style: { collapsed } }]);
      else if (elementType === "combo")
        this.updateComboData([{ id: id3, style: { collapsed } }]);
    }
    /**
     * <zh/> 导出画布内容为 DataURL
     *
     * <en/> Export canvas content as DataURL
     * @param options - <zh/> 导出配置 | <en/> export options
     * @returns <zh/> DataURL | <en/> DataURL
     * @apiCategory exportImage
     */
    toDataURL() {
      return __awaiter27(this, arguments, void 0, function* (options = {}) {
        return this.context.canvas.toDataURL(options);
      });
    }
    /**
     * <zh/> 给定的视窗 DOM 坐标，转换为画布上的绘制坐标
     *
     * <en/> Convert the given viewport DOM coordinates to the drawing coordinates on the canvas
     * @param point - <zh/> 视窗坐标 | <en/> viewport coordinates
     * @returns <zh/> 画布上的绘制坐标 | <en/> drawing coordinates on the canvas
     * @apiCategory viewport
     */
    getCanvasByViewport(point4) {
      return this.context.canvas.getCanvasByViewport(point4);
    }
    /**
     * <zh/> 给定画布上的绘制坐标，转换为视窗 DOM 的坐标
     *
     * <en/> Convert the given drawing coordinates on the canvas to the coordinates of the viewport DOM
     * @param point - <zh/> 画布坐标 | <en/> canvas coordinates
     * @returns <zh/> 视窗 DOM 的坐标 | <en/> coordinates of the viewport DOM
     * @apiCategory viewport
     */
    getViewportByCanvas(point4) {
      return this.context.canvas.getViewportByCanvas(point4);
    }
    /**
     * <zh/> 给定画布上的绘制坐标，转换为浏览器坐标
     *
     * <en/> Convert the given drawing coordinates on the canvas to browser coordinates
     * @param point - <zh/> 画布坐标 | <en/> canvas coordinates
     * @returns <zh/> 浏览器坐标 | <en/> browser coordinates
     * @apiCategory viewport
     */
    getClientByCanvas(point4) {
      return this.context.canvas.getClientByCanvas(point4);
    }
    /**
     * <zh/> 给定的浏览器坐标，转换为画布上的绘制坐标
     *
     * <en/> Convert the given browser coordinates to drawing coordinates on the canvas
     * @param point - <zh/> 浏览器坐标 | <en/> browser coordinates
     * @returns <zh/> 画布上的绘制坐标 | <en/> drawing coordinates on the canvas
     * @apiCategory viewport
     */
    getCanvasByClient(point4) {
      return this.context.canvas.getCanvasByClient(point4);
    }
    /**
     * <zh/> 获取视口中心的画布坐标
     *
     * <en/> Get the canvas coordinates of the viewport center
     * @returns <zh/> 视口中心的画布坐标 | <en/> Canvas coordinates of the viewport center
     * @apiCategory viewport
     */
    getViewportCenter() {
      return this.context.viewport.getViewportCenter();
    }
    /**
     * <zh/> 获取视口中心的视口坐标
     *
     * <en/> Get the viewport coordinates of the viewport center
     * @returns <zh/> 视口中心的视口坐标 | <en/> Viewport coordinates of the viewport center
     * @apiCategory viewport
     */
    getCanvasCenter() {
      return this.context.viewport.getCanvasCenter();
    }
    /**
     * <zh/> 监听事件
     *
     * <en/> Listen to events
     * @param eventName - <zh/> 事件名称 | <en/> event name
     * @param callback - <zh/> 回调函数 | <en/> callback function
     * @param once - <zh/> 是否只监听一次 | <en/> whether to listen only once
     * @returns <zh/> Graph 实例 | <en/> Graph instance
     * @apiCategory event
     */
    on(eventName, callback, once) {
      return super.on(eventName, callback, once);
    }
    /**
     * <zh/> 一次性监听事件
     *
     * <en/> Listen to events once
     * @param eventName - <zh/> 事件名称 | <en/> event name
     * @param callback - <zh/> 回调函数 | <en/> callback function
     * @returns <zh/> Graph 实例 | <en/> Graph instance
     * @apiCategory event
     */
    once(eventName, callback) {
      return super.once(eventName, callback);
    }
    off(eventName, callback) {
      return super.off(eventName, callback);
    }
  };
  Graph3.defaultOptions = {
    autoResize: false,
    theme: "light",
    rotation: 0,
    zoom: 1,
    zoomRange: [0.01, 10]
  };

  // node_modules/@antv/g6/esm/transforms/get-edge-actual-ends.js
  var GetEdgeActualEnds = class extends BaseTransform {
    beforeDraw(input) {
      const { add: add5, update } = input;
      const { model } = this.context;
      [...add5.edges.entries(), ...update.edges.entries()].forEach(([, edge]) => {
        getEdgeEndsContext(model, edge);
      });
      return input;
    }
  };
  var getEdgeEndsContext = (model, edge) => {
    const { source, target } = edge;
    const sourceNodeData = model.getElementDataById(source);
    const targetNodeData = model.getElementDataById(target);
    const actualSourceNode = findActualConnectNodeData(sourceNodeData, (id3) => model.getParentData(id3, COMBO_KEY));
    const actualTargetNode = findActualConnectNodeData(targetNodeData, (id3) => model.getParentData(id3, COMBO_KEY));
    const sourceNode = idOf(actualSourceNode);
    const targetNode = idOf(actualTargetNode);
    const ends = { sourceNode, targetNode };
    if (edge.style) {
      Object.assign(edge.style, ends);
    } else
      edge.style = ends;
    return edge;
  };

  // node_modules/@antv/g6/esm/transforms/map-node-size.js
  var import_util208 = __toESM(require_lib());

  // node_modules/@antv/g6/esm/utils/scale.js
  var linear4 = (value, domain, range) => {
    const [d0, d1] = domain;
    const [r0, r1] = range;
    if (d1 === d0)
      return r0;
    const ratio = (value - d0) / (d1 - d0);
    return r0 + ratio * (r1 - r0);
  };
  var log = (value, domain, range) => {
    const [d0, d1] = domain;
    const [r0, r1] = range;
    const ratio = Math.log(value - d0 + 1) / Math.log(d1 - d0 + 1);
    return r0 + ratio * (r1 - r0);
  };
  var pow = (value, domain, range, exponent = 2) => {
    const [d0, d1] = domain;
    const [r0, r1] = range;
    const ratio = Math.pow((value - d0) / (d1 - d0), exponent);
    return r0 + ratio * (r1 - r0);
  };
  var sqrt = (value, domain, range) => {
    const [d0, d1] = domain;
    const [r0, r1] = range;
    const ratio = Math.sqrt((value - d0) / (d1 - d0));
    return r0 + ratio * (r1 - r0);
  };

  // node_modules/@antv/g6/esm/transforms/map-node-size.js
  var MapNodeSize = class _MapNodeSize extends BaseTransform {
    constructor(context, options) {
      super(context, (0, import_util208.deepMix)({}, _MapNodeSize.defaultOptions, options));
      this.assignSizeByCentrality = (centrality, minCentrality, maxCentrality, minSize, maxSize, scale4) => {
        const domain = [minCentrality, maxCentrality];
        const rangeX = [minSize[0], maxSize[0]];
        const rangeY = [minSize[1], maxSize[1]];
        const rangeZ = [minSize[2], maxSize[2]];
        const interpolate3 = (centrality2, range) => {
          if (typeof scale4 === "function") {
            return scale4(centrality2, domain, range);
          }
          switch (scale4) {
            case "linear":
              return linear4(centrality2, domain, range);
            case "log":
              return log(centrality2, domain, range);
            case "pow":
              return pow(centrality2, domain, range, 2);
            case "sqrt":
              return sqrt(centrality2, domain, range);
            default:
              return range[0];
          }
        };
        return [interpolate3(centrality, rangeX), interpolate3(centrality, rangeY), interpolate3(centrality, rangeZ)];
      };
    }
    beforeDraw(input) {
      const { model } = this.context;
      const nodes = model.getNodeData();
      const maxSize = parseSize(this.options.maxSize);
      const minSize = parseSize(this.options.minSize);
      const centralities = this.getCentralities(this.options.centrality);
      const maxCentrality = centralities.size > 0 ? Math.max(...centralities.values()) : 0;
      const minCentrality = centralities.size > 0 ? Math.min(...centralities.values()) : 0;
      nodes.forEach((datum) => {
        var _a2;
        const size2 = this.assignSizeByCentrality(centralities.get(idOf(datum)) || 0, minCentrality, maxCentrality, minSize, maxSize, this.options.scale);
        const element = (_a2 = this.context.element) === null || _a2 === void 0 ? void 0 : _a2.getElement(idOf(datum));
        const style = { size: size2 };
        this.assignLabelStyle(style, size2, datum, element);
        if (!element || !isStyleEqual(style, element.attributes)) {
          reassignTo(input, element ? "update" : "add", "node", (0, import_util208.deepMix)(datum, { style }), true);
        }
      });
      return input;
    }
    assignLabelStyle(style, size2, datum, element) {
      var _a2;
      const configStyle = element ? element.config.style : (_a2 = this.context.element) === null || _a2 === void 0 ? void 0 : _a2.getElementComputedStyle("node", datum);
      Object.assign(style, (0, import_util208.pick)(configStyle, ["labelFontSize", "labelLineHeight"]));
      if (this.options.mapLabelSize) {
        const fontSize = this.getLabelSizeByNodeSize(size2, Infinity, Number(style.labelFontSize));
        Object.assign(style, {
          labelFontSize: fontSize,
          labelLineHeight: fontSize + getVerticalPadding(style.labelPadding)
        });
      }
      return style;
    }
    getLabelSizeByNodeSize(size2, defaultMaxFontSize, defaultMinFontSize) {
      const fontSize = Math.min(...size2) / 2;
      const [minFontSize, maxFontSize] = !Array.isArray(this.options.mapLabelSize) ? [defaultMinFontSize, defaultMaxFontSize] : this.options.mapLabelSize;
      return Math.min(maxFontSize, Math.max(fontSize, minFontSize));
    }
    getCentralities(centrality) {
      const { model } = this.context;
      const graphData = model.getData();
      if (typeof centrality === "function")
        return centrality(graphData);
      const getRelatedEdgesData = model.getRelatedEdgesData.bind(model);
      return getNodeCentralities(graphData, getRelatedEdgesData, centrality);
    }
  };
  MapNodeSize.defaultOptions = {
    centrality: { type: "degree" },
    maxSize: 80,
    minSize: 20,
    scale: "linear",
    mapLabelSize: false
  };

  // node_modules/@antv/g6/esm/transforms/place-radial-labels.js
  var PlaceRadialLabels = class _PlaceRadialLabels extends BaseTransform {
    constructor(context, options) {
      super(context, Object.assign({}, _PlaceRadialLabels.defaultOptions, options));
    }
    get ref() {
      return this.context.model.getRootsData()[0];
    }
    afterLayout() {
      var _a2;
      const refPoint = positionOf(this.ref);
      const { graph, model } = this.context;
      const data2 = model.getData();
      (_a2 = data2.nodes) === null || _a2 === void 0 ? void 0 : _a2.forEach((datum) => {
        var _a3;
        if (idOf(datum) === idOf(this.ref))
          return;
        const radian = rad(subtract(positionOf(datum), refPoint));
        const isLeft = Math.abs(radian) > Math.PI / 2;
        const isLeaf = !datum.children || datum.children.length === 0;
        const nodeId = idOf(datum);
        const node = (_a3 = this.context.element) === null || _a3 === void 0 ? void 0 : _a3.getElement(nodeId);
        if (!node || !node.isVisible())
          return;
        const nodeHalfWidth = parseSize(graph.getElementRenderStyle(nodeId).size)[0] / 2;
        const offset = (isLeaf ? 1 : -1) * (nodeHalfWidth + this.options.offset);
        const labelTransform = [
          ["translate", offset * Math.cos(radian), offset * Math.sin(radian)],
          ["rotate", isLeft ? rad2deg(radian) + 180 : rad2deg(radian)]
        ];
        model.updateNodeData([
          {
            id: idOf(datum),
            style: {
              labelTextAlign: isLeft === isLeaf ? "right" : "left",
              labelTextBaseline: "middle",
              labelTransform
            }
          }
        ]);
      });
      graph.draw();
    }
  };
  PlaceRadialLabels.defaultOptions = {
    offset: 5
  };

  // node_modules/@antv/g6/esm/transforms/process-parallel-edges.js
  var import_util209 = __toESM(require_lib());
  var CUBIC_EDGE_TYPE = "quadratic";
  var CUBIC_LOOP_PLACEMENTS = [
    "top",
    "top-right",
    "right",
    "right-bottom",
    "bottom",
    "bottom-left",
    "left",
    "left-top"
  ];
  var ProcessParallelEdges = class _ProcessParallelEdges extends BaseTransform {
    constructor(context, options) {
      super(context, Object.assign({}, _ProcessParallelEdges.defaultOptions, options));
      this.cacheMergeStyle = /* @__PURE__ */ new Map();
      this.getAffectedParallelEdges = (input) => {
        const { add: { edges: edgesToAdd }, update: { nodes: nodesToUpdate, edges: edgesToUpdate, combos: combosToUpdate }, remove: { edges: edgesToRemove } } = input;
        const { model } = this.context;
        const edges = /* @__PURE__ */ new Map();
        const addRelatedEdges = (_2, id3) => {
          const relatedEdgesData = model.getRelatedEdgesData(id3);
          relatedEdgesData.forEach((edge) => !edges.has(idOf(edge)) && edges.set(idOf(edge), edge));
        };
        nodesToUpdate.forEach(addRelatedEdges);
        combosToUpdate.forEach(addRelatedEdges);
        const pushParallelEdges = (edge) => {
          const removedEdgeIds = new Set(input.remove.edges.keys());
          const validEdgeData = model.getEdgeData().filter((edge2) => !removedEdgeIds.has(idOf(edge2))).map((edge2) => getEdgeEndsContext(model, edge2));
          getParallelEdges(edge, validEdgeData, true).forEach((e) => {
            const id3 = idOf(e);
            if (!edges.has(id3))
              edges.set(id3, e);
          });
        };
        if (edgesToRemove.size)
          edgesToRemove.forEach(pushParallelEdges);
        if (edgesToAdd.size)
          edgesToAdd.forEach(pushParallelEdges);
        if (edgesToUpdate.size) {
          const changes = groupByChangeType(reduceDataChanges(model.getChanges())).update.edges;
          edgesToUpdate.forEach((edge) => {
            var _a2;
            pushParallelEdges(edge);
            const originalEdge = (_a2 = changes.find((e) => idOf(e.value) === idOf(edge))) === null || _a2 === void 0 ? void 0 : _a2.original;
            if (originalEdge && !isParallelEdges(edge, originalEdge)) {
              pushParallelEdges(originalEdge);
            }
          });
        }
        if (!(0, import_util209.isEmpty)(this.options.edges)) {
          edges.forEach((_2, id3) => !this.options.edges.includes(id3) && edges.delete(id3));
        }
        const edgeIds = model.getEdgeData().map(idOf);
        return new Map([...edges].sort((a2, b) => edgeIds.indexOf(a2[0]) - edgeIds.indexOf(b[0])));
      };
      this.applyBundlingStyle = (input, edges, distance6) => {
        const { edgeMap, reverses } = groupByEndpoints(edges);
        edgeMap.forEach((arcEdges) => {
          arcEdges.forEach((edge, i, edgeArr) => {
            var _a2;
            const length = edgeArr.length;
            const style = edge.style || {};
            if (edge.source === edge.target) {
              const len = CUBIC_LOOP_PLACEMENTS.length;
              style.loopPlacement = CUBIC_LOOP_PLACEMENTS[i % len];
              style.loopDist = Math.floor(i / len) * distance6 + 50;
            } else if (length === 1) {
              style.curveOffset = 0;
            } else {
              const sign = (i % 2 === 0 ? 1 : -1) * (reverses[`${edge.source}|${edge.target}|${i}`] ? -1 : 1);
              style.curveOffset = length % 2 === 1 ? sign * Math.ceil(i / 2) * distance6 * 2 : sign * (Math.floor(i / 2) * distance6 * 2 + distance6);
            }
            const mergedEdgeData = Object.assign(edge, { type: CUBIC_EDGE_TYPE, style });
            const element = (_a2 = this.context.element) === null || _a2 === void 0 ? void 0 : _a2.getElement(idOf(edge));
            if (!element || !isStyleEqual(mergedEdgeData.style, element.attributes)) {
              reassignTo(input, element ? "update" : "add", "edge", mergedEdgeData, true);
            }
          });
        });
      };
      this.resetEdgeStyle = (edge) => {
        const style = edge.style || {};
        const cacheStyle2 = this.cacheMergeStyle.get(idOf(edge)) || {};
        Object.keys(cacheStyle2).forEach((key) => {
          if ((0, import_util209.isEqual)(style[key], cacheStyle2[key])) {
            if (edge[key]) {
              style[key] = edge[key];
            } else {
              delete style[key];
            }
          }
        });
        return Object.assign(edge, { style });
      };
      this.applyMergingStyle = (input, edges) => {
        const { edgeMap, reverses } = groupByEndpoints(edges);
        edgeMap.forEach((edges2) => {
          var _a2;
          if (edges2.length === 1) {
            const edge = edges2[0];
            const element = (_a2 = this.context.element) === null || _a2 === void 0 ? void 0 : _a2.getElement(idOf(edge));
            const edgeStyle = this.resetEdgeStyle(edge);
            if (!element || !isStyleEqual(edgeStyle, element.attributes)) {
              reassignTo(input, element ? "update" : "add", "edge", edgeStyle);
            }
            return;
          }
          const mergedStyle = edges2.map(({ source, target, style = {} }, i) => {
            const { startArrow, endArrow } = style;
            const newStyle = {};
            const [start, end] = reverses[`${source}|${target}|${i}`] ? ["endArrow", "startArrow"] : ["startArrow", "endArrow"];
            if ((0, import_util209.isBoolean)(startArrow))
              newStyle[start] = startArrow;
            if ((0, import_util209.isBoolean)(endArrow))
              newStyle[end] = endArrow;
            return newStyle;
          }).reduce((acc, style) => Object.assign(Object.assign({}, acc), style), {});
          edges2.forEach((edge, i, edges3) => {
            var _a3;
            if (i !== 0) {
              reassignTo(input, "remove", "edge", edge);
              return;
            }
            const parsedStyle = Object.assign({}, (0, import_util209.isFunction)(this.options.style) ? this.options.style(edges3) : this.options.style, { childrenData: edges3 });
            this.cacheMergeStyle.set(idOf(edge), parsedStyle);
            const mergedEdgeData = Object.assign(Object.assign({}, edge), { type: "line", style: Object.assign(Object.assign(Object.assign({}, edge.style), mergedStyle), parsedStyle) });
            const element = (_a3 = this.context.element) === null || _a3 === void 0 ? void 0 : _a3.getElement(idOf(edge));
            if (!element || !isStyleEqual(mergedEdgeData.style, element.attributes)) {
              reassignTo(input, element ? "update" : "add", "edge", mergedEdgeData, true);
            }
          });
        });
      };
    }
    /**
     * <zh/> 在每次绘制前处理平行边
     *
     * <en/> Process parallel edges before each drawing
     * @param input
     */
    beforeDraw(input) {
      const edges = this.getAffectedParallelEdges(input);
      if (edges.size === 0)
        return input;
      this.options.mode === "bundle" ? this.applyBundlingStyle(input, edges, this.options.distance) : this.applyMergingStyle(input, edges);
      return input;
    }
  };
  ProcessParallelEdges.defaultOptions = {
    mode: "bundle",
    distance: 15
    // only valid for bundling mode
  };
  var groupByEndpoints = (edges) => {
    const edgeMap = /* @__PURE__ */ new Map();
    const processedEdgesSet = /* @__PURE__ */ new Set();
    const reverses = {};
    const includedEdgesInGroup = /* @__PURE__ */ new Map();
    for (const [id3, edge] of edges) {
      if (processedEdgesSet.has(id3))
        continue;
      const { source, target } = edge;
      const sourceTarget = `${source}-${target}`;
      if (!edgeMap.has(sourceTarget)) {
        edgeMap.set(sourceTarget, []);
        includedEdgesInGroup.set(sourceTarget, /* @__PURE__ */ new Set());
      }
      const sourceTargetEdges = edgeMap.get(sourceTarget);
      const includedEdges = includedEdgesInGroup.get(sourceTarget);
      if (sourceTargetEdges && includedEdges && !includedEdges.has(id3)) {
        sourceTargetEdges.push(edge);
        includedEdges.add(id3);
        processedEdgesSet.add(id3);
      }
      for (const [otherId, sedge] of edges) {
        if (processedEdgesSet.has(otherId) || otherId === id3)
          continue;
        if (isParallelEdges(edge, sedge)) {
          const groupEdges = edgeMap.get(sourceTarget);
          const includedGroupEdges = includedEdgesInGroup.get(sourceTarget);
          if (groupEdges && includedGroupEdges && !includedGroupEdges.has(otherId)) {
            groupEdges.push(sedge);
            includedGroupEdges.add(otherId);
            if (source === sedge.target && target === sedge.source) {
              reverses[`${sedge.source}|${sedge.target}|${groupEdges.length - 1}`] = true;
            }
            processedEdgesSet.add(otherId);
          }
        }
      }
    }
    return { edgeMap, reverses };
  };
  var getParallelEdges = (edge, edges, containsSelf) => {
    return edges.filter((e) => (containsSelf || idOf(e) !== idOf(edge)) && isParallelEdges(e, edge));
  };
  var isParallelEdges = (edge1, edge2) => {
    const { sourceNode: src1, targetNode: tgt1 } = edge1.style || {};
    const { sourceNode: src2, targetNode: tgt2 } = edge2.style || {};
    return src1 === src2 && tgt1 === tgt2 || src1 === tgt2 && tgt1 === src2;
  };

  // node_modules/@antv/g6/esm/transforms/update-related-edge.js
  var UpdateRelatedEdge = class extends BaseTransform {
    beforeDraw(input, context) {
      const { stage } = context;
      if (stage === "visibility")
        return input;
      const { model } = this.context;
      const { update: { nodes, edges, combos } } = input;
      const addRelatedEdges = (_2, id3) => {
        const relatedEdgesData = model.getRelatedEdgesData(id3);
        relatedEdgesData.forEach((edge) => !edges.has(idOf(edge)) && edges.set(idOf(edge), edge));
      };
      nodes.forEach(addRelatedEdges);
      combos.forEach(addRelatedEdges);
      return input;
    }
  };

  // node_modules/@antv/g6/esm/registry/build-in.js
  var BUILT_IN_EXTENSIONS = {
    animation: {
      "combo-collapse": ComboCollapse,
      "combo-expand": ComboExpand,
      "node-collapse": NodeCollapse,
      "node-expand": NodeExpand,
      "path-in": PathIn,
      "path-out": PathOut,
      fade: Fade,
      translate: Translate
    },
    behavior: {
      "brush-select": BrushSelect,
      "click-select": ClickSelect,
      "collapse-expand": CollapseExpand,
      "create-edge": CreateEdge,
      "drag-canvas": DragCanvas,
      "drag-element-force": DragElementForce,
      "drag-element": DragElement,
      "fix-element-size": FixElementSize,
      "focus-element": FocusElement,
      "hover-activate": HoverActivate,
      "lasso-select": LassoSelect,
      "auto-adapt-label": AutoAdaptLabel,
      "optimize-viewport-transform": OptimizeViewportTransform,
      "scroll-canvas": ScrollCanvas,
      "zoom-canvas": ZoomCanvas
    },
    combo: {
      circle: CircleCombo,
      rect: RectCombo
    },
    edge: {
      cubic: Cubic3,
      line: Line2,
      polyline: Polyline2,
      quadratic: Quadratic,
      "cubic-horizontal": CubicHorizontal,
      "cubic-radial": CubicRadial,
      "cubic-vertical": CubicVertical
    },
    layout: {
      "antv-dagre": AntVDagreLayout,
      "combo-combined": ComboCombinedLayout,
      "compact-box": import_hierarchy.compactBox,
      "d3-force": D3ForceLayout,
      "force-atlas2": ForceAtlas2Layout,
      circular: CircularLayout,
      concentric: ConcentricLayout,
      dagre: DagreLayout,
      dendrogram: import_hierarchy.dendrogram,
      fishbone: FishboneLayout,
      force: ForceLayout,
      fruchterman: FruchtermanLayout,
      grid: GridLayout,
      indented: import_hierarchy.indented,
      mds: MDSLayout,
      mindmap: import_hierarchy.mindmap,
      radial: RadialLayout,
      random: RandomLayout,
      snake: SnakeLayout
    },
    node: {
      circle: Circle2,
      diamond: Diamond,
      ellipse: Ellipse2,
      hexagon: Hexagon,
      html: HTML2,
      image: Image4,
      rect: Rect2,
      star: Star,
      donut: Donut,
      triangle: Triangle
    },
    palette: {
      spectral,
      tableau,
      oranges,
      greens,
      blues
    },
    theme: {
      dark,
      light
    },
    plugin: {
      "bubble-sets": BubbleSets2,
      "edge-bundling": EdgeBundling,
      "edge-filter-lens": EdgeFilterLens,
      "grid-line": GridLine,
      background: Background,
      contextmenu: Contextmenu,
      fisheye: Fisheye,
      fullscreen: Fullscreen,
      history: History2,
      hull: Hull,
      legend: Legend,
      minimap: Minimap,
      snapline: Snapline,
      timebar: Timebar2,
      title: Title2,
      toolbar: Toolbar,
      tooltip: Tooltip2,
      watermark: Watermark
    },
    transform: {
      "arrange-draw-order": ArrangeDrawOrder,
      "collapse-expand-combo": CollapseExpandCombo,
      "collapse-expand-node": CollapseExpandNode,
      "get-edge-actual-ends": GetEdgeActualEnds,
      "map-node-size": MapNodeSize,
      "place-radial-labels": PlaceRadialLabels,
      "process-parallel-edges": ProcessParallelEdges,
      "update-related-edges": UpdateRelatedEdge
    },
    shape: {
      circle: Circle,
      ellipse: Ellipse,
      group: Group,
      html: HTML,
      image: Image3,
      line: Line,
      path: Path,
      polygon: Polygon,
      polyline: Polyline,
      rect: Rect,
      text: Text,
      label: Label,
      badge: Badge
    }
  };
  function registerBuiltInExtensions() {
    Object.entries(BUILT_IN_EXTENSIONS).forEach(([category, extensions]) => {
      Object.entries(extensions).forEach(([type, extension]) => {
        register(category, type, extension);
      });
    });
  }

  // node_modules/@antv/g6/esm/preset.js
  registerBuiltInExtensions();

  // src/conspiracy.ts
  function currentConspiracy() {
    return window._conspiracy;
  }
  function updateConspiracy(newConspiracy) {
    return window._conspiracy = { ...window._conspiracy, ...newConspiracy };
  }
  function createConspiracy(name) {
    return {
      id: crypto.randomUUID(),
      name,
      last_modified: new Date(Date.now()),
      created: new Date(Date.now())
    };
  }

  // src/entity.ts
  var import_image7 = __toESM(require_image(), 1);

  // src/database.ts
  var DB_NAME = "sc";
  var DB_VERSION = 1;
  var DB_CONSPIRACY_STORE = "conspiracies";
  var DB_ASSET_STORE = "assets";
  var DB_GRAPH_STORE = "graphs";
  var ScDatabase = class {
    errorHandler = (ev) => {
      console.log("database error: " + ev.target.errorCode);
    };
    db;
    constructor() {
      const req = window.indexedDB.open(DB_NAME, DB_VERSION);
      req.onsuccess = (ev) => {
        this.db = ev.target.result;
        this.db.onerror = this.errorHandler;
        this.getMostRecentConspiracy((c2) => {
          window._conspiracy = c2;
          window.dispatchEvent(new Event("conspiracyload"));
        });
      };
      req.onerror = this.errorHandler;
      req.onupgradeneeded = (ev) => {
        this.db = ev.target.result;
        const conspiracyStore = this.db?.createObjectStore(DB_CONSPIRACY_STORE, { keyPath: "id" });
        conspiracyStore?.createIndex("name", "name", { unique: false });
        const graphStore = this.db?.createObjectStore(DB_GRAPH_STORE, { keyPath: "id" });
        const assetStore = this.db?.createObjectStore(DB_ASSET_STORE, { keyPath: "id" });
        assetStore?.createIndex("name", "name", { unique: false });
      };
    }
    conspiracyStore(mode) {
      const t = this.db?.transaction(DB_CONSPIRACY_STORE, mode);
      return t?.objectStore(DB_CONSPIRACY_STORE);
    }
    assetStore(mode) {
      const t = this.db?.transaction(DB_ASSET_STORE, mode);
      return t?.objectStore(DB_ASSET_STORE);
    }
    graphStore(mode) {
      const t = this.db?.transaction(DB_GRAPH_STORE, mode);
      return t?.objectStore(DB_GRAPH_STORE);
    }
    getConspiracyList(callback) {
      const store = this.conspiracyStore("readonly");
      const req = store?.getAll();
      if (req) {
        req.onerror = this.errorHandler;
        req.onsuccess = (ev) => {
          callback(ev.target.result);
        };
      }
    }
    getConspiracy(id3, callback) {
      const store = this.conspiracyStore("readonly");
      const req = store?.get(id3);
      if (req) {
        req.onerror = this.errorHandler;
        req.onsuccess = (ev) => {
          callback(ev.target.result);
        };
      }
    }
    getMostRecentConspiracy(callback) {
      const store = this.conspiracyStore("readwrite");
      const req = store?.openCursor(null, "prev");
      if (req) {
        req.onsuccess = (ev) => {
          const cursor = ev.target.result;
          if (cursor) {
            callback(cursor.value);
          } else {
            const newConspiracy = createConspiracy("new conspiracy");
            store.add(newConspiracy).onsuccess = (ev2) => {
              const graphStore = this.graphStore("readwrite");
              graphStore.add({
                id: newConspiracy.id,
                data: {
                  nodes: [],
                  edges: [],
                  combos: []
                }
              }).onsuccess = (ev3) => {
                callback(newConspiracy);
              };
            };
          }
        };
      }
    }
    saveConspiracy() {
      this.conspiracyStore("readwrite")?.put(updateConspiracy({ last_modified: new Date(Date.now()) }));
    }
    makeImageSample(nodeId, assetId, x0, y0, width2, height, callback) {
      const assetStore = this.assetStore("readonly");
      assetStore.get(assetId).onsuccess = async (ev) => {
        const asset = ev.target.result;
        const canvas2 = new OffscreenCanvas(width2, height);
        const ctx3 = canvas2.getContext("bitmaprenderer");
        const bitmap = await window.createImageBitmap(new Blob([asset.data], { type: asset.type }), x0, y0, width2, height);
        ctx3.transferFromImageBitmap(bitmap);
        const blob = await canvas2.convertToBlob();
        const url = URL.createObjectURL(blob);
        callback(url);
      };
    }
    loadGraphData(callback) {
      this.graphStore("readonly").get(currentConspiracy().id).onsuccess = (ev) => {
        const graphData = ev.target.result.data;
        callback(graphData);
      };
    }
    saveGraphData(graphData) {
      this.graphStore("readwrite").put({ id: currentConspiracy().id, data: {
        combos: graphData.combos,
        edges: graphData.edges,
        nodes: graphData.nodes
        /*?.map(node => {
            //const { x, y, z, ...style } = node.style as any;
            //return { ...node, style: style };
        })*/
      } });
      this.conspiracyStore("readwrite")?.put(updateConspiracy({ last_modified: new Date(Date.now()) }));
    }
    saveAsset(asset) {
      this.assetStore("readwrite").put(asset);
      this.conspiracyStore("readwrite")?.put(updateConspiracy({ last_modified: new Date(Date.now()) }));
    }
  };
  function getDatabase() {
    return window._db;
  }

  // src/imagenode.ts
  var ScImage = class extends Rect2 {
    blobUrl;
    getComputedSize(attributes) {
      const [w, h] = this.getSize(attributes);
      return [w, h];
    }
    geomMeanLength(attributes) {
      const [width2, height] = this.getComputedSize(attributes);
      return Math.sqrt(width2 * height);
    }
    destroy() {
      if (this.blobUrl) {
        URL.revokeObjectURL(this.blobUrl);
      }
      super.destroy();
    }
    getIconStyle(attributes) {
      const [width2, height] = this.getComputedSize(attributes);
      let style = super.getIconStyle(attributes);
      if (!this.blobUrl) {
        style = { text: "?", fill: "#ffffff", ...style };
      }
      return style ? { width: width2 * 0.8, height: height * 0.8 } : false;
    }
    getLabelStyle(attributes) {
      const parentStyle = super.getLabelStyle(attributes);
      if (parentStyle) {
        return { ...parentStyle, fontSize: Math.max(this.geomMeanLength(attributes) / 24, 24) };
      }
      return false;
    }
    getImageStyle(attributes) {
      const [width2, height] = this.getComputedSize(attributes);
      if (this.blobUrl) {
        return { src: this.blobUrl, x: -width2 / 2, y: -height / 2 };
      } else {
        getDatabase().makeImageSample(this.id, attributes.source_id || "", attributes.x0 || 0, attributes.y0 || 0, width2, height, (url) => {
          this.blobUrl = url;
          this.render();
        });
      }
      return false;
    }
    drawImageShape(attributes, container) {
      this.upsert("image", Image2, this.getImageStyle(attributes), container);
    }
    render(attributes = this.parsedAttributes, container = this) {
      super.render(attributes, container);
      this.drawImageShape(attributes, container);
    }
  };
  register(ExtensionCategory.NODE, "sc-image", ScImage);
  function getNodeImageUrl(id3) {
    return getScApp().graphRuntimeElement(id3, ScImage)?.blobUrl;
  }

  // src/modes.ts
  var NORMAL = {
    name: "NORMAL",
    behaviors: [
      { key: "drag-canvas-1", enable: (ev) => ev.targetType && ev.targetType === "canvas" && !ev.shiftKey },
      { key: "brush-select-1", enable: true, trigger: ["shift"] },
      { key: "drag-element-1", enable: (ev) => {
        return !ev.shiftKey;
      } },
      // { key: "drag-element-force-1", enable: (ev: any) => { return !ev.shiftKey; } },
      { key: "focus-element-1", enable: true },
      { key: "create-edge-1", enable: false },
      { key: "brush-extract", enable: false }
    ],
    keys: [
      { key: "Delete", callback: (app, ev) => {
        app.graph.stopLayout();
        app.panel.focusNode();
        const edges = app.graph.getElementDataByState("edge", "selected").map((edge) => idOf(edge));
        const nodes = app.graph.getElementDataByState("node", "selected").map((node) => {
          return node.id;
        });
        app.graph.removeData({ nodes, edges });
        app.graph.render();
      } },
      { key: "Escape", callback: (app, ev) => {
        app.graph.updateData({
          nodes: app.graph.getNodeData().map((data2) => {
            return { id: data2.id, states: [] };
          }),
          edges: app.graph.getEdgeData().map((data2) => {
            return { id: idOf(data2), states: [] };
          })
        });
        app.hoveredNode = void 0;
        app.panel.focusNode();
      } },
      { key: "=", callback: (app, ev) => {
        app.graph.zoomTo(1);
      } }
    ]
  };
  var SELECT = {
    name: "SELECT",
    behaviors: [
      { key: "drag-canvas-1", enable: (ev) => ev.targetType && ev.targetType === "canvas" && ev.shiftKey },
      { key: "brush-select-1", enable: true, trigger: ["drag"] },
      { key: "focus-element-1", enable: true },
      { key: "create-edge-1", enable: false },
      { key: "brush-extract", enable: false },
      { key: "drag-element-1", enable: false }
    ]
  };
  var INSERT = {
    name: "INSERT",
    behaviors: [
      { key: "drag-canvas-1", enable: (ev) => ev.targetType && ev.targetType === "canvas" && ev.shiftKey },
      { key: "create-edge-1", enable: true, trigger: ["drag", "click"] },
      { key: "brush-select-1", enable: false },
      { key: "focus-element-1", enable: false },
      { key: "brush-extract", enable: false },
      { key: "drag-element-1", enable: false }
    ]
  };
  var EXTRACT = {
    name: "EXTRACT",
    behaviors: [
      { key: "drag-canvas-1", enable: (ev) => ev.targetType && ev.targetType === "canvas" && ev.shiftKey },
      { key: "focus-element-1", enable: true },
      { key: "brush-select-1", enable: false },
      { key: "create-edge-1", enable: (ev) => ev.shiftKey, trigger: ["drag", "click"] },
      { key: "drag-element-1", enable: false },
      { key: "brush-extract", enable: true }
    ]
  };
  var ScModeEvent = class extends Event {
    current;
    next;
    app;
    constructor(_app, _current, _next) {
      super("scmode");
      this.app = _app;
      this.current = _current;
      this.next = _next;
    }
  };

  // src/entities.ts
  var NodeProperty = class {
    value;
    editable;
    constructor(t, editable = true) {
      this.value = t;
      this.editable = true;
    }
  };
  function makeImageNodeData(data2) {
    return {
      id: data2.id,
      type: "sc-image",
      style: {
        stroke: "#ffffff",
        lineWidth: 4,
        ...data2.style,
        fillOpacity: 0
      },
      data: {
        ...data2.data
      }
    };
  }

  // src/info_panel.ts
  var InfoPanel = class {
    container;
    nameInput;
    picture;
    propList;
    currentNode;
    constructor(_container) {
      this.container = _container;
      this.nameInput = this.container.querySelector(".sc-entity-info-name-input");
      this.picture = this.container.querySelector(".sc-entity-info-picture");
      this.propList = this.container.querySelector(".sc-entity-info-prop-list");
      window.addEventListener("scmode", ((ev) => {
        if (ev.next == INSERT && getScApp().mode != INSERT) {
        }
      }));
    }
    updateProperties() {
      if (this.currentNode && getScApp().graph.hasNode(this.currentNode.id)) {
        getScApp().graph.updateNodeData([{
          id: this.currentNode.id,
          data: Object.fromEntries([["name", this.nameInput.value], ...[...this.propList.children].filter((prop) => prop.id !== "id").map((prop) => {
            return [prop.id, prop.querySelector("input,textarea").value];
          })])
        }]);
      }
    }
    makeShortProperty(key, value, readonly) {
      const propBox = document.createElement("div");
      propBox.className = "sc-short-property";
      propBox.id = key;
      const label = document.createElement("span");
      label.className = "sc-short-property-label";
      label.textContent = key;
      propBox.appendChild(label);
      const valueBox = document.createElement("input");
      valueBox.className = `sc-short-property-value sc-short-property-${key}`;
      valueBox.type = "text";
      valueBox.disabled = readonly || false;
      valueBox.value = value;
      valueBox.onchange = () => this.updateProperties();
      propBox.appendChild(valueBox);
      return propBox;
    }
    makeLongProperty(key, value, lines, readonly) {
      if (value instanceof NodeProperty) {
        readonly = true;
      }
      const propBox = document.createElement("div");
      propBox.className = "sc-long-property";
      propBox.id = key;
      const label = document.createElement("span");
      label.className = "sc-long-property-label";
      label.textContent = key;
      propBox.appendChild(label);
      const valueBox = document.createElement("textarea");
      valueBox.className = `sc-long-property-value sc-long-property-${key}`;
      valueBox.rows = lines;
      valueBox.disabled = readonly || false;
      valueBox.value = value instanceof NodeProperty ? value.value : value;
      valueBox.onchange = () => this.updateProperties();
      propBox.appendChild(valueBox);
      return propBox;
    }
    focusNode(node) {
      this.updateProperties();
      [...this.propList.children].forEach((c2) => this.propList.removeChild(c2));
      if (node) {
        const { name, ...props } = node.data;
        this.container.style = "display: flex;";
        this.nameInput.value = name || "";
        this.picture.src = getNodeImageUrl(node.id) || "";
        this.picture.alt = node.data?.icon || "\u2002?";
        this.propList.appendChild(this.makeShortProperty("id", node.id, true));
        console.log(node);
        Object.entries(props).forEach(([key, value]) => {
          if (key === "notes") {
            this.propList.appendChild(this.makeLongProperty(key, value, 6, false));
          } else {
            this.propList.appendChild(this.makeShortProperty(key, value, false));
          }
        });
        getScApp().statusline.update({ midRight: `in: ${getScApp().graph.getRelatedEdgesData(node.id, "in").length} | out ${getScApp().graph.getRelatedEdgesData(node.id, "out").length}` });
      } else {
        if (this.currentNode) {
          getScApp().graph.setElementState(this.currentNode.id, []);
        }
        this.container.style = "display: none;";
        getScApp().statusline.update({ midRight: "" });
      }
      this.currentNode = node;
    }
  };

  // src/statusline.ts
  var ScStatusline = class {
    text;
    mode;
    left;
    midLeft;
    midRight;
    right;
    constructor() {
      this.text = { mode: "", left: "", midLeft: "", midRight: "", right: "" };
      this.mode = document.querySelector(".sc-statusline-mode");
      this.left = document.querySelector(".sc-statusline-left");
      this.midLeft = document.querySelector(".sc-statusline-mid-left");
      this.midRight = document.querySelector(".sc-statusline-mid-right");
      this.right = document.querySelector(".sc-statusline-right");
      window.addEventListener("scmode", ((ev) => {
        this.mode.className = "sc-statusline-mode sc-statusline-" + ev.next.name;
        this.left.className = "sc-statusline-left sc-statusline-" + ev.next.name;
        this.midLeft.className = "sc-statusline-mid-left sc-statusline-" + ev.next.name;
        this.midRight.className = "sc-statusline-mid-right sc-statusline-" + ev.next.name;
        this.right.className = "sc-statusline-right sc-statusline-" + ev.next.name;
        this.update({ mode: ev.next.name });
      }));
    }
    update(newText) {
      this.text = { ...this.text, ...newText };
      this.mode.textContent = this.text.mode || "";
      this.left.textContent = this.text.left || "";
      this.midLeft.textContent = this.text.midLeft || "";
      this.midRight.textContent = this.text.midRight || "";
      this.right.textContent = this.text.right || "";
    }
    msgTimeout;
    message(msgText, timeout2 = 1e4) {
      if (this.msgTimeout) {
        window.clearTimeout(this.msgTimeout);
      }
      this.update({ midLeft: msgText });
      this.msgTimeout = window.setTimeout(() => {
        this.update({ midLeft: "" });
        this.msgTimeout = void 0;
      }, timeout2);
    }
  };

  // src/extracttool.ts
  var ExtractTool = class extends BrushSelect {
    onPointerUp(event) {
      const ctx3 = this.context;
      const node = getScApp().panel.currentNode;
      const rect2 = this.rectShape;
      if (rect2 && node && node.type === "sc-image") {
        const bounds = ctx3.graph.getElementRenderBounds(node.id);
        const rectBounds = rect2.getBounds();
        rectBounds.setMinMax([rectBounds.min[0], rectBounds.min[1], bounds.min[2]], [rectBounds.max[0], rectBounds.max[1], bounds.max[2]]);
        const intersection = bounds.intersection(rectBounds);
        if (intersection) {
          const el = ctx3.element.getElement(node.id);
          const elStyle = el.attributes;
          console.log(el);
          const [x0, y0] = [elStyle.x0 || 0 + intersection.min[0] - bounds.min[0], elStyle.y0 || 0 + intersection.min[1] - bounds.min[1]];
          const [width2, height] = [intersection.halfExtents[0] * 2, intersection.halfExtents[1] * 2];
          const sampleNode = makeImageNodeData({
            id: crypto.randomUUID(),
            style: {
              size: [width2, height],
              x0,
              y0,
              source_id: elStyle.source_id,
              stroke: "#c5152f",
              lineWidth: 4
            },
            data: {
              mimetype: node.data?.mimetype || "application/octet-stream"
            }
          });
          ctx3.graph.addNodeData([sampleNode]);
          ctx3.graph.addEdgeData([{ source: node.id, target: sampleNode.id }]);
          getDatabase().saveGraphData(ctx3.graph.getData());
          ctx3.graph.render();
        }
      }
      super.onPointerUp(event);
    }
  };
  register(ExtensionCategory.BEHAVIOR, "extract-tool", ExtractTool);

  // src/commands.ts
  var CommandManager = class {
    commands = /* @__PURE__ */ new Map();
    commandLineElement;
    constructor() {
      this.commandLineElement = document.querySelector(".sc-commandline");
      this.commandLineElement.onkeydown = (ev) => {
        if (ev.key === "Enter") {
          this.execute();
          this.deactivate();
        } else if (ev.key === "Escape") {
          this.deactivate();
        }
      };
    }
    execute() {
      const text = this.commandLineElement.value;
      const [baseCmd, ...args] = text.split(" ");
      if (baseCmd) {
        const cmd = this.commands.get(baseCmd);
        if (cmd) {
          cmd.callback(args);
        } else {
          getScApp().statusline.message(`unknown command ${text}`);
        }
      }
    }
    activate(prefix) {
      this.commandLineElement.style = "display: block;";
      this.commandLineElement.focus();
    }
    deactivate() {
      this.commandLineElement.value = "";
      this.commandLineElement.style = "";
      this.commandLineElement.blur();
    }
    register(cmd, desc, callback) {
      cmd.forEach((alias) => this.commands.set(alias, { cmd, desc, callback }));
    }
  };

  // src/layouts.ts
  var rectangleNodeRadius = (d2) => {
    const size2 = d2.data.style?.size || d2.style.size;
    if (Array.isArray(size2)) {
      return Math.sqrt((size2[0] / 2) ** 2 + (size2[1] / 2) ** 2);
    } else {
      return (size2 || 64) / 2;
    }
  };
  var layouts = {
    d3: {
      type: "d3-force",
      link: {
        distance: (d2) => {
          const sourceSize = d2.source.style.size;
          const targetSize = d2.target.style.size;
          return 0.5 * (Math.max(sourceSize[0], targetSize[0]) + Math.max(sourceSize[1], targetSize[1]));
        },
        strength: 0.05
      },
      collide: {
        strength: 0.5,
        radius: rectangleNodeRadius
      },
      alphaDecay: 0.06
    },
    radial: {
      type: "radial",
      nodeSize: (d2) => {
        return 2 * rectangleNodeRadius(d2);
      },
      preventOverlap: true,
      strictRadial: false,
      maxPreventOverlapIteration: 100,
      linkDistance: 400
    },
    atlas: {
      type: "force-atlas2",
      preventOverlap: true,
      nodeSize: (d2) => 2 * rectangleNodeRadius(d2)
    },
    dendro: {
      type: "dendrogram",
      radial: true,
      nodeSep: 30,
      rankSep: 80
    }
  };

  // src/index.ts
  var ScApplication = class {
    container_id = "graph-container";
    mode = NORMAL;
    graph;
    statusline;
    commands;
    panel;
    hoveredNode;
    helpDialog;
    constructor(data2) {
      this.panel = new InfoPanel(document.getElementById("sc-info-panel"));
      this.statusline = new ScStatusline();
      this.statusline.update({ left: currentConspiracy().name });
      this.commands = new CommandManager();
      const container = document.querySelector(`#${this.container_id}`);
      this.graph = new Graph3({
        container: this.container_id,
        data: data2,
        theme: "dark",
        background: "#000000",
        // layout: layouts.d3!,
        node: {
          style: {
            label: true,
            labelText: (n) => n.data?.name || "",
            iconText: (n) => n.data?.icon || "?",
            iconFill: (n) => n.data?.color || "#ffffff",
            iconStroke: (n) => n.data?.color || "#ffffff",
            labelFill: (n) => n.data?.color || "#ffffff",
            labelFontSize: 48,
            fillOpacity: 0,
            margin: 2
          },
          state: {
            selected: {
              fill: (n) => n.style?.stroke || "#ffffff",
              labelFontSize: 48,
              stroke: (n) => n.style?.stroke || "#ffffff",
              lineWidth: 8
            }
          }
        },
        edge: {
          style: {
            label: false,
            opacity: 0.9,
            stroke: "#ffffff",
            lineWidth: 4,
            endArrow: true
          }
        },
        behaviors: [
          {
            type: "zoom-canvas",
            key: "zoom-canvas-1",
            enable: true
          },
          /*{
              type: "drag-element-force",
              key: "drag-element-force-1",
          },*/
          {
            type: "drag-element",
            key: "drag-element-1"
          },
          "click-select",
          {
            type: "focus-element",
            key: "focus-element-1"
          },
          {
            type: "drag-canvas",
            key: "drag-canvas-1"
          },
          {
            type: "brush-select",
            key: "brush-select-1",
            immediately: "true",
            mode: "diff",
            style: {
              fill: "#c9d05c",
              stroke: "#9faa00"
            }
          },
          {
            type: "create-edge",
            key: "create-edge-1",
            trigger: ["drag"]
          },
          {
            type: "extract-tool",
            key: "brush-extract",
            immediately: "false",
            enable: false,
            enableElements: [],
            style: {
              lineDash: 6,
              fill: "#f43753",
              fillOpacity: 0.1,
              stroke: "#c5152f"
            },
            trigger: ["drag"]
          }
        ]
      });
      window.addEventListener("resize", (ev) => {
        this.graph.fitCenter();
        this.graph.resize();
      });
      this.graph.on(ContainerEvent.KEY_DOWN, (ev) => {
        if (ev.key === "Alt") {
          this.updateMode(INSERT);
          ev.stopPropagation();
        } else if (this.mode === NORMAL && ev.key === ":") {
          this.commands.activate(":");
        }
      });
      this.graph.on(GraphEvent.AFTER_ELEMENT_UPDATE, (ev) => {
        this.statusline.update({ right: `v: ${this.graph.getNodeData().length} | e: ${this.graph.getEdgeData().length}` });
        getDatabase().saveGraphData(this.graph.getData());
      });
      window.addEventListener("scmode", ((ev) => {
        ev.next.behaviors.forEach((behavior) => {
          this.graph.updateBehavior(behavior);
        });
      }));
      this.graph.on(NodeEvent.CLICK, (ev) => {
        const data3 = this.graph.getNodeData(ev.target.id);
        if (data3.states?.includes("selected")) {
          this.panel.focusNode();
        } else {
          this.panel.focusNode(data3);
        }
      });
      this.graph.on(CanvasEvent2.CLICK, (ev) => {
        this.panel.focusNode();
        if (this.mode === INSERT) {
          const [x3, y3] = this.graph.getCanvasByViewport([ev.clientX, ev.clientY]);
          this.graph.addNodeData([{
            id: crypto.randomUUID(),
            type: "rect",
            style: {
              size: [128, 128],
              iconFontFamily: "iconfont",
              stroke: "#ffffff",
              lineWidth: 2,
              fillOpacity: 0,
              x: x3 || 0,
              y: y3 || 0
            },
            data: {
              name: "",
              type: "",
              icon: "\u{1F464}",
              notes: ""
            }
          }]);
        }
      });
      this.graph.on(ContainerEvent.KEY_UP, (ev) => {
        if (ev.key === "Alt" || ev.key === "Escape") {
          this.updateMode(NORMAL);
        } else if (ev.key === "i") {
          this.updateMode(INSERT);
        } else if (ev.key === "s") {
          this.updateMode(SELECT);
        } else if (ev.key === "x") {
          this.updateMode(EXTRACT);
        }
        const handler = this.mode.keys?.filter((k) => {
          return (k.shift || false == ev.shiftKey) && (k.alt || false == ev.altKey) && (k.ctrl || false == ev.altKey) && ev.key === k.key;
        }).forEach((k) => {
          k.callback(this, ev);
        });
      });
      window.addEventListener("dragover", (ev) => ev.preventDefault());
      window.addEventListener("drop", (ev) => {
        ev.preventDefault();
        this.processTransfer(ev.dataTransfer);
      });
      this.registerCommands();
      this.updateMode(NORMAL);
    }
    updateMode(newMode) {
      const event = new ScModeEvent(this, this.mode, newMode);
      window.dispatchEvent(event);
      this.mode = newMode;
    }
    async processFile(f) {
      const ab = await f.arrayBuffer();
      const hashBytes = await crypto.subtle.digest("SHA-1", ab);
      const hashView = new Uint8Array(hashBytes);
      const hashString = Array.from(hashView).map((b) => b.toString(16).padStart(2, "0")).join("");
      const a2 = {
        id: hashString,
        name: f.name,
        type: f.type,
        data: ab
      };
      const bitmap = await createImageBitmap(f);
      getDatabase().saveAsset(a2);
      const id3 = crypto.randomUUID();
      this.graph.addNodeData([makeImageNodeData({
        id: id3,
        style: {
          size: [bitmap.width, bitmap.height],
          source_id: hashString
        },
        data: {
          name: f.name,
          mimetype: f.type
        }
      })]);
      return id3;
    }
    processTransfer(transfer2) {
      Promise.all([...transfer2.items].filter((i) => i.type.match(/^image/)).map((i) => {
        const f = i.getAsFile();
        return this.processFile(f);
      })).then(() => {
        getDatabase().saveGraphData(this.graph.getData());
        this.graph.render();
      });
    }
    setLayout(layout2) {
      this.graph.stopLayout();
      this.graph.setLayout(layout2);
      this.graph.layout();
    }
    graphRuntimeContext() {
      return this.graph.context;
    }
    graphRuntimeElement(id3, ctor) {
      const elementController = this.graphRuntimeContext().element;
      const elementMap = elementController.elementMap;
      const el = elementMap[id3];
      if (el && el instanceof ctor) {
        return el;
      }
    }
    registerCommands() {
      this.commands.register([":layout"], "[layout name or ?] set an automatic layout", (args) => {
        if (args[0]) {
          const layout2 = layouts[args[0]];
          if (layout2) {
            this.statusline.message(`layout ${layout2.type}`);
            this.setLayout(layout2);
          } else {
            this.statusline.message(`available layouts: ${Object.keys(layouts).join(", ")}`);
          }
        } else {
          if (this.graph.getLayout()) {
            this.graph.stopLayout();
            this.statusline.message(`layout ${this.graph.getLayout().type}`);
            this.graph.layout();
          } else {
            this.setLayout(layouts.d3);
          }
        }
      });
      this.commands.register([":stoplayout"], "stop iterative layout", (args) => {
        this.graph.stopLayout();
      });
      this.commands.register([":write"], "<name> save the conspiracy with the specified name", (nameParts) => {
        const name = nameParts.join(" ");
        updateConspiracy({ name });
        getDatabase().saveConspiracy();
        this.statusline.update({ left: name });
      });
      this.commands.register([":export"], "export the conspiracy as an image", () => {
        this.graph.toDataURL({ mode: "overall" }).then((dataURL) => {
          const [head2, content] = dataURL.split(",");
          const contentType = head2.match(/:(.*?);/)[1];
          const bstr = atob(content);
          let length = bstr.length;
          const u8arr = new Uint8Array(length);
          while (length--) {
            u8arr[length] = bstr.charCodeAt(length);
          }
          const blob = new Blob([u8arr], { type: contentType });
          const url = URL.createObjectURL(blob);
          const a2 = document.createElement("a");
          a2.href = url;
          a2.download = currentConspiracy().name;
          a2.click();
        });
      });
      this.commands.register([":upload"], "upload images to the graph", () => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = "image/png, image/jpeg, image.gif";
        input.multiple = true;
        input.onchange = (ev) => {
          const files = input.files;
          if (files && files.length > 0) {
            Promise.all([...files].map((f) => {
              return this.processFile(f);
            })).then(() => {
              getDatabase().saveGraphData(this.graph.getData());
              this.graph.render();
            });
          }
        };
        input.click();
      });
      this.commands.register([":help"], "display this help message", () => {
        console.log(this.helpDialog);
        this.helpDialog.open = true;
      });
      this.addHelpDialog();
    }
    addHelpDialog() {
      const dialog = document.querySelector(".sc-help");
      const normalModeHelp = document.createElement("span");
      normalModeHelp.className = "sc-statusline-mid-left sc-statusline-NORMAL";
      normalModeHelp.innerText = "NORMAL (press <escape>) to move the graph around";
      dialog.appendChild(normalModeHelp);
      dialog.append("u can drag image files into the graph from your computer (hopefully)");
      const insertModeHelp = document.createElement("span");
      insertModeHelp.className = "sc-statusline-mid-left sc-statusline-INSERT";
      insertModeHelp.innerText = "INSERT (press <i>) to add new vertices (click) and edges (drag)";
      dialog.appendChild(insertModeHelp);
      const selectModeHelp = document.createElement("span");
      selectModeHelp.className = "sc-statusline-mid-left sc-statusline-SELECT";
      selectModeHelp.innerText = "SELECT (press <s>) to select multiple vertices at once";
      dialog.appendChild(selectModeHelp);
      const extractModeHelp = document.createElement("span");
      extractModeHelp.className = "sc-statusline-mid-left sc-statusline-EXTRACT";
      extractModeHelp.innerText = "EXTRACT (press <x>) to clip parts of images";
      dialog.appendChild(extractModeHelp);
      const cmdHelp = document.createElement("table");
      new Set(this.commands.commands.values()).forEach((cmd) => {
        const tr = document.createElement("tr");
        const aliases = document.createElement("td");
        aliases.className = "sc-help-command";
        aliases.innerText = cmd.cmd.join(", ");
        tr.appendChild(aliases);
        const desc = document.createElement("td");
        desc.innerText = cmd.desc;
        tr.appendChild(desc);
        cmdHelp.appendChild(tr);
        return tr;
      });
      dialog.appendChild(cmdHelp);
      dialog.append("everything is saved on your computer (nothing is uploaded anywhere). u maybe need to reload the page a lot because things break. remember that i love u.");
      const closeButton = document.createElement("button");
      closeButton.autofocus = true;
      closeButton.innerText = "close <3";
      closeButton.onclick = () => dialog.close();
      dialog.appendChild(closeButton);
      this.helpDialog = dialog;
      this.statusline.message("type :help for information <3", 2e4);
    }
  };
  function getScApp() {
    return window._app;
  }
  window.addEventListener("conspiracyload", (ev) => {
    getDatabase().loadGraphData((data2) => {
      window._app = new ScApplication(data2);
      getScApp().graph.render();
    });
  });
  window.addEventListener("load", (ev) => {
    window._db = new ScDatabase();
  });
})();
/*! Bundled license information:

@antv/g-math/dist/index.js:
@antv/g-math/dist/index.esm.js:
  (*!
   * @antv/g-math
   * @description Geometry util
   * @version 3.0.1
   * @date 5/9/2025, 8:18:51 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@babel/runtime/helpers/regenerator.js:
@babel/runtime/helpers/esm/regenerator.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE *)

@antv/g-lite/dist/index.js:
@antv/g-lite/dist/index.esm.js:
  (*!
   * @antv/g-lite
   * @description A core module for rendering engine implements DOM API.
   * @version 2.3.2
   * @date 7/30/2025, 1:34:19 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-camera-api/dist/index.js:
@antv/g-camera-api/dist/index.esm.js:
  (*!
   * @antv/g-camera-api
   * @description A simple implementation of Camera API.
   * @version 2.0.41
   * @date 7/30/2025, 1:34:37 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-dom-mutation-observer-api/dist/index.js:
@antv/g-dom-mutation-observer-api/dist/index.esm.js:
  (*!
   * @antv/g-dom-mutation-observer-api
   * @description A simple implementation of DOM MutationObserver API.
   * @version 2.0.38
   * @date 7/30/2025, 1:34:51 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-web-animations-api/dist/index.js:
@antv/g-web-animations-api/dist/index.esm.js:
  (*!
   * @antv/g-web-animations-api
   * @description A simple implementation of Web Animations API.
   * @version 2.1.28
   * @date 7/30/2025, 1:36:24 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g/dist/index.js:
@antv/g/dist/index.esm.js:
  (*!
   * @antv/g
   * @description A core module for rendering engine implements DOM API.
   * @version 6.1.28
   * @date 7/30/2025, 1:36:29 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-canvas-path-generator/dist/index.esm.js:
  (*!
   * @antv/g-plugin-canvas-path-generator
   * @description A G plugin of path generator with Canvas2D API
   * @version 2.1.22
   * @date 7/30/2025, 1:35:25 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-canvas-picker/dist/index.esm.js:
  (*!
   * @antv/g-plugin-canvas-picker
   * @description A G plugin for picking in canvas
   * @version 2.1.27
   * @date 7/30/2025, 1:37:32 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-image-loader/dist/index.esm.js:
  (*!
   * @antv/g-plugin-image-loader
   * @description A G plugin for loading image
   * @version 2.1.26
   * @date 7/30/2025, 1:35:52 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-canvas-renderer/dist/index.esm.js:
  (*!
   * @antv/g-plugin-canvas-renderer
   * @description A G plugin of renderer implementation with Canvas2D API
   * @version 2.3.3
   * @date 7/30/2025, 1:36:40 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-dom-interaction/dist/index.esm.js:
  (*!
   * @antv/g-plugin-dom-interaction
   * @description A G plugin
   * @version 2.1.27
   * @date 7/30/2025, 1:35:38 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-html-renderer/dist/index.esm.js:
  (*!
   * @antv/g-plugin-html-renderer
   * @description A G plugin for rendering HTML
   * @version 2.1.27
   * @date 7/30/2025, 1:35:48 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-canvas/dist/index.esm.js:
  (*!
   * @antv/g-canvas
   * @description A renderer implemented by Canvas 2D API
   * @version 2.0.48
   * @date 7/30/2025, 1:38:18 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

comlink/dist/esm/comlink.mjs:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)

@antv/g-plugin-dragndrop/dist/index.esm.js:
  (*!
   * @antv/g-plugin-dragndrop
   * @description A G plugin for Drag n Drop implemented with PointerEvents
   * @version 2.0.38
   * @date 7/30/2025, 1:35:41 PM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)
*/
//# sourceMappingURL=sc0.js.map
